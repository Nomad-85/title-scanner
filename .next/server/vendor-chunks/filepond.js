"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/filepond";
exports.ids = ["vendor-chunks/filepond"];
exports.modules = {

/***/ "(ssr)/./node_modules/filepond/dist/filepond.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileOrigin: () => (/* binding */ FileOrigin$1),\n/* harmony export */   FileStatus: () => (/* binding */ FileStatus),\n/* harmony export */   OptionTypes: () => (/* binding */ OptionTypes),\n/* harmony export */   Status: () => (/* binding */ Status$1),\n/* harmony export */   create: () => (/* binding */ create$f),\n/* harmony export */   destroy: () => (/* binding */ destroy),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   getOptions: () => (/* binding */ getOptions$1),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   setOptions: () => (/* binding */ setOptions$1),\n/* harmony export */   supported: () => (/* binding */ supported)\n/* harmony export */ });\n/*!\n * FilePond 4.32.7\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */ /* eslint-disable */ const isNode = (value)=>value instanceof HTMLElement;\nconst createStore = (initialState, queries = [], actions = [])=>{\n    // internal state\n    const state = {\n        ...initialState\n    };\n    // contains all actions for next frame, is clear when actions are requested\n    const actionQueue = [];\n    const dispatchQueue = [];\n    // returns a duplicate of the current state\n    const getState = ()=>({\n            ...state\n        });\n    // returns a duplicate of the actions array and clears the actions array\n    const processActionQueue = ()=>{\n        // create copy of actions queue\n        const queue = [\n            ...actionQueue\n        ];\n        // clear actions queue (we don't want no double actions)\n        actionQueue.length = 0;\n        return queue;\n    };\n    // processes actions that might block the main UI thread\n    const processDispatchQueue = ()=>{\n        // create copy of actions queue\n        const queue = [\n            ...dispatchQueue\n        ];\n        // clear actions queue (we don't want no double actions)\n        dispatchQueue.length = 0;\n        // now dispatch these actions\n        queue.forEach(({ type, data })=>{\n            dispatch(type, data);\n        });\n    };\n    // adds a new action, calls its handler and\n    const dispatch = (type, data, isBlocking)=>{\n        // is blocking action (should never block if document is hidden)\n        if (isBlocking && !document.hidden) {\n            dispatchQueue.push({\n                type,\n                data\n            });\n            return;\n        }\n        // if this action has a handler, handle the action\n        if (actionHandlers[type]) {\n            actionHandlers[type](data);\n        }\n        // now add action\n        actionQueue.push({\n            type,\n            data\n        });\n    };\n    const query = (str, ...args)=>queryHandles[str] ? queryHandles[str](...args) : null;\n    const api = {\n        getState,\n        processActionQueue,\n        processDispatchQueue,\n        dispatch,\n        query\n    };\n    let queryHandles = {};\n    queries.forEach((query)=>{\n        queryHandles = {\n            ...query(state),\n            ...queryHandles\n        };\n    });\n    let actionHandlers = {};\n    actions.forEach((action)=>{\n        actionHandlers = {\n            ...action(dispatch, query, state),\n            ...actionHandlers\n        };\n    });\n    return api;\n};\nconst defineProperty = (obj, property, definition)=>{\n    if (typeof definition === \"function\") {\n        obj[property] = definition;\n        return;\n    }\n    Object.defineProperty(obj, property, {\n        ...definition\n    });\n};\nconst forin = (obj, cb)=>{\n    for(const key in obj){\n        if (!obj.hasOwnProperty(key)) {\n            continue;\n        }\n        cb(key, obj[key]);\n    }\n};\nconst createObject = (definition)=>{\n    const obj = {};\n    forin(definition, (property)=>{\n        defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n};\nconst attr = (node, name, value = null)=>{\n    if (value === null) {\n        return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n};\nconst ns = \"http://www.w3.org/2000/svg\";\nconst svgElements = [\n    \"svg\",\n    \"path\"\n]; // only svg elements used\nconst isSVGElement = (tag)=>svgElements.includes(tag);\nconst createElement = (tag, className, attributes = {})=>{\n    if (typeof className === \"object\") {\n        attributes = className;\n        className = null;\n    }\n    const element = isSVGElement(tag) ? document.createElementNS(ns, tag) : document.createElement(tag);\n    if (className) {\n        if (isSVGElement(tag)) {\n            attr(element, \"class\", className);\n        } else {\n            element.className = className;\n        }\n    }\n    forin(attributes, (name, value)=>{\n        attr(element, name, value);\n    });\n    return element;\n};\nconst appendChild = (parent)=>(child, index)=>{\n        if (typeof index !== \"undefined\" && parent.children[index]) {\n            parent.insertBefore(child, parent.children[index]);\n        } else {\n            parent.appendChild(child);\n        }\n    };\nconst appendChildView = (parent, childViews)=>(view, index)=>{\n        if (typeof index !== \"undefined\") {\n            childViews.splice(index, 0, view);\n        } else {\n            childViews.push(view);\n        }\n        return view;\n    };\nconst removeChildView = (parent, childViews)=>(view)=>{\n        // remove from child views\n        childViews.splice(childViews.indexOf(view), 1);\n        // remove the element\n        if (view.element.parentNode) {\n            parent.removeChild(view.element);\n        }\n        return view;\n    };\nconst IS_BROWSER = (()=> false && 0)();\nconst isBrowser = ()=>IS_BROWSER;\nconst testElement = isBrowser() ? createElement(\"svg\") : {};\nconst getChildCount = \"children\" in testElement ? (el)=>el.children.length : (el)=>el.childNodes.length;\nconst getViewRect = (elementRect, childViews, offset, scale)=>{\n    const left = offset[0] || elementRect.left;\n    const top = offset[1] || elementRect.top;\n    const right = left + elementRect.width;\n    const bottom = top + elementRect.height * (scale[1] || 1);\n    const rect = {\n        // the rectangle of the element itself\n        element: {\n            ...elementRect\n        },\n        // the rectangle of the element expanded to contain its children, does not include any margins\n        inner: {\n            left: elementRect.left,\n            top: elementRect.top,\n            right: elementRect.right,\n            bottom: elementRect.bottom\n        },\n        // the rectangle of the element expanded to contain its children including own margin and child margins\n        // margins will be added after we've recalculated the size\n        outer: {\n            left,\n            top,\n            right,\n            bottom\n        }\n    };\n    // expand rect to fit all child rectangles\n    childViews.filter((childView)=>!childView.isRectIgnored()).map((childView)=>childView.rect).forEach((childViewRect)=>{\n        expandRect(rect.inner, {\n            ...childViewRect.inner\n        });\n        expandRect(rect.outer, {\n            ...childViewRect.outer\n        });\n    });\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n    return rect;\n};\nconst expandRect = (parent, child)=>{\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n    if (child.bottom > parent.bottom) {\n        parent.bottom = child.bottom;\n    }\n    if (child.right > parent.right) {\n        parent.right = child.right;\n    }\n};\nconst calculateRectSize = (rect)=>{\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n};\nconst isNumber = (value)=>typeof value === \"number\";\n/**\n * Determines if position is at destination\n * @param position\n * @param destination\n * @param velocity\n * @param errorMargin\n * @returns {boolean}\n */ const thereYet = (position, destination, velocity, errorMargin = 0.001)=>{\n    return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;\n};\n/**\n * Spring animation\n */ const spring = // default options\n({ stiffness = 0.5, damping = 0.75, mass = 10 } = {})=>// method definition\n{\n    let target = null;\n    let position = null;\n    let velocity = 0;\n    let resting = false;\n    // updates spring state\n    const interpolate = (ts, skipToEndState)=>{\n        // in rest, don't animate\n        if (resting) return;\n        // need at least a target or position to do springy things\n        if (!(isNumber(target) && isNumber(position))) {\n            resting = true;\n            velocity = 0;\n            return;\n        }\n        // calculate spring force\n        const f = -(position - target) * stiffness;\n        // update velocity by adding force based on mass\n        velocity += f / mass;\n        // update position by adding velocity\n        position += velocity;\n        // slow down based on amount of damping\n        velocity *= damping;\n        // we've arrived if we're near target and our velocity is near zero\n        if (thereYet(position, target, velocity) || skipToEndState) {\n            position = target;\n            velocity = 0;\n            resting = true;\n            // we done\n            api.onupdate(position);\n            api.oncomplete(position);\n        } else {\n            // progress update\n            api.onupdate(position);\n        }\n    };\n    /**\n             * Set new target value\n             * @param value\n             */ const setTarget = (value)=>{\n        // if currently has no position, set target and position to this value\n        if (isNumber(value) && !isNumber(position)) {\n            position = value;\n        }\n        // next target value will not be animated to\n        if (target === null) {\n            target = value;\n            position = value;\n        }\n        // let start moving to target\n        target = value;\n        // already at target\n        if (position === target || typeof target === \"undefined\") {\n            // now resting as target is current position, stop moving\n            resting = true;\n            velocity = 0;\n            // done!\n            api.onupdate(position);\n            api.oncomplete(position);\n            return;\n        }\n        resting = false;\n    };\n    // need 'api' to call onupdate callback\n    const api = createObject({\n        interpolate,\n        target: {\n            set: setTarget,\n            get: ()=>target\n        },\n        resting: {\n            get: ()=>resting\n        },\n        onupdate: (value)=>{},\n        oncomplete: (value)=>{}\n    });\n    return api;\n};\nconst easeLinear = (t)=>t;\nconst easeInOutQuad = (t)=>t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\nconst tween = // default values\n({ duration = 500, easing = easeInOutQuad, delay = 0 } = {})=>// method definition\n{\n    let start = null;\n    let t;\n    let p;\n    let resting = true;\n    let reverse = false;\n    let target = null;\n    const interpolate = (ts, skipToEndState)=>{\n        if (resting || target === null) return;\n        if (start === null) {\n            start = ts;\n        }\n        if (ts - start < delay) return;\n        t = ts - start - delay;\n        if (t >= duration || skipToEndState) {\n            t = 1;\n            p = reverse ? 0 : 1;\n            api.onupdate(p * target);\n            api.oncomplete(p * target);\n            resting = true;\n        } else {\n            p = t / duration;\n            api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n        }\n    };\n    // need 'api' to call onupdate callback\n    const api = createObject({\n        interpolate,\n        target: {\n            get: ()=>reverse ? 0 : target,\n            set: (value)=>{\n                // is initial value\n                if (target === null) {\n                    target = value;\n                    api.onupdate(value);\n                    api.oncomplete(value);\n                    return;\n                }\n                // want to tween to a smaller value and have a current value\n                if (value < target) {\n                    target = 1;\n                    reverse = true;\n                } else {\n                    // not tweening to a smaller value\n                    reverse = false;\n                    target = value;\n                }\n                // let's go!\n                resting = false;\n                start = null;\n            }\n        },\n        resting: {\n            get: ()=>resting\n        },\n        onupdate: (value)=>{},\n        oncomplete: (value)=>{}\n    });\n    return api;\n};\nconst animator = {\n    spring,\n    tween\n};\n/*\n { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n { translation: { type: 'spring', ... }, ... }\n { translation: { x: { type: 'spring', ... } } }\n*/ const createAnimator = (definition, category, property)=>{\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    const def = definition[category] && typeof definition[category][property] === \"object\" ? definition[category][property] : definition[category] || definition;\n    const type = typeof def === \"string\" ? def : def.type;\n    const props = typeof def === \"object\" ? {\n        ...def\n    } : {};\n    return animator[type] ? animator[type](props) : null;\n};\nconst addGetSet = (keys, obj, props, overwrite = false)=>{\n    obj = Array.isArray(obj) ? obj : [\n        obj\n    ];\n    obj.forEach((o)=>{\n        keys.forEach((key)=>{\n            let name = key;\n            let getter = ()=>props[key];\n            let setter = (value)=>props[key] = value;\n            if (typeof key === \"object\") {\n                name = key.key;\n                getter = key.getter || getter;\n                setter = key.setter || setter;\n            }\n            if (o[name] && !overwrite) {\n                return;\n            }\n            o[name] = {\n                get: getter,\n                set: setter\n            };\n        });\n    });\n};\n// add to state,\n// add getters and setters to internal and external api (if not set)\n// setup animators\nconst animations = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI })=>{\n    // initial properties\n    const initialProps = {\n        ...viewProps\n    };\n    // list of all active animations\n    const animations = [];\n    // setup animators\n    forin(mixinConfig, (property, animation)=>{\n        const animator = createAnimator(animation);\n        if (!animator) {\n            return;\n        }\n        // when the animator updates, update the view state value\n        animator.onupdate = (value)=>{\n            viewProps[property] = value;\n        };\n        // set animator target\n        animator.target = initialProps[property];\n        // when value is set, set the animator target value\n        const prop = {\n            key: property,\n            setter: (value)=>{\n                // if already at target, we done!\n                if (animator.target === value) {\n                    return;\n                }\n                animator.target = value;\n            },\n            getter: ()=>viewProps[property]\n        };\n        // add getters and setters\n        addGetSet([\n            prop\n        ], [\n            viewInternalAPI,\n            viewExternalAPI\n        ], viewProps, true);\n        // add it to the list for easy updating from the _write method\n        animations.push(animator);\n    });\n    // expose internal write api\n    return {\n        write: (ts)=>{\n            let skipToEndState = document.hidden;\n            let resting = true;\n            animations.forEach((animation)=>{\n                if (!animation.resting) resting = false;\n                animation.interpolate(ts, skipToEndState);\n            });\n            return resting;\n        },\n        destroy: ()=>{}\n    };\n};\nconst addEvent = (element)=>(type, fn)=>{\n        element.addEventListener(type, fn);\n    };\nconst removeEvent = (element)=>(type, fn)=>{\n        element.removeEventListener(type, fn);\n    };\n// mixin\nconst listeners = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, viewState, view })=>{\n    const events = [];\n    const add = addEvent(view.element);\n    const remove = removeEvent(view.element);\n    viewExternalAPI.on = (type, fn)=>{\n        events.push({\n            type,\n            fn\n        });\n        add(type, fn);\n    };\n    viewExternalAPI.off = (type, fn)=>{\n        events.splice(events.findIndex((event)=>event.type === type && event.fn === fn), 1);\n        remove(type, fn);\n    };\n    return {\n        write: ()=>{\n            // not busy\n            return true;\n        },\n        destroy: ()=>{\n            events.forEach((event)=>{\n                remove(event.type, event.fn);\n            });\n        }\n    };\n};\n// add to external api and link to props\nconst apis = ({ mixinConfig, viewProps, viewExternalAPI })=>{\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n};\nconst isDefined = (value)=>value != null;\n// add to state,\n// add getters and setters to internal and external api (if not set)\n// set initial state based on props in viewProps\n// apply as transforms each frame\nconst defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0\n};\nconst styles = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, view })=>{\n    // initial props\n    const initialProps = {\n        ...viewProps\n    };\n    // current props\n    const currentProps = {};\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [\n        viewInternalAPI,\n        viewExternalAPI\n    ], viewProps);\n    // override rect on internal and external rect getter so it takes in account transforms\n    const getOffset = ()=>[\n            viewProps[\"translateX\"] || 0,\n            viewProps[\"translateY\"] || 0\n        ];\n    const getScale = ()=>[\n            viewProps[\"scaleX\"] || 0,\n            viewProps[\"scaleY\"] || 0\n        ];\n    const getRect = ()=>view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;\n    viewInternalAPI.rect = {\n        get: getRect\n    };\n    viewExternalAPI.rect = {\n        get: getRect\n    };\n    // apply view props\n    mixinConfig.forEach((key)=>{\n        viewProps[key] = typeof initialProps[key] === \"undefined\" ? defaults[key] : initialProps[key];\n    });\n    // expose api\n    return {\n        write: ()=>{\n            // see if props have changed\n            if (!propsHaveChanged(currentProps, viewProps)) {\n                return;\n            }\n            // moves element to correct position on screen\n            applyStyles(view.element, viewProps);\n            // store new transforms\n            Object.assign(currentProps, {\n                ...viewProps\n            });\n            // no longer busy\n            return true;\n        },\n        destroy: ()=>{}\n    };\n};\nconst propsHaveChanged = (currentProps, newProps)=>{\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n        return true;\n    }\n    // lets analyze the individual props\n    for(const prop in newProps){\n        if (newProps[prop] !== currentProps[prop]) {\n            return true;\n        }\n    }\n    return false;\n};\nconst applyStyles = (element, { opacity, perspective, translateX, translateY, scaleX, scaleY, rotateX, rotateY, rotateZ, originX, originY, width, height })=>{\n    let transforms = \"\";\n    let styles = \"\";\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n        styles += `transform-origin: ${originX || 0}px ${originY || 0}px;`;\n    }\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n        transforms += `perspective(${perspective}px) `;\n    }\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n        transforms += `translate3d(${translateX || 0}px, ${translateY || 0}px, 0) `;\n    }\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n        transforms += `scale3d(${isDefined(scaleX) ? scaleX : 1}, ${isDefined(scaleY) ? scaleY : 1}, 1) `;\n    }\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n        transforms += `rotateZ(${rotateZ}rad) `;\n    }\n    if (isDefined(rotateX)) {\n        transforms += `rotateX(${rotateX}rad) `;\n    }\n    if (isDefined(rotateY)) {\n        transforms += `rotateY(${rotateY}rad) `;\n    }\n    // add transforms\n    if (transforms.length) {\n        styles += `transform:${transforms};`;\n    }\n    // add opacity\n    if (isDefined(opacity)) {\n        styles += `opacity:${opacity};`;\n        // if we reach zero, we make the element inaccessible\n        if (opacity === 0) {\n            styles += `visibility:hidden;`;\n        }\n        // if we're below 100% opacity this element can't be clicked\n        if (opacity < 1) {\n            styles += `pointer-events:none;`;\n        }\n    }\n    // add height\n    if (isDefined(height)) {\n        styles += `height:${height}px;`;\n    }\n    // add width\n    if (isDefined(width)) {\n        styles += `width:${width}px;`;\n    }\n    // apply styles\n    const elementCurrentStyle = element.elementCurrentStyle || \"\";\n    // if new styles does not match current styles, lets update!\n    if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {\n        element.style.cssText = styles;\n        // store current styles so we can compare them to new styles later on\n        // _not_ getting the style value is faster\n        element.elementCurrentStyle = styles;\n    }\n};\nconst Mixins = {\n    styles,\n    listeners,\n    animations,\n    apis\n};\nconst updateRect = (rect = {}, element = {}, style = {})=>{\n    if (!element.layoutCalculated) {\n        rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n        rect.marginTop = parseInt(style.marginTop, 10) || 0;\n        rect.marginRight = parseInt(style.marginRight, 10) || 0;\n        rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n        rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n        element.layoutCalculated = true;\n    }\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n    rect.scrollTop = element.scrollTop;\n    rect.hidden = element.offsetParent === null;\n    return rect;\n};\nconst createView = // default view definition\n({ // element definition\ntag = \"div\", name = null, attributes = {}, // view interaction\nread = ()=>{}, write = ()=>{}, create = ()=>{}, destroy = ()=>{}, // hooks\nfilterFrameActionsForChild = (child, actions)=>actions, didCreateView = ()=>{}, didWriteView = ()=>{}, // rect related\nignoreRect = false, ignoreRectUpdate = false, // mixins\nmixins = [] } = {})=>(// each view requires reference to store\n    store, // specific properties for this view\n    props = {})=>{\n        // root element should not be changed\n        const element = createElement(tag, `filepond--${name}`, attributes);\n        // style reference should also not be changed\n        const style = window.getComputedStyle(element, null);\n        // element rectangle\n        const rect = updateRect();\n        let frameRect = null;\n        // rest state\n        let isResting = false;\n        // pretty self explanatory\n        const childViews = [];\n        // loaded mixins\n        const activeMixins = [];\n        // references to created children\n        const ref = {};\n        // state used for each instance\n        const state = {};\n        // list of writers that will be called to update this view\n        const writers = [\n            write\n        ];\n        const readers = [\n            read\n        ];\n        const destroyers = [\n            destroy\n        ];\n        // core view methods\n        const getElement = ()=>element;\n        const getChildViews = ()=>childViews.concat();\n        const getReference = ()=>ref;\n        const createChildView = (store)=>(view, props)=>view(store, props);\n        const getRect = ()=>{\n            if (frameRect) {\n                return frameRect;\n            }\n            frameRect = getViewRect(rect, childViews, [\n                0,\n                0\n            ], [\n                1,\n                1\n            ]);\n            return frameRect;\n        };\n        const getStyle = ()=>style;\n        /**\n         * Read data from DOM\n         * @private\n         */ const _read = ()=>{\n            frameRect = null;\n            // read child views\n            childViews.forEach((child)=>child._read());\n            const shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n            if (shouldUpdate) {\n                updateRect(rect, element, style);\n            }\n            // readers\n            const api = {\n                root: internalAPI,\n                props,\n                rect\n            };\n            readers.forEach((reader)=>reader(api));\n        };\n        /**\n         * Write data to DOM\n         * @private\n         */ const _write = (ts, frameActions, shouldOptimize)=>{\n            // if no actions, we assume that the view is resting\n            let resting = frameActions.length === 0;\n            // writers\n            writers.forEach((writer)=>{\n                const writerResting = writer({\n                    props,\n                    root: internalAPI,\n                    actions: frameActions,\n                    timestamp: ts,\n                    shouldOptimize\n                });\n                if (writerResting === false) {\n                    resting = false;\n                }\n            });\n            // run mixins\n            activeMixins.forEach((mixin)=>{\n                // if one of the mixins is still busy after write operation, we are not resting\n                const mixinResting = mixin.write(ts);\n                if (mixinResting === false) {\n                    resting = false;\n                }\n            });\n            // updates child views that are currently attached to the DOM\n            childViews.filter((child)=>!!child.element.parentNode).forEach((child)=>{\n                // if a child view is not resting, we are not resting\n                const childResting = child._write(ts, filterFrameActionsForChild(child, frameActions), shouldOptimize);\n                if (!childResting) {\n                    resting = false;\n                }\n            });\n            // append new elements to DOM and update those\n            childViews//.filter(child => !child.element.parentNode)\n            .forEach((child, index)=>{\n                // skip\n                if (child.element.parentNode) {\n                    return;\n                }\n                // append to DOM\n                internalAPI.appendChild(child.element, index);\n                // call read (need to know the size of these elements)\n                child._read();\n                // re-call write\n                child._write(ts, filterFrameActionsForChild(child, frameActions), shouldOptimize);\n                // we just added somthing to the dom, no rest\n                resting = false;\n            });\n            // update resting state\n            isResting = resting;\n            didWriteView({\n                props,\n                root: internalAPI,\n                actions: frameActions,\n                timestamp: ts\n            });\n            // let parent know if we are resting\n            return resting;\n        };\n        const _destroy = ()=>{\n            activeMixins.forEach((mixin)=>mixin.destroy());\n            destroyers.forEach((destroyer)=>{\n                destroyer({\n                    root: internalAPI,\n                    props\n                });\n            });\n            childViews.forEach((child)=>child._destroy());\n        };\n        // sharedAPI\n        const sharedAPIDefinition = {\n            element: {\n                get: getElement\n            },\n            style: {\n                get: getStyle\n            },\n            childViews: {\n                get: getChildViews\n            }\n        };\n        // private API definition\n        const internalAPIDefinition = {\n            ...sharedAPIDefinition,\n            rect: {\n                get: getRect\n            },\n            // access to custom children references\n            ref: {\n                get: getReference\n            },\n            // dom modifiers\n            is: (needle)=>name === needle,\n            appendChild: appendChild(element),\n            createChildView: createChildView(store),\n            linkView: (view)=>{\n                childViews.push(view);\n                return view;\n            },\n            unlinkView: (view)=>{\n                childViews.splice(childViews.indexOf(view), 1);\n            },\n            appendChildView: appendChildView(element, childViews),\n            removeChildView: removeChildView(element, childViews),\n            registerWriter: (writer)=>writers.push(writer),\n            registerReader: (reader)=>readers.push(reader),\n            registerDestroyer: (destroyer)=>destroyers.push(destroyer),\n            invalidateLayout: ()=>element.layoutCalculated = false,\n            // access to data store\n            dispatch: store.dispatch,\n            query: store.query\n        };\n        // public view API methods\n        const externalAPIDefinition = {\n            element: {\n                get: getElement\n            },\n            childViews: {\n                get: getChildViews\n            },\n            rect: {\n                get: getRect\n            },\n            resting: {\n                get: ()=>isResting\n            },\n            isRectIgnored: ()=>ignoreRect,\n            _read,\n            _write,\n            _destroy\n        };\n        // mixin API methods\n        const mixinAPIDefinition = {\n            ...sharedAPIDefinition,\n            rect: {\n                get: ()=>rect\n            }\n        };\n        // add mixin functionality\n        Object.keys(mixins).sort((a, b)=>{\n            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n            if (a === \"styles\") {\n                return 1;\n            } else if (b === \"styles\") {\n                return -1;\n            }\n            return 0;\n        }).forEach((key)=>{\n            const mixinAPI = Mixins[key]({\n                mixinConfig: mixins[key],\n                viewProps: props,\n                viewState: state,\n                viewInternalAPI: internalAPIDefinition,\n                viewExternalAPI: externalAPIDefinition,\n                view: createObject(mixinAPIDefinition)\n            });\n            if (mixinAPI) {\n                activeMixins.push(mixinAPI);\n            }\n        });\n        // construct private api\n        const internalAPI = createObject(internalAPIDefinition);\n        // create the view\n        create({\n            root: internalAPI,\n            props\n        });\n        // append created child views to root node\n        const childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n        childViews.forEach((child, index)=>{\n            internalAPI.appendChild(child.element, childCount + index);\n        });\n        // call did create\n        didCreateView(internalAPI);\n        // expose public api\n        return createObject(externalAPIDefinition);\n    };\nconst createPainter = (read, write, fps = 60)=>{\n    const name = \"__framePainter\";\n    // set global painter\n    if (window[name]) {\n        window[name].readers.push(read);\n        window[name].writers.push(write);\n        return;\n    }\n    window[name] = {\n        readers: [\n            read\n        ],\n        writers: [\n            write\n        ]\n    };\n    const painter = window[name];\n    const interval = 1000 / fps;\n    let last = null;\n    let id = null;\n    let requestTick = null;\n    let cancelTick = null;\n    const setTimerType = ()=>{\n        if (document.hidden) {\n            requestTick = ()=>window.setTimeout(()=>tick(performance.now()), interval);\n            cancelTick = ()=>window.clearTimeout(id);\n        } else {\n            requestTick = ()=>window.requestAnimationFrame(tick);\n            cancelTick = ()=>window.cancelAnimationFrame(id);\n        }\n    };\n    document.addEventListener(\"visibilitychange\", ()=>{\n        if (cancelTick) cancelTick();\n        setTimerType();\n        tick(performance.now());\n    });\n    const tick = (ts)=>{\n        // queue next tick\n        id = requestTick(tick);\n        // limit fps\n        if (!last) {\n            last = ts;\n        }\n        const delta = ts - last;\n        if (delta <= interval) {\n            // skip frame\n            return;\n        }\n        // align next frame\n        last = ts - delta % interval;\n        // update view\n        painter.readers.forEach((read)=>read());\n        painter.writers.forEach((write)=>write(ts));\n    };\n    setTimerType();\n    tick(performance.now());\n    return {\n        pause: ()=>{\n            cancelTick(id);\n        }\n    };\n};\nconst createRoute = (routes, fn)=>({ root, props, actions = [], timestamp, shouldOptimize })=>{\n        actions.filter((action)=>routes[action.type]).forEach((action)=>routes[action.type]({\n                root,\n                props,\n                action: action.data,\n                timestamp,\n                shouldOptimize\n            }));\n        if (fn) {\n            fn({\n                root,\n                props,\n                actions,\n                timestamp,\n                shouldOptimize\n            });\n        }\n    };\nconst insertBefore = (newNode, referenceNode)=>referenceNode.parentNode.insertBefore(newNode, referenceNode);\nconst insertAfter = (newNode, referenceNode)=>{\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n};\nconst isArray = (value)=>Array.isArray(value);\nconst isEmpty = (value)=>value == null;\nconst trim = (str)=>str.trim();\nconst toString = (value)=>\"\" + value;\nconst toArray = (value, splitter = \",\")=>{\n    if (isEmpty(value)) {\n        return [];\n    }\n    if (isArray(value)) {\n        return value;\n    }\n    return toString(value).split(splitter).map(trim).filter((str)=>str.length);\n};\nconst isBoolean = (value)=>typeof value === \"boolean\";\nconst toBoolean = (value)=>isBoolean(value) ? value : value === \"true\";\nconst isString = (value)=>typeof value === \"string\";\nconst toNumber = (value)=>isNumber(value) ? value : isString(value) ? toString(value).replace(/[a-z]+/gi, \"\") : 0;\nconst toInt = (value)=>parseInt(toNumber(value), 10);\nconst toFloat = (value)=>parseFloat(toNumber(value));\nconst isInt = (value)=>isNumber(value) && isFinite(value) && Math.floor(value) === value;\nconst toBytes = (value, base = 1000)=>{\n    // is in bytes\n    if (isInt(value)) {\n        return value;\n    }\n    // is natural file size\n    let naturalFileSize = toString(value).trim();\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n        naturalFileSize = naturalFileSize.replace(/MB$i/, \"\").trim();\n        return toInt(naturalFileSize) * base * base;\n    }\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n        naturalFileSize = naturalFileSize.replace(/KB$i/, \"\").trim();\n        return toInt(naturalFileSize) * base;\n    }\n    return toInt(naturalFileSize);\n};\nconst isFunction = (value)=>typeof value === \"function\";\nconst toFunctionReference = (string)=>{\n    let ref = self;\n    let levels = string.split(\".\");\n    let level = null;\n    while(level = levels.shift()){\n        ref = ref[level];\n        if (!ref) {\n            return null;\n        }\n    }\n    return ref;\n};\nconst methods = {\n    process: \"POST\",\n    patch: \"PATCH\",\n    revert: \"DELETE\",\n    fetch: \"GET\",\n    restore: \"GET\",\n    load: \"GET\"\n};\nconst createServerAPI = (outline)=>{\n    const api = {};\n    api.url = isString(outline) ? outline : outline.url || \"\";\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n    forin(methods, (key)=>{\n        api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);\n    });\n    // remove process if no url or process on outline\n    api.process = outline.process || isString(outline) || outline.url ? api.process : null;\n    // special treatment for remove\n    api.remove = outline.remove || null;\n    // remove generic headers from api object\n    delete api.headers;\n    return api;\n};\nconst createAction = (name, outline, method, timeout, headers)=>{\n    // is explicitely set to null so disable\n    if (outline === null) {\n        return null;\n    }\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === \"function\") {\n        return outline;\n    }\n    // build action object\n    const action = {\n        url: method === \"GET\" || method === \"PATCH\" ? `?${name}=` : \"\",\n        method,\n        headers,\n        withCredentials: false,\n        timeout,\n        onload: null,\n        ondata: null,\n        onerror: null\n    };\n    // is a single url\n    if (isString(outline)) {\n        action.url = outline;\n        return action;\n    }\n    // overwrite\n    Object.assign(action, outline);\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n        const parts = action.headers.split(/:(.+)/);\n        action.headers = {\n            header: parts[0],\n            value: parts[1]\n        };\n    }\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n    return action;\n};\nconst toServerAPI = (value)=>createServerAPI(value);\nconst isNull = (value)=>value === null;\nconst isObject = (value)=>typeof value === \"object\" && value !== null;\nconst isAPI = (value)=>{\n    return isObject(value) && isString(value.url) && isObject(value.process) && isObject(value.revert) && isObject(value.restore) && isObject(value.fetch);\n};\nconst getType = (value)=>{\n    if (isArray(value)) {\n        return \"array\";\n    }\n    if (isNull(value)) {\n        return \"null\";\n    }\n    if (isInt(value)) {\n        return \"int\";\n    }\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n        return \"bytes\";\n    }\n    if (isAPI(value)) {\n        return \"api\";\n    }\n    return typeof value;\n};\nconst replaceSingleQuotes = (str)=>str.replace(/{\\s*'/g, '{\"').replace(/'\\s*}/g, '\"}').replace(/'\\s*:/g, '\":').replace(/:\\s*'/g, ':\"').replace(/,\\s*'/g, ',\"').replace(/'\\s*,/g, '\",');\nconst conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: (value)=>getType(value) === \"bytes\" ? toBytes(value) : toInt(value),\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: (value)=>isFunction(value) ? value : toString(value),\n    function: (value)=>toFunctionReference(value),\n    serverapi: toServerAPI,\n    object: (value)=>{\n        try {\n            return JSON.parse(replaceSingleQuotes(value));\n        } catch (e) {\n            return null;\n        }\n    }\n};\nconst convertTo = (value, type)=>conversionTable[type](value);\nconst getValueByType = (newValue, defaultValue, valueType)=>{\n    // can always assign default value\n    if (newValue === defaultValue) {\n        return newValue;\n    }\n    // get the type of the new value\n    let newValueType = getType(newValue);\n    // is valid type?\n    if (newValueType !== valueType) {\n        // is string input, let's attempt to convert\n        const convertedValue = convertTo(newValue, valueType);\n        // what is the type now\n        newValueType = getType(convertedValue);\n        // no valid conversions found\n        if (convertedValue === null) {\n            throw `Trying to assign value with incorrect type to \"${option}\", allowed type: \"${valueType}\"`;\n        } else {\n            newValue = convertedValue;\n        }\n    }\n    // assign new value\n    return newValue;\n};\nconst createOption = (defaultValue, valueType)=>{\n    let currentValue = defaultValue;\n    return {\n        enumerable: true,\n        get: ()=>currentValue,\n        set: (newValue)=>{\n            currentValue = getValueByType(newValue, defaultValue, valueType);\n        }\n    };\n};\nconst createOptions = (options)=>{\n    const obj = {};\n    forin(options, (prop)=>{\n        const optionDefinition = options[prop];\n        obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n};\nconst createInitialState = (options)=>({\n        // model\n        items: [],\n        // timeout used for calling update items\n        listUpdateTimeout: null,\n        // timeout used for stacking metadata updates\n        itemUpdateTimeout: null,\n        // queue of items waiting to be processed\n        processingQueue: [],\n        // options\n        options: createOptions(options)\n    });\nconst fromCamels = (string, separator = \"-\")=>string.split(/(?=[A-Z])/).map((part)=>part.toLowerCase()).join(separator);\nconst createOptionAPI = (store, options)=>{\n    const obj = {};\n    forin(options, (key)=>{\n        obj[key] = {\n            get: ()=>store.getState().options[key],\n            set: (value)=>{\n                store.dispatch(`SET_${fromCamels(key, \"_\").toUpperCase()}`, {\n                    value\n                });\n            }\n        };\n    });\n    return obj;\n};\nconst createOptionActions = (options)=>(dispatch, query, state)=>{\n        const obj = {};\n        forin(options, (key)=>{\n            const name = fromCamels(key, \"_\").toUpperCase();\n            obj[`SET_${name}`] = (action)=>{\n                try {\n                    state.options[key] = action.value;\n                } catch (e) {\n                // nope, failed\n                }\n                // we successfully set the value of this option\n                dispatch(`DID_SET_${name}`, {\n                    value: state.options[key]\n                });\n            };\n        });\n        return obj;\n    };\nconst createOptionQueries = (options)=>(state)=>{\n        const obj = {};\n        forin(options, (key)=>{\n            obj[`GET_${fromCamels(key, \"_\").toUpperCase()}`] = (action)=>state.options[key];\n        });\n        return obj;\n    };\nconst InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5\n};\nconst getUniqueId = ()=>Math.random().toString(36).substring(2, 11);\nconst arrayRemove = (arr, index)=>arr.splice(index, 1);\nconst run = (cb, sync)=>{\n    if (sync) {\n        cb();\n    } else if (document.hidden) {\n        Promise.resolve(1).then(cb);\n    } else {\n        setTimeout(cb, 0);\n    }\n};\nconst on = ()=>{\n    const listeners = [];\n    const off = (event, cb)=>{\n        arrayRemove(listeners, listeners.findIndex((listener)=>listener.event === event && (listener.cb === cb || !cb)));\n    };\n    const fire = (event, args, sync)=>{\n        listeners.filter((listener)=>listener.event === event).map((listener)=>listener.cb).forEach((cb)=>run(()=>cb(...args), sync));\n    };\n    return {\n        fireSync: (event, ...args)=>{\n            fire(event, args, true);\n        },\n        fire: (event, ...args)=>{\n            fire(event, args, false);\n        },\n        on: (event, cb)=>{\n            listeners.push({\n                event,\n                cb\n            });\n        },\n        onOnce: (event, cb)=>{\n            listeners.push({\n                event,\n                cb: (...args)=>{\n                    off(event, cb);\n                    cb(...args);\n                }\n            });\n        },\n        off\n    };\n};\nconst copyObjectPropertiesToObject = (src, target, excluded)=>{\n    Object.getOwnPropertyNames(src).filter((property)=>!excluded.includes(property)).forEach((key)=>Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(src, key)));\n};\nconst PRIVATE = [\n    \"fire\",\n    \"process\",\n    \"revert\",\n    \"load\",\n    \"on\",\n    \"off\",\n    \"onOnce\",\n    \"retryLoad\",\n    \"extend\",\n    \"archive\",\n    \"archived\",\n    \"release\",\n    \"released\",\n    \"requestProcessing\",\n    \"freeze\"\n];\nconst createItemAPI = (item)=>{\n    const api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n};\nconst removeReleasedItems = (items)=>{\n    items.forEach((item, index)=>{\n        if (item.released) {\n            arrayRemove(items, index);\n        }\n    });\n};\nconst ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8\n};\nconst FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3\n};\nconst getNonNumeric = (str)=>/[^0-9]+/.exec(str);\nconst getDecimalSeparator = ()=>getNonNumeric(1.1.toLocaleString())[0];\nconst getThousandsSeparator = ()=>{\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    const decimalSeparator = getDecimalSeparator();\n    const thousandsStringWithSeparator = 1000.0.toLocaleString();\n    const thousandsStringWithoutSeparator = 1000.0.toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n        return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === \".\" ? \",\" : \".\";\n};\nconst Type = {\n    BOOLEAN: \"boolean\",\n    INT: \"int\",\n    NUMBER: \"number\",\n    STRING: \"string\",\n    ARRAY: \"array\",\n    OBJECT: \"object\",\n    FUNCTION: \"function\",\n    ACTION: \"action\",\n    SERVER_API: \"serverapi\",\n    REGEX: \"regex\"\n};\n// all registered filters\nconst filters = [];\n// loops over matching filters and passes options to each filter, returning the mapped results\nconst applyFilterChain = (key, value, utils)=>new Promise((resolve, reject)=>{\n        // find matching filters for this key\n        const matchingFilters = filters.filter((f)=>f.key === key).map((f)=>f.cb);\n        // resolve now\n        if (matchingFilters.length === 0) {\n            resolve(value);\n            return;\n        }\n        // first filter to kick things of\n        const initialFilter = matchingFilters.shift();\n        // chain filters\n        matchingFilters.reduce(// loop over promises passing value to next promise\n        (current, next)=>current.then((value)=>next(value, utils)), // call initial filter, will return a promise\n        initialFilter(value, utils)).then((value)=>resolve(value)).catch((error)=>reject(error));\n    });\nconst applyFilters = (key, value, utils)=>filters.filter((f)=>f.key === key).map((f)=>f.cb(value, utils));\n// adds a new filter to the list\nconst addFilter = (key, cb)=>filters.push({\n        key,\n        cb\n    });\nconst extendDefaultOptions = (additionalOptions)=>Object.assign(defaultOptions, additionalOptions);\nconst getOptions = ()=>({\n        ...defaultOptions\n    });\nconst setOptions = (opts)=>{\n    forin(opts, (key, value)=>{\n        // key does not exist, so this option cannot be set\n        if (!defaultOptions[key]) {\n            return;\n        }\n        defaultOptions[key][0] = getValueByType(value, defaultOptions[key][0], defaultOptions[key][1]);\n    });\n};\n// default options on app\nconst defaultOptions = {\n    // the id to add to the root element\n    id: [\n        null,\n        Type.STRING\n    ],\n    // input field name to use\n    name: [\n        \"filepond\",\n        Type.STRING\n    ],\n    // disable the field\n    disabled: [\n        false,\n        Type.BOOLEAN\n    ],\n    // classname to put on wrapper\n    className: [\n        null,\n        Type.STRING\n    ],\n    // is the field required\n    required: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Allow media capture when value is set\n    captureMethod: [\n        null,\n        Type.STRING\n    ],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n    // sync `acceptedFileTypes` property with `accept` attribute\n    allowSyncAcceptAttribute: [\n        true,\n        Type.BOOLEAN\n    ],\n    // Feature toggles\n    allowDrop: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowBrowse: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowPaste: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowMultiple: [\n        false,\n        Type.BOOLEAN\n    ],\n    allowReplace: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowRevert: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowRemove: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowProcess: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowReorder: [\n        false,\n        Type.BOOLEAN\n    ],\n    allowDirectoriesOnly: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Try store file if `server` not set\n    storeAsFile: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Revert mode\n    forceRevert: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Input requirements\n    maxFiles: [\n        null,\n        Type.INT\n    ],\n    checkValidity: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Where to put file\n    itemInsertLocationFreedom: [\n        true,\n        Type.BOOLEAN\n    ],\n    itemInsertLocation: [\n        \"before\",\n        Type.STRING\n    ],\n    itemInsertInterval: [\n        75,\n        Type.INT\n    ],\n    // Drag 'n Drop related\n    dropOnPage: [\n        false,\n        Type.BOOLEAN\n    ],\n    dropOnElement: [\n        true,\n        Type.BOOLEAN\n    ],\n    dropValidation: [\n        false,\n        Type.BOOLEAN\n    ],\n    ignoredFiles: [\n        [\n            \".ds_store\",\n            \"thumbs.db\",\n            \"desktop.ini\"\n        ],\n        Type.ARRAY\n    ],\n    // Upload related\n    instantUpload: [\n        true,\n        Type.BOOLEAN\n    ],\n    maxParallelUploads: [\n        2,\n        Type.INT\n    ],\n    allowMinimumUploadDuration: [\n        true,\n        Type.BOOLEAN\n    ],\n    // Chunks\n    chunkUploads: [\n        false,\n        Type.BOOLEAN\n    ],\n    chunkForce: [\n        false,\n        Type.BOOLEAN\n    ],\n    chunkSize: [\n        5000000,\n        Type.INT\n    ],\n    chunkRetryDelays: [\n        [\n            500,\n            1000,\n            3000\n        ],\n        Type.ARRAY\n    ],\n    // The server api end points to use for uploading (see docs)\n    server: [\n        null,\n        Type.SERVER_API\n    ],\n    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n    fileSizeBase: [\n        1000,\n        Type.INT\n    ],\n    // Labels and status messages\n    labelFileSizeBytes: [\n        \"bytes\",\n        Type.STRING\n    ],\n    labelFileSizeKilobytes: [\n        \"KB\",\n        Type.STRING\n    ],\n    labelFileSizeMegabytes: [\n        \"MB\",\n        Type.STRING\n    ],\n    labelFileSizeGigabytes: [\n        \"GB\",\n        Type.STRING\n    ],\n    labelDecimalSeparator: [\n        getDecimalSeparator(),\n        Type.STRING\n    ],\n    labelThousandsSeparator: [\n        getThousandsSeparator(),\n        Type.STRING\n    ],\n    labelIdle: [\n        'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n        Type.STRING\n    ],\n    labelInvalidField: [\n        \"Field contains invalid files\",\n        Type.STRING\n    ],\n    labelFileWaitingForSize: [\n        \"Waiting for size\",\n        Type.STRING\n    ],\n    labelFileSizeNotAvailable: [\n        \"Size not available\",\n        Type.STRING\n    ],\n    labelFileCountSingular: [\n        \"file in list\",\n        Type.STRING\n    ],\n    labelFileCountPlural: [\n        \"files in list\",\n        Type.STRING\n    ],\n    labelFileLoading: [\n        \"Loading\",\n        Type.STRING\n    ],\n    labelFileAdded: [\n        \"Added\",\n        Type.STRING\n    ],\n    labelFileLoadError: [\n        \"Error during load\",\n        Type.STRING\n    ],\n    labelFileRemoved: [\n        \"Removed\",\n        Type.STRING\n    ],\n    labelFileRemoveError: [\n        \"Error during remove\",\n        Type.STRING\n    ],\n    labelFileProcessing: [\n        \"Uploading\",\n        Type.STRING\n    ],\n    labelFileProcessingComplete: [\n        \"Upload complete\",\n        Type.STRING\n    ],\n    labelFileProcessingAborted: [\n        \"Upload cancelled\",\n        Type.STRING\n    ],\n    labelFileProcessingError: [\n        \"Error during upload\",\n        Type.STRING\n    ],\n    labelFileProcessingRevertError: [\n        \"Error during revert\",\n        Type.STRING\n    ],\n    labelTapToCancel: [\n        \"tap to cancel\",\n        Type.STRING\n    ],\n    labelTapToRetry: [\n        \"tap to retry\",\n        Type.STRING\n    ],\n    labelTapToUndo: [\n        \"tap to undo\",\n        Type.STRING\n    ],\n    labelButtonRemoveItem: [\n        \"Remove\",\n        Type.STRING\n    ],\n    labelButtonAbortItemLoad: [\n        \"Abort\",\n        Type.STRING\n    ],\n    labelButtonRetryItemLoad: [\n        \"Retry\",\n        Type.STRING\n    ],\n    labelButtonAbortItemProcessing: [\n        \"Cancel\",\n        Type.STRING\n    ],\n    labelButtonUndoItemProcessing: [\n        \"Undo\",\n        Type.STRING\n    ],\n    labelButtonRetryItemProcessing: [\n        \"Retry\",\n        Type.STRING\n    ],\n    labelButtonProcessItem: [\n        \"Upload\",\n        Type.STRING\n    ],\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    iconProcess: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n        Type.STRING\n    ],\n    iconRetry: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    iconUndo: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    iconDone: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    // event handlers\n    oninit: [\n        null,\n        Type.FUNCTION\n    ],\n    onwarning: [\n        null,\n        Type.FUNCTION\n    ],\n    onerror: [\n        null,\n        Type.FUNCTION\n    ],\n    onactivatefile: [\n        null,\n        Type.FUNCTION\n    ],\n    oninitfile: [\n        null,\n        Type.FUNCTION\n    ],\n    onaddfilestart: [\n        null,\n        Type.FUNCTION\n    ],\n    onaddfileprogress: [\n        null,\n        Type.FUNCTION\n    ],\n    onaddfile: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfilestart: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfileprogress: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfileabort: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfilerevert: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfile: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfiles: [\n        null,\n        Type.FUNCTION\n    ],\n    onremovefile: [\n        null,\n        Type.FUNCTION\n    ],\n    onpreparefile: [\n        null,\n        Type.FUNCTION\n    ],\n    onupdatefiles: [\n        null,\n        Type.FUNCTION\n    ],\n    onreorderfiles: [\n        null,\n        Type.FUNCTION\n    ],\n    // hooks\n    beforeDropFile: [\n        null,\n        Type.FUNCTION\n    ],\n    beforeAddFile: [\n        null,\n        Type.FUNCTION\n    ],\n    beforeRemoveFile: [\n        null,\n        Type.FUNCTION\n    ],\n    beforePrepareFile: [\n        null,\n        Type.FUNCTION\n    ],\n    // styles\n    stylePanelLayout: [\n        null,\n        Type.STRING\n    ],\n    stylePanelAspectRatio: [\n        null,\n        Type.STRING\n    ],\n    styleItemPanelAspectRatio: [\n        null,\n        Type.STRING\n    ],\n    styleButtonRemoveItemPosition: [\n        \"left\",\n        Type.STRING\n    ],\n    styleButtonProcessItemPosition: [\n        \"right\",\n        Type.STRING\n    ],\n    styleLoadIndicatorPosition: [\n        \"right\",\n        Type.STRING\n    ],\n    styleProgressIndicatorPosition: [\n        \"right\",\n        Type.STRING\n    ],\n    styleButtonRemoveItemAlign: [\n        false,\n        Type.BOOLEAN\n    ],\n    // custom initial files array\n    files: [\n        [],\n        Type.ARRAY\n    ],\n    // show support by displaying credits\n    credits: [\n        [\n            \"https://pqina.nl/\",\n            \"Powered by PQINA\"\n        ],\n        Type.ARRAY\n    ]\n};\nconst getItemByQuery = (items, query)=>{\n    // just return first index\n    if (isEmpty(query)) {\n        return items[0] || null;\n    }\n    // query is index\n    if (isInt(query)) {\n        return items[query] || null;\n    }\n    // if query is item, get the id\n    if (typeof query === \"object\") {\n        query = query.id;\n    }\n    // assume query is a string and return item by id\n    return items.find((item)=>item.id === query) || null;\n};\nconst getNumericAspectRatioFromString = (aspectRatio)=>{\n    if (isEmpty(aspectRatio)) {\n        return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n        const parts = aspectRatio.split(\":\");\n        return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n};\nconst getActiveItems = (items)=>items.filter((item)=>!item.archived);\nconst Status = {\n    EMPTY: 0,\n    IDLE: 1,\n    ERROR: 2,\n    BUSY: 3,\n    READY: 4\n};\nlet res = null;\nconst canUpdateFileInput = ()=>{\n    if (res === null) {\n        try {\n            const dataTransfer = new DataTransfer();\n            dataTransfer.items.add(new File([\n                \"hello world\"\n            ], \"This_Works.txt\"));\n            const el = document.createElement(\"input\");\n            el.setAttribute(\"type\", \"file\");\n            el.files = dataTransfer.files;\n            res = el.files.length === 1;\n        } catch (err) {\n            res = false;\n        }\n    }\n    return res;\n};\nconst ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR\n];\nconst ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT\n];\nconst ITEM_READY = [\n    ItemStatus.PROCESSING_COMPLETE\n];\nconst isItemInErrorState = (item)=>ITEM_ERROR.includes(item.status);\nconst isItemInBusyState = (item)=>ITEM_BUSY.includes(item.status);\nconst isItemInReadyState = (item)=>ITEM_READY.includes(item.status);\nconst isAsync = (state)=>isObject(state.options.server) && (isObject(state.options.server.process) || isFunction(state.options.server.process));\nconst queries = (state)=>({\n        GET_STATUS: ()=>{\n            const items = getActiveItems(state.items);\n            const { EMPTY, ERROR, BUSY, IDLE, READY } = Status;\n            if (items.length === 0) return EMPTY;\n            if (items.some(isItemInErrorState)) return ERROR;\n            if (items.some(isItemInBusyState)) return BUSY;\n            if (items.some(isItemInReadyState)) return READY;\n            return IDLE;\n        },\n        GET_ITEM: (query)=>getItemByQuery(state.items, query),\n        GET_ACTIVE_ITEM: (query)=>getItemByQuery(getActiveItems(state.items), query),\n        GET_ACTIVE_ITEMS: ()=>getActiveItems(state.items),\n        GET_ITEMS: ()=>state.items,\n        GET_ITEM_NAME: (query)=>{\n            const item = getItemByQuery(state.items, query);\n            return item ? item.filename : null;\n        },\n        GET_ITEM_SIZE: (query)=>{\n            const item = getItemByQuery(state.items, query);\n            return item ? item.fileSize : null;\n        },\n        GET_STYLES: ()=>Object.keys(state.options).filter((key)=>/^style/.test(key)).map((option1)=>({\n                    name: option1,\n                    value: state.options[option1]\n                })),\n        GET_PANEL_ASPECT_RATIO: ()=>{\n            const isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n            const aspectRatio = isShapeCircle ? 1 : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);\n            return aspectRatio;\n        },\n        GET_ITEM_PANEL_ASPECT_RATIO: ()=>state.options.styleItemPanelAspectRatio,\n        GET_ITEMS_BY_STATUS: (status)=>getActiveItems(state.items).filter((item)=>item.status === status),\n        GET_TOTAL_ITEMS: ()=>getActiveItems(state.items).length,\n        SHOULD_UPDATE_FILE_INPUT: ()=>state.options.storeAsFile && canUpdateFileInput() && !isAsync(state),\n        IS_ASYNC: ()=>isAsync(state),\n        GET_FILE_SIZE_LABELS: (query)=>({\n                labelBytes: query(\"GET_LABEL_FILE_SIZE_BYTES\") || undefined,\n                labelKilobytes: query(\"GET_LABEL_FILE_SIZE_KILOBYTES\") || undefined,\n                labelMegabytes: query(\"GET_LABEL_FILE_SIZE_MEGABYTES\") || undefined,\n                labelGigabytes: query(\"GET_LABEL_FILE_SIZE_GIGABYTES\") || undefined\n            })\n    });\nconst hasRoomForItem = (state)=>{\n    const count = getActiveItems(state.items).length;\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n        return count === 0;\n    }\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    const maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n        return true;\n    }\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n        return true;\n    }\n    // no more room for another file\n    return false;\n};\nconst limit = (value, min, max)=>Math.max(Math.min(max, value), min);\nconst arrayInsert = (arr, index, item)=>arr.splice(index, 0, item);\nconst insertItem = (items, item, index)=>{\n    if (isEmpty(item)) {\n        return null;\n    }\n    // if index is undefined, append\n    if (typeof index === \"undefined\") {\n        items.push(item);\n        return item;\n    }\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n    // add item to array\n    arrayInsert(items, index, item);\n    // expose\n    return item;\n};\nconst isBase64DataURI = (str)=>/^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(str);\nconst getFilenameFromURL = (url)=>`${url}`.split(\"/\").pop().split(\"?\").shift();\nconst getExtensionFromFilename = (name)=>name.split(\".\").pop();\nconst guesstimateExtension = (type)=>{\n    // if no extension supplied, exit here\n    if (typeof type !== \"string\") {\n        return \"\";\n    }\n    // get subtype\n    const subtype = type.split(\"/\").pop();\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n        return \"svg\";\n    }\n    if (/zip|compressed/.test(subtype)) {\n        return \"zip\";\n    }\n    if (/plain/.test(subtype)) {\n        return \"txt\";\n    }\n    if (/msword/.test(subtype)) {\n        return \"doc\";\n    }\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n        // always use jpg extension\n        if (subtype === \"jpeg\") {\n            return \"jpg\";\n        }\n        // return subtype\n        return subtype;\n    }\n    return \"\";\n};\nconst leftPad = (value, padding = \"\")=>(padding + value).slice(-padding.length);\nconst getDateString = (date = new Date())=>`${date.getFullYear()}-${leftPad(date.getMonth() + 1, \"00\")}-${leftPad(date.getDate(), \"00\")}_${leftPad(date.getHours(), \"00\")}-${leftPad(date.getMinutes(), \"00\")}-${leftPad(date.getSeconds(), \"00\")}`;\nconst getFileFromBlob = (blob, filename, type = null, extension = null)=>{\n    const file = typeof type === \"string\" ? blob.slice(0, blob.size, type) : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n    // copy relative path\n    if (blob._relativePath) file._relativePath = blob._relativePath;\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n        filename = getDateString();\n    }\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n        file.name = filename;\n    } else {\n        extension = extension || guesstimateExtension(file.type);\n        file.name = filename + (extension ? \".\" + extension : \"\");\n    }\n    return file;\n};\nconst getBlobBuilder = ()=>{\n    return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n};\nconst createBlob = (arrayBuffer, mimeType)=>{\n    const BB = getBlobBuilder();\n    if (BB) {\n        const bb = new BB();\n        bb.append(arrayBuffer);\n        return bb.getBlob(mimeType);\n    }\n    return new Blob([\n        arrayBuffer\n    ], {\n        type: mimeType\n    });\n};\nconst getBlobFromByteStringWithMimeType = (byteString, mimeType)=>{\n    const ab = new ArrayBuffer(byteString.length);\n    const ia = new Uint8Array(ab);\n    for(let i = 0; i < byteString.length; i++){\n        ia[i] = byteString.charCodeAt(i);\n    }\n    return createBlob(ab, mimeType);\n};\nconst getMimeTypeFromBase64DataURI = (dataURI)=>{\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n};\nconst getBase64DataFromBase64DataURI = (dataURI)=>{\n    // get data part of string (remove data:image/jpeg...,)\n    const data = dataURI.split(\",\")[1];\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, \"\");\n};\nconst getByteStringFromBase64DataURI = (dataURI)=>{\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n};\nconst getBlobFromBase64DataURI = (dataURI)=>{\n    const mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    const byteString = getByteStringFromBase64DataURI(dataURI);\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n};\nconst getFileFromBase64DataURI = (dataURI, filename, extension)=>{\n    return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);\n};\nconst getFileNameFromHeader = (header)=>{\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n    // get filename parts\n    const matches = header.split(/filename=|filename\\*=.+''/).splice(1).map((name)=>name.trim().replace(/^[\"']|[;\"']{0,2}$/g, \"\")).filter((name)=>name.length);\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n};\nconst getFileSizeFromHeader = (header)=>{\n    if (/content-length:/i.test(header)) {\n        const size = header.match(/[0-9]+/)[0];\n        return size ? parseInt(size, 10) : null;\n    }\n    return null;\n};\nconst getTranfserIdFromHeader = (header)=>{\n    if (/x-content-transfer-id:/i.test(header)) {\n        const id = (header.split(\":\")[1] || \"\").trim();\n        return id || null;\n    }\n    return null;\n};\nconst getFileInfoFromHeaders = (headers)=>{\n    const info = {\n        source: null,\n        name: null,\n        size: null\n    };\n    const rows = headers.split(\"\\n\");\n    for (let header of rows){\n        const name = getFileNameFromHeader(header);\n        if (name) {\n            info.name = name;\n            continue;\n        }\n        const size = getFileSizeFromHeader(header);\n        if (size) {\n            info.size = size;\n            continue;\n        }\n        const source = getTranfserIdFromHeader(header);\n        if (source) {\n            info.source = source;\n            continue;\n        }\n    }\n    return info;\n};\nconst createFileLoader = (fetchFn)=>{\n    const state = {\n        source: null,\n        complete: false,\n        progress: 0,\n        size: null,\n        timestamp: null,\n        duration: 0,\n        request: null\n    };\n    const getProgress = ()=>state.progress;\n    const abort = ()=>{\n        if (state.request && state.request.abort) {\n            state.request.abort();\n        }\n    };\n    // load source\n    const load = ()=>{\n        // get quick reference\n        const source = state.source;\n        api.fire(\"init\", source);\n        // Load Files\n        if (source instanceof File) {\n            api.fire(\"load\", source);\n        } else if (source instanceof Blob) {\n            // Load blobs, set default name to current date\n            api.fire(\"load\", getFileFromBlob(source, source.name));\n        } else if (isBase64DataURI(source)) {\n            // Load base 64, set default name to current date\n            api.fire(\"load\", getFileFromBase64DataURI(source));\n        } else {\n            // Deal as if is external URL, let's load it!\n            loadURL(source);\n        }\n    };\n    // loads a url\n    const loadURL = (url)=>{\n        // is remote url and no fetch method supplied\n        if (!fetchFn) {\n            api.fire(\"error\", {\n                type: \"error\",\n                body: \"Can't load URL\",\n                code: 400\n            });\n            return;\n        }\n        // set request start\n        state.timestamp = Date.now();\n        // load file\n        state.request = fetchFn(url, (response)=>{\n            // update duration\n            state.duration = Date.now() - state.timestamp;\n            // done!\n            state.complete = true;\n            // turn blob response into a file\n            if (response instanceof Blob) {\n                response = getFileFromBlob(response, response.name || getFilenameFromURL(url));\n            }\n            api.fire(\"load\", // if has received blob, we go with blob, if no response, we return null\n            response instanceof Blob ? response : response ? response.body : null);\n        }, (error)=>{\n            api.fire(\"error\", typeof error === \"string\" ? {\n                type: \"error\",\n                code: 0,\n                body: error\n            } : error);\n        }, (computable, current, total)=>{\n            // collected some meta data already\n            if (total) {\n                state.size = total;\n            }\n            // update duration\n            state.duration = Date.now() - state.timestamp;\n            // if we can't compute progress, we're not going to fire progress events\n            if (!computable) {\n                state.progress = null;\n                return;\n            }\n            // update progress percentage\n            state.progress = current / total;\n            // expose\n            api.fire(\"progress\", state.progress);\n        }, ()=>{\n            api.fire(\"abort\");\n        }, (response)=>{\n            const fileinfo = getFileInfoFromHeaders(typeof response === \"string\" ? response : response.headers);\n            api.fire(\"meta\", {\n                size: state.size || fileinfo.size,\n                filename: fileinfo.name,\n                source: fileinfo.source\n            });\n        });\n    };\n    const api = {\n        ...on(),\n        setSource: (source)=>state.source = source,\n        getProgress,\n        abort,\n        load\n    };\n    return api;\n};\nconst isGet = (method)=>/GET|HEAD/.test(method);\nconst sendRequest = (data, url, options)=>{\n    const api = {\n        onheaders: ()=>{},\n        onprogress: ()=>{},\n        onload: ()=>{},\n        ontimeout: ()=>{},\n        onerror: ()=>{},\n        onabort: ()=>{},\n        abort: ()=>{\n            aborted = true;\n            xhr.abort();\n        }\n    };\n    // timeout identifier, only used when timeout is defined\n    let aborted = false;\n    let headersReceived = false;\n    // set default options\n    options = {\n        method: \"POST\",\n        headers: {},\n        withCredentials: false,\n        ...options\n    };\n    // encode url\n    url = encodeURI(url);\n    // if method is GET, add any received data to url\n    if (isGet(options.method) && data) {\n        url = `${url}${encodeURIComponent(typeof data === \"string\" ? data : JSON.stringify(data))}`;\n    }\n    // create request\n    const xhr = new XMLHttpRequest();\n    // progress of load\n    const process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = (e)=>{\n        // no progress event when aborted ( onprogress is called once after abort() )\n        if (aborted) {\n            return;\n        }\n        api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = ()=>{\n        // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n        if (xhr.readyState < 2) {\n            return;\n        }\n        // no server response\n        if (xhr.readyState === 4 && xhr.status === 0) {\n            return;\n        }\n        if (headersReceived) {\n            return;\n        }\n        headersReceived = true;\n        // we've probably received some useful data in response headers\n        api.onheaders(xhr);\n    };\n    // load successful\n    xhr.onload = ()=>{\n        // is classified as valid response\n        if (xhr.status >= 200 && xhr.status < 300) {\n            api.onload(xhr);\n        } else {\n            api.onerror(xhr);\n        }\n    };\n    // error during load\n    xhr.onerror = ()=>api.onerror(xhr);\n    // request aborted\n    xhr.onabort = ()=>{\n        aborted = true;\n        api.onabort();\n    };\n    // request timeout\n    xhr.ontimeout = ()=>api.ontimeout(xhr);\n    // open up open up!\n    xhr.open(options.method, url, true);\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n        xhr.timeout = options.timeout;\n    }\n    // add headers\n    Object.keys(options.headers).forEach((key)=>{\n        const value = unescape(encodeURIComponent(options.headers[key]));\n        xhr.setRequestHeader(key, value);\n    });\n    // set type of response\n    if (options.responseType) {\n        xhr.responseType = options.responseType;\n    }\n    // set credentials\n    if (options.withCredentials) {\n        xhr.withCredentials = true;\n    }\n    // let's send our data\n    xhr.send(data);\n    return api;\n};\nconst createResponse = (type, code, body, headers)=>({\n        type,\n        code,\n        body,\n        headers\n    });\nconst createTimeoutResponse = (cb)=>(xhr)=>{\n        cb(createResponse(\"error\", 0, \"Timeout\", xhr.getAllResponseHeaders()));\n    };\nconst hasQS = (str)=>/\\?/.test(str);\nconst buildURL = (...parts)=>{\n    let url = \"\";\n    parts.forEach((part)=>{\n        url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, \"&\") : part;\n    });\n    return url;\n};\nconst createFetchFunction = (apiUrl = \"\", action)=>{\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === \"function\") {\n        return action;\n    }\n    // no action supplied\n    if (!action || !isString(action.url)) {\n        return null;\n    }\n    // set onload hanlder\n    const onload = action.onload || ((res)=>res);\n    const onerror = action.onerror || ((res)=>null);\n    // internal handler\n    return (url, load, error, progress, abort, headers)=>{\n        // do local or remote request based on if the url is external\n        const request = sendRequest(url, buildURL(apiUrl, action.url), {\n            ...action,\n            responseType: \"blob\"\n        });\n        request.onload = (xhr)=>{\n            // get headers\n            const headers = xhr.getAllResponseHeaders();\n            // get filename\n            const filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n            // create response\n            load(createResponse(\"load\", xhr.status, action.method === \"HEAD\" ? null : getFileFromBlob(onload(xhr.response), filename), headers));\n        };\n        request.onerror = (xhr)=>{\n            error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n        request.onheaders = (xhr)=>{\n            headers(createResponse(\"headers\", xhr.status, null, xhr.getAllResponseHeaders()));\n        };\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n        // should return request\n        return request;\n    };\n};\nconst ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4\n};\n/*\nfunction signature:\n  (file, metadata, load, error, progress, abort, transfer, options) => {\n    return {\n    abort:() => {}\n  }\n}\n*/ // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\nconst processFileChunked = (apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options)=>{\n    // all chunks\n    const chunks = [];\n    const { chunkTransferId, chunkServer, chunkSize, chunkRetryDelays } = options;\n    // default state\n    const state = {\n        serverId: chunkTransferId,\n        aborted: false\n    };\n    // set onload handlers\n    const ondata = action.ondata || ((fd)=>fd);\n    const onload = action.onload || ((xhr, method)=>method === \"HEAD\" ? xhr.getResponseHeader(\"Upload-Offset\") : xhr.response);\n    const onerror = action.onerror || ((res)=>null);\n    // create server hook\n    const requestTransferId = (cb)=>{\n        const formData = new FormData();\n        // add metadata under same name\n        if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n        const headers = typeof action.headers === \"function\" ? action.headers(file, metadata) : {\n            ...action.headers,\n            \"Upload-Length\": file.size\n        };\n        const requestParams = {\n            ...action,\n            headers\n        };\n        // send request object\n        const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);\n        request.onload = (xhr)=>cb(onload(xhr, requestParams.method));\n        request.onerror = (xhr)=>error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        request.ontimeout = createTimeoutResponse(error);\n    };\n    const requestTransferOffset = (cb)=>{\n        const requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n        const headers = typeof action.headers === \"function\" ? action.headers(state.serverId) : {\n            ...action.headers\n        };\n        const requestParams = {\n            headers,\n            method: \"HEAD\"\n        };\n        const request = sendRequest(null, requestUrl, requestParams);\n        request.onload = (xhr)=>cb(onload(xhr, requestParams.method));\n        request.onerror = (xhr)=>error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        request.ontimeout = createTimeoutResponse(error);\n    };\n    // create chunks\n    const lastChunkIndex = Math.floor(file.size / chunkSize);\n    for(let i = 0; i <= lastChunkIndex; i++){\n        const offset = i * chunkSize;\n        const data = file.slice(offset, offset + chunkSize, \"application/offset+octet-stream\");\n        chunks[i] = {\n            index: i,\n            size: data.size,\n            offset,\n            data,\n            file,\n            progress: 0,\n            retries: [\n                ...chunkRetryDelays\n            ],\n            status: ChunkStatus.QUEUED,\n            error: null,\n            request: null,\n            timeout: null\n        };\n    }\n    const completeProcessingChunks = ()=>load(state.serverId);\n    const canProcessChunk = (chunk)=>chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;\n    const processChunk = (chunk)=>{\n        // processing is paused, wait here\n        if (state.aborted) return;\n        // get next chunk to process\n        chunk = chunk || chunks.find(canProcessChunk);\n        // no more chunks to process\n        if (!chunk) {\n            // all done?\n            if (chunks.every((chunk)=>chunk.status === ChunkStatus.COMPLETE)) {\n                completeProcessingChunks();\n            }\n            // no chunk to handle\n            return;\n        }\n        // now processing this chunk\n        chunk.status = ChunkStatus.PROCESSING;\n        chunk.progress = null;\n        // allow parsing of formdata\n        const ondata = chunkServer.ondata || ((fd)=>fd);\n        const onerror = chunkServer.onerror || ((res)=>null);\n        const onload = chunkServer.onload || (()=>{});\n        // send request object\n        const requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n        const headers = typeof chunkServer.headers === \"function\" ? chunkServer.headers(chunk) : {\n            ...chunkServer.headers,\n            \"Content-Type\": \"application/offset+octet-stream\",\n            \"Upload-Offset\": chunk.offset,\n            \"Upload-Length\": file.size,\n            \"Upload-Name\": file.name\n        };\n        const request = chunk.request = sendRequest(ondata(chunk.data), requestUrl, {\n            ...chunkServer,\n            headers\n        });\n        request.onload = (xhr)=>{\n            // allow hooking into request result\n            onload(xhr, chunk.index, chunks.length);\n            // done!\n            chunk.status = ChunkStatus.COMPLETE;\n            // remove request reference\n            chunk.request = null;\n            // start processing more chunks\n            processChunks();\n        };\n        request.onprogress = (lengthComputable, loaded, total)=>{\n            chunk.progress = lengthComputable ? loaded : null;\n            updateTotalProgress();\n        };\n        request.onerror = (xhr)=>{\n            chunk.status = ChunkStatus.ERROR;\n            chunk.request = null;\n            chunk.error = onerror(xhr.response) || xhr.statusText;\n            if (!retryProcessChunk(chunk)) {\n                error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n            }\n        };\n        request.ontimeout = (xhr)=>{\n            chunk.status = ChunkStatus.ERROR;\n            chunk.request = null;\n            if (!retryProcessChunk(chunk)) {\n                createTimeoutResponse(error)(xhr);\n            }\n        };\n        request.onabort = ()=>{\n            chunk.status = ChunkStatus.QUEUED;\n            chunk.request = null;\n            abort();\n        };\n    };\n    const retryProcessChunk = (chunk)=>{\n        // no more retries left\n        if (chunk.retries.length === 0) return false;\n        // new retry\n        chunk.status = ChunkStatus.WAITING;\n        clearTimeout(chunk.timeout);\n        chunk.timeout = setTimeout(()=>{\n            processChunk(chunk);\n        }, chunk.retries.shift());\n        // we're going to retry\n        return true;\n    };\n    const updateTotalProgress = ()=>{\n        // calculate total progress fraction\n        const totalBytesTransfered = chunks.reduce((p, chunk)=>{\n            if (p === null || chunk.progress === null) return null;\n            return p + chunk.progress;\n        }, 0);\n        // can't compute progress\n        if (totalBytesTransfered === null) return progress(false, 0, 0);\n        // calculate progress values\n        const totalSize = chunks.reduce((total, chunk)=>total + chunk.size, 0);\n        // can update progress indicator\n        progress(true, totalBytesTransfered, totalSize);\n    };\n    // process new chunks\n    const processChunks = ()=>{\n        const totalProcessing = chunks.filter((chunk)=>chunk.status === ChunkStatus.PROCESSING).length;\n        if (totalProcessing >= 1) return;\n        processChunk();\n    };\n    const abortChunks = ()=>{\n        chunks.forEach((chunk)=>{\n            clearTimeout(chunk.timeout);\n            if (chunk.request) {\n                chunk.request.abort();\n            }\n        });\n    };\n    // let's go!\n    if (!state.serverId) {\n        requestTransferId((serverId)=>{\n            // stop here if aborted, might have happened in between request and callback\n            if (state.aborted) return;\n            // pass back to item so we can use it if something goes wrong\n            transfer(serverId);\n            // store internally\n            state.serverId = serverId;\n            processChunks();\n        });\n    } else {\n        requestTransferOffset((offset)=>{\n            // stop here if aborted, might have happened in between request and callback\n            if (state.aborted) return;\n            // mark chunks with lower offset as complete\n            chunks.filter((chunk)=>chunk.offset < offset).forEach((chunk)=>{\n                chunk.status = ChunkStatus.COMPLETE;\n                chunk.progress = chunk.size;\n            });\n            // continue processing\n            processChunks();\n        });\n    }\n    return {\n        abort: ()=>{\n            state.aborted = true;\n            abortChunks();\n        }\n    };\n};\n/*\nfunction signature:\n  (file, metadata, load, error, progress, abort) => {\n    return {\n    abort:() => {}\n  }\n}\n*/ const createFileProcessorFunction = (apiUrl, action, name, options)=>(file, metadata, load, error, progress, abort, transfer)=>{\n        // no file received\n        if (!file) return;\n        // if was passed a file, and we can chunk it, exit here\n        const canChunkUpload = options.chunkUploads;\n        const shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n        const willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);\n        if (file instanceof Blob && willChunkUpload) return processFileChunked(apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options);\n        // set handlers\n        const ondata = action.ondata || ((fd)=>fd);\n        const onload = action.onload || ((res)=>res);\n        const onerror = action.onerror || ((res)=>null);\n        const headers = typeof action.headers === \"function\" ? action.headers(file, metadata) || {} : {\n            ...action.headers\n        };\n        const requestParams = {\n            ...action,\n            headers\n        };\n        // create formdata object\n        var formData = new FormData();\n        // add metadata under same name\n        if (isObject(metadata)) {\n            formData.append(name, JSON.stringify(metadata));\n        }\n        // Turn into an array of objects so no matter what the input, we can handle it the same way\n        (file instanceof Blob ? [\n            {\n                name: null,\n                file\n            }\n        ] : file).forEach((item)=>{\n            formData.append(name, item.file, item.name === null ? item.file.name : `${item.name}${item.file.name}`);\n        });\n        // send request object\n        const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);\n        request.onload = (xhr)=>{\n            load(createResponse(\"load\", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));\n        };\n        request.onerror = (xhr)=>{\n            error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n        // should return request\n        return request;\n    };\nconst createProcessorFunction = (apiUrl = \"\", action, name, options)=>{\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === \"function\") return (...params)=>action(name, ...params, options);\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n};\n/*\n function signature:\n (uniqueFileId, load, error) => { }\n */ const createRevertFunction = (apiUrl = \"\", action)=>{\n    // is custom implementation\n    if (typeof action === \"function\") {\n        return action;\n    }\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n        return (uniqueFileId, load)=>load();\n    }\n    // set onload hanlder\n    const onload = action.onload || ((res)=>res);\n    const onerror = action.onerror || ((res)=>null);\n    // internal implementation\n    return (uniqueFileId, load, error)=>{\n        const request = sendRequest(uniqueFileId, apiUrl + action.url, action // contains method, headers and withCredentials properties\n        );\n        request.onload = (xhr)=>{\n            load(createResponse(\"load\", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));\n        };\n        request.onerror = (xhr)=>{\n            error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n        request.ontimeout = createTimeoutResponse(error);\n        return request;\n    };\n};\nconst getRandomNumber = (min = 0, max = 1)=>min + Math.random() * (max - min);\nconst createPerceivedPerformanceUpdater = (cb, duration = 1000, offset = 0, tickMin = 25, tickMax = 250)=>{\n    let timeout = null;\n    const start = Date.now();\n    const tick = ()=>{\n        let runtime = Date.now() - start;\n        let delay = getRandomNumber(tickMin, tickMax);\n        if (runtime + delay > duration) {\n            delay = runtime + delay - duration;\n        }\n        let progress = runtime / duration;\n        if (progress >= 1 || document.hidden) {\n            cb(1);\n            return;\n        }\n        cb(progress);\n        timeout = setTimeout(tick, delay);\n    };\n    if (duration > 0) tick();\n    return {\n        clear: ()=>{\n            clearTimeout(timeout);\n        }\n    };\n};\nconst createFileProcessor = (processFn, options)=>{\n    const state = {\n        complete: false,\n        perceivedProgress: 0,\n        perceivedPerformanceUpdater: null,\n        progress: null,\n        timestamp: null,\n        perceivedDuration: 0,\n        duration: 0,\n        request: null,\n        response: null\n    };\n    const { allowMinimumUploadDuration } = options;\n    const process = (file, metadata)=>{\n        const progressFn = ()=>{\n            // we've not yet started the real download, stop here\n            // the request might not go through, for instance, there might be some server trouble\n            // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n            if (state.duration === 0 || state.progress === null) return;\n            // as we're now processing, fire the progress event\n            api.fire(\"progress\", api.getProgress());\n        };\n        const completeFn = ()=>{\n            state.complete = true;\n            api.fire(\"load-perceived\", state.response.body);\n        };\n        // let's start processing\n        api.fire(\"start\");\n        // set request start\n        state.timestamp = Date.now();\n        // create perceived performance progress indicator\n        state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater((progress)=>{\n            state.perceivedProgress = progress;\n            state.perceivedDuration = Date.now() - state.timestamp;\n            progressFn();\n            // if fake progress is done, and a response has been received,\n            // and we've not yet called the complete method\n            if (state.response && state.perceivedProgress === 1 && !state.complete) {\n                // we done!\n                completeFn();\n            }\n        }, // random delay as in a list of files you start noticing\n        // files uploading at the exact same speed\n        allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0);\n        // remember request so we can abort it later\n        state.request = processFn(// the file to process\n        file, // the metadata to send along\n        metadata, // callbacks (load, error, progress, abort, transfer)\n        // load expects the body to be a server id if\n        // you want to make use of revert\n        (response)=>{\n            // we put the response in state so we can access\n            // it outside of this method\n            state.response = isObject(response) ? response : {\n                type: \"load\",\n                code: 200,\n                body: `${response}`,\n                headers: {}\n            };\n            // update duration\n            state.duration = Date.now() - state.timestamp;\n            // force progress to 1 as we're now done\n            state.progress = 1;\n            // actual load is done let's share results\n            api.fire(\"load\", state.response.body);\n            // we are really done\n            // if perceived progress is 1 ( wait for perceived progress to complete )\n            // or if server does not support progress ( null )\n            if (!allowMinimumUploadDuration || allowMinimumUploadDuration && state.perceivedProgress === 1) {\n                completeFn();\n            }\n        }, // error is expected to be an object with type, code, body\n        (error)=>{\n            // cancel updater\n            state.perceivedPerformanceUpdater.clear();\n            // update others about this error\n            api.fire(\"error\", isObject(error) ? error : {\n                type: \"error\",\n                code: 0,\n                body: `${error}`\n            });\n        }, // actual processing progress\n        (computable, current, total)=>{\n            // update actual duration\n            state.duration = Date.now() - state.timestamp;\n            // update actual progress\n            state.progress = computable ? current / total : null;\n            progressFn();\n        }, // abort does not expect a value\n        ()=>{\n            // stop updater\n            state.perceivedPerformanceUpdater.clear();\n            // fire the abort event so we can switch visuals\n            api.fire(\"abort\", state.response ? state.response.body : null);\n        }, // register the id for this transfer\n        (transferId)=>{\n            api.fire(\"transfer\", transferId);\n        });\n    };\n    const abort = ()=>{\n        // no request running, can't abort\n        if (!state.request) return;\n        // stop updater\n        state.perceivedPerformanceUpdater.clear();\n        // abort actual request\n        if (state.request.abort) state.request.abort();\n        // if has response object, we've completed the request\n        state.complete = true;\n    };\n    const reset = ()=>{\n        abort();\n        state.complete = false;\n        state.perceivedProgress = 0;\n        state.progress = 0;\n        state.timestamp = null;\n        state.perceivedDuration = 0;\n        state.duration = 0;\n        state.request = null;\n        state.response = null;\n    };\n    const getProgress = allowMinimumUploadDuration ? ()=>state.progress ? Math.min(state.progress, state.perceivedProgress) : null : ()=>state.progress || null;\n    const getDuration = allowMinimumUploadDuration ? ()=>Math.min(state.duration, state.perceivedDuration) : ()=>state.duration;\n    const api = {\n        ...on(),\n        process,\n        abort,\n        getProgress,\n        getDuration,\n        reset\n    };\n    return api;\n};\nconst getFilenameWithoutExtension = (name)=>name.substring(0, name.lastIndexOf(\".\")) || name;\nconst createFileStub = (source)=>{\n    let data = [\n        source.name,\n        source.size,\n        source.type\n    ];\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n        data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n        // if is base64 data uri we need to determine the average size and type\n        data[1] = source.length;\n        data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n        // url\n        data[0] = getFilenameFromURL(source);\n        data[1] = 0;\n        data[2] = \"application/octet-stream\";\n    }\n    return {\n        name: data[0],\n        size: data[1],\n        type: data[2]\n    };\n};\nconst isFile = (value)=>!!(value instanceof File || value instanceof Blob && value.name);\nconst deepCloneObject = (src)=>{\n    if (!isObject(src)) return src;\n    const target = isArray(src) ? [] : {};\n    for(const key in src){\n        if (!src.hasOwnProperty(key)) continue;\n        const v = src[key];\n        target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n};\nconst createItem = (origin = null, serverFileReference = null, file = null)=>{\n    // unique id for this item, is used to identify the item across views\n    const id = getUniqueId();\n    /**\n     * Internal item state\n     */ const state = {\n        // is archived\n        archived: false,\n        // if is frozen, no longer fires events\n        frozen: false,\n        // removed from view\n        released: false,\n        // original source\n        source: null,\n        // file model reference\n        file,\n        // id of file on server\n        serverFileReference,\n        // id of file transfer on server\n        transferId: null,\n        // is aborted\n        processingAborted: false,\n        // current item status\n        status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,\n        // active processes\n        activeLoader: null,\n        activeProcessor: null\n    };\n    // callback used when abort processing is called to link back to the resolve method\n    let abortProcessingRequestComplete = null;\n    /**\n     * Externally added item metadata\n     */ const metadata = {};\n    // item data\n    const setStatus = (status)=>state.status = status;\n    // fire event unless the item has been archived\n    const fire = (event, ...params)=>{\n        if (state.released || state.frozen) return;\n        api.fire(event, ...params);\n    };\n    // file data\n    const getFileExtension = ()=>getExtensionFromFilename(state.file.name);\n    const getFileType = ()=>state.file.type;\n    const getFileSize = ()=>state.file.size;\n    const getFile = ()=>state.file;\n    //\n    // logic to load a file\n    //\n    const load = (source, loader, onload)=>{\n        // remember the original item source\n        state.source = source;\n        // source is known\n        api.fireSync(\"init\");\n        // file stub is already there\n        if (state.file) {\n            api.fireSync(\"load-skip\");\n            return;\n        }\n        // set a stub file object while loading the actual data\n        state.file = createFileStub(source);\n        // starts loading\n        loader.on(\"init\", ()=>{\n            fire(\"load-init\");\n        });\n        // we'eve received a size indication, let's update the stub\n        loader.on(\"meta\", (meta)=>{\n            // set size of file stub\n            state.file.size = meta.size;\n            // set name of file stub\n            state.file.filename = meta.filename;\n            // if has received source, we done\n            if (meta.source) {\n                origin = FileOrigin.LIMBO;\n                state.serverFileReference = meta.source;\n                state.status = ItemStatus.PROCESSING_COMPLETE;\n            }\n            // size has been updated\n            fire(\"load-meta\");\n        });\n        // the file is now loading we need to update the progress indicators\n        loader.on(\"progress\", (progress)=>{\n            setStatus(ItemStatus.LOADING);\n            fire(\"load-progress\", progress);\n        });\n        // an error was thrown while loading the file, we need to switch to error state\n        loader.on(\"error\", (error)=>{\n            setStatus(ItemStatus.LOAD_ERROR);\n            fire(\"load-request-error\", error);\n        });\n        // user or another process aborted the file load (cannot retry)\n        loader.on(\"abort\", ()=>{\n            setStatus(ItemStatus.INIT);\n            fire(\"load-abort\");\n        });\n        // done loading\n        loader.on(\"load\", (file)=>{\n            // as we've now loaded the file the loader is no longer required\n            state.activeLoader = null;\n            // called when file has loaded succesfully\n            const success = (result)=>{\n                // set (possibly) transformed file\n                state.file = isFile(result) ? result : state.file;\n                // file received\n                if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n                    setStatus(ItemStatus.PROCESSING_COMPLETE);\n                } else {\n                    setStatus(ItemStatus.IDLE);\n                }\n                fire(\"load\");\n            };\n            const error = (result)=>{\n                // set original file\n                state.file = file;\n                fire(\"load-meta\");\n                setStatus(ItemStatus.LOAD_ERROR);\n                fire(\"load-file-error\", result);\n            };\n            // if we already have a server file reference, we don't need to call the onload method\n            if (state.serverFileReference) {\n                success(file);\n                return;\n            }\n            // no server id, let's give this file the full treatment\n            onload(file, success, error);\n        });\n        // set loader source data\n        loader.setSource(source);\n        // set as active loader\n        state.activeLoader = loader;\n        // load the source data\n        loader.load();\n    };\n    const retryLoad = ()=>{\n        if (!state.activeLoader) {\n            return;\n        }\n        state.activeLoader.load();\n    };\n    const abortLoad = ()=>{\n        if (state.activeLoader) {\n            state.activeLoader.abort();\n            return;\n        }\n        setStatus(ItemStatus.INIT);\n        fire(\"load-abort\");\n    };\n    //\n    // logic to process a file\n    //\n    const process = (processor, onprocess)=>{\n        // processing was aborted\n        if (state.processingAborted) {\n            state.processingAborted = false;\n            return;\n        }\n        // now processing\n        setStatus(ItemStatus.PROCESSING);\n        // reset abort callback\n        abortProcessingRequestComplete = null;\n        // if no file loaded we'll wait for the load event\n        if (!(state.file instanceof Blob)) {\n            api.on(\"load\", ()=>{\n                process(processor, onprocess);\n            });\n            return;\n        }\n        // setup processor\n        processor.on(\"load\", (serverFileReference)=>{\n            // need this id to be able to revert the upload\n            state.transferId = null;\n            state.serverFileReference = serverFileReference;\n        });\n        // register transfer id\n        processor.on(\"transfer\", (transferId)=>{\n            // need this id to be able to revert the upload\n            state.transferId = transferId;\n        });\n        processor.on(\"load-perceived\", (serverFileReference)=>{\n            // no longer required\n            state.activeProcessor = null;\n            // need this id to be able to rever the upload\n            state.transferId = null;\n            state.serverFileReference = serverFileReference;\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n            fire(\"process-complete\", serverFileReference);\n        });\n        processor.on(\"start\", ()=>{\n            fire(\"process-start\");\n        });\n        processor.on(\"error\", (error)=>{\n            state.activeProcessor = null;\n            setStatus(ItemStatus.PROCESSING_ERROR);\n            fire(\"process-error\", error);\n        });\n        processor.on(\"abort\", (serverFileReference)=>{\n            state.activeProcessor = null;\n            // if file was uploaded but processing was cancelled during perceived processor time store file reference\n            state.serverFileReference = serverFileReference;\n            setStatus(ItemStatus.IDLE);\n            fire(\"process-abort\");\n            // has timeout so doesn't interfere with remove action\n            if (abortProcessingRequestComplete) {\n                abortProcessingRequestComplete();\n            }\n        });\n        processor.on(\"progress\", (progress)=>{\n            fire(\"process-progress\", progress);\n        });\n        // when successfully transformed\n        const success = (file)=>{\n            // if was archived in the mean time, don't process\n            if (state.archived) return;\n            // process file!\n            processor.process(file, {\n                ...metadata\n            });\n        };\n        // something went wrong during transform phase\n        const error = console.error;\n        // start processing the file\n        onprocess(state.file, success, error);\n        // set as active processor\n        state.activeProcessor = processor;\n    };\n    const requestProcessing = ()=>{\n        state.processingAborted = false;\n        setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n    const abortProcessing = ()=>new Promise((resolve)=>{\n            if (!state.activeProcessor) {\n                state.processingAborted = true;\n                setStatus(ItemStatus.IDLE);\n                fire(\"process-abort\");\n                resolve();\n                return;\n            }\n            abortProcessingRequestComplete = ()=>{\n                resolve();\n            };\n            state.activeProcessor.abort();\n        });\n    //\n    // logic to revert a processed file\n    //\n    const revert = (revertFileUpload, forceRevert)=>new Promise((resolve, reject)=>{\n            // a completed upload will have a serverFileReference, a failed chunked upload where\n            // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set\n            const serverTransferId = state.serverFileReference !== null ? state.serverFileReference : state.transferId;\n            // cannot revert without a server id for this process\n            if (serverTransferId === null) {\n                resolve();\n                return;\n            }\n            // revert the upload (fire and forget)\n            revertFileUpload(serverTransferId, ()=>{\n                // reset file server id and transfer id as now it's not available on the server\n                state.serverFileReference = null;\n                state.transferId = null;\n                resolve();\n            }, (error)=>{\n                // don't set error state when reverting is optional, it will always resolve\n                if (!forceRevert) {\n                    resolve();\n                    return;\n                }\n                // oh no errors\n                setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n                fire(\"process-revert-error\");\n                reject(error);\n            });\n            // fire event\n            setStatus(ItemStatus.IDLE);\n            fire(\"process-revert\");\n        });\n    // exposed methods\n    const setMetadata = (key, value, silent)=>{\n        const keys = key.split(\".\");\n        const root = keys[0];\n        const last = keys.pop();\n        let data = metadata;\n        keys.forEach((key)=>data = data[key]);\n        // compare old value against new value, if they're the same, we're not updating\n        if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n        // update value\n        data[last] = value;\n        // fire update\n        fire(\"metadata-update\", {\n            key: root,\n            value: metadata[root],\n            silent\n        });\n    };\n    const getMetadata = (key)=>deepCloneObject(key ? metadata[key] : metadata);\n    const api = {\n        id: {\n            get: ()=>id\n        },\n        origin: {\n            get: ()=>origin,\n            set: (value)=>origin = value\n        },\n        serverId: {\n            get: ()=>state.serverFileReference\n        },\n        transferId: {\n            get: ()=>state.transferId\n        },\n        status: {\n            get: ()=>state.status\n        },\n        filename: {\n            get: ()=>state.file.name\n        },\n        filenameWithoutExtension: {\n            get: ()=>getFilenameWithoutExtension(state.file.name)\n        },\n        fileExtension: {\n            get: getFileExtension\n        },\n        fileType: {\n            get: getFileType\n        },\n        fileSize: {\n            get: getFileSize\n        },\n        file: {\n            get: getFile\n        },\n        relativePath: {\n            get: ()=>state.file._relativePath\n        },\n        source: {\n            get: ()=>state.source\n        },\n        getMetadata,\n        setMetadata: (key, value, silent)=>{\n            if (isObject(key)) {\n                const data = key;\n                Object.keys(data).forEach((key)=>{\n                    setMetadata(key, data[key], value);\n                });\n                return key;\n            }\n            setMetadata(key, value, silent);\n            return value;\n        },\n        extend: (name, handler)=>itemAPI[name] = handler,\n        abortLoad,\n        retryLoad,\n        requestProcessing,\n        abortProcessing,\n        load,\n        process,\n        revert,\n        ...on(),\n        freeze: ()=>state.frozen = true,\n        release: ()=>state.released = true,\n        released: {\n            get: ()=>state.released\n        },\n        archive: ()=>state.archived = true,\n        archived: {\n            get: ()=>state.archived\n        },\n        // replace source and file object\n        setFile: (file)=>state.file = file\n    };\n    // create it here instead of returning it instantly so we can extend it later\n    const itemAPI = createObject(api);\n    return itemAPI;\n};\nconst getItemIndexByQuery = (items, query)=>{\n    // just return first index\n    if (isEmpty(query)) {\n        return 0;\n    }\n    // invalid queries\n    if (!isString(query)) {\n        return -1;\n    }\n    // return item by id (or -1 if not found)\n    return items.findIndex((item)=>item.id === query);\n};\nconst getItemById = (items, itemId)=>{\n    const index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n        return;\n    }\n    return items[index] || null;\n};\nconst fetchBlob = (url, load, error, progress, abort, headers)=>{\n    const request = sendRequest(null, url, {\n        method: \"GET\",\n        responseType: \"blob\"\n    });\n    request.onload = (xhr)=>{\n        // get headers\n        const headers = xhr.getAllResponseHeaders();\n        // get filename\n        const filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n        // create response\n        load(createResponse(\"load\", xhr.status, getFileFromBlob(xhr.response, filename), headers));\n    };\n    request.onerror = (xhr)=>{\n        error(createResponse(\"error\", xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));\n    };\n    request.onheaders = (xhr)=>{\n        headers(createResponse(\"headers\", xhr.status, null, xhr.getAllResponseHeaders()));\n    };\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n    // should return request\n    return request;\n};\nconst getDomainFromURL = (url)=>{\n    if (url.indexOf(\"//\") === 0) {\n        url = location.protocol + url;\n    }\n    return url.toLowerCase().replace(\"blob:\", \"\").replace(/([a-z])?:\\/\\//, \"$1\").split(\"/\")[0];\n};\nconst isExternalURL = (url)=>(url.indexOf(\":\") > -1 || url.indexOf(\"//\") > -1) && getDomainFromURL(location.href) !== getDomainFromURL(url);\nconst dynamicLabel = (label)=>(...params)=>isFunction(label) ? label(...params) : label;\nconst isMockItem = (item)=>!isFile(item.file);\nconst listUpdated = (dispatch, state)=>{\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(()=>{\n        dispatch(\"DID_UPDATE_ITEMS\", {\n            items: getActiveItems(state.items)\n        });\n    }, 0);\n};\nconst optionalPromise = (fn, ...params)=>new Promise((resolve)=>{\n        if (!fn) {\n            return resolve(true);\n        }\n        const result = fn(...params);\n        if (result == null) {\n            return resolve(true);\n        }\n        if (typeof result === \"boolean\") {\n            return resolve(result);\n        }\n        if (typeof result.then === \"function\") {\n            result.then(resolve);\n        }\n    });\nconst sortItems = (state, compare)=>{\n    state.items.sort((a, b)=>compare(createItemAPI(a), createItemAPI(b)));\n};\n// returns item based on state\nconst getItemByQueryFromState = (state, itemHandler)=>({ query, success = ()=>{}, failure = ()=>{}, ...options } = {})=>{\n        const item = getItemByQuery(state.items, query);\n        if (!item) {\n            failure({\n                error: createResponse(\"error\", 0, \"Item not found\"),\n                file: null\n            });\n            return;\n        }\n        itemHandler(item, success, failure, options || {});\n    };\nconst actions = (dispatch, query, state)=>({\n        /**\n     * Aborts all ongoing processes\n     */ ABORT_ALL: ()=>{\n            getActiveItems(state.items).forEach((item)=>{\n                item.freeze();\n                item.abortLoad();\n                item.abortProcessing();\n            });\n        },\n        /**\n     * Sets initial files\n     */ DID_SET_FILES: ({ value = [] })=>{\n            // map values to file objects\n            const files = value.map((file)=>({\n                    source: file.source ? file.source : file,\n                    options: file.options\n                }));\n            // loop over files, if file is in list, leave it be, if not, remove\n            // test if items should be moved\n            let activeItems = getActiveItems(state.items);\n            activeItems.forEach((item)=>{\n                // if item not is in new value, remove\n                if (!files.find((file)=>file.source === item.source || file.source === item.file)) {\n                    dispatch(\"REMOVE_ITEM\", {\n                        query: item,\n                        remove: false\n                    });\n                }\n            });\n            // add new files\n            activeItems = getActiveItems(state.items);\n            files.forEach((file, index)=>{\n                // if file is already in list\n                if (activeItems.find((item)=>item.source === file.source || item.file === file.source)) return;\n                // not in list, add\n                dispatch(\"ADD_ITEM\", {\n                    ...file,\n                    interactionMethod: InteractionMethod.NONE,\n                    index\n                });\n            });\n        },\n        DID_UPDATE_ITEM_METADATA: ({ id, action, change })=>{\n            // don't do anything\n            if (change.silent) return;\n            // if is called multiple times in close succession we combined all calls together to save resources\n            clearTimeout(state.itemUpdateTimeout);\n            state.itemUpdateTimeout = setTimeout(()=>{\n                const item = getItemById(state.items, id);\n                // only revert and attempt to upload when we're uploading to a server\n                if (!query(\"IS_ASYNC\")) {\n                    // should we update the output data\n                    applyFilterChain(\"SHOULD_PREPARE_OUTPUT\", false, {\n                        item,\n                        query,\n                        action,\n                        change\n                    }).then((shouldPrepareOutput)=>{\n                        // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                        const beforePrepareFile = query(\"GET_BEFORE_PREPARE_FILE\");\n                        if (beforePrepareFile) shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n                        if (!shouldPrepareOutput) return;\n                        dispatch(\"REQUEST_PREPARE_OUTPUT\", {\n                            query: id,\n                            item,\n                            success: (file)=>{\n                                dispatch(\"DID_PREPARE_OUTPUT\", {\n                                    id,\n                                    file\n                                });\n                            }\n                        }, true);\n                    });\n                    return;\n                }\n                // if is local item we need to enable upload button so change can be propagated to server\n                if (item.origin === FileOrigin.LOCAL) {\n                    dispatch(\"DID_LOAD_ITEM\", {\n                        id: item.id,\n                        error: null,\n                        serverFileReference: item.source\n                    });\n                }\n                // for async scenarios\n                const upload = ()=>{\n                    // we push this forward a bit so the interface is updated correctly\n                    setTimeout(()=>{\n                        dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                            query: id\n                        });\n                    }, 32);\n                };\n                const revert = (doUpload)=>{\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\")).then(doUpload ? upload : ()=>{}).catch(()=>{});\n                };\n                const abort = (doUpload)=>{\n                    item.abortProcessing().then(doUpload ? upload : ()=>{});\n                };\n                // if we should re-upload the file immediately\n                if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n                    return revert(state.options.instantUpload);\n                }\n                // if currently uploading, cancel upload\n                if (item.status === ItemStatus.PROCESSING) {\n                    return abort(state.options.instantUpload);\n                }\n                if (state.options.instantUpload) {\n                    upload();\n                }\n            }, 0);\n        },\n        MOVE_ITEM: ({ query, index })=>{\n            const item = getItemByQuery(state.items, query);\n            if (!item) return;\n            const currentIndex = state.items.indexOf(item);\n            index = limit(index, 0, state.items.length - 1);\n            if (currentIndex === index) return;\n            state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n        },\n        SORT: ({ compare })=>{\n            sortItems(state, compare);\n            dispatch(\"DID_SORT_ITEMS\", {\n                items: query(\"GET_ACTIVE_ITEMS\")\n            });\n        },\n        ADD_ITEMS: ({ items, index, interactionMethod, success = ()=>{}, failure = ()=>{} })=>{\n            let currentIndex = index;\n            if (index === -1 || typeof index === \"undefined\") {\n                const insertLocation = query(\"GET_ITEM_INSERT_LOCATION\");\n                const totalItems = query(\"GET_TOTAL_ITEMS\");\n                currentIndex = insertLocation === \"before\" ? 0 : totalItems;\n            }\n            const ignoredFiles = query(\"GET_IGNORED_FILES\");\n            const isValidFile = (source)=>isFile(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);\n            const validItems = items.filter(isValidFile);\n            const promises = validItems.map((source)=>new Promise((resolve, reject)=>{\n                    dispatch(\"ADD_ITEM\", {\n                        interactionMethod,\n                        source: source.source || source,\n                        success: resolve,\n                        failure: reject,\n                        index: currentIndex++,\n                        options: source.options || {}\n                    });\n                }));\n            Promise.all(promises).then(success).catch(failure);\n        },\n        /**\n     * @param source\n     * @param index\n     * @param interactionMethod\n     */ ADD_ITEM: ({ source, index = -1, interactionMethod, success = ()=>{}, failure = ()=>{}, options = {} })=>{\n            // if no source supplied\n            if (isEmpty(source)) {\n                failure({\n                    error: createResponse(\"error\", 0, \"No source\"),\n                    file: null\n                });\n                return;\n            }\n            // filter out invalid file items, used to filter dropped directory contents\n            if (isFile(source) && state.options.ignoredFiles.includes(source.name.toLowerCase())) {\n                // fail silently\n                return;\n            }\n            // test if there's still room in the list of files\n            if (!hasRoomForItem(state)) {\n                // if multiple allowed, we can't replace\n                // or if only a single item is allowed but we're not allowed to replace it we exit\n                if (state.options.allowMultiple || !state.options.allowMultiple && !state.options.allowReplace) {\n                    const error = createResponse(\"warning\", 0, \"Max files\");\n                    dispatch(\"DID_THROW_MAX_FILES\", {\n                        source,\n                        error\n                    });\n                    failure({\n                        error,\n                        file: null\n                    });\n                    return;\n                }\n                // let's replace the item\n                // id of first item we're about to remove\n                const item = getActiveItems(state.items)[0];\n                // if has been processed remove it from the server as well\n                if (item.status === ItemStatus.PROCESSING_COMPLETE || item.status === ItemStatus.PROCESSING_REVERT_ERROR) {\n                    const forceRevert = query(\"GET_FORCE_REVERT\");\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), forceRevert).then(()=>{\n                        if (!forceRevert) return;\n                        // try to add now\n                        dispatch(\"ADD_ITEM\", {\n                            source,\n                            index,\n                            interactionMethod,\n                            success,\n                            failure,\n                            options\n                        });\n                    }).catch(()=>{}); // no need to handle this catch state for now\n                    if (forceRevert) return;\n                }\n                // remove first item as it will be replaced by this item\n                dispatch(\"REMOVE_ITEM\", {\n                    query: item.id\n                });\n            }\n            // where did the file originate\n            const origin = options.type === \"local\" ? FileOrigin.LOCAL : options.type === \"limbo\" ? FileOrigin.LIMBO : FileOrigin.INPUT;\n            // create a new blank item\n            const item = createItem(// where did this file come from\n            origin, // an input file never has a server file reference\n            origin === FileOrigin.INPUT ? null : source, // file mock data, if defined\n            options.file);\n            // set initial meta data\n            Object.keys(options.metadata || {}).forEach((key)=>{\n                item.setMetadata(key, options.metadata[key]);\n            });\n            // created the item, let plugins add methods\n            applyFilters(\"DID_CREATE_ITEM\", item, {\n                query,\n                dispatch\n            });\n            // where to insert new items\n            const itemInsertLocation = query(\"GET_ITEM_INSERT_LOCATION\");\n            // adjust index if is not allowed to pick location\n            if (!state.options.itemInsertLocationFreedom) {\n                index = itemInsertLocation === \"before\" ? -1 : state.items.length;\n            }\n            // add item to list\n            insertItem(state.items, item, index);\n            // sort items in list\n            if (isFunction(itemInsertLocation) && source) {\n                sortItems(state, itemInsertLocation);\n            }\n            // get a quick reference to the item id\n            const id = item.id;\n            // observe item events\n            item.on(\"init\", ()=>{\n                dispatch(\"DID_INIT_ITEM\", {\n                    id\n                });\n            });\n            item.on(\"load-init\", ()=>{\n                dispatch(\"DID_START_ITEM_LOAD\", {\n                    id\n                });\n            });\n            item.on(\"load-meta\", ()=>{\n                dispatch(\"DID_UPDATE_ITEM_META\", {\n                    id\n                });\n            });\n            item.on(\"load-progress\", (progress)=>{\n                dispatch(\"DID_UPDATE_ITEM_LOAD_PROGRESS\", {\n                    id,\n                    progress\n                });\n            });\n            item.on(\"load-request-error\", (error)=>{\n                const mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);\n                // is client error, no way to recover\n                if (error.code >= 400 && error.code < 500) {\n                    dispatch(\"DID_THROW_ITEM_INVALID\", {\n                        id,\n                        error,\n                        status: {\n                            main: mainStatus,\n                            sub: `${error.code} (${error.body})`\n                        }\n                    });\n                    // reject the file so can be dealt with through API\n                    failure({\n                        error,\n                        file: createItemAPI(item)\n                    });\n                    return;\n                }\n                // is possible server error, so might be possible to retry\n                dispatch(\"DID_THROW_ITEM_LOAD_ERROR\", {\n                    id,\n                    error,\n                    status: {\n                        main: mainStatus,\n                        sub: state.options.labelTapToRetry\n                    }\n                });\n            });\n            item.on(\"load-file-error\", (error)=>{\n                dispatch(\"DID_THROW_ITEM_INVALID\", {\n                    id,\n                    error: error.status,\n                    status: error.status\n                });\n                failure({\n                    error: error.status,\n                    file: createItemAPI(item)\n                });\n            });\n            item.on(\"load-abort\", ()=>{\n                dispatch(\"REMOVE_ITEM\", {\n                    query: id\n                });\n            });\n            item.on(\"load-skip\", ()=>{\n                item.on(\"metadata-update\", (change)=>{\n                    if (!isFile(item.file)) return;\n                    dispatch(\"DID_UPDATE_ITEM_METADATA\", {\n                        id,\n                        change\n                    });\n                });\n                dispatch(\"COMPLETE_LOAD_ITEM\", {\n                    query: id,\n                    item,\n                    data: {\n                        source,\n                        success\n                    }\n                });\n            });\n            item.on(\"load\", ()=>{\n                const handleAdd = (shouldAdd)=>{\n                    // no should not add this file\n                    if (!shouldAdd) {\n                        dispatch(\"REMOVE_ITEM\", {\n                            query: id\n                        });\n                        return;\n                    }\n                    // now interested in metadata updates\n                    item.on(\"metadata-update\", (change)=>{\n                        dispatch(\"DID_UPDATE_ITEM_METADATA\", {\n                            id,\n                            change\n                        });\n                    });\n                    // let plugins decide if the output data should be prepared at this point\n                    // means we'll do this and wait for idle state\n                    applyFilterChain(\"SHOULD_PREPARE_OUTPUT\", false, {\n                        item,\n                        query\n                    }).then((shouldPrepareOutput)=>{\n                        // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                        const beforePrepareFile = query(\"GET_BEFORE_PREPARE_FILE\");\n                        if (beforePrepareFile) shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n                        const loadComplete = ()=>{\n                            dispatch(\"COMPLETE_LOAD_ITEM\", {\n                                query: id,\n                                item,\n                                data: {\n                                    source,\n                                    success\n                                }\n                            });\n                            listUpdated(dispatch, state);\n                        };\n                        // exit\n                        if (shouldPrepareOutput) {\n                            // wait for idle state and then run PREPARE_OUTPUT\n                            dispatch(\"REQUEST_PREPARE_OUTPUT\", {\n                                query: id,\n                                item,\n                                success: (file)=>{\n                                    dispatch(\"DID_PREPARE_OUTPUT\", {\n                                        id,\n                                        file\n                                    });\n                                    loadComplete();\n                                }\n                            }, true);\n                            return;\n                        }\n                        loadComplete();\n                    });\n                };\n                // item loaded, allow plugins to\n                // - read data (quickly)\n                // - add metadata\n                applyFilterChain(\"DID_LOAD_ITEM\", item, {\n                    query,\n                    dispatch\n                }).then(()=>{\n                    optionalPromise(query(\"GET_BEFORE_ADD_FILE\"), createItemAPI(item)).then(handleAdd);\n                }).catch((e)=>{\n                    if (!e || !e.error || !e.status) return handleAdd(false);\n                    dispatch(\"DID_THROW_ITEM_INVALID\", {\n                        id,\n                        error: e.error,\n                        status: e.status\n                    });\n                });\n            });\n            item.on(\"process-start\", ()=>{\n                dispatch(\"DID_START_ITEM_PROCESSING\", {\n                    id\n                });\n            });\n            item.on(\"process-progress\", (progress)=>{\n                dispatch(\"DID_UPDATE_ITEM_PROCESS_PROGRESS\", {\n                    id,\n                    progress\n                });\n            });\n            item.on(\"process-error\", (error)=>{\n                dispatch(\"DID_THROW_ITEM_PROCESSING_ERROR\", {\n                    id,\n                    error,\n                    status: {\n                        main: dynamicLabel(state.options.labelFileProcessingError)(error),\n                        sub: state.options.labelTapToRetry\n                    }\n                });\n            });\n            item.on(\"process-revert-error\", (error)=>{\n                dispatch(\"DID_THROW_ITEM_PROCESSING_REVERT_ERROR\", {\n                    id,\n                    error,\n                    status: {\n                        main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),\n                        sub: state.options.labelTapToRetry\n                    }\n                });\n            });\n            item.on(\"process-complete\", (serverFileReference)=>{\n                dispatch(\"DID_COMPLETE_ITEM_PROCESSING\", {\n                    id,\n                    error: null,\n                    serverFileReference\n                });\n                dispatch(\"DID_DEFINE_VALUE\", {\n                    id,\n                    value: serverFileReference\n                });\n            });\n            item.on(\"process-abort\", ()=>{\n                dispatch(\"DID_ABORT_ITEM_PROCESSING\", {\n                    id\n                });\n            });\n            item.on(\"process-revert\", ()=>{\n                dispatch(\"DID_REVERT_ITEM_PROCESSING\", {\n                    id\n                });\n                dispatch(\"DID_DEFINE_VALUE\", {\n                    id,\n                    value: null\n                });\n            });\n            // let view know the item has been inserted\n            dispatch(\"DID_ADD_ITEM\", {\n                id,\n                index,\n                interactionMethod\n            });\n            listUpdated(dispatch, state);\n            // start loading the source\n            const { url, load, restore, fetch } = state.options.server || {};\n            item.load(source, // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n            createFileLoader(origin === FileOrigin.INPUT ? isString(source) && isExternalURL(source) ? fetch ? createFetchFunction(url, fetch) : fetchBlob // remote url\n             : fetchBlob // try to fetch url\n             : origin === FileOrigin.LIMBO ? createFetchFunction(url, restore) // limbo\n             : createFetchFunction(url, load) // local\n            ), // called when the file is loaded so it can be piped through the filters\n            (file, success, error)=>{\n                // let's process the file\n                applyFilterChain(\"LOAD_FILE\", file, {\n                    query\n                }).then(success).catch(error);\n            });\n        },\n        REQUEST_PREPARE_OUTPUT: ({ item, success, failure = ()=>{} })=>{\n            // error response if item archived\n            const err = {\n                error: createResponse(\"error\", 0, \"Item not found\"),\n                file: null\n            };\n            // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n            if (item.archived) return failure(err);\n            // allow plugins to alter the file data\n            applyFilterChain(\"PREPARE_OUTPUT\", item.file, {\n                query,\n                item\n            }).then((result)=>{\n                applyFilterChain(\"COMPLETE_PREPARE_OUTPUT\", result, {\n                    query,\n                    item\n                }).then((result)=>{\n                    // don't handle archived items, an item could have been archived (load aborted) while being prepared\n                    if (item.archived) return failure(err);\n                    // we done!\n                    success(result);\n                });\n            });\n        },\n        COMPLETE_LOAD_ITEM: ({ item, data })=>{\n            const { success, source } = data;\n            // sort items in list\n            const itemInsertLocation = query(\"GET_ITEM_INSERT_LOCATION\");\n            if (isFunction(itemInsertLocation) && source) {\n                sortItems(state, itemInsertLocation);\n            }\n            // let interface know the item has loaded\n            dispatch(\"DID_LOAD_ITEM\", {\n                id: item.id,\n                error: null,\n                serverFileReference: item.origin === FileOrigin.INPUT ? null : source\n            });\n            // item has been successfully loaded and added to the\n            // list of items so can now be safely returned for use\n            success(createItemAPI(item));\n            // if this is a local server file we need to show a different state\n            if (item.origin === FileOrigin.LOCAL) {\n                dispatch(\"DID_LOAD_LOCAL_ITEM\", {\n                    id: item.id\n                });\n                return;\n            }\n            // if is a temp server file we prevent async upload call here (as the file is already on the server)\n            if (item.origin === FileOrigin.LIMBO) {\n                dispatch(\"DID_COMPLETE_ITEM_PROCESSING\", {\n                    id: item.id,\n                    error: null,\n                    serverFileReference: source\n                });\n                dispatch(\"DID_DEFINE_VALUE\", {\n                    id: item.id,\n                    value: item.serverId || source\n                });\n                return;\n            }\n            // id we are allowed to upload the file immediately, lets do it\n            if (query(\"IS_ASYNC\") && state.options.instantUpload) {\n                dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                    query: item.id\n                });\n            }\n        },\n        RETRY_ITEM_LOAD: getItemByQueryFromState(state, (item)=>{\n            // try loading the source one more time\n            item.retryLoad();\n        }),\n        REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, (item, success, failure)=>{\n            dispatch(\"REQUEST_PREPARE_OUTPUT\", {\n                query: item.id,\n                item,\n                success: (file)=>{\n                    dispatch(\"DID_PREPARE_OUTPUT\", {\n                        id: item.id,\n                        file\n                    });\n                    success({\n                        file: item,\n                        output: file\n                    });\n                },\n                failure\n            }, true);\n        }),\n        REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, (item, success, failure)=>{\n            // cannot be queued (or is already queued)\n            const itemCanBeQueuedForProcessing = // waiting for something\n            item.status === ItemStatus.IDLE || // processing went wrong earlier\n            item.status === ItemStatus.PROCESSING_ERROR;\n            // not ready to be processed\n            if (!itemCanBeQueuedForProcessing) {\n                const processNow = ()=>dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                        query: item,\n                        success,\n                        failure\n                    });\n                const process = ()=>document.hidden ? processNow() : setTimeout(processNow, 32);\n                // if already done processing or tried to revert but didn't work, try again\n                if (item.status === ItemStatus.PROCESSING_COMPLETE || item.status === ItemStatus.PROCESSING_REVERT_ERROR) {\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\")).then(process).catch(()=>{}); // don't continue with processing if something went wrong\n                } else if (item.status === ItemStatus.PROCESSING) {\n                    item.abortProcessing().then(process);\n                }\n                return;\n            }\n            // already queued for processing\n            if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n            item.requestProcessing();\n            dispatch(\"DID_REQUEST_ITEM_PROCESSING\", {\n                id: item.id\n            });\n            dispatch(\"PROCESS_ITEM\", {\n                query: item,\n                success,\n                failure\n            }, true);\n        }),\n        PROCESS_ITEM: getItemByQueryFromState(state, (item, success, failure)=>{\n            const maxParallelUploads = query(\"GET_MAX_PARALLEL_UPLOADS\");\n            const totalCurrentUploads = query(\"GET_ITEMS_BY_STATUS\", ItemStatus.PROCESSING).length;\n            // queue and wait till queue is freed up\n            if (totalCurrentUploads === maxParallelUploads) {\n                // queue for later processing\n                state.processingQueue.push({\n                    id: item.id,\n                    success,\n                    failure\n                });\n                // stop it!\n                return;\n            }\n            // if was not queued or is already processing exit here\n            if (item.status === ItemStatus.PROCESSING) return;\n            const processNext = ()=>{\n                // process queueud items\n                const queueEntry = state.processingQueue.shift();\n                // no items left\n                if (!queueEntry) return;\n                // get item reference\n                const { id, success, failure } = queueEntry;\n                const itemReference = getItemByQuery(state.items, id);\n                // if item was archived while in queue, jump to next\n                if (!itemReference || itemReference.archived) {\n                    processNext();\n                    return;\n                }\n                // process queued item\n                dispatch(\"PROCESS_ITEM\", {\n                    query: id,\n                    success,\n                    failure\n                }, true);\n            };\n            // we done function\n            item.onOnce(\"process-complete\", ()=>{\n                success(createItemAPI(item));\n                processNext();\n                // if origin is local, and we're instant uploading, trigger remove of original\n                // as revert will remove file from list\n                const server = state.options.server;\n                const instantUpload = state.options.instantUpload;\n                if (instantUpload && item.origin === FileOrigin.LOCAL && isFunction(server.remove)) {\n                    const noop = ()=>{};\n                    item.origin = FileOrigin.LIMBO;\n                    state.options.server.remove(item.source, noop, noop);\n                }\n                // All items processed? No errors?\n                const allItemsProcessed = query(\"GET_ITEMS_BY_STATUS\", ItemStatus.PROCESSING_COMPLETE).length === state.items.length;\n                if (allItemsProcessed) {\n                    dispatch(\"DID_COMPLETE_ITEM_PROCESSING_ALL\");\n                }\n            });\n            // we error function\n            item.onOnce(\"process-error\", (error)=>{\n                failure({\n                    error,\n                    file: createItemAPI(item)\n                });\n                processNext();\n            });\n            // start file processing\n            const options = state.options;\n            item.process(createFileProcessor(createProcessorFunction(options.server.url, options.server.process, options.name, {\n                chunkTransferId: item.transferId,\n                chunkServer: options.server.patch,\n                chunkUploads: options.chunkUploads,\n                chunkForce: options.chunkForce,\n                chunkSize: options.chunkSize,\n                chunkRetryDelays: options.chunkRetryDelays\n            }), {\n                allowMinimumUploadDuration: query(\"GET_ALLOW_MINIMUM_UPLOAD_DURATION\")\n            }), // called when the file is about to be processed so it can be piped through the transform filters\n            (file, success, error)=>{\n                // allow plugins to alter the file data\n                applyFilterChain(\"PREPARE_OUTPUT\", file, {\n                    query,\n                    item\n                }).then((file)=>{\n                    dispatch(\"DID_PREPARE_OUTPUT\", {\n                        id: item.id,\n                        file\n                    });\n                    success(file);\n                }).catch(error);\n            });\n        }),\n        RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                query: item\n            });\n        }),\n        REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, (item)=>{\n            optionalPromise(query(\"GET_BEFORE_REMOVE_FILE\"), createItemAPI(item)).then((shouldRemove)=>{\n                if (!shouldRemove) {\n                    return;\n                }\n                dispatch(\"REMOVE_ITEM\", {\n                    query: item\n                });\n            });\n        }),\n        RELEASE_ITEM: getItemByQueryFromState(state, (item)=>{\n            item.release();\n        }),\n        REMOVE_ITEM: getItemByQueryFromState(state, (item, success, failure, options)=>{\n            const removeFromView = ()=>{\n                // get id reference\n                const id = item.id;\n                // archive the item, this does not remove it from the list\n                getItemById(state.items, id).archive();\n                // tell the view the item has been removed\n                dispatch(\"DID_REMOVE_ITEM\", {\n                    error: null,\n                    id,\n                    item\n                });\n                // now the list has been modified\n                listUpdated(dispatch, state);\n                // correctly removed\n                success(createItemAPI(item));\n            };\n            // if this is a local file and the `server.remove` function has been configured,\n            // send source there so dev can remove file from server\n            const server = state.options.server;\n            if (item.origin === FileOrigin.LOCAL && server && isFunction(server.remove) && options.remove !== false) {\n                dispatch(\"DID_START_ITEM_REMOVE\", {\n                    id: item.id\n                });\n                server.remove(item.source, ()=>removeFromView(), (status)=>{\n                    dispatch(\"DID_THROW_ITEM_REMOVE_ERROR\", {\n                        id: item.id,\n                        error: createResponse(\"error\", 0, status, null),\n                        status: {\n                            main: dynamicLabel(state.options.labelFileRemoveError)(status),\n                            sub: state.options.labelTapToRetry\n                        }\n                    });\n                });\n            } else {\n                // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n                if (options.revert && item.origin !== FileOrigin.LOCAL && item.serverId !== null || // if chunked uploads are enabled and we're uploading in chunks for this specific file\n                // or if the file isn't big enough for chunked uploads but chunkForce is set then call\n                // revert before removing from the view...\n                state.options.chunkUploads && item.file.size > state.options.chunkSize || state.options.chunkUploads && state.options.chunkForce) {\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\"));\n                }\n                // can now safely remove from view\n                removeFromView();\n            }\n        }),\n        ABORT_ITEM_LOAD: getItemByQueryFromState(state, (item)=>{\n            item.abortLoad();\n        }),\n        ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            // test if is already processed\n            if (item.serverId) {\n                dispatch(\"REVERT_ITEM_PROCESSING\", {\n                    id: item.id\n                });\n                return;\n            }\n            // abort\n            item.abortProcessing().then(()=>{\n                const shouldRemove = state.options.instantUpload;\n                if (shouldRemove) {\n                    dispatch(\"REMOVE_ITEM\", {\n                        query: item.id\n                    });\n                }\n            });\n        }),\n        REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            // not instant uploading, revert immediately\n            if (!state.options.instantUpload) {\n                dispatch(\"REVERT_ITEM_PROCESSING\", {\n                    query: item\n                });\n                return;\n            }\n            // if we're instant uploading the file will also be removed if we revert,\n            // so if a before remove file hook is defined we need to run it now\n            const handleRevert = (shouldRevert)=>{\n                if (!shouldRevert) return;\n                dispatch(\"REVERT_ITEM_PROCESSING\", {\n                    query: item\n                });\n            };\n            const fn = query(\"GET_BEFORE_REMOVE_FILE\");\n            if (!fn) {\n                return handleRevert(true);\n            }\n            const requestRemoveResult = fn(createItemAPI(item));\n            if (requestRemoveResult == null) {\n                // undefined or null\n                return handleRevert(true);\n            }\n            if (typeof requestRemoveResult === \"boolean\") {\n                return handleRevert(requestRemoveResult);\n            }\n            if (typeof requestRemoveResult.then === \"function\") {\n                requestRemoveResult.then(handleRevert);\n            }\n        }),\n        REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\")).then(()=>{\n                const shouldRemove = state.options.instantUpload || isMockItem(item);\n                if (shouldRemove) {\n                    dispatch(\"REMOVE_ITEM\", {\n                        query: item.id\n                    });\n                }\n            }).catch(()=>{});\n        }),\n        SET_OPTIONS: ({ options })=>{\n            // get all keys passed\n            const optionKeys = Object.keys(options);\n            // get prioritized keyed to include (remove once not in options object)\n            const prioritizedOptionKeys = PrioritizedOptions.filter((key)=>optionKeys.includes(key));\n            // order the keys, prioritized first, then rest\n            const orderedOptionKeys = [\n                // add prioritized first if passed to options, else remove\n                ...prioritizedOptionKeys,\n                // prevent duplicate keys\n                ...Object.keys(options).filter((key)=>!prioritizedOptionKeys.includes(key))\n            ];\n            // dispatch set event for each option\n            orderedOptionKeys.forEach((key)=>{\n                dispatch(`SET_${fromCamels(key, \"_\").toUpperCase()}`, {\n                    value: options[key]\n                });\n            });\n        }\n    });\nconst PrioritizedOptions = [\n    \"server\"\n];\nconst formatFilename = (name)=>name;\nconst createElement$1 = (tagName)=>{\n    return document.createElement(tagName);\n};\nconst text = (node, value)=>{\n    let textNode = node.childNodes[0];\n    if (!textNode) {\n        textNode = document.createTextNode(value);\n        node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n        textNode.nodeValue = value;\n    }\n};\nconst polarToCartesian = (centerX, centerY, radius, angleInDegrees)=>{\n    const angleInRadians = (angleInDegrees % 360 - 90) * Math.PI / 180.0;\n    return {\n        x: centerX + radius * Math.cos(angleInRadians),\n        y: centerY + radius * Math.sin(angleInRadians)\n    };\n};\nconst describeArc = (x, y, radius, startAngle, endAngle, arcSweep)=>{\n    const start = polarToCartesian(x, y, radius, endAngle);\n    const end = polarToCartesian(x, y, radius, startAngle);\n    return [\n        \"M\",\n        start.x,\n        start.y,\n        \"A\",\n        radius,\n        radius,\n        0,\n        arcSweep,\n        0,\n        end.x,\n        end.y\n    ].join(\" \");\n};\nconst percentageArc = (x, y, radius, from, to)=>{\n    let arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n        arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n        arcSweep = 0;\n    }\n    return describeArc(x, y, radius, Math.min(0.9999, from) * 360, Math.min(0.9999, to) * 360, arcSweep);\n};\nconst create = ({ root, props })=>{\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n    // svg\n    const svg = createElement(\"svg\");\n    root.ref.path = createElement(\"path\", {\n        \"stroke-width\": 2,\n        \"stroke-linecap\": \"round\"\n    });\n    svg.appendChild(root.ref.path);\n    root.ref.svg = svg;\n    root.appendChild(svg);\n};\nconst write = ({ root, props })=>{\n    if (props.opacity === 0) {\n        return;\n    }\n    if (props.align) {\n        root.element.dataset.align = props.align;\n    }\n    // get width of stroke\n    const ringStrokeWidth = parseInt(attr(root.ref.path, \"stroke-width\"), 10);\n    // calculate size of ring\n    const size = root.rect.element.width * 0.5;\n    // ring state\n    let ringFrom = 0;\n    let ringTo = 0;\n    // now in busy mode\n    if (props.spin) {\n        ringFrom = 0;\n        ringTo = 0.5;\n    } else {\n        ringFrom = 0;\n        ringTo = props.progress;\n    }\n    // get arc path\n    const coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);\n    // update progress bar\n    attr(root.ref.path, \"d\", coordinates);\n    // hide while contains 0 value\n    attr(root.ref.path, \"stroke-opacity\", props.spin || props.progress > 0 ? 1 : 0);\n};\nconst progressIndicator = createView({\n    tag: \"div\",\n    name: \"progress-indicator\",\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create,\n    write,\n    mixins: {\n        apis: [\n            \"progress\",\n            \"spin\",\n            \"align\"\n        ],\n        styles: [\n            \"opacity\"\n        ],\n        animations: {\n            opacity: {\n                type: \"tween\",\n                duration: 500\n            },\n            progress: {\n                type: \"spring\",\n                stiffness: 0.95,\n                damping: 0.65,\n                mass: 10\n            }\n        }\n    }\n});\nconst create$1 = ({ root, props })=>{\n    root.element.innerHTML = (props.icon || \"\") + `<span>${props.label}</span>`;\n    props.isDisabled = false;\n};\nconst write$1 = ({ root, props })=>{\n    const { isDisabled } = props;\n    const shouldDisable = root.query(\"GET_DISABLED\") || props.opacity === 0;\n    if (shouldDisable && !isDisabled) {\n        props.isDisabled = true;\n        attr(root.element, \"disabled\", \"disabled\");\n    } else if (!shouldDisable && isDisabled) {\n        props.isDisabled = false;\n        root.element.removeAttribute(\"disabled\");\n    }\n};\nconst fileActionButton = createView({\n    tag: \"button\",\n    attributes: {\n        type: \"button\"\n    },\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: \"file-action-button\",\n    mixins: {\n        apis: [\n            \"label\"\n        ],\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\"\n        ],\n        animations: {\n            scaleX: \"spring\",\n            scaleY: \"spring\",\n            translateX: \"spring\",\n            translateY: \"spring\",\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            }\n        },\n        listeners: true\n    },\n    create: create$1,\n    write: write$1\n});\nconst toNaturalFileSize = (bytes, decimalSeparator = \".\", base = 1000, options = {})=>{\n    const { labelBytes = \"bytes\", labelKilobytes = \"KB\", labelMegabytes = \"MB\", labelGigabytes = \"GB\" } = options;\n    // no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n    const KB = base;\n    const MB = base * base;\n    const GB = base * base * base;\n    // just bytes\n    if (bytes < KB) {\n        return `${bytes} ${labelBytes}`;\n    }\n    // kilobytes\n    if (bytes < MB) {\n        return `${Math.floor(bytes / KB)} ${labelKilobytes}`;\n    }\n    // megabytes\n    if (bytes < GB) {\n        return `${removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator)} ${labelMegabytes}`;\n    }\n    // gigabytes\n    return `${removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator)} ${labelGigabytes}`;\n};\nconst removeDecimalsWhenZero = (value, decimalCount, separator)=>{\n    return value.toFixed(decimalCount).split(\".\").filter((part)=>part !== \"0\").join(separator);\n};\nconst create$2 = ({ root, props })=>{\n    // filename\n    const fileName = createElement$1(\"span\");\n    fileName.className = \"filepond--file-info-main\";\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, \"aria-hidden\", \"true\");\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n    // filesize\n    const fileSize = createElement$1(\"span\");\n    fileSize.className = \"filepond--file-info-sub\";\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n    // set initial values\n    text(fileSize, root.query(\"GET_LABEL_FILE_WAITING_FOR_SIZE\"));\n    text(fileName, formatFilename(root.query(\"GET_ITEM_NAME\", props.id)));\n};\nconst updateFile = ({ root, props })=>{\n    text(root.ref.fileSize, toNaturalFileSize(root.query(\"GET_ITEM_SIZE\", props.id), \".\", root.query(\"GET_FILE_SIZE_BASE\"), root.query(\"GET_FILE_SIZE_LABELS\", root.query)));\n    text(root.ref.fileName, formatFilename(root.query(\"GET_ITEM_NAME\", props.id)));\n};\nconst updateFileSizeOnError = ({ root, props })=>{\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query(\"GET_ITEM_SIZE\", props.id))) {\n        updateFile({\n            root,\n            props\n        });\n        return;\n    }\n    text(root.ref.fileSize, root.query(\"GET_LABEL_FILE_SIZE_NOT_AVAILABLE\"));\n};\nconst fileInfo = createView({\n    name: \"file-info\",\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: updateFile,\n        DID_UPDATE_ITEM_META: updateFile,\n        DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n        DID_THROW_ITEM_INVALID: updateFileSizeOnError\n    }),\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    create: create$2,\n    mixins: {\n        styles: [\n            \"translateX\",\n            \"translateY\"\n        ],\n        animations: {\n            translateX: \"spring\",\n            translateY: \"spring\"\n        }\n    }\n});\nconst toPercentage = (value)=>Math.round(value * 100);\nconst create$3 = ({ root })=>{\n    // main status\n    const main = createElement$1(\"span\");\n    main.className = \"filepond--file-status-main\";\n    root.appendChild(main);\n    root.ref.main = main;\n    // sub status\n    const sub = createElement$1(\"span\");\n    sub.className = \"filepond--file-status-sub\";\n    root.appendChild(sub);\n    root.ref.sub = sub;\n    didSetItemLoadProgress({\n        root,\n        action: {\n            progress: null\n        }\n    });\n};\nconst didSetItemLoadProgress = ({ root, action })=>{\n    const title = action.progress === null ? root.query(\"GET_LABEL_FILE_LOADING\") : `${root.query(\"GET_LABEL_FILE_LOADING\")} ${toPercentage(action.progress)}%`;\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_CANCEL\"));\n};\nconst didSetItemProcessProgress = ({ root, action })=>{\n    const title = action.progress === null ? root.query(\"GET_LABEL_FILE_PROCESSING\") : `${root.query(\"GET_LABEL_FILE_PROCESSING\")} ${toPercentage(action.progress)}%`;\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_CANCEL\"));\n};\nconst didRequestItemProcessing = ({ root })=>{\n    text(root.ref.main, root.query(\"GET_LABEL_FILE_PROCESSING\"));\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_CANCEL\"));\n};\nconst didAbortItemProcessing = ({ root })=>{\n    text(root.ref.main, root.query(\"GET_LABEL_FILE_PROCESSING_ABORTED\"));\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_RETRY\"));\n};\nconst didCompleteItemProcessing = ({ root })=>{\n    text(root.ref.main, root.query(\"GET_LABEL_FILE_PROCESSING_COMPLETE\"));\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_UNDO\"));\n};\nconst clear = ({ root })=>{\n    text(root.ref.main, \"\");\n    text(root.ref.sub, \"\");\n};\nconst error = ({ root, action })=>{\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n};\nconst fileStatus = createView({\n    name: \"file-status\",\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: clear,\n        DID_REVERT_ITEM_PROCESSING: clear,\n        DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n        DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n        DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n        DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n        DID_THROW_ITEM_LOAD_ERROR: error,\n        DID_THROW_ITEM_INVALID: error,\n        DID_THROW_ITEM_PROCESSING_ERROR: error,\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n        DID_THROW_ITEM_REMOVE_ERROR: error\n    }),\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    create: create$3,\n    mixins: {\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"opacity\"\n        ],\n        animations: {\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            },\n            translateX: \"spring\",\n            translateY: \"spring\"\n        }\n    }\n});\n/**\n * Button definitions for the file view\n */ const Buttons = {\n    AbortItemLoad: {\n        label: \"GET_LABEL_BUTTON_ABORT_ITEM_LOAD\",\n        action: \"ABORT_ITEM_LOAD\",\n        className: \"filepond--action-abort-item-load\",\n        align: \"LOAD_INDICATOR_POSITION\"\n    },\n    RetryItemLoad: {\n        label: \"GET_LABEL_BUTTON_RETRY_ITEM_LOAD\",\n        action: \"RETRY_ITEM_LOAD\",\n        icon: \"GET_ICON_RETRY\",\n        className: \"filepond--action-retry-item-load\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    RemoveItem: {\n        label: \"GET_LABEL_BUTTON_REMOVE_ITEM\",\n        action: \"REQUEST_REMOVE_ITEM\",\n        icon: \"GET_ICON_REMOVE\",\n        className: \"filepond--action-remove-item\",\n        align: \"BUTTON_REMOVE_ITEM_POSITION\"\n    },\n    ProcessItem: {\n        label: \"GET_LABEL_BUTTON_PROCESS_ITEM\",\n        action: \"REQUEST_ITEM_PROCESSING\",\n        icon: \"GET_ICON_PROCESS\",\n        className: \"filepond--action-process-item\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    AbortItemProcessing: {\n        label: \"GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING\",\n        action: \"ABORT_ITEM_PROCESSING\",\n        className: \"filepond--action-abort-item-processing\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    RetryItemProcessing: {\n        label: \"GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING\",\n        action: \"RETRY_ITEM_PROCESSING\",\n        icon: \"GET_ICON_RETRY\",\n        className: \"filepond--action-retry-item-processing\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    RevertItemProcessing: {\n        label: \"GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING\",\n        action: \"REQUEST_REVERT_ITEM_PROCESSING\",\n        icon: \"GET_ICON_UNDO\",\n        className: \"filepond--action-revert-item-processing\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    }\n};\n// make a list of buttons, we can then remove buttons from this list if they're disabled\nconst ButtonKeys = [];\nforin(Buttons, (key)=>{\n    ButtonKeys.push(key);\n});\nconst calculateFileInfoOffset = (root)=>{\n    if (getRemoveIndicatorAligment(root) === \"right\") return 0;\n    const buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n};\nconst calculateButtonWidth = (root)=>{\n    const buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n    return buttonRect.width;\n};\n// Force on full pixels so text stays crips\nconst calculateFileVerticalCenterOffset = (root)=>Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\nconst calculateFileHorizontalCenterOffset = (root)=>Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\nconst getLoadIndicatorAlignment = (root)=>root.query(\"GET_STYLE_LOAD_INDICATOR_POSITION\");\nconst getProcessIndicatorAlignment = (root)=>root.query(\"GET_STYLE_PROGRESS_INDICATOR_POSITION\");\nconst getRemoveIndicatorAligment = (root)=>root.query(\"GET_STYLE_BUTTON_REMOVE_ITEM_POSITION\");\nconst DefaultStyle = {\n    buttonAbortItemLoad: {\n        opacity: 0\n    },\n    buttonRetryItemLoad: {\n        opacity: 0\n    },\n    buttonRemoveItem: {\n        opacity: 0\n    },\n    buttonProcessItem: {\n        opacity: 0\n    },\n    buttonAbortItemProcessing: {\n        opacity: 0\n    },\n    buttonRetryItemProcessing: {\n        opacity: 0\n    },\n    buttonRevertItemProcessing: {\n        opacity: 0\n    },\n    loadProgressIndicator: {\n        opacity: 0,\n        align: getLoadIndicatorAlignment\n    },\n    processProgressIndicator: {\n        opacity: 0,\n        align: getProcessIndicatorAlignment\n    },\n    processingCompleteIndicator: {\n        opacity: 0,\n        scaleX: 0.75,\n        scaleY: 0.75\n    },\n    info: {\n        translateX: 0,\n        translateY: 0,\n        opacity: 0\n    },\n    status: {\n        translateX: 0,\n        translateY: 0,\n        opacity: 0\n    }\n};\nconst IdleStyle = {\n    buttonRemoveItem: {\n        opacity: 1\n    },\n    buttonProcessItem: {\n        opacity: 1\n    },\n    info: {\n        translateX: calculateFileInfoOffset\n    },\n    status: {\n        translateX: calculateFileInfoOffset\n    }\n};\nconst ProcessingStyle = {\n    buttonAbortItemProcessing: {\n        opacity: 1\n    },\n    processProgressIndicator: {\n        opacity: 1\n    },\n    status: {\n        opacity: 1\n    }\n};\nconst StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            translateX: calculateFileInfoOffset,\n            opacity: 1\n        }\n    },\n    DID_START_ITEM_LOAD: {\n        buttonAbortItemLoad: {\n            opacity: 1\n        },\n        loadProgressIndicator: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_THROW_ITEM_LOAD_ERROR: {\n        buttonRetryItemLoad: {\n            opacity: 1\n        },\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_START_ITEM_REMOVE: {\n        processProgressIndicator: {\n            opacity: 1,\n            align: getRemoveIndicatorAligment\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 0\n        }\n    },\n    DID_THROW_ITEM_REMOVE_ERROR: {\n        processProgressIndicator: {\n            opacity: 0,\n            align: getRemoveIndicatorAligment\n        },\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 1,\n            translateX: calculateFileInfoOffset\n        }\n    },\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            translateX: calculateFileInfoOffset\n        }\n    },\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n        buttonRevertItemProcessing: {\n            opacity: 1\n        },\n        info: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        buttonRetryItemProcessing: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        }\n    },\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n        buttonRevertItemProcessing: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        },\n        info: {\n            opacity: 1\n        }\n    },\n    DID_ABORT_ITEM_PROCESSING: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        buttonProcessItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_REVERT_ITEM_PROCESSING: IdleStyle\n};\n// complete indicator view\nconst processingCompleteIndicatorView = createView({\n    create: ({ root })=>{\n        root.element.innerHTML = root.query(\"GET_ICON_DONE\");\n    },\n    name: \"processing-complete-indicator\",\n    ignoreRect: true,\n    mixins: {\n        styles: [\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\"\n        ],\n        animations: {\n            scaleX: \"spring\",\n            scaleY: \"spring\",\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            }\n        }\n    }\n});\n/**\n * Creates the file view\n */ const create$4 = ({ root, props })=>{\n    // copy Buttons object\n    const LocalButtons = Object.keys(Buttons).reduce((prev, curr)=>{\n        prev[curr] = {\n            ...Buttons[curr]\n        };\n        return prev;\n    }, {});\n    const { id } = props;\n    // allow reverting upload\n    const allowRevert = root.query(\"GET_ALLOW_REVERT\");\n    // allow remove file\n    const allowRemove = root.query(\"GET_ALLOW_REMOVE\");\n    // allow processing upload\n    const allowProcess = root.query(\"GET_ALLOW_PROCESS\");\n    // is instant uploading, need this to determine the icon of the undo button\n    const instantUpload = root.query(\"GET_INSTANT_UPLOAD\");\n    // is async set up\n    const isAsync = root.query(\"IS_ASYNC\");\n    // should align remove item buttons\n    const alignRemoveItemButton = root.query(\"GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN\");\n    // enabled buttons array\n    let buttonFilter;\n    if (isAsync) {\n        if (allowProcess && !allowRevert) {\n            // only remove revert button\n            buttonFilter = (key)=>!/RevertItemProcessing/.test(key);\n        } else if (!allowProcess && allowRevert) {\n            // only remove process button\n            buttonFilter = (key)=>!/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);\n        } else if (!allowProcess && !allowRevert) {\n            // remove all process buttons\n            buttonFilter = (key)=>!/Process/.test(key);\n        }\n    } else {\n        // no process controls available\n        buttonFilter = (key)=>!/Process/.test(key);\n    }\n    const enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n        LocalButtons[\"RevertItemProcessing\"].label = \"GET_LABEL_BUTTON_REMOVE_ITEM\";\n        LocalButtons[\"RevertItemProcessing\"].icon = \"GET_ICON_REMOVE\";\n    }\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n        const map = StyleMap[\"DID_COMPLETE_ITEM_PROCESSING\"];\n        map.info.translateX = calculateFileHorizontalCenterOffset;\n        map.info.translateY = calculateFileVerticalCenterOffset;\n        map.status.translateY = calculateFileVerticalCenterOffset;\n        map.processingCompleteIndicator = {\n            opacity: 1,\n            scaleX: 1,\n            scaleY: 1\n        };\n    }\n    // should align center\n    if (isAsync && !allowProcess) {\n        [\n            \"DID_START_ITEM_PROCESSING\",\n            \"DID_REQUEST_ITEM_PROCESSING\",\n            \"DID_UPDATE_ITEM_PROCESS_PROGRESS\",\n            \"DID_THROW_ITEM_PROCESSING_ERROR\"\n        ].forEach((key)=>{\n            StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n        });\n        StyleMap[\"DID_THROW_ITEM_PROCESSING_ERROR\"].status.translateX = calculateButtonWidth;\n    }\n    // move remove button to right\n    if (alignRemoveItemButton && allowRevert) {\n        LocalButtons[\"RevertItemProcessing\"].align = \"BUTTON_REMOVE_ITEM_POSITION\";\n        const map = StyleMap[\"DID_COMPLETE_ITEM_PROCESSING\"];\n        map.info.translateX = calculateFileInfoOffset;\n        map.status.translateY = calculateFileVerticalCenterOffset;\n        map.processingCompleteIndicator = {\n            opacity: 1,\n            scaleX: 1,\n            scaleY: 1\n        };\n    }\n    // show/hide RemoveItem button\n    if (!allowRemove) {\n        LocalButtons[\"RemoveItem\"].disabled = true;\n    }\n    // create the button views\n    forin(LocalButtons, (key, definition)=>{\n        // create button\n        const buttonView = root.createChildView(fileActionButton, {\n            label: root.query(definition.label),\n            icon: root.query(definition.icon),\n            opacity: 0\n        });\n        // should be appended?\n        if (enabledButtons.includes(key)) {\n            root.appendChildView(buttonView);\n        }\n        // toggle\n        if (definition.disabled) {\n            buttonView.element.setAttribute(\"disabled\", \"disabled\");\n            buttonView.element.setAttribute(\"hidden\", \"hidden\");\n        }\n        // add position attribute\n        buttonView.element.dataset.align = root.query(`GET_STYLE_${definition.align}`);\n        // add class\n        buttonView.element.classList.add(definition.className);\n        // handle interactions\n        buttonView.on(\"click\", (e)=>{\n            e.stopPropagation();\n            if (definition.disabled) return;\n            root.dispatch(definition.action, {\n                query: id\n            });\n        });\n        // set reference\n        root.ref[`button${key}`] = buttonView;\n    });\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(root.createChildView(processingCompleteIndicatorView));\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(`GET_STYLE_BUTTON_PROCESS_ITEM_POSITION`);\n    // create file info view\n    root.ref.info = root.appendChildView(root.createChildView(fileInfo, {\n        id\n    }));\n    // create file status view\n    root.ref.status = root.appendChildView(root.createChildView(fileStatus, {\n        id\n    }));\n    // add progress indicators\n    const loadIndicatorView = root.appendChildView(root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query(`GET_STYLE_LOAD_INDICATOR_POSITION`)\n    }));\n    loadIndicatorView.element.classList.add(\"filepond--load-indicator\");\n    root.ref.loadProgressIndicator = loadIndicatorView;\n    const progressIndicatorView = root.appendChildView(root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query(`GET_STYLE_PROGRESS_INDICATOR_POSITION`)\n    }));\n    progressIndicatorView.element.classList.add(\"filepond--process-indicator\");\n    root.ref.processProgressIndicator = progressIndicatorView;\n    // current active styles\n    root.ref.activeStyles = [];\n};\nconst write$2 = ({ root, actions, props })=>{\n    // route actions\n    route({\n        root,\n        actions,\n        props\n    });\n    // select last state change action\n    let action = actions.concat().filter((action)=>/^DID_/.test(action.type)).reverse().find((action)=>StyleMap[action.type]);\n    // a new action happened, let's get the matching styles\n    if (action) {\n        // define new active styles\n        root.ref.activeStyles = [];\n        const stylesToApply = StyleMap[action.type];\n        forin(DefaultStyle, (name, defaultStyles)=>{\n            // get reference to control\n            const control = root.ref[name];\n            // loop over all styles for this control\n            forin(defaultStyles, (key, defaultValue)=>{\n                const value = stylesToApply[name] && typeof stylesToApply[name][key] !== \"undefined\" ? stylesToApply[name][key] : defaultValue;\n                root.ref.activeStyles.push({\n                    control,\n                    key,\n                    value\n                });\n            });\n        });\n    }\n    // apply active styles to element\n    root.ref.activeStyles.forEach(({ control, key, value })=>{\n        control[key] = typeof value === \"function\" ? value(root) : value;\n    });\n};\nconst route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: ({ root, action })=>{\n        root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: ({ root, action })=>{\n        root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: ({ root, action })=>{\n        root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: ({ root })=>{\n        root.ref.processProgressIndicator.spin = true;\n        root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: ({ root })=>{\n        root.ref.loadProgressIndicator.spin = true;\n        root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: ({ root })=>{\n        root.ref.processProgressIndicator.spin = true;\n        root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: ({ root, action })=>{\n        root.ref.loadProgressIndicator.spin = false;\n        root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ({ root, action })=>{\n        root.ref.processProgressIndicator.spin = false;\n        root.ref.processProgressIndicator.progress = action.progress;\n    }\n});\nconst file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    name: \"file\"\n});\n/**\n * Creates the file view\n */ const create$5 = ({ root, props })=>{\n    // filename\n    root.ref.fileName = createElement$1(\"legend\");\n    root.appendChild(root.ref.fileName);\n    // file appended\n    root.ref.file = root.appendChildView(root.createChildView(file, {\n        id: props.id\n    }));\n    // data has moved to data.js\n    root.ref.data = false;\n};\n/**\n * Data storage\n */ const didLoadItem = ({ root, props })=>{\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(root.ref.fileName, formatFilename(root.query(\"GET_ITEM_NAME\", props.id)));\n};\nconst fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n        DID_LOAD_ITEM: didLoadItem\n    }),\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    tag: \"fieldset\",\n    name: \"file-wrapper\"\n});\nconst PANEL_SPRING_PROPS = {\n    type: \"spring\",\n    damping: 0.6,\n    mass: 7\n};\nconst create$6 = ({ root, props })=>{\n    [\n        {\n            name: \"top\"\n        },\n        {\n            name: \"center\",\n            props: {\n                translateY: null,\n                scaleY: null\n            },\n            mixins: {\n                animations: {\n                    scaleY: PANEL_SPRING_PROPS\n                },\n                styles: [\n                    \"translateY\",\n                    \"scaleY\"\n                ]\n            }\n        },\n        {\n            name: \"bottom\",\n            props: {\n                translateY: null\n            },\n            mixins: {\n                animations: {\n                    translateY: PANEL_SPRING_PROPS\n                },\n                styles: [\n                    \"translateY\"\n                ]\n            }\n        }\n    ].forEach((section)=>{\n        createSection(root, section, props.name);\n    });\n    root.element.classList.add(`filepond--${props.name}`);\n    root.ref.scalable = null;\n};\nconst createSection = (root, section, className)=>{\n    const viewConstructor = createView({\n        name: `panel-${section.name} filepond--${className}`,\n        mixins: section.mixins,\n        ignoreRectUpdate: true\n    });\n    const view = root.createChildView(viewConstructor, section.props);\n    root.ref[section.name] = root.appendChildView(view);\n};\nconst write$3 = ({ root, props })=>{\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n        root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n        root.element.dataset.scalable = root.ref.scalable;\n    }\n    // no height, can't set\n    if (!props.height) return;\n    // get child rects\n    const topRect = root.ref.top.rect.element;\n    const bottomRect = root.ref.bottom.rect.element;\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    const height = Math.max(topRect.height + bottomRect.height, props.height);\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n};\nconst panel = createView({\n    name: \"panel\",\n    read: ({ root, props })=>props.heightCurrent = root.ref.bottom.translateY,\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n        apis: [\n            \"height\",\n            \"heightCurrent\",\n            \"scalable\"\n        ]\n    }\n});\nconst createDragHelper = (items)=>{\n    const itemIds = items.map((item)=>item.id);\n    let prevIndex = undefined;\n    return {\n        setIndex: (index)=>{\n            prevIndex = index;\n        },\n        getIndex: ()=>prevIndex,\n        getItemIndex: (item)=>itemIds.indexOf(item.id)\n    };\n};\nconst ITEM_TRANSLATE_SPRING = {\n    type: \"spring\",\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10\n};\nconst ITEM_SCALE_SPRING = \"spring\";\nconst StateMap = {\n    DID_START_ITEM_LOAD: \"busy\",\n    DID_UPDATE_ITEM_LOAD_PROGRESS: \"loading\",\n    DID_THROW_ITEM_INVALID: \"load-invalid\",\n    DID_THROW_ITEM_LOAD_ERROR: \"load-error\",\n    DID_LOAD_ITEM: \"idle\",\n    DID_THROW_ITEM_REMOVE_ERROR: \"remove-error\",\n    DID_START_ITEM_REMOVE: \"busy\",\n    DID_START_ITEM_PROCESSING: \"busy processing\",\n    DID_REQUEST_ITEM_PROCESSING: \"busy processing\",\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: \"processing\",\n    DID_COMPLETE_ITEM_PROCESSING: \"processing-complete\",\n    DID_THROW_ITEM_PROCESSING_ERROR: \"processing-error\",\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: \"processing-revert-error\",\n    DID_ABORT_ITEM_PROCESSING: \"cancelled\",\n    DID_REVERT_ITEM_PROCESSING: \"idle\"\n};\n/**\n * Creates the file view\n */ const create$7 = ({ root, props })=>{\n    // select\n    root.ref.handleClick = (e)=>root.dispatch(\"DID_ACTIVATE_ITEM\", {\n            id: props.id\n        });\n    // set id\n    root.element.id = `filepond--item-${props.id}`;\n    root.element.addEventListener(\"click\", root.ref.handleClick);\n    // file view\n    root.ref.container = root.appendChildView(root.createChildView(fileWrapper, {\n        id: props.id\n    }));\n    // file panel\n    root.ref.panel = root.appendChildView(root.createChildView(panel, {\n        name: \"item-panel\"\n    }));\n    // default start height\n    root.ref.panel.height = null;\n    // by default not marked for removal\n    props.markedForRemoval = false;\n    // if not allowed to reorder file items, exit here\n    if (!root.query(\"GET_ALLOW_REORDER\")) return;\n    // set to idle so shows grab cursor\n    root.element.dataset.dragState = \"idle\";\n    const grab = (e)=>{\n        if (!e.isPrimary) return;\n        let removedActivateListener = false;\n        const origin = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        props.dragOrigin = {\n            x: root.translateX,\n            y: root.translateY\n        };\n        props.dragCenter = {\n            x: e.offsetX,\n            y: e.offsetY\n        };\n        const dragState = createDragHelper(root.query(\"GET_ACTIVE_ITEMS\"));\n        root.dispatch(\"DID_GRAB_ITEM\", {\n            id: props.id,\n            dragState\n        });\n        const drag = (e)=>{\n            if (!e.isPrimary) return;\n            e.stopPropagation();\n            e.preventDefault();\n            props.dragOffset = {\n                x: e.pageX - origin.x,\n                y: e.pageY - origin.y\n            };\n            // if dragged stop listening to clicks, will re-add when done dragging\n            const dist = props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;\n            if (dist > 16 && !removedActivateListener) {\n                removedActivateListener = true;\n                root.element.removeEventListener(\"click\", root.ref.handleClick);\n            }\n            root.dispatch(\"DID_DRAG_ITEM\", {\n                id: props.id,\n                dragState\n            });\n        };\n        const drop = (e)=>{\n            if (!e.isPrimary) return;\n            props.dragOffset = {\n                x: e.pageX - origin.x,\n                y: e.pageY - origin.y\n            };\n            reset();\n        };\n        const cancel = ()=>{\n            reset();\n        };\n        const reset = ()=>{\n            document.removeEventListener(\"pointercancel\", cancel);\n            document.removeEventListener(\"pointermove\", drag);\n            document.removeEventListener(\"pointerup\", drop);\n            root.dispatch(\"DID_DROP_ITEM\", {\n                id: props.id,\n                dragState\n            });\n            // start listening to clicks again\n            if (removedActivateListener) {\n                setTimeout(()=>root.element.addEventListener(\"click\", root.ref.handleClick), 0);\n            }\n        };\n        document.addEventListener(\"pointercancel\", cancel);\n        document.addEventListener(\"pointermove\", drag);\n        document.addEventListener(\"pointerup\", drop);\n    };\n    root.element.addEventListener(\"pointerdown\", grab);\n};\nconst route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: ({ root, action })=>{\n        root.height = action.height;\n    }\n});\nconst write$4 = createRoute({\n    DID_GRAB_ITEM: ({ root, props })=>{\n        props.dragOrigin = {\n            x: root.translateX,\n            y: root.translateY\n        };\n    },\n    DID_DRAG_ITEM: ({ root })=>{\n        root.element.dataset.dragState = \"drag\";\n    },\n    DID_DROP_ITEM: ({ root, props })=>{\n        props.dragOffset = null;\n        props.dragOrigin = null;\n        root.element.dataset.dragState = \"drop\";\n    }\n}, ({ root, actions, props, shouldOptimize })=>{\n    if (root.element.dataset.dragState === \"drop\") {\n        if (root.scaleX <= 1) {\n            root.element.dataset.dragState = \"idle\";\n        }\n    }\n    // select last state change action\n    let action = actions.concat().filter((action)=>/^DID_/.test(action.type)).reverse().find((action)=>StateMap[action.type]);\n    // no need to set same state twice\n    if (action && action.type !== props.currentState) {\n        // set current state\n        props.currentState = action.type;\n        // set state\n        root.element.dataset.filepondItemState = StateMap[props.currentState] || \"\";\n    }\n    // route actions\n    const aspectRatio = root.query(\"GET_ITEM_PANEL_ASPECT_RATIO\") || root.query(\"GET_PANEL_ASPECT_RATIO\");\n    if (!aspectRatio) {\n        route$1({\n            root,\n            actions,\n            props\n        });\n        if (!root.height && root.ref.container.rect.element.height > 0) {\n            root.height = root.ref.container.rect.element.height;\n        }\n    } else if (!shouldOptimize) {\n        root.height = root.rect.element.width * aspectRatio;\n    }\n    // sync panel height with item height\n    if (shouldOptimize) {\n        root.ref.panel.height = null;\n    }\n    root.ref.panel.height = root.height;\n});\nconst item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: ({ root, props })=>{\n        root.element.removeEventListener(\"click\", root.ref.handleClick);\n        root.dispatch(\"RELEASE_ITEM\", {\n            query: props.id\n        });\n    },\n    tag: \"li\",\n    name: \"item\",\n    mixins: {\n        apis: [\n            \"id\",\n            \"interactionMethod\",\n            \"markedForRemoval\",\n            \"spawnDate\",\n            \"dragCenter\",\n            \"dragOrigin\",\n            \"dragOffset\"\n        ],\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\",\n            \"height\"\n        ],\n        animations: {\n            scaleX: ITEM_SCALE_SPRING,\n            scaleY: ITEM_SCALE_SPRING,\n            translateX: ITEM_TRANSLATE_SPRING,\n            translateY: ITEM_TRANSLATE_SPRING,\n            opacity: {\n                type: \"tween\",\n                duration: 150\n            }\n        }\n    }\n});\nvar getItemsPerRow = (horizontalSpace, itemWidth)=>{\n    // add one pixel leeway, when using percentages for item width total items can be 1.99 per row\n    return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));\n};\nconst getItemIndexByPosition = (view, children, positionInView)=>{\n    if (!positionInView) return;\n    const horizontalSpace = view.rect.element.width;\n    // const children = view.childViews;\n    const l = children.length;\n    let last = null;\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n    // let's get the item width\n    const item = children[0];\n    const itemRect = item.rect.element;\n    const itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    const itemWidth = itemRect.width + itemHorizontalMargin;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n    // stack\n    if (itemsPerRow === 1) {\n        for(let index = 0; index < l; index++){\n            const child = children[index];\n            const childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n            if (positionInView.top < childMid) {\n                return index;\n            }\n        }\n        return l;\n    }\n    // grid\n    const itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    const itemHeight = itemRect.height + itemVerticalMargin;\n    for(let index = 0; index < l; index++){\n        const indexX = index % itemsPerRow;\n        const indexY = Math.floor(index / itemsPerRow);\n        const offsetX = indexX * itemWidth;\n        const offsetY = indexY * itemHeight;\n        const itemTop = offsetY - itemRect.marginTop;\n        const itemRight = offsetX + itemWidth;\n        const itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n        if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n            if (positionInView.left < itemRight) {\n                return index;\n            } else if (index !== l - 1) {\n                last = index;\n            } else {\n                last = null;\n            }\n        }\n    }\n    if (last !== null) {\n        return last;\n    }\n    return l;\n};\nconst dropAreaDimensions = {\n    height: 0,\n    width: 0,\n    get getHeight () {\n        return this.height;\n    },\n    set setHeight (val){\n        if (this.height === 0 || val === 0) this.height = val;\n    },\n    get getWidth () {\n        return this.width;\n    },\n    set setWidth (val){\n        if (this.width === 0 || val === 0) this.width = val;\n    },\n    setDimensions: function(height, width) {\n        if (this.height === 0 || height === 0) this.height = height;\n        if (this.width === 0 || width === 0) this.width = width;\n    }\n};\nconst create$8 = ({ root })=>{\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, \"role\", \"list\");\n    root.ref.lastItemSpanwDate = Date.now();\n};\n/**\n * Inserts a new item\n * @param root\n * @param action\n */ const addItemView = ({ root, action })=>{\n    const { id, index, interactionMethod } = action;\n    root.ref.addIndex = index;\n    const now = Date.now();\n    let spawnDate = now;\n    let opacity = 1;\n    if (interactionMethod !== InteractionMethod.NONE) {\n        opacity = 0;\n        const cooldown = root.query(\"GET_ITEM_INSERT_INTERVAL\");\n        const dist = now - root.ref.lastItemSpanwDate;\n        spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n    root.ref.lastItemSpanwDate = spawnDate;\n    root.appendChildView(root.createChildView(// view type\n    item, // props\n    {\n        spawnDate,\n        id,\n        opacity,\n        interactionMethod\n    }), index);\n};\nconst moveItem = (item, x, y, vx = 0, vy = 1)=>{\n    // set to null to remove animation while dragging\n    if (item.dragOffset) {\n        item.translateX = null;\n        item.translateY = null;\n        item.translateX = item.dragOrigin.x + item.dragOffset.x;\n        item.translateY = item.dragOrigin.y + item.dragOffset.y;\n        item.scaleX = 1.025;\n        item.scaleY = 1.025;\n    } else {\n        item.translateX = x;\n        item.translateY = y;\n        if (Date.now() > item.spawnDate) {\n            // reveal element\n            if (item.opacity === 0) {\n                introItemView(item, x, y, vx, vy);\n            }\n            // make sure is default scale every frame\n            item.scaleX = 1;\n            item.scaleY = 1;\n            item.opacity = 1;\n        }\n    }\n};\nconst introItemView = (item, x, y, vx, vy)=>{\n    if (item.interactionMethod === InteractionMethod.NONE) {\n        item.translateX = null;\n        item.translateX = x;\n        item.translateY = null;\n        item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n        item.translateX = null;\n        item.translateX = x - vx * 20;\n        item.translateY = null;\n        item.translateY = y - vy * 10;\n        item.scaleX = 0.8;\n        item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n        item.translateY = null;\n        item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n        item.translateX = null;\n        item.translateX = x - 30;\n        item.translateY = null;\n    }\n};\n/**\n * Removes an existing item\n * @param root\n * @param action\n */ const removeItemView = ({ root, action })=>{\n    const { id } = action;\n    // get the view matching the given id\n    const view = root.childViews.find((child)=>child.id === id);\n    // if no view found, exit\n    if (!view) {\n        return;\n    }\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n    // mark for removal\n    view.markedForRemoval = true;\n};\nconst getItemHeight = (child)=>child.rect.element.height + child.rect.element.marginBottom * 0.5 + child.rect.element.marginTop * 0.5;\nconst getItemWidth = (child)=>child.rect.element.width + child.rect.element.marginLeft * 0.5 + child.rect.element.marginRight * 0.5;\nconst dragItem = ({ root, action })=>{\n    const { id, dragState } = action;\n    // reference to item\n    const item = root.query(\"GET_ITEM\", {\n        id\n    });\n    // get the view matching the given id\n    const view = root.childViews.find((child)=>child.id === id);\n    const numItems = root.childViews.length;\n    const oldIndex = dragState.getItemIndex(item);\n    // if no view found, exit\n    if (!view) return;\n    const dragPosition = {\n        x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n        y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y\n    };\n    // get drag area dimensions\n    const dragHeight = getItemHeight(view);\n    const dragWidth = getItemWidth(view);\n    // get rows and columns (There will always be at least one row and one column if a file is present)\n    let cols = Math.floor(root.rect.outer.width / dragWidth);\n    if (cols > numItems) cols = numItems;\n    // rows are used to find when we have left the preview area bounding box\n    const rows = Math.floor(numItems / cols + 1);\n    dropAreaDimensions.setHeight = dragHeight * rows;\n    dropAreaDimensions.setWidth = dragWidth * cols;\n    // get new index of dragged item\n    var location1 = {\n        y: Math.floor(dragPosition.y / dragHeight),\n        x: Math.floor(dragPosition.x / dragWidth),\n        getGridIndex: function getGridIndex() {\n            if (dragPosition.y > dropAreaDimensions.getHeight || dragPosition.y < 0 || dragPosition.x > dropAreaDimensions.getWidth || dragPosition.x < 0) return oldIndex;\n            return this.y * cols + this.x;\n        },\n        getColIndex: function getColIndex() {\n            const items = root.query(\"GET_ACTIVE_ITEMS\");\n            const visibleChildren = root.childViews.filter((child)=>child.rect.element.height);\n            const children = items.map((item)=>visibleChildren.find((childView)=>childView.id === item.id));\n            const currentIndex = children.findIndex((child)=>child === view);\n            const dragHeight = getItemHeight(view);\n            const l = children.length;\n            let idx = l;\n            let childHeight = 0;\n            let childBottom = 0;\n            let childTop = 0;\n            for(let i = 0; i < l; i++){\n                childHeight = getItemHeight(children[i]);\n                childTop = childBottom;\n                childBottom = childTop + childHeight;\n                if (dragPosition.y < childBottom) {\n                    if (currentIndex > i) {\n                        if (dragPosition.y < childTop + dragHeight) {\n                            idx = i;\n                            break;\n                        }\n                        continue;\n                    }\n                    idx = i;\n                    break;\n                }\n            }\n            return idx;\n        }\n    };\n    // get new index\n    const index = cols > 1 ? location1.getGridIndex() : location1.getColIndex();\n    root.dispatch(\"MOVE_ITEM\", {\n        query: view,\n        index\n    });\n    // if the index of the item changed, dispatch reorder action\n    const currentIndex = dragState.getIndex();\n    if (currentIndex === undefined || currentIndex !== index) {\n        dragState.setIndex(index);\n        if (currentIndex === undefined) return;\n        root.dispatch(\"DID_REORDER_ITEMS\", {\n            items: root.query(\"GET_ACTIVE_ITEMS\"),\n            origin: oldIndex,\n            target: index\n        });\n    }\n};\n/**\n * Setup action routes\n */ const route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView,\n    DID_DRAG_ITEM: dragItem\n});\n/**\n * Write to view\n * @param root\n * @param actions\n * @param props\n */ const write$5 = ({ root, props, actions, shouldOptimize })=>{\n    // route actions\n    route$2({\n        root,\n        props,\n        actions\n    });\n    const { dragCoordinates } = props;\n    // available space on horizontal axis\n    const horizontalSpace = root.rect.element.width;\n    // only draw children that have dimensions\n    const visibleChildren = root.childViews.filter((child)=>child.rect.element.height);\n    // sort based on current active items\n    const children = root.query(\"GET_ACTIVE_ITEMS\").map((item)=>visibleChildren.find((child)=>child.id === item.id)).filter((item)=>item);\n    // get index\n    const dragIndex = dragCoordinates ? getItemIndexByPosition(root, children, dragCoordinates) : null;\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    const addIndex = root.ref.addIndex || null;\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n    let dragIndexOffset = 0;\n    let removeIndexOffset = 0;\n    let addIndexOffset = 0;\n    if (children.length === 0) return;\n    const childRect = children[0].rect.element;\n    const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    const itemWidth = childRect.width + itemHorizontalMargin;\n    const itemHeight = childRect.height + itemVerticalMargin;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n    // stack\n    if (itemsPerRow === 1) {\n        let offsetY = 0;\n        let dragOffset = 0;\n        children.forEach((child, index)=>{\n            if (dragIndex) {\n                let dist = index - dragIndex;\n                if (dist === -2) {\n                    dragOffset = -itemVerticalMargin * 0.25;\n                } else if (dist === -1) {\n                    dragOffset = -itemVerticalMargin * 0.75;\n                } else if (dist === 0) {\n                    dragOffset = itemVerticalMargin * 0.75;\n                } else if (dist === 1) {\n                    dragOffset = itemVerticalMargin * 0.25;\n                } else {\n                    dragOffset = 0;\n                }\n            }\n            if (shouldOptimize) {\n                child.translateX = null;\n                child.translateY = null;\n            }\n            if (!child.markedForRemoval) {\n                moveItem(child, 0, offsetY + dragOffset);\n            }\n            let itemHeight = child.rect.element.height + itemVerticalMargin;\n            let visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);\n            offsetY += visualHeight;\n        });\n    } else {\n        let prevX = 0;\n        let prevY = 0;\n        children.forEach((child, index)=>{\n            if (index === dragIndex) {\n                dragIndexOffset = 1;\n            }\n            if (index === addIndex) {\n                addIndexOffset += 1;\n            }\n            if (child.markedForRemoval && child.opacity < 0.5) {\n                removeIndexOffset -= 1;\n            }\n            const visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n            const indexX = visualIndex % itemsPerRow;\n            const indexY = Math.floor(visualIndex / itemsPerRow);\n            const offsetX = indexX * itemWidth;\n            const offsetY = indexY * itemHeight;\n            const vectorX = Math.sign(offsetX - prevX);\n            const vectorY = Math.sign(offsetY - prevY);\n            prevX = offsetX;\n            prevY = offsetY;\n            if (child.markedForRemoval) return;\n            if (shouldOptimize) {\n                child.translateX = null;\n                child.translateY = null;\n            }\n            moveItem(child, offsetX, offsetY, vectorX, vectorY);\n        });\n    }\n};\n/**\n * Filters actions that are meant specifically for a certain child of the list\n * @param child\n * @param actions\n */ const filterSetItemActions = (child, actions)=>actions.filter((action)=>{\n        // if action has an id, filter out actions that don't have this child id\n        if (action.data && action.data.id) {\n            return child.id === action.data.id;\n        }\n        // allow all other actions\n        return true;\n    });\nconst list = createView({\n    create: create$8,\n    write: write$5,\n    tag: \"ul\",\n    name: \"list\",\n    didWriteView: ({ root })=>{\n        root.childViews.filter((view)=>view.markedForRemoval && view.opacity === 0 && view.resting).forEach((view)=>{\n            view._destroy();\n            root.removeChildView(view);\n        });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n        apis: [\n            \"dragCoordinates\"\n        ]\n    }\n});\nconst create$9 = ({ root, props })=>{\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n};\nconst storeDragCoordinates = ({ root, props, action })=>{\n    if (!root.query(\"GET_ITEM_INSERT_LOCATION_FREEDOM\")) return;\n    props.dragCoordinates = {\n        left: action.position.scopeLeft - root.ref.list.rect.element.left,\n        top: action.position.scopeTop - (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop)\n    };\n};\nconst clearDragCoordinates = ({ props })=>{\n    props.dragCoordinates = null;\n};\nconst route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates\n});\nconst write$6 = ({ root, props, actions })=>{\n    // route actions\n    route$3({\n        root,\n        props,\n        actions\n    });\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n        props.overflowing = false;\n        // reset overflow state\n        root.element.dataset.state = \"\";\n        root.height = null;\n    }\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n        const newHeight = Math.round(props.overflow);\n        if (newHeight !== root.height) {\n            props.overflowing = true;\n            root.element.dataset.state = \"overflow\";\n            root.height = newHeight;\n        }\n    }\n};\nconst listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: \"list-scroller\",\n    mixins: {\n        apis: [\n            \"overflow\",\n            \"dragCoordinates\"\n        ],\n        styles: [\n            \"height\",\n            \"translateY\"\n        ],\n        animations: {\n            translateY: \"spring\"\n        }\n    }\n});\nconst attrToggle = (element, name, state, enabledValue = \"\")=>{\n    if (state) {\n        attr(element, name, enabledValue);\n    } else {\n        element.removeAttribute(name);\n    }\n};\nconst resetFileInput = (input)=>{\n    // no value, no need to reset\n    if (!input || input.value === \"\") {\n        return;\n    }\n    try {\n        // for modern browsers\n        input.value = \"\";\n    } catch (err) {}\n    // for IE10\n    if (input.value) {\n        // quickly append input to temp form and reset form\n        const form = createElement$1(\"form\");\n        const parentNode = input.parentNode;\n        const ref = input.nextSibling;\n        form.appendChild(input);\n        form.reset();\n        // re-inject input where it originally was\n        if (ref) {\n            parentNode.insertBefore(input, ref);\n        } else {\n            parentNode.appendChild(input);\n        }\n    }\n};\nconst create$a = ({ root, props })=>{\n    // set id so can be referenced from outside labels\n    root.element.id = `filepond--browser-${props.id}`;\n    // set name of element (is removed when a value is set)\n    attr(root.element, \"name\", root.query(\"GET_NAME\"));\n    // we have to link this element to the status element\n    attr(root.element, \"aria-controls\", `filepond--assistant-${props.id}`);\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, \"aria-labelledby\", `filepond--drop-label-${props.id}`);\n    // set configurable props\n    setAcceptedFileTypes({\n        root,\n        action: {\n            value: root.query(\"GET_ACCEPTED_FILE_TYPES\")\n        }\n    });\n    toggleAllowMultiple({\n        root,\n        action: {\n            value: root.query(\"GET_ALLOW_MULTIPLE\")\n        }\n    });\n    toggleDirectoryFilter({\n        root,\n        action: {\n            value: root.query(\"GET_ALLOW_DIRECTORIES_ONLY\")\n        }\n    });\n    toggleDisabled({\n        root\n    });\n    toggleRequired({\n        root,\n        action: {\n            value: root.query(\"GET_REQUIRED\")\n        }\n    });\n    setCaptureMethod({\n        root,\n        action: {\n            value: root.query(\"GET_CAPTURE_METHOD\")\n        }\n    });\n    // handle changes to the input field\n    root.ref.handleChange = (e)=>{\n        if (!root.element.value) {\n            return;\n        }\n        // extract files and move value of webkitRelativePath path to _relativePath\n        const files = Array.from(root.element.files).map((file)=>{\n            file._relativePath = file.webkitRelativePath;\n            return file;\n        });\n        // we add a little delay so the OS file select window can move out of the way before we add our file\n        setTimeout(()=>{\n            // load files\n            props.onload(files);\n            // reset input, it's just for exposing a method to drop files, should not retain any state\n            resetFileInput(root.element);\n        }, 250);\n    };\n    root.element.addEventListener(\"change\", root.ref.handleChange);\n};\nconst setAcceptedFileTypes = ({ root, action })=>{\n    if (!root.query(\"GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE\")) return;\n    attrToggle(root.element, \"accept\", !!action.value, action.value ? action.value.join(\",\") : \"\");\n};\nconst toggleAllowMultiple = ({ root, action })=>{\n    attrToggle(root.element, \"multiple\", action.value);\n};\nconst toggleDirectoryFilter = ({ root, action })=>{\n    attrToggle(root.element, \"webkitdirectory\", action.value);\n};\nconst toggleDisabled = ({ root })=>{\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const doesAllowBrowse = root.query(\"GET_ALLOW_BROWSE\");\n    const disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, \"disabled\", disableField);\n};\nconst toggleRequired = ({ root, action })=>{\n    // want to remove required, always possible\n    if (!action.value) {\n        attrToggle(root.element, \"required\", false);\n    } else if (root.query(\"GET_TOTAL_ITEMS\") === 0) {\n        attrToggle(root.element, \"required\", true);\n    }\n};\nconst setCaptureMethod = ({ root, action })=>{\n    attrToggle(root.element, \"capture\", !!action.value, action.value === true ? \"\" : action.value);\n};\nconst updateRequiredStatus = ({ root })=>{\n    const { element } = root;\n    // always remove the required attribute when more than zero items\n    if (root.query(\"GET_TOTAL_ITEMS\") > 0) {\n        attrToggle(element, \"required\", false);\n        attrToggle(element, \"name\", false);\n        // still has items\n        const activeItems = root.query(\"GET_ACTIVE_ITEMS\");\n        let hasInvalidField = false;\n        for(let i = 0; i < activeItems.length; i++){\n            if (activeItems[i].status === ItemStatus.LOAD_ERROR) {\n                hasInvalidField = true;\n            }\n        }\n        // set validity status\n        root.element.setCustomValidity(hasInvalidField ? root.query(\"GET_LABEL_INVALID_FIELD\") : \"\");\n    } else {\n        // add name attribute\n        attrToggle(element, \"name\", true, root.query(\"GET_NAME\"));\n        // remove any validation messages\n        const shouldCheckValidity = root.query(\"GET_CHECK_VALIDITY\");\n        if (shouldCheckValidity) {\n            element.setCustomValidity(\"\");\n        }\n        // we only add required if the field has been deemed required\n        if (root.query(\"GET_REQUIRED\")) {\n            attrToggle(element, \"required\", true);\n        }\n    }\n};\nconst updateFieldValidityStatus = ({ root })=>{\n    const shouldCheckValidity = root.query(\"GET_CHECK_VALIDITY\");\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query(\"GET_LABEL_INVALID_FIELD\"));\n};\nconst browser = createView({\n    tag: \"input\",\n    name: \"browser\",\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n        type: \"file\"\n    },\n    create: create$a,\n    destroy: ({ root })=>{\n        root.element.removeEventListener(\"change\", root.ref.handleChange);\n    },\n    write: createRoute({\n        DID_LOAD_ITEM: updateRequiredStatus,\n        DID_REMOVE_ITEM: updateRequiredStatus,\n        DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n        DID_SET_DISABLED: toggleDisabled,\n        DID_SET_ALLOW_BROWSE: toggleDisabled,\n        DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n        DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n        DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n        DID_SET_CAPTURE_METHOD: setCaptureMethod,\n        DID_SET_REQUIRED: toggleRequired\n    })\n});\nconst Key = {\n    ENTER: 13,\n    SPACE: 32\n};\nconst create$b = ({ root, props })=>{\n    // create the label and link it to the file browser\n    const label = createElement$1(\"label\");\n    attr(label, \"for\", `filepond--browser-${props.id}`);\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, \"id\", `filepond--drop-label-${props.id}`);\n    // handle keys\n    root.ref.handleKeyDown = (e)=>{\n        const isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n        if (!isActivationKey) return;\n        // stops from triggering the element a second time\n        e.preventDefault();\n        // click link (will then in turn activate file input)\n        root.ref.label.click();\n    };\n    root.ref.handleClick = (e)=>{\n        const isLabelClick = e.target === label || label.contains(e.target);\n        // don't want to click twice\n        if (isLabelClick) return;\n        // click link (will then in turn activate file input)\n        root.ref.label.click();\n    };\n    // attach events\n    label.addEventListener(\"keydown\", root.ref.handleKeyDown);\n    root.element.addEventListener(\"click\", root.ref.handleClick);\n    // update\n    updateLabelValue(label, props.caption);\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n};\nconst updateLabelValue = (label, value)=>{\n    label.innerHTML = value;\n    const clickable = label.querySelector(\".filepond--label-action\");\n    if (clickable) {\n        attr(clickable, \"tabindex\", \"0\");\n    }\n    return value;\n};\nconst dropLabel = createView({\n    name: \"drop-label\",\n    ignoreRect: true,\n    create: create$b,\n    destroy: ({ root })=>{\n        root.ref.label.addEventListener(\"keydown\", root.ref.handleKeyDown);\n        root.element.removeEventListener(\"click\", root.ref.handleClick);\n    },\n    write: createRoute({\n        DID_SET_LABEL_IDLE: ({ root, action })=>{\n            updateLabelValue(root.ref.label, action.value);\n        }\n    }),\n    mixins: {\n        styles: [\n            \"opacity\",\n            \"translateX\",\n            \"translateY\"\n        ],\n        animations: {\n            opacity: {\n                type: \"tween\",\n                duration: 150\n            },\n            translateX: \"spring\",\n            translateY: \"spring\"\n        }\n    }\n});\nconst blob = createView({\n    name: \"drip-blob\",\n    ignoreRect: true,\n    mixins: {\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\"\n        ],\n        animations: {\n            scaleX: \"spring\",\n            scaleY: \"spring\",\n            translateX: \"spring\",\n            translateY: \"spring\",\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            }\n        }\n    }\n});\nconst addBlob = ({ root })=>{\n    const centerX = root.rect.element.width * 0.5;\n    const centerY = root.rect.element.height * 0.5;\n    root.ref.blob = root.appendChildView(root.createChildView(blob, {\n        opacity: 0,\n        scaleX: 2.5,\n        scaleY: 2.5,\n        translateX: centerX,\n        translateY: centerY\n    }));\n};\nconst moveBlob = ({ root, action })=>{\n    if (!root.ref.blob) {\n        addBlob({\n            root\n        });\n        return;\n    }\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n};\nconst hideBlob = ({ root })=>{\n    if (!root.ref.blob) {\n        return;\n    }\n    root.ref.blob.opacity = 0;\n};\nconst explodeBlob = ({ root })=>{\n    if (!root.ref.blob) {\n        return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n};\nconst write$7 = ({ root, props, actions })=>{\n    route$4({\n        root,\n        props,\n        actions\n    });\n    const { blob } = root.ref;\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n        root.removeChildView(blob);\n        root.ref.blob = null;\n    }\n};\nconst route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob\n});\nconst drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: \"drip\",\n    write: write$7\n});\nconst setInputFiles = (element, files)=>{\n    try {\n        // Create a DataTransfer instance and add a newly created file\n        const dataTransfer = new DataTransfer();\n        files.forEach((file)=>{\n            if (file instanceof File) {\n                dataTransfer.items.add(file);\n            } else {\n                dataTransfer.items.add(new File([\n                    file\n                ], file.name, {\n                    type: file.type\n                }));\n            }\n        });\n        // Assign the DataTransfer files list to the file input\n        element.files = dataTransfer.files;\n    } catch (err) {\n        return false;\n    }\n    return true;\n};\nconst create$c = ({ root })=>{\n    root.ref.fields = {};\n    const legend = document.createElement(\"legend\");\n    legend.textContent = \"Files\";\n    root.element.appendChild(legend);\n};\nconst getField = (root, id)=>root.ref.fields[id];\nconst syncFieldPositionsWithItems = (root)=>{\n    root.query(\"GET_ACTIVE_ITEMS\").forEach((item)=>{\n        if (!root.ref.fields[item.id]) return;\n        root.element.appendChild(root.ref.fields[item.id]);\n    });\n};\nconst didReorderItems = ({ root })=>syncFieldPositionsWithItems(root);\nconst didAddItem = ({ root, action })=>{\n    const fileItem = root.query(\"GET_ITEM\", action.id);\n    const isLocalFile = fileItem.origin === FileOrigin.LOCAL;\n    const shouldUseFileInput = !isLocalFile && root.query(\"SHOULD_UPDATE_FILE_INPUT\");\n    const dataContainer = createElement$1(\"input\");\n    dataContainer.type = shouldUseFileInput ? \"file\" : \"hidden\";\n    dataContainer.name = root.query(\"GET_NAME\");\n    root.ref.fields[action.id] = dataContainer;\n    syncFieldPositionsWithItems(root);\n};\nconst didLoadItem$1 = ({ root, action })=>{\n    const field = getField(root, action.id);\n    if (!field) return;\n    // store server ref in hidden input\n    if (action.serverFileReference !== null) field.value = action.serverFileReference;\n    // store file item in file input\n    if (!root.query(\"SHOULD_UPDATE_FILE_INPUT\")) return;\n    const fileItem = root.query(\"GET_ITEM\", action.id);\n    setInputFiles(field, [\n        fileItem.file\n    ]);\n};\nconst didPrepareOutput = ({ root, action })=>{\n    // this timeout pushes the handler after 'load'\n    if (!root.query(\"SHOULD_UPDATE_FILE_INPUT\")) return;\n    setTimeout(()=>{\n        const field = getField(root, action.id);\n        if (!field) return;\n        setInputFiles(field, [\n            action.file\n        ]);\n    }, 0);\n};\nconst didSetDisabled = ({ root })=>{\n    root.element.disabled = root.query(\"GET_DISABLED\");\n};\nconst didRemoveItem = ({ root, action })=>{\n    const field = getField(root, action.id);\n    if (!field) return;\n    if (field.parentNode) field.parentNode.removeChild(field);\n    delete root.ref.fields[action.id];\n};\n// only runs for server files. will refuse to update the value if the field\n// is a file field\nconst didDefineValue = ({ root, action })=>{\n    const field = getField(root, action.id);\n    if (!field) return;\n    if (action.value === null) {\n        // clear field value\n        field.removeAttribute(\"value\");\n    } else {\n        // set field value\n        if (field.type != \"file\") {\n            field.value = action.value;\n        }\n    }\n    syncFieldPositionsWithItems(root);\n};\nconst write$8 = createRoute({\n    DID_SET_DISABLED: didSetDisabled,\n    DID_ADD_ITEM: didAddItem,\n    DID_LOAD_ITEM: didLoadItem$1,\n    DID_REMOVE_ITEM: didRemoveItem,\n    DID_DEFINE_VALUE: didDefineValue,\n    DID_PREPARE_OUTPUT: didPrepareOutput,\n    DID_REORDER_ITEMS: didReorderItems,\n    DID_SORT_ITEMS: didReorderItems\n});\nconst data = createView({\n    tag: \"fieldset\",\n    name: \"data\",\n    create: create$c,\n    write: write$8,\n    ignoreRect: true\n});\nconst getRootNode = (element)=>\"getRootNode\" in element ? element.getRootNode() : document;\nconst images = [\n    \"jpg\",\n    \"jpeg\",\n    \"png\",\n    \"gif\",\n    \"bmp\",\n    \"webp\",\n    \"svg\",\n    \"tiff\"\n];\nconst text$1 = [\n    \"css\",\n    \"csv\",\n    \"html\",\n    \"txt\"\n];\nconst map = {\n    zip: \"zip|compressed\",\n    epub: \"application/epub+zip\"\n};\nconst guesstimateMimeType = (extension = \"\")=>{\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n        return \"image/\" + (extension === \"jpg\" ? \"jpeg\" : extension === \"svg\" ? \"svg+xml\" : extension);\n    }\n    if (text$1.includes(extension)) {\n        return \"text/\" + extension;\n    }\n    return map[extension] || \"\";\n};\nconst requestDataTransferItems = (dataTransfer)=>new Promise((resolve, reject)=>{\n        // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n        const links = getLinks(dataTransfer);\n        if (links.length && !hasFiles(dataTransfer)) {\n            return resolve(links);\n        }\n        // try to get files from the transfer\n        getFiles(dataTransfer).then(resolve);\n    });\n/**\n * Test if datatransfer has files\n */ const hasFiles = (dataTransfer)=>{\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n};\n/**\n * Extracts files from a DataTransfer object\n */ const getFiles = (dataTransfer)=>new Promise((resolve, reject)=>{\n        // get the transfer items as promises\n        const promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])// only keep file system items (files and directories)\n        .filter((item)=>isFileSystemItem(item))// map each item to promise\n        .map((item)=>getFilesFromItem(item));\n        // if is empty, see if we can extract some info from the files property as a fallback\n        if (!promisedFiles.length) {\n            // TODO: test for directories (should not be allowed)\n            // Use FileReader, problem is that the files property gets lost in the process\n            resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n            return;\n        }\n        // done!\n        Promise.all(promisedFiles).then((returnedFileGroups)=>{\n            // flatten groups\n            const files = [];\n            returnedFileGroups.forEach((group)=>{\n                files.push.apply(files, group);\n            });\n            // done (filter out empty files)!\n            resolve(files.filter((file)=>file).map((file)=>{\n                if (!file._relativePath) file._relativePath = file.webkitRelativePath;\n                return file;\n            }));\n        }).catch(console.error);\n    });\nconst isFileSystemItem = (item)=>{\n    if (isEntry(item)) {\n        const entry = getAsEntry(item);\n        if (entry) {\n            return entry.isFile || entry.isDirectory;\n        }\n    }\n    return item.kind === \"file\";\n};\nconst getFilesFromItem = (item)=>new Promise((resolve, reject)=>{\n        if (isDirectoryEntry(item)) {\n            getFilesInDirectory(getAsEntry(item)).then(resolve).catch(reject);\n            return;\n        }\n        resolve([\n            item.getAsFile()\n        ]);\n    });\nconst getFilesInDirectory = (entry)=>new Promise((resolve, reject)=>{\n        const files = [];\n        // the total entries to read\n        let dirCounter = 0;\n        let fileCounter = 0;\n        const resolveIfDone = ()=>{\n            if (fileCounter === 0 && dirCounter === 0) {\n                resolve(files);\n            }\n        };\n        // the recursive function\n        const readEntries = (dirEntry)=>{\n            dirCounter++;\n            const directoryReader = dirEntry.createReader();\n            // directories are returned in batches, we need to process all batches before we're done\n            const readBatch = ()=>{\n                directoryReader.readEntries((entries)=>{\n                    if (entries.length === 0) {\n                        dirCounter--;\n                        resolveIfDone();\n                        return;\n                    }\n                    entries.forEach((entry)=>{\n                        // recursively read more directories\n                        if (entry.isDirectory) {\n                            readEntries(entry);\n                        } else {\n                            // read as file\n                            fileCounter++;\n                            entry.file((file)=>{\n                                const correctedFile = correctMissingFileType(file);\n                                if (entry.fullPath) correctedFile._relativePath = entry.fullPath;\n                                files.push(correctedFile);\n                                fileCounter--;\n                                resolveIfDone();\n                            });\n                        }\n                    });\n                    // try to get next batch of files\n                    readBatch();\n                }, reject);\n            };\n            // read first batch of files\n            readBatch();\n        };\n        // go!\n        readEntries(entry);\n    });\nconst correctMissingFileType = (file)=>{\n    if (file.type.length) return file;\n    const date = file.lastModifiedDate;\n    const name = file.name;\n    const type = guesstimateMimeType(getExtensionFromFilename(file.name));\n    if (!type.length) return file;\n    file = file.slice(0, file.size, type);\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n};\nconst isDirectoryEntry = (item)=>isEntry(item) && (getAsEntry(item) || {}).isDirectory;\nconst isEntry = (item)=>\"webkitGetAsEntry\" in item;\nconst getAsEntry = (item)=>item.webkitGetAsEntry();\n/**\n * Extracts links from a DataTransfer object\n */ const getLinks = (dataTransfer)=>{\n    let links = [];\n    try {\n        // look in meta data property\n        links = getLinksFromTransferMetaData(dataTransfer);\n        if (links.length) {\n            return links;\n        }\n        links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n    // nope nope nope (probably IE trouble)\n    }\n    return links;\n};\nconst getLinksFromTransferURLData = (dataTransfer)=>{\n    let data = dataTransfer.getData(\"url\");\n    if (typeof data === \"string\" && data.length) {\n        return [\n            data\n        ];\n    }\n    return [];\n};\nconst getLinksFromTransferMetaData = (dataTransfer)=>{\n    let data = dataTransfer.getData(\"text/html\");\n    if (typeof data === \"string\" && data.length) {\n        const matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n        if (matches) {\n            return [\n                matches[1]\n            ];\n        }\n    }\n    return [];\n};\nconst dragNDropObservers = [];\nconst eventPosition = (e)=>({\n        pageLeft: e.pageX,\n        pageTop: e.pageY,\n        scopeLeft: e.offsetX || e.layerX,\n        scopeTop: e.offsetY || e.layerY\n    });\nconst createDragNDropClient = (element, scopeToObserve, filterElement)=>{\n    const observer = getDragNDropObserver(scopeToObserve);\n    const client = {\n        element,\n        filterElement,\n        state: null,\n        ondrop: ()=>{},\n        onenter: ()=>{},\n        ondrag: ()=>{},\n        onexit: ()=>{},\n        onload: ()=>{},\n        allowdrop: ()=>{}\n    };\n    client.destroy = observer.addListener(client);\n    return client;\n};\nconst getDragNDropObserver = (element)=>{\n    // see if already exists, if so, return\n    const observer = dragNDropObservers.find((item)=>item.element === element);\n    if (observer) {\n        return observer;\n    }\n    // create new observer, does not yet exist for this element\n    const newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n};\nconst createDragNDropObserver = (element)=>{\n    const clients = [];\n    const routes = {\n        dragenter,\n        dragover,\n        dragleave,\n        drop\n    };\n    const handlers = {};\n    forin(routes, (event, createHandler)=>{\n        handlers[event] = createHandler(element, clients);\n        element.addEventListener(event, handlers[event], false);\n    });\n    const observer = {\n        element,\n        addListener: (client)=>{\n            // add as client\n            clients.push(client);\n            // return removeListener function\n            return ()=>{\n                // remove client\n                clients.splice(clients.indexOf(client), 1);\n                // if no more clients, clean up observer\n                if (clients.length === 0) {\n                    dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n                    forin(routes, (event)=>{\n                        element.removeEventListener(event, handlers[event], false);\n                    });\n                }\n            };\n        }\n    };\n    return observer;\n};\nconst elementFromPoint = (root, point)=>{\n    if (!(\"elementFromPoint\" in root)) {\n        root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n};\nconst isEventTarget = (e, target)=>{\n    // get root\n    const root = getRootNode(target);\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    const elementAtPosition = elementFromPoint(root, {\n        x: e.pageX - window.pageXOffset,\n        y: e.pageY - window.pageYOffset\n    });\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n};\nlet initialTarget = null;\nconst setDropEffect = (dataTransfer, effect)=>{\n    // is in try catch as IE11 will throw error if not\n    try {\n        dataTransfer.dropEffect = effect;\n    } catch (e) {}\n};\nconst dragenter = (root, clients)=>(e)=>{\n        e.preventDefault();\n        initialTarget = e.target;\n        clients.forEach((client)=>{\n            const { element, onenter } = client;\n            if (isEventTarget(e, element)) {\n                client.state = \"enter\";\n                // fire enter event\n                onenter(eventPosition(e));\n            }\n        });\n    };\nconst dragover = (root, clients)=>(e)=>{\n        e.preventDefault();\n        const dataTransfer = e.dataTransfer;\n        requestDataTransferItems(dataTransfer).then((items)=>{\n            let overDropTarget = false;\n            clients.some((client)=>{\n                const { filterElement, element, onenter, onexit, ondrag, allowdrop } = client;\n                // by default we can drop\n                setDropEffect(dataTransfer, \"copy\");\n                // allow transfer of these items\n                const allowsTransfer = allowdrop(items);\n                // only used when can be dropped on page\n                if (!allowsTransfer) {\n                    setDropEffect(dataTransfer, \"none\");\n                    return;\n                }\n                // targetting this client\n                if (isEventTarget(e, element)) {\n                    overDropTarget = true;\n                    // had no previous state, means we are entering this client\n                    if (client.state === null) {\n                        client.state = \"enter\";\n                        onenter(eventPosition(e));\n                        return;\n                    }\n                    // now over element (no matter if it allows the drop or not)\n                    client.state = \"over\";\n                    // needs to allow transfer\n                    if (filterElement && !allowsTransfer) {\n                        setDropEffect(dataTransfer, \"none\");\n                        return;\n                    }\n                    // dragging\n                    ondrag(eventPosition(e));\n                } else {\n                    // should be over an element to drop\n                    if (filterElement && !overDropTarget) {\n                        setDropEffect(dataTransfer, \"none\");\n                    }\n                    // might have just left this client?\n                    if (client.state) {\n                        client.state = null;\n                        onexit(eventPosition(e));\n                    }\n                }\n            });\n        });\n    };\nconst drop = (root, clients)=>(e)=>{\n        e.preventDefault();\n        const dataTransfer = e.dataTransfer;\n        requestDataTransferItems(dataTransfer).then((items)=>{\n            clients.forEach((client)=>{\n                const { filterElement, element, ondrop, onexit, allowdrop } = client;\n                client.state = null;\n                // if we're filtering on element we need to be over the element to drop\n                if (filterElement && !isEventTarget(e, element)) return;\n                // no transfer for this client\n                if (!allowdrop(items)) return onexit(eventPosition(e));\n                // we can drop these items on this client\n                ondrop(eventPosition(e), items);\n            });\n        });\n    };\nconst dragleave = (root, clients)=>(e)=>{\n        if (initialTarget !== e.target) {\n            return;\n        }\n        clients.forEach((client)=>{\n            const { onexit } = client;\n            client.state = null;\n            onexit(eventPosition(e));\n        });\n    };\nconst createHopper = (scope, validateItems, options)=>{\n    // is now hopper scope\n    scope.classList.add(\"filepond--hopper\");\n    // shortcuts\n    const { catchesDropsOnPage, requiresDropOnElement, filterItems = (items)=>items } = options;\n    // create a dnd client\n    const client = createDragNDropClient(scope, catchesDropsOnPage ? document.documentElement : scope, requiresDropOnElement);\n    // current client state\n    let lastState = \"\";\n    let currentState = \"\";\n    // determines if a file may be dropped\n    client.allowdrop = (items)=>{\n        // TODO: if we can, throw error to indicate the items cannot by dropped\n        return validateItems(filterItems(items));\n    };\n    client.ondrop = (position, items)=>{\n        const filteredItems = filterItems(items);\n        if (!validateItems(filteredItems)) {\n            api.ondragend(position);\n            return;\n        }\n        currentState = \"drag-drop\";\n        api.onload(filteredItems, position);\n    };\n    client.ondrag = (position)=>{\n        api.ondrag(position);\n    };\n    client.onenter = (position)=>{\n        currentState = \"drag-over\";\n        api.ondragstart(position);\n    };\n    client.onexit = (position)=>{\n        currentState = \"drag-exit\";\n        api.ondragend(position);\n    };\n    const api = {\n        updateHopperState: ()=>{\n            if (lastState !== currentState) {\n                scope.dataset.hopperState = currentState;\n                lastState = currentState;\n            }\n        },\n        onload: ()=>{},\n        ondragstart: ()=>{},\n        ondrag: ()=>{},\n        ondragend: ()=>{},\n        destroy: ()=>{\n            // destroy client\n            client.destroy();\n        }\n    };\n    return api;\n};\nlet listening = false;\nconst listeners$1 = [];\nconst handlePaste = (e)=>{\n    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n    const activeEl = document.activeElement;\n    const isActiveElementEditable = activeEl && (/textarea|input/i.test(activeEl.nodeName) || activeEl.getAttribute(\"contenteditable\") === \"true\");\n    if (isActiveElementEditable) {\n        // test textarea or input is contained in filepond root\n        let inScope = false;\n        let element = activeEl;\n        while(element !== document.body){\n            if (element.classList.contains(\"filepond--root\")) {\n                inScope = true;\n                break;\n            }\n            element = element.parentNode;\n        }\n        if (!inScope) return;\n    }\n    requestDataTransferItems(e.clipboardData).then((files)=>{\n        // no files received\n        if (!files.length) {\n            return;\n        }\n        // notify listeners of received files\n        listeners$1.forEach((listener)=>listener(files));\n    });\n};\nconst listen = (cb)=>{\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n        return;\n    }\n    // add initial listener\n    listeners$1.push(cb);\n    // setup paste listener for entire page\n    if (listening) {\n        return;\n    }\n    listening = true;\n    document.addEventListener(\"paste\", handlePaste);\n};\nconst unlisten = (listener)=>{\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n    // clean up\n    if (listeners$1.length === 0) {\n        document.removeEventListener(\"paste\", handlePaste);\n        listening = false;\n    }\n};\nconst createPaster = ()=>{\n    const cb = (files)=>{\n        api.onload(files);\n    };\n    const api = {\n        destroy: ()=>{\n            unlisten(cb);\n        },\n        onload: ()=>{}\n    };\n    listen(cb);\n    return api;\n};\n/**\n * Creates the file view\n */ const create$d = ({ root, props })=>{\n    root.element.id = `filepond--assistant-${props.id}`;\n    attr(root.element, \"role\", \"alert\");\n    attr(root.element, \"aria-live\", \"polite\");\n    attr(root.element, \"aria-relevant\", \"additions\");\n};\nlet addFilesNotificationTimeout = null;\nlet notificationClearTimeout = null;\nconst filenames = [];\nconst assist = (root, message)=>{\n    root.element.textContent = message;\n};\nconst clear$1 = (root)=>{\n    root.element.textContent = \"\";\n};\nconst listModified = (root, filename, label)=>{\n    const total = root.query(\"GET_TOTAL_ITEMS\");\n    assist(root, `${label} ${filename}, ${total} ${total === 1 ? root.query(\"GET_LABEL_FILE_COUNT_SINGULAR\") : root.query(\"GET_LABEL_FILE_COUNT_PLURAL\")}`);\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(()=>{\n        clear$1(root);\n    }, 1500);\n};\nconst isUsingFilePond = (root)=>root.element.parentNode.contains(document.activeElement);\nconst itemAdded = ({ root, action })=>{\n    if (!isUsingFilePond(root)) {\n        return;\n    }\n    root.element.textContent = \"\";\n    const item = root.query(\"GET_ITEM\", action.id);\n    filenames.push(item.filename);\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(()=>{\n        listModified(root, filenames.join(\", \"), root.query(\"GET_LABEL_FILE_ADDED\"));\n        filenames.length = 0;\n    }, 750);\n};\nconst itemRemoved = ({ root, action })=>{\n    if (!isUsingFilePond(root)) {\n        return;\n    }\n    const item = action.item;\n    listModified(root, item.filename, root.query(\"GET_LABEL_FILE_REMOVED\"));\n};\nconst itemProcessed = ({ root, action })=>{\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n    const item = root.query(\"GET_ITEM\", action.id);\n    const filename = item.filename;\n    const label = root.query(\"GET_LABEL_FILE_PROCESSING_COMPLETE\");\n    assist(root, `${filename} ${label}`);\n};\nconst itemProcessedUndo = ({ root, action })=>{\n    const item = root.query(\"GET_ITEM\", action.id);\n    const filename = item.filename;\n    const label = root.query(\"GET_LABEL_FILE_PROCESSING_ABORTED\");\n    assist(root, `${filename} ${label}`);\n};\nconst itemError = ({ root, action })=>{\n    const item = root.query(\"GET_ITEM\", action.id);\n    const filename = item.filename;\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n    assist(root, `${action.status.main} ${filename} ${action.status.sub}`);\n};\nconst assistant = createView({\n    create: create$d,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: itemAdded,\n        DID_REMOVE_ITEM: itemRemoved,\n        DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n        DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n        DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n        DID_THROW_ITEM_REMOVE_ERROR: itemError,\n        DID_THROW_ITEM_LOAD_ERROR: itemError,\n        DID_THROW_ITEM_INVALID: itemError,\n        DID_THROW_ITEM_PROCESSING_ERROR: itemError\n    }),\n    tag: \"span\",\n    name: \"assistant\"\n});\nconst toCamels = (string, separator = \"-\")=>string.replace(new RegExp(`${separator}.`, \"g\"), (sub)=>sub.charAt(1).toUpperCase());\nconst debounce = (func, interval = 16, immidiateOnly = true)=>{\n    let last = Date.now();\n    let timeout = null;\n    return (...args)=>{\n        clearTimeout(timeout);\n        const dist = Date.now() - last;\n        const fn = ()=>{\n            last = Date.now();\n            func(...args);\n        };\n        if (dist < interval) {\n            // we need to delay by the difference between interval and dist\n            // for example: if distance is 10 ms and interval is 16 ms,\n            // we need to wait an additional 6ms before calling the function)\n            if (!immidiateOnly) {\n                timeout = setTimeout(fn, interval - dist);\n            }\n        } else {\n            // go!\n            fn();\n        }\n    };\n};\nconst MAX_FILES_LIMIT = 1000000;\nconst prevent = (e)=>e.preventDefault();\nconst create$e = ({ root, props })=>{\n    // Add id\n    const id = root.query(\"GET_ID\");\n    if (id) {\n        root.element.id = id;\n    }\n    // Add className\n    const className = root.query(\"GET_CLASS_NAME\");\n    if (className) {\n        className.split(\" \").filter((name)=>name.length).forEach((name)=>{\n            root.element.classList.add(name);\n        });\n    }\n    // Field label\n    root.ref.label = root.appendChildView(root.createChildView(dropLabel, {\n        ...props,\n        translateY: null,\n        caption: root.query(\"GET_LABEL_IDLE\")\n    }));\n    // List of items\n    root.ref.list = root.appendChildView(root.createChildView(listScroller, {\n        translateY: null\n    }));\n    // Background panel\n    root.ref.panel = root.appendChildView(root.createChildView(panel, {\n        name: \"panel-root\"\n    }));\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(root.createChildView(assistant, {\n        ...props\n    }));\n    // Data\n    root.ref.data = root.appendChildView(root.createChildView(data, {\n        ...props\n    }));\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1(\"div\");\n    root.ref.measure.style.height = \"100%\";\n    root.element.appendChild(root.ref.measure);\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n    // apply initial style properties\n    root.query(\"GET_STYLES\").filter((style)=>!isEmpty(style.value)).map(({ name, value })=>{\n        root.element.dataset[name] = value;\n    });\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(()=>{\n        root.ref.updateHistory = [];\n        root.dispatch(\"DID_RESIZE_ROOT\");\n    }, 250);\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n    const canHover = window.matchMedia(\"(pointer: fine) and (hover: hover)\").matches;\n    const hasPointerEvents = \"PointerEvent\" in window;\n    if (root.query(\"GET_ALLOW_REORDER\") && hasPointerEvents && !canHover) {\n        root.element.addEventListener(\"touchmove\", prevent, {\n            passive: false\n        });\n        root.element.addEventListener(\"gesturestart\", prevent);\n    }\n    // add credits\n    const credits = root.query(\"GET_CREDITS\");\n    const hasCredits = credits.length === 2;\n    if (hasCredits) {\n        const frag = document.createElement(\"a\");\n        frag.className = \"filepond--credits\";\n        frag.href = credits[0];\n        frag.tabIndex = -1;\n        frag.target = \"_blank\";\n        frag.rel = \"noopener noreferrer nofollow\";\n        frag.textContent = credits[1];\n        root.element.appendChild(frag);\n        root.ref.credits = frag;\n    }\n};\nconst write$9 = ({ root, props, actions })=>{\n    // route actions\n    route$5({\n        root,\n        props,\n        actions\n    });\n    // apply style properties\n    actions.filter((action)=>/^DID_SET_STYLE_/.test(action.type)).filter((action)=>!isEmpty(action.data.value)).map(({ type, data })=>{\n        const name = toCamels(type.substring(8).toLowerCase(), \"_\");\n        root.element.dataset[name] = data.value;\n        root.invalidateLayout();\n    });\n    if (root.rect.element.hidden) return;\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n        root.ref.widthPrevious = root.rect.element.width;\n        root.ref.widthUpdated();\n    }\n    // get box bounds, we do this only once\n    let bounds = root.ref.bounds;\n    if (!bounds) {\n        bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n        // destroy measure element\n        root.element.removeChild(root.ref.measure);\n        root.ref.measure = null;\n    }\n    // get quick references to various high level parts of the upload tool\n    const { hopper, label, list, panel } = root.ref;\n    // sets correct state to hopper scope\n    if (hopper) {\n        hopper.updateHopperState();\n    }\n    // bool to indicate if we're full or not\n    const aspectRatio = root.query(\"GET_PANEL_ASPECT_RATIO\");\n    const isMultiItem = root.query(\"GET_ALLOW_MULTIPLE\");\n    const totalItems = root.query(\"GET_TOTAL_ITEMS\");\n    const maxItems = isMultiItem ? root.query(\"GET_MAX_FILES\") || MAX_FILES_LIMIT : 1;\n    const atMaxCapacity = totalItems === maxItems;\n    // action used to add item\n    const addAction = actions.find((action)=>action.type === \"DID_ADD_ITEM\");\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n        // get interaction type\n        const interactionMethod = addAction.data.interactionMethod;\n        // hide label\n        label.opacity = 0;\n        if (isMultiItem) {\n            label.translateY = -40;\n        } else {\n            if (interactionMethod === InteractionMethod.API) {\n                label.translateX = 40;\n            } else if (interactionMethod === InteractionMethod.BROWSE) {\n                label.translateY = 40;\n            } else {\n                label.translateY = 30;\n            }\n        }\n    } else if (!atMaxCapacity) {\n        label.opacity = 1;\n        label.translateX = 0;\n        label.translateY = 0;\n    }\n    const listItemMargin = calculateListItemMargin(root);\n    const listHeight = calculateListHeight(root);\n    const labelHeight = label.rect.element.height;\n    const currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n    const listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    const listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;\n    const visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    const boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n    // link list to label bottom position\n    list.translateY = Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;\n    if (aspectRatio) {\n        // fixed aspect ratio\n        // calculate height based on width\n        const width = root.rect.element.width;\n        const height = width * aspectRatio;\n        // clear history if aspect ratio has changed\n        if (aspectRatio !== root.ref.previousAspectRatio) {\n            root.ref.previousAspectRatio = aspectRatio;\n            root.ref.updateHistory = [];\n        }\n        // remember this width\n        const history = root.ref.updateHistory;\n        history.push(width);\n        const MAX_BOUNCES = 2;\n        if (history.length > MAX_BOUNCES * 2) {\n            const l = history.length;\n            const bottom = l - 10;\n            let bounces = 0;\n            for(let i = l; i >= bottom; i--){\n                if (history[i] === history[i - 2]) {\n                    bounces++;\n                }\n                if (bounces >= MAX_BOUNCES) {\n                    // dont adjust height\n                    return;\n                }\n            }\n        }\n        // fix height of panel so it adheres to aspect ratio\n        panel.scalable = false;\n        panel.height = height;\n        // available height for list\n        const listAvailableHeight = // the height of the panel minus the label height\n        height - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n        if (listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n        // set container bounds (so pushes siblings downwards)\n        root.height = height;\n    } else if (bounds.fixedHeight) {\n        // fixed height\n        // fix height of panel\n        panel.scalable = false;\n        // available height for list\n        const listAvailableHeight = // the height of the panel minus the label height\n        bounds.fixedHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n        // set list height\n        if (listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n    // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n        // max-height\n        // not a fixed height panel\n        const isCappedHeight = visualHeight >= bounds.cappedHeight;\n        const panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n        panel.scalable = true;\n        panel.height = isCappedHeight ? panelHeight : panelHeight - listItemMargin.top - listItemMargin.bottom;\n        // available height for list\n        const listAvailableHeight = // the height of the panel minus the label height\n        panelHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n        // set list height (if is overflowing)\n        if (visualHeight > bounds.cappedHeight && listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n        // set container bounds (so pushes siblings downwards)\n        root.height = Math.min(bounds.cappedHeight, boundsHeight - listItemMargin.top - listItemMargin.bottom);\n    } else {\n        // flexible height\n        // not a fixed height panel\n        const itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n        panel.scalable = true;\n        panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n        // set container bounds (so pushes siblings downwards)\n        root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n    // move credits to bottom\n    if (root.ref.credits && panel.heightCurrent) root.ref.credits.style.transform = `translateY(${panel.heightCurrent}px)`;\n};\nconst calculateListItemMargin = (root)=>{\n    const item = root.ref.list.childViews[0].childViews[0];\n    return item ? {\n        top: item.rect.element.marginTop,\n        bottom: item.rect.element.marginBottom\n    } : {\n        top: 0,\n        bottom: 0\n    };\n};\nconst calculateListHeight = (root)=>{\n    let visual = 0;\n    let bounds = 0;\n    // get file list reference\n    const scrollList = root.ref.list;\n    const itemList = scrollList.childViews[0];\n    const visibleChildren = itemList.childViews.filter((child)=>child.rect.element.height);\n    const children = root.query(\"GET_ACTIVE_ITEMS\").map((item)=>visibleChildren.find((child)=>child.id === item.id)).filter((item)=>item);\n    // no children, done!\n    if (children.length === 0) return {\n        visual,\n        bounds\n    };\n    const horizontalSpace = itemList.rect.element.width;\n    const dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);\n    const childRect = children[0].rect.element;\n    const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    const itemWidth = childRect.width + itemHorizontalMargin;\n    const itemHeight = childRect.height + itemVerticalMargin;\n    const newItem = typeof dragIndex !== \"undefined\" && dragIndex >= 0 ? 1 : 0;\n    const removedItem = children.find((child)=>child.markedForRemoval && child.opacity < 0.45) ? -1 : 0;\n    const verticalItemCount = children.length + newItem + removedItem;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n    // stack\n    if (itemsPerRow === 1) {\n        children.forEach((item)=>{\n            const height = item.rect.element.height + itemVerticalMargin;\n            bounds += height;\n            visual += height * item.opacity;\n        });\n    } else {\n        bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n        visual = bounds;\n    }\n    return {\n        visual,\n        bounds\n    };\n};\nconst calculateRootBoundingBoxHeight = (root)=>{\n    const height = root.ref.measureHeight || null;\n    const cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    const fixedHeight = height === 0 ? null : height;\n    return {\n        cappedHeight,\n        fixedHeight\n    };\n};\nconst exceedsMaxFiles = (root, items)=>{\n    const allowReplace = root.query(\"GET_ALLOW_REPLACE\");\n    const allowMultiple = root.query(\"GET_ALLOW_MULTIPLE\");\n    const totalItems = root.query(\"GET_TOTAL_ITEMS\");\n    let maxItems = root.query(\"GET_MAX_FILES\");\n    // total amount of items being dragged\n    const totalBrowseItems = items.length;\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n        root.dispatch(\"DID_THROW_MAX_FILES\", {\n            source: items,\n            error: createResponse(\"warning\", 0, \"Max files\")\n        });\n        return true;\n    }\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : 1;\n    if (!allowMultiple && allowReplace) {\n        // There is only one item, so there is room to replace or add an item\n        return false;\n    }\n    // no more room?\n    const hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n        root.dispatch(\"DID_THROW_MAX_FILES\", {\n            source: items,\n            error: createResponse(\"warning\", 0, \"Max files\")\n        });\n        return true;\n    }\n    return false;\n};\nconst getDragIndex = (list, children, position)=>{\n    const itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, children, {\n        left: position.scopeLeft - itemList.rect.element.left,\n        top: position.scopeTop - (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop)\n    });\n};\n/**\n * Enable or disable file drop functionality\n */ const toggleDrop = (root)=>{\n    const isAllowed = root.query(\"GET_ALLOW_DROP\");\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n        const hopper = createHopper(root.element, (items)=>{\n            // allow quick validation of dropped items\n            const beforeDropFile = root.query(\"GET_BEFORE_DROP_FILE\") || (()=>true);\n            // all items should be validated by all filters as valid\n            const dropValidation = root.query(\"GET_DROP_VALIDATION\");\n            return dropValidation ? items.every((item)=>applyFilters(\"ALLOW_HOPPER_ITEM\", item, {\n                    query: root.query\n                }).every((result)=>result === true) && beforeDropFile(item)) : true;\n        }, {\n            filterItems: (items)=>{\n                const ignoredFiles = root.query(\"GET_IGNORED_FILES\");\n                return items.filter((item)=>{\n                    if (isFile(item)) {\n                        return !ignoredFiles.includes(item.name.toLowerCase());\n                    }\n                    return true;\n                });\n            },\n            catchesDropsOnPage: root.query(\"GET_DROP_ON_PAGE\"),\n            requiresDropOnElement: root.query(\"GET_DROP_ON_ELEMENT\")\n        });\n        hopper.onload = (items, position)=>{\n            // get item children elements and sort based on list sort\n            const list = root.ref.list.childViews[0];\n            const visibleChildren = list.childViews.filter((child)=>child.rect.element.height);\n            const children = root.query(\"GET_ACTIVE_ITEMS\").map((item)=>visibleChildren.find((child)=>child.id === item.id)).filter((item)=>item);\n            applyFilterChain(\"ADD_ITEMS\", items, {\n                dispatch: root.dispatch\n            }).then((queue)=>{\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n                // go\n                root.dispatch(\"ADD_ITEMS\", {\n                    items: queue,\n                    index: getDragIndex(root.ref.list, children, position),\n                    interactionMethod: InteractionMethod.DROP\n                });\n            });\n            root.dispatch(\"DID_DROP\", {\n                position\n            });\n            root.dispatch(\"DID_END_DRAG\", {\n                position\n            });\n        };\n        hopper.ondragstart = (position)=>{\n            root.dispatch(\"DID_START_DRAG\", {\n                position\n            });\n        };\n        hopper.ondrag = debounce((position)=>{\n            root.dispatch(\"DID_DRAG\", {\n                position\n            });\n        });\n        hopper.ondragend = (position)=>{\n            root.dispatch(\"DID_END_DRAG\", {\n                position\n            });\n        };\n        root.ref.hopper = hopper;\n        root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n        root.ref.hopper.destroy();\n        root.ref.hopper = null;\n        root.removeChildView(root.ref.drip);\n    }\n};\n/**\n * Enable or disable browse functionality\n */ const toggleBrowse = (root, props)=>{\n    const isAllowed = root.query(\"GET_ALLOW_BROWSE\");\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n        root.ref.browser = root.appendChildView(root.createChildView(browser, {\n            ...props,\n            onload: (items)=>{\n                applyFilterChain(\"ADD_ITEMS\", items, {\n                    dispatch: root.dispatch\n                }).then((queue)=>{\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n                    // add items!\n                    root.dispatch(\"ADD_ITEMS\", {\n                        items: queue,\n                        index: -1,\n                        interactionMethod: InteractionMethod.BROWSE\n                    });\n                });\n            }\n        }), 0);\n    } else if (!enabled && root.ref.browser) {\n        root.removeChildView(root.ref.browser);\n        root.ref.browser = null;\n    }\n};\n/**\n * Enable or disable paste functionality\n */ const togglePaste = (root)=>{\n    const isAllowed = root.query(\"GET_ALLOW_PASTE\");\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n        root.ref.paster = createPaster();\n        root.ref.paster.onload = (items)=>{\n            applyFilterChain(\"ADD_ITEMS\", items, {\n                dispatch: root.dispatch\n            }).then((queue)=>{\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n                // add items!\n                root.dispatch(\"ADD_ITEMS\", {\n                    items: queue,\n                    index: -1,\n                    interactionMethod: InteractionMethod.PASTE\n                });\n            });\n        };\n    } else if (!enabled && root.ref.paster) {\n        root.ref.paster.destroy();\n        root.ref.paster = null;\n    }\n};\n/**\n * Route actions\n */ const route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: ({ root, props })=>{\n        toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: ({ root })=>{\n        toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: ({ root })=>{\n        togglePaste(root);\n    },\n    DID_SET_DISABLED: ({ root, props })=>{\n        toggleDrop(root);\n        togglePaste(root);\n        toggleBrowse(root, props);\n        const isDisabled = root.query(\"GET_DISABLED\");\n        if (isDisabled) {\n            root.element.dataset.disabled = \"disabled\";\n        } else {\n            // delete root.element.dataset.disabled; <= this does not work on iOS 10\n            root.element.removeAttribute(\"data-disabled\");\n        }\n    }\n});\nconst root = createView({\n    name: \"root\",\n    read: ({ root })=>{\n        if (root.ref.measure) {\n            root.ref.measureHeight = root.ref.measure.offsetHeight;\n        }\n    },\n    create: create$e,\n    write: write$9,\n    destroy: ({ root })=>{\n        if (root.ref.paster) {\n            root.ref.paster.destroy();\n        }\n        if (root.ref.hopper) {\n            root.ref.hopper.destroy();\n        }\n        root.element.removeEventListener(\"touchmove\", prevent);\n        root.element.removeEventListener(\"gesturestart\", prevent);\n    },\n    mixins: {\n        styles: [\n            \"height\"\n        ]\n    }\n});\n// creates the app\nconst createApp = (initialOptions = {})=>{\n    // let element\n    let originalElement = null;\n    // get default options\n    const defaultOptions = getOptions();\n    // create the data store, this will contain all our app info\n    const store = createStore(// initial state (should be serializable)\n    createInitialState(defaultOptions), // queries\n    [\n        queries,\n        createOptionQueries(defaultOptions)\n    ], // action handlers\n    [\n        actions,\n        createOptionActions(defaultOptions)\n    ]);\n    // set initial options\n    store.dispatch(\"SET_OPTIONS\", {\n        options: initialOptions\n    });\n    // kick thread if visibility changes\n    const visibilityHandler = ()=>{\n        if (document.hidden) return;\n        store.dispatch(\"KICK\");\n    };\n    document.addEventListener(\"visibilitychange\", visibilityHandler);\n    // re-render on window resize start and finish\n    let resizeDoneTimer = null;\n    let isResizing = false;\n    let isResizingHorizontally = false;\n    let initialWindowWidth = null;\n    let currentWindowWidth = null;\n    const resizeHandler = ()=>{\n        if (!isResizing) {\n            isResizing = true;\n        }\n        clearTimeout(resizeDoneTimer);\n        resizeDoneTimer = setTimeout(()=>{\n            isResizing = false;\n            initialWindowWidth = null;\n            currentWindowWidth = null;\n            if (isResizingHorizontally) {\n                isResizingHorizontally = false;\n                store.dispatch(\"DID_STOP_RESIZE\");\n            }\n        }, 500);\n    };\n    window.addEventListener(\"resize\", resizeHandler);\n    // render initial view\n    const view = root(store, {\n        id: getUniqueId()\n    });\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    let isResting = false;\n    let isHidden = false;\n    const readWriteApi = {\n        // necessary for update loop\n        /**\n         * Reads from dom (never call manually)\n         * @private\n         */ _read: ()=>{\n            // test if we're resizing horizontally\n            // TODO: see if we can optimize this by measuring root rect\n            if (isResizing) {\n                currentWindowWidth = window.innerWidth;\n                if (!initialWindowWidth) {\n                    initialWindowWidth = currentWindowWidth;\n                }\n                if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {\n                    store.dispatch(\"DID_START_RESIZE\");\n                    isResizingHorizontally = true;\n                }\n            }\n            if (isHidden && isResting) {\n                // test if is no longer hidden\n                isResting = view.element.offsetParent === null;\n            }\n            // if resting, no need to read as numbers will still all be correct\n            if (isResting) return;\n            // read view data\n            view._read();\n            // if is hidden we need to know so we exit rest mode when revealed\n            isHidden = view.rect.element.hidden;\n        },\n        /**\n         * Writes to dom (never call manually)\n         * @private\n         */ _write: (ts)=>{\n            // get all actions from store\n            const actions = store.processActionQueue()// filter out set actions (these will automatically trigger DID_SET)\n            .filter((action)=>!/^SET_/.test(action.type));\n            // if was idling and no actions stop here\n            if (isResting && !actions.length) return;\n            // some actions might trigger events\n            routeActionsToEvents(actions);\n            // update the view\n            isResting = view._write(ts, actions, isResizingHorizontally);\n            // will clean up all archived items\n            removeReleasedItems(store.query(\"GET_ITEMS\"));\n            // now idling\n            if (isResting) {\n                store.processDispatchQueue();\n            }\n        }\n    };\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    const createEvent = (name)=>(data)=>{\n            // create default event\n            const event = {\n                type: name\n            };\n            // no data to add\n            if (!data) {\n                return event;\n            }\n            // copy relevant props\n            if (data.hasOwnProperty(\"error\")) {\n                event.error = data.error ? {\n                    ...data.error\n                } : null;\n            }\n            if (data.status) {\n                event.status = {\n                    ...data.status\n                };\n            }\n            if (data.file) {\n                event.output = data.file;\n            }\n            // only source is available, else add item if possible\n            if (data.source) {\n                event.file = data.source;\n            } else if (data.item || data.id) {\n                const item = data.item ? data.item : store.query(\"GET_ITEM\", data.id);\n                event.file = item ? createItemAPI(item) : null;\n            }\n            // map all items in a possible items array\n            if (data.items) {\n                event.items = data.items.map(createItemAPI);\n            }\n            // if this is a progress event add the progress amount\n            if (/progress/.test(name)) {\n                event.progress = data.progress;\n            }\n            // copy relevant props\n            if (data.hasOwnProperty(\"origin\") && data.hasOwnProperty(\"target\")) {\n                event.origin = data.origin;\n                event.target = data.target;\n            }\n            return event;\n        };\n    const eventRoutes = {\n        DID_DESTROY: createEvent(\"destroy\"),\n        DID_INIT: createEvent(\"init\"),\n        DID_THROW_MAX_FILES: createEvent(\"warning\"),\n        DID_INIT_ITEM: createEvent(\"initfile\"),\n        DID_START_ITEM_LOAD: createEvent(\"addfilestart\"),\n        DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent(\"addfileprogress\"),\n        DID_LOAD_ITEM: createEvent(\"addfile\"),\n        DID_THROW_ITEM_INVALID: [\n            createEvent(\"error\"),\n            createEvent(\"addfile\")\n        ],\n        DID_THROW_ITEM_LOAD_ERROR: [\n            createEvent(\"error\"),\n            createEvent(\"addfile\")\n        ],\n        DID_THROW_ITEM_REMOVE_ERROR: [\n            createEvent(\"error\"),\n            createEvent(\"removefile\")\n        ],\n        DID_PREPARE_OUTPUT: createEvent(\"preparefile\"),\n        DID_START_ITEM_PROCESSING: createEvent(\"processfilestart\"),\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent(\"processfileprogress\"),\n        DID_ABORT_ITEM_PROCESSING: createEvent(\"processfileabort\"),\n        DID_COMPLETE_ITEM_PROCESSING: createEvent(\"processfile\"),\n        DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent(\"processfiles\"),\n        DID_REVERT_ITEM_PROCESSING: createEvent(\"processfilerevert\"),\n        DID_THROW_ITEM_PROCESSING_ERROR: [\n            createEvent(\"error\"),\n            createEvent(\"processfile\")\n        ],\n        DID_REMOVE_ITEM: createEvent(\"removefile\"),\n        DID_UPDATE_ITEMS: createEvent(\"updatefiles\"),\n        DID_ACTIVATE_ITEM: createEvent(\"activatefile\"),\n        DID_REORDER_ITEMS: createEvent(\"reorderfiles\")\n    };\n    const exposeEvent = (event)=>{\n        // create event object to be dispatched\n        const detail = {\n            pond: exports,\n            ...event\n        };\n        delete detail.type;\n        view.element.dispatchEvent(new CustomEvent(`FilePond:${event.type}`, {\n            // event info\n            detail,\n            // event behaviour\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        }));\n        // event object to params used for `on()` event handlers and callbacks `oninit()`\n        const params = [];\n        // if is possible error event, make it the first param\n        if (event.hasOwnProperty(\"error\")) {\n            params.push(event.error);\n        }\n        // file is always section\n        if (event.hasOwnProperty(\"file\")) {\n            params.push(event.file);\n        }\n        // append other props\n        const filtered = [\n            \"type\",\n            \"error\",\n            \"file\"\n        ];\n        Object.keys(event).filter((key)=>!filtered.includes(key)).forEach((key)=>params.push(event[key]));\n        // on(type, () => { })\n        exports.fire(event.type, ...params);\n        // oninit = () => {}\n        const handler = store.query(`GET_ON${event.type.toUpperCase()}`);\n        if (handler) {\n            handler(...params);\n        }\n    };\n    const routeActionsToEvents = (actions)=>{\n        if (!actions.length) return;\n        actions.filter((action)=>eventRoutes[action.type]).forEach((action)=>{\n            const routes = eventRoutes[action.type];\n            (Array.isArray(routes) ? routes : [\n                routes\n            ]).forEach((route)=>{\n                // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n                if (action.type === \"DID_INIT_ITEM\") {\n                    exposeEvent(route(action.data));\n                } else {\n                    setTimeout(()=>{\n                        exposeEvent(route(action.data));\n                    }, 0);\n                }\n            });\n        });\n    };\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    const setOptions = (options)=>store.dispatch(\"SET_OPTIONS\", {\n            options\n        });\n    const getFile = (query)=>store.query(\"GET_ACTIVE_ITEM\", query);\n    const prepareFile = (query)=>new Promise((resolve, reject)=>{\n            store.dispatch(\"REQUEST_ITEM_PREPARE\", {\n                query,\n                success: (item)=>{\n                    resolve(item);\n                },\n                failure: (error)=>{\n                    reject(error);\n                }\n            });\n        });\n    const addFile = (source, options = {})=>new Promise((resolve, reject)=>{\n            addFiles([\n                {\n                    source,\n                    options\n                }\n            ], {\n                index: options.index\n            }).then((items)=>resolve(items && items[0])).catch(reject);\n        });\n    const isFilePondFile = (obj)=>obj.file && obj.id;\n    const removeFile = (query, options)=>{\n        // if only passed options\n        if (typeof query === \"object\" && !isFilePondFile(query) && !options) {\n            options = query;\n            query = undefined;\n        }\n        // request item removal\n        store.dispatch(\"REMOVE_ITEM\", {\n            ...options,\n            query\n        });\n        // see if item has been removed\n        return store.query(\"GET_ACTIVE_ITEM\", query) === null;\n    };\n    const addFiles = (...args)=>new Promise((resolve, reject)=>{\n            const sources = [];\n            const options = {};\n            // user passed a sources array\n            if (isArray(args[0])) {\n                sources.push.apply(sources, args[0]);\n                Object.assign(options, args[1] || {});\n            } else {\n                // user passed sources as arguments, last one might be options object\n                const lastArgument = args[args.length - 1];\n                if (typeof lastArgument === \"object\" && !(lastArgument instanceof Blob)) {\n                    Object.assign(options, args.pop());\n                }\n                // add rest to sources\n                sources.push(...args);\n            }\n            store.dispatch(\"ADD_ITEMS\", {\n                items: sources,\n                index: options.index,\n                interactionMethod: InteractionMethod.API,\n                success: resolve,\n                failure: reject\n            });\n        });\n    const getFiles = ()=>store.query(\"GET_ACTIVE_ITEMS\");\n    const processFile = (query)=>new Promise((resolve, reject)=>{\n            store.dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                query,\n                success: (item)=>{\n                    resolve(item);\n                },\n                failure: (error)=>{\n                    reject(error);\n                }\n            });\n        });\n    const prepareFiles = (...args)=>{\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        const items = queries.length ? queries : getFiles();\n        return Promise.all(items.map(prepareFile));\n    };\n    const processFiles = (...args)=>{\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        if (!queries.length) {\n            const files = getFiles().filter((item)=>!(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) && item.status !== ItemStatus.PROCESSING && item.status !== ItemStatus.PROCESSING_COMPLETE && item.status !== ItemStatus.PROCESSING_REVERT_ERROR);\n            return Promise.all(files.map(processFile));\n        }\n        return Promise.all(queries.map(processFile));\n    };\n    const removeFiles = (...args)=>{\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        let options;\n        if (typeof queries[queries.length - 1] === \"object\") {\n            options = queries.pop();\n        } else if (Array.isArray(args[0])) {\n            options = args[1];\n        }\n        const files = getFiles();\n        if (!queries.length) return Promise.all(files.map((file)=>removeFile(file, options)));\n        // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n        const mappedQueries = queries.map((query)=>isNumber(query) ? files[query] ? files[query].id : null : query).filter((query)=>query);\n        return mappedQueries.map((q)=>removeFile(q, options));\n    };\n    const exports = {\n        // supports events\n        ...on(),\n        // inject private api methods\n        ...readWriteApi,\n        // inject all getters and setters\n        ...createOptionAPI(store, defaultOptions),\n        /**\n         * Override options defined in options object\n         * @param options\n         */ setOptions,\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */ addFile,\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */ addFiles,\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */ getFile,\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */ processFile,\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */ prepareFile,\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */ removeFile,\n        /**\n         * Moves a file to a new location in the files list\n         */ moveFile: (query, index)=>store.dispatch(\"MOVE_ITEM\", {\n                query,\n                index\n            }),\n        /**\n         * Returns all files (wrapped in public api)\n         */ getFiles,\n        /**\n         * Starts uploading all files\n         */ processFiles,\n        /**\n         * Clears all files from the files list\n         */ removeFiles,\n        /**\n         * Starts preparing output of all files\n         */ prepareFiles,\n        /**\n         * Sort list of files\n         */ sort: (compare)=>store.dispatch(\"SORT\", {\n                compare\n            }),\n        /**\n         * Browse the file system for a file\n         */ browse: ()=>{\n            // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n            var input = view.element.querySelector(\"input[type=file]\");\n            if (input) {\n                input.click();\n            }\n        },\n        /**\n         * Destroys the app\n         */ destroy: ()=>{\n            // request destruction\n            exports.fire(\"destroy\", view.element);\n            // stop active processes (file uploads, fetches, stuff like that)\n            // loop over items and depending on states call abort for ongoing processes\n            store.dispatch(\"ABORT_ALL\");\n            // destroy view\n            view._destroy();\n            // stop listening to resize\n            window.removeEventListener(\"resize\", resizeHandler);\n            // stop listening to the visiblitychange event\n            document.removeEventListener(\"visibilitychange\", visibilityHandler);\n            // dispatch destroy\n            store.dispatch(\"DID_DESTROY\");\n        },\n        /**\n         * Inserts the plugin before the target element\n         */ insertBefore: (element)=>insertBefore(view.element, element),\n        /**\n         * Inserts the plugin after the target element\n         */ insertAfter: (element)=>insertAfter(view.element, element),\n        /**\n         * Appends the plugin to the target element\n         */ appendTo: (element)=>element.appendChild(view.element),\n        /**\n         * Replaces an element with the app\n         */ replaceElement: (element)=>{\n            // insert the app before the element\n            insertBefore(view.element, element);\n            // remove the original element\n            element.parentNode.removeChild(element);\n            // remember original element\n            originalElement = element;\n        },\n        /**\n         * Restores the original element\n         */ restoreElement: ()=>{\n            if (!originalElement) {\n                return; // no element to restore\n            }\n            // restore original element\n            insertAfter(originalElement, view.element);\n            // remove our element\n            view.element.parentNode.removeChild(view.element);\n            // remove reference\n            originalElement = null;\n        },\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */ isAttachedTo: (element)=>view.element === element || originalElement === element,\n        /**\n         * Returns the root element\n         */ element: {\n            get: ()=>view.element\n        },\n        /**\n         * Returns the current pond status\n         */ status: {\n            get: ()=>store.query(\"GET_STATUS\")\n        }\n    };\n    // Done!\n    store.dispatch(\"DID_INIT\");\n    // create actual api object\n    return createObject(exports);\n};\nconst createAppObject = (customOptions = {})=>{\n    // default options\n    const defaultOptions = {};\n    forin(getOptions(), (key, value)=>{\n        defaultOptions[key] = value[0];\n    });\n    // set app options\n    const app = createApp({\n        // default options\n        ...defaultOptions,\n        // custom options\n        ...customOptions\n    });\n    // return the plugin instance\n    return app;\n};\nconst lowerCaseFirstLetter = (string)=>string.charAt(0).toLowerCase() + string.slice(1);\nconst attributeNameToPropertyName = (attributeName)=>toCamels(attributeName.replace(/^data-/, \"\"));\nconst mapObject = (object, propertyMap)=>{\n    // remove unwanted\n    forin(propertyMap, (selector, mapping)=>{\n        forin(object, (property, value)=>{\n            // create regexp shortcut\n            const selectorRegExp = new RegExp(selector);\n            // tests if\n            const matches = selectorRegExp.test(property);\n            // no match, skip\n            if (!matches) {\n                return;\n            }\n            // if there's a mapping, the original property is always removed\n            delete object[property];\n            // should only remove, we done!\n            if (mapping === false) {\n                return;\n            }\n            // move value to new property\n            if (isString(mapping)) {\n                object[mapping] = value;\n                return;\n            }\n            // move to group\n            const group = mapping.group;\n            if (isObject(mapping) && !object[group]) {\n                object[group] = {};\n            }\n            object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, \"\"))] = value;\n        });\n        // do submapping\n        if (mapping.mapping) {\n            mapObject(object[mapping.group], mapping.mapping);\n        }\n    });\n};\nconst getAttributesAsObject = (node, attributeMapping = {})=>{\n    // turn attributes into object\n    const attributes = [];\n    forin(node.attributes, (index)=>{\n        attributes.push(node.attributes[index]);\n    });\n    const output = attributes.filter((attribute)=>attribute.name).reduce((obj, attribute)=>{\n        const value = attr(node, attribute.name);\n        obj[attributeNameToPropertyName(attribute.name)] = value === attribute.name ? true : value;\n        return obj;\n    }, {});\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n    return output;\n};\nconst createAppAtElement = (element, options = {})=>{\n    // how attributes of the input element are mapped to the options for the plugin\n    const attributeMapping = {\n        // translate to other name\n        \"^class$\": \"className\",\n        \"^multiple$\": \"allowMultiple\",\n        \"^capture$\": \"captureMethod\",\n        \"^webkitdirectory$\": \"allowDirectoriesOnly\",\n        // group under single property\n        \"^server\": {\n            group: \"server\",\n            mapping: {\n                \"^process\": {\n                    group: \"process\"\n                },\n                \"^revert\": {\n                    group: \"revert\"\n                },\n                \"^fetch\": {\n                    group: \"fetch\"\n                },\n                \"^restore\": {\n                    group: \"restore\"\n                },\n                \"^load\": {\n                    group: \"load\"\n                }\n            }\n        },\n        // don't include in object\n        \"^type$\": false,\n        \"^files$\": false\n    };\n    // add additional option translators\n    applyFilters(\"SET_ATTRIBUTE_TO_OPTION_MAP\", attributeMapping);\n    // create final options object by setting options object and then overriding options supplied on element\n    const mergedOptions = {\n        ...options\n    };\n    const attributeOptions = getAttributesAsObject(element.nodeName === \"FIELDSET\" ? element.querySelector(\"input[type=file]\") : element, attributeMapping);\n    // merge with options object\n    Object.keys(attributeOptions).forEach((key)=>{\n        if (isObject(attributeOptions[key])) {\n            if (!isObject(mergedOptions[key])) {\n                mergedOptions[key] = {};\n            }\n            Object.assign(mergedOptions[key], attributeOptions[key]);\n        } else {\n            mergedOptions[key] = attributeOptions[key];\n        }\n    });\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(Array.from(element.querySelectorAll(\"input:not([type=file])\")).map((input)=>({\n            source: input.value,\n            options: {\n                type: input.dataset.type\n            }\n        })));\n    // build plugin\n    const app = createAppObject(mergedOptions);\n    // add already selected files\n    if (element.files) {\n        Array.from(element.files).forEach((file)=>{\n            app.addFile(file);\n        });\n    }\n    // replace the target element\n    app.replaceElement(element);\n    // expose\n    return app;\n};\n// if an element is passed, we create the instance at that element, if not, we just create an up object\nconst createApp$1 = (...args)=>isNode(args[0]) ? createAppAtElement(...args) : createAppObject(...args);\nconst PRIVATE_METHODS = [\n    \"fire\",\n    \"_read\",\n    \"_write\"\n];\nconst createAppAPI = (app)=>{\n    const api = {};\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n    return api;\n};\n/**\n * Replaces placeholders in given string with replacements\n * @param string - \"Foo {bar}\"\"\n * @param replacements - { \"bar\": 10 }\n */ const replaceInString = (string, replacements)=>string.replace(/(?:{([a-zA-Z]+)})/g, (match, group)=>replacements[group]);\nconst createWorker = (fn)=>{\n    const workerBlob = new Blob([\n        \"(\",\n        fn.toString(),\n        \")()\"\n    ], {\n        type: \"application/javascript\"\n    });\n    const workerURL = URL.createObjectURL(workerBlob);\n    const worker = new Worker(workerURL);\n    return {\n        transfer: (message, cb)=>{},\n        post: (message, cb, transferList)=>{\n            const id = getUniqueId();\n            worker.onmessage = (e)=>{\n                if (e.data.id === id) {\n                    cb(e.data.message);\n                }\n            };\n            worker.postMessage({\n                id,\n                message\n            }, transferList);\n        },\n        terminate: ()=>{\n            worker.terminate();\n            URL.revokeObjectURL(workerURL);\n        }\n    };\n};\nconst loadImage = (url)=>new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve(img);\n        };\n        img.onerror = (e)=>{\n            reject(e);\n        };\n        img.src = url;\n    });\nconst renameFile = (file, name)=>{\n    const renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n};\nconst copyFile = (file)=>renameFile(file, file.name);\n// already registered plugins (can't register twice)\nconst registeredPlugins = [];\n// pass utils to plugin\nconst createAppPlugin = (plugin)=>{\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n        return;\n    }\n    // remember this plugin\n    registeredPlugins.push(plugin);\n    // setup!\n    const pluginOutline = plugin({\n        addFilter,\n        utils: {\n            Type,\n            forin,\n            isString,\n            isFile,\n            toNaturalFileSize,\n            replaceInString,\n            getExtensionFromFilename,\n            getFilenameWithoutExtension,\n            guesstimateMimeType,\n            getFileFromBlob,\n            getFilenameFromURL,\n            createRoute,\n            createWorker,\n            createView,\n            createItemAPI,\n            loadImage,\n            copyFile,\n            renameFile,\n            createBlob,\n            applyFilterChain,\n            text,\n            getNumericAspectRatioFromString\n        },\n        views: {\n            fileActionButton\n        }\n    });\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n};\n// feature detection used by supported() method\nconst isOperaMini = ()=>Object.prototype.toString.call(window.operamini) === \"[object OperaMini]\";\nconst hasPromises = ()=>\"Promise\" in window;\nconst hasBlobSlice = ()=>\"slice\" in Blob.prototype;\nconst hasCreateObjectURL = ()=>\"URL\" in window && \"createObjectURL\" in window.URL;\nconst hasVisibility = ()=>\"visibilityState\" in document;\nconst hasTiming = ()=>\"performance\" in window; // iOS 8.x\nconst hasCSSSupports = ()=>\"supports\" in (window.CSS || {}); // use to detect Safari 9+\nconst isIE11 = ()=>/MSIE|Trident/.test(window.navigator.userAgent);\nconst supported = (()=>{\n    // Runs immediately and then remembers result for subsequent calls\n    const isSupported = // Has to be a browser\n    isBrowser() && // Can't run on Opera Mini due to lack of everything\n    !isOperaMini() && // Require these APIs to feature detect a modern browser\n    hasVisibility() && hasPromises() && hasBlobSlice() && hasCreateObjectURL() && hasTiming() && // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n    (hasCSSSupports() || isIE11());\n    return ()=>isSupported;\n})();\n/**\n * Plugin internal state (over all instances)\n */ const state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: []\n};\n// plugin name\nconst name = \"filepond\";\n/**\n * Public Plugin methods\n */ const fn = ()=>{};\nlet Status$1 = {};\nlet FileStatus = {};\nlet FileOrigin$1 = {};\nlet OptionTypes = {};\nlet create$f = fn;\nlet destroy = fn;\nlet parse = fn;\nlet find = fn;\nlet registerPlugin = fn;\nlet getOptions$1 = fn;\nlet setOptions$1 = fn;\n// if not supported, no API\nif (supported()) {\n    // start painter and fire load event\n    createPainter(()=>{\n        state.apps.forEach((app)=>app._read());\n    }, (ts)=>{\n        state.apps.forEach((app)=>app._write(ts));\n    });\n    // fire loaded event so we know when FilePond is available\n    const dispatch = ()=>{\n        // let others know we have area ready\n        document.dispatchEvent(new CustomEvent(\"FilePond:loaded\", {\n            detail: {\n                supported,\n                create: create$f,\n                destroy,\n                parse,\n                find,\n                registerPlugin,\n                setOptions: setOptions$1\n            }\n        }));\n        // clean up event\n        document.removeEventListener(\"DOMContentLoaded\", dispatch);\n    };\n    if (document.readyState !== \"loading\") {\n        // move to back of execution queue, FilePond should have been exported by then\n        setTimeout(()=>dispatch(), 0);\n    } else {\n        document.addEventListener(\"DOMContentLoaded\", dispatch);\n    }\n    // updates the OptionTypes object based on the current options\n    const updateOptionTypes = ()=>forin(getOptions(), (key, value)=>{\n            OptionTypes[key] = value[1];\n        });\n    Status$1 = {\n        ...Status\n    };\n    FileOrigin$1 = {\n        ...FileOrigin\n    };\n    FileStatus = {\n        ...ItemStatus\n    };\n    OptionTypes = {};\n    updateOptionTypes();\n    // create method, creates apps and adds them to the app array\n    create$f = (...args)=>{\n        const app = createApp$1(...args);\n        app.on(\"destroy\", destroy);\n        state.apps.push(app);\n        return createAppAPI(app);\n    };\n    // destroys apps and removes them from the app array\n    destroy = (hook)=>{\n        // returns true if the app was destroyed successfully\n        const indexToRemove = state.apps.findIndex((app)=>app.isAttachedTo(hook));\n        if (indexToRemove >= 0) {\n            // remove from apps\n            const app = state.apps.splice(indexToRemove, 1)[0];\n            // restore original dom element\n            app.restoreElement();\n            return true;\n        }\n        return false;\n    };\n    // parses the given context for plugins (does not include the context element itself)\n    parse = (context)=>{\n        // get all possible hooks\n        const matchedHooks = Array.from(context.querySelectorAll(`.${name}`));\n        // filter out already active hooks\n        const newHooks = matchedHooks.filter((newHook)=>!state.apps.find((app)=>app.isAttachedTo(newHook)));\n        // create new instance for each hook\n        return newHooks.map((hook)=>create$f(hook));\n    };\n    // returns an app based on the given element hook\n    find = (hook)=>{\n        const app = state.apps.find((app)=>app.isAttachedTo(hook));\n        if (!app) {\n            return null;\n        }\n        return createAppAPI(app);\n    };\n    // adds a plugin extension\n    registerPlugin = (...plugins)=>{\n        // register plugins\n        plugins.forEach(createAppPlugin);\n        // update OptionTypes, each plugin might have extended the default options\n        updateOptionTypes();\n    };\n    getOptions$1 = ()=>{\n        const opts = {};\n        forin(getOptions(), (key, value)=>{\n            opts[key] = value[0];\n        });\n        return opts;\n    };\n    setOptions$1 = (opts)=>{\n        if (isObject(opts)) {\n            // update existing plugins\n            state.apps.forEach((app)=>{\n                app.setOptions(opts);\n            });\n            // override defaults\n            setOptions(opts);\n        }\n        // return new options\n        return getOptions$1();\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUVELGtCQUFrQixHQUVsQixNQUFNQSxTQUFTQyxDQUFBQSxRQUFTQSxpQkFBaUJDO0FBRXpDLE1BQU1DLGNBQWMsQ0FBQ0MsY0FBY0MsVUFBVSxFQUFFLEVBQUVDLFVBQVUsRUFBRTtJQUN6RCxpQkFBaUI7SUFDakIsTUFBTUMsUUFBUTtRQUNWLEdBQUdILFlBQVk7SUFDbkI7SUFFQSwyRUFBMkU7SUFDM0UsTUFBTUksY0FBYyxFQUFFO0lBQ3RCLE1BQU1DLGdCQUFnQixFQUFFO0lBRXhCLDJDQUEyQztJQUMzQyxNQUFNQyxXQUFXLElBQU87WUFBRSxHQUFHSCxLQUFLO1FBQUM7SUFFbkMsd0VBQXdFO0lBQ3hFLE1BQU1JLHFCQUFxQjtRQUN2QiwrQkFBK0I7UUFDL0IsTUFBTUMsUUFBUTtlQUFJSjtTQUFZO1FBRTlCLHdEQUF3RDtRQUN4REEsWUFBWUssTUFBTSxHQUFHO1FBRXJCLE9BQU9EO0lBQ1g7SUFFQSx3REFBd0Q7SUFDeEQsTUFBTUUsdUJBQXVCO1FBQ3pCLCtCQUErQjtRQUMvQixNQUFNRixRQUFRO2VBQUlIO1NBQWM7UUFFaEMsd0RBQXdEO1FBQ3hEQSxjQUFjSSxNQUFNLEdBQUc7UUFFdkIsNkJBQTZCO1FBQzdCRCxNQUFNRyxPQUFPLENBQUMsQ0FBQyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtZQUN6QkMsU0FBU0YsTUFBTUM7UUFDbkI7SUFDSjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNQyxXQUFXLENBQUNGLE1BQU1DLE1BQU1FO1FBQzFCLGdFQUFnRTtRQUNoRSxJQUFJQSxjQUFjLENBQUNDLFNBQVNDLE1BQU0sRUFBRTtZQUNoQ1osY0FBY2EsSUFBSSxDQUFDO2dCQUFFTjtnQkFBTUM7WUFBSztZQUNoQztRQUNKO1FBRUEsa0RBQWtEO1FBQ2xELElBQUlNLGNBQWMsQ0FB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QkFBb0I7WUFDcEJELFdBQVdDO1FBQ2Y7UUFFQSxxQkFBcUI7UUFDckIsT0FBT3NsQztJQUNYO0FBQ0o7QUFlRSIsInNvdXJjZXMiOlsid2VicGFjazovL3Zpbi1leHRyYWN0b3IvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5lc20uanM/MTdmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEZpbGVQb25kIDQuMzIuN1xuICogTGljZW5zZWQgdW5kZXIgTUlULCBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC9cbiAqIFBsZWFzZSB2aXNpdCBodHRwczovL3BxaW5hLm5sL2ZpbGVwb25kLyBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG5jb25zdCBpc05vZGUgPSB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuXG5jb25zdCBjcmVhdGVTdG9yZSA9IChpbml0aWFsU3RhdGUsIHF1ZXJpZXMgPSBbXSwgYWN0aW9ucyA9IFtdKSA9PiB7XG4gICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgLi4uaW5pdGlhbFN0YXRlLFxuICAgIH07XG5cbiAgICAvLyBjb250YWlucyBhbGwgYWN0aW9ucyBmb3IgbmV4dCBmcmFtZSwgaXMgY2xlYXIgd2hlbiBhY3Rpb25zIGFyZSByZXF1ZXN0ZWRcbiAgICBjb25zdCBhY3Rpb25RdWV1ZSA9IFtdO1xuICAgIGNvbnN0IGRpc3BhdGNoUXVldWUgPSBbXTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+ICh7IC4uLnN0YXRlIH0pO1xuXG4gICAgLy8gcmV0dXJucyBhIGR1cGxpY2F0ZSBvZiB0aGUgYWN0aW9ucyBhcnJheSBhbmQgY2xlYXJzIHRoZSBhY3Rpb25zIGFycmF5XG4gICAgY29uc3QgcHJvY2Vzc0FjdGlvblF1ZXVlID0gKCkgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgY29weSBvZiBhY3Rpb25zIHF1ZXVlXG4gICAgICAgIGNvbnN0IHF1ZXVlID0gWy4uLmFjdGlvblF1ZXVlXTtcblxuICAgICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgICBhY3Rpb25RdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9O1xuXG4gICAgLy8gcHJvY2Vzc2VzIGFjdGlvbnMgdGhhdCBtaWdodCBibG9jayB0aGUgbWFpbiBVSSB0aHJlYWRcbiAgICBjb25zdCBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSA9ICgpID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgICBjb25zdCBxdWV1ZSA9IFsuLi5kaXNwYXRjaFF1ZXVlXTtcblxuICAgICAgICAvLyBjbGVhciBhY3Rpb25zIHF1ZXVlICh3ZSBkb24ndCB3YW50IG5vIGRvdWJsZSBhY3Rpb25zKVxuICAgICAgICBkaXNwYXRjaFF1ZXVlLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgLy8gbm93IGRpc3BhdGNoIHRoZXNlIGFjdGlvbnNcbiAgICAgICAgcXVldWUuZm9yRWFjaCgoeyB0eXBlLCBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHR5cGUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gYWRkcyBhIG5ldyBhY3Rpb24sIGNhbGxzIGl0cyBoYW5kbGVyIGFuZFxuICAgIGNvbnN0IGRpc3BhdGNoID0gKHR5cGUsIGRhdGEsIGlzQmxvY2tpbmcpID0+IHtcbiAgICAgICAgLy8gaXMgYmxvY2tpbmcgYWN0aW9uIChzaG91bGQgbmV2ZXIgYmxvY2sgaWYgZG9jdW1lbnQgaXMgaGlkZGVuKVxuICAgICAgICBpZiAoaXNCbG9ja2luZyAmJiAhZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyB0eXBlLCBkYXRhIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBhY3Rpb24gaGFzIGEgaGFuZGxlciwgaGFuZGxlIHRoZSBhY3Rpb25cbiAgICAgICAgaWYgKGFjdGlvbkhhbmRsZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICBhY3Rpb25IYW5kbGVyc1t0eXBlXShkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBhZGQgYWN0aW9uXG4gICAgICAgIGFjdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBxdWVyeSA9IChzdHIsIC4uLmFyZ3MpID0+IChxdWVyeUhhbmRsZXNbc3RyXSA/IHF1ZXJ5SGFuZGxlc1tzdHJdKC4uLmFyZ3MpIDogbnVsbCk7XG5cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIGdldFN0YXRlLFxuICAgICAgICBwcm9jZXNzQWN0aW9uUXVldWUsXG4gICAgICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgcXVlcnksXG4gICAgfTtcblxuICAgIGxldCBxdWVyeUhhbmRsZXMgPSB7fTtcbiAgICBxdWVyaWVzLmZvckVhY2gocXVlcnkgPT4ge1xuICAgICAgICBxdWVyeUhhbmRsZXMgPSB7XG4gICAgICAgICAgICAuLi5xdWVyeShzdGF0ZSksXG4gICAgICAgICAgICAuLi5xdWVyeUhhbmRsZXMsXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBsZXQgYWN0aW9uSGFuZGxlcnMgPSB7fTtcbiAgICBhY3Rpb25zLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgYWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgICAgICAgICAuLi5hY3Rpb24oZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSksXG4gICAgICAgICAgICAuLi5hY3Rpb25IYW5kbGVycyxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBkZWZpbmVQcm9wZXJ0eSA9IChvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ialtwcm9wZXJ0eV0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7IC4uLmRlZmluaXRpb24gfSk7XG59O1xuXG5jb25zdCBmb3JpbiA9IChvYmosIGNiKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2Ioa2V5LCBvYmpba2V5XSk7XG4gICAgfVxufTtcblxuY29uc3QgY3JlYXRlT2JqZWN0ID0gZGVmaW5pdGlvbiA9PiB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yaW4oZGVmaW5pdGlvbiwgcHJvcGVydHkgPT4ge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCBkZWZpbml0aW9uW3Byb3BlcnR5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IGF0dHIgPSAobm9kZSwgbmFtZSwgdmFsdWUgPSBudWxsKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCBub2RlLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufTtcblxuY29uc3QgbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuY29uc3Qgc3ZnRWxlbWVudHMgPSBbJ3N2ZycsICdwYXRoJ107IC8vIG9ubHkgc3ZnIGVsZW1lbnRzIHVzZWRcblxuY29uc3QgaXNTVkdFbGVtZW50ID0gdGFnID0+IHN2Z0VsZW1lbnRzLmluY2x1ZGVzKHRhZyk7XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnQgPSAodGFnLCBjbGFzc05hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhdHRyaWJ1dGVzID0gY2xhc3NOYW1lO1xuICAgICAgICBjbGFzc05hbWUgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gaXNTVkdFbGVtZW50KHRhZylcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZylcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBpZiAoaXNTVkdFbGVtZW50KHRhZykpIHtcbiAgICAgICAgICAgIGF0dHIoZWxlbWVudCwgJ2NsYXNzJywgY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmluKGF0dHJpYnV0ZXMsIChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmNvbnN0IGFwcGVuZENoaWxkID0gcGFyZW50ID0+IChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5jaGlsZHJlbltpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxufTtcblxuY29uc3QgYXBwZW5kQ2hpbGRWaWV3ID0gKHBhcmVudCwgY2hpbGRWaWV3cykgPT4gKHZpZXcsIGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoaW5kZXgsIDAsIHZpZXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkVmlld3MucHVzaCh2aWV3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlldztcbn07XG5cbmNvbnN0IHJlbW92ZUNoaWxkVmlldyA9IChwYXJlbnQsIGNoaWxkVmlld3MpID0+IHZpZXcgPT4ge1xuICAgIC8vIHJlbW92ZSBmcm9tIGNoaWxkIHZpZXdzXG4gICAgY2hpbGRWaWV3cy5zcGxpY2UoY2hpbGRWaWV3cy5pbmRleE9mKHZpZXcpLCAxKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudFxuICAgIGlmICh2aWV3LmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodmlldy5lbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlldztcbn07XG5cbmNvbnN0IElTX0JST1dTRVIgPSAoKCkgPT5cbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykoKTtcbmNvbnN0IGlzQnJvd3NlciA9ICgpID0+IElTX0JST1dTRVI7XG5cbmNvbnN0IHRlc3RFbGVtZW50ID0gaXNCcm93c2VyKCkgPyBjcmVhdGVFbGVtZW50KCdzdmcnKSA6IHt9O1xuY29uc3QgZ2V0Q2hpbGRDb3VudCA9XG4gICAgJ2NoaWxkcmVuJyBpbiB0ZXN0RWxlbWVudCA/IGVsID0+IGVsLmNoaWxkcmVuLmxlbmd0aCA6IGVsID0+IGVsLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG5jb25zdCBnZXRWaWV3UmVjdCA9IChlbGVtZW50UmVjdCwgY2hpbGRWaWV3cywgb2Zmc2V0LCBzY2FsZSkgPT4ge1xuICAgIGNvbnN0IGxlZnQgPSBvZmZzZXRbMF0gfHwgZWxlbWVudFJlY3QubGVmdDtcbiAgICBjb25zdCB0b3AgPSBvZmZzZXRbMV0gfHwgZWxlbWVudFJlY3QudG9wO1xuICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIGVsZW1lbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodCAqIChzY2FsZVsxXSB8fCAxKTtcblxuICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgaXRzZWxmXG4gICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgIC4uLmVsZW1lbnRSZWN0LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4sIGRvZXMgbm90IGluY2x1ZGUgYW55IG1hcmdpbnNcbiAgICAgICAgaW5uZXI6IHtcbiAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICB0b3A6IGVsZW1lbnRSZWN0LnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiBlbGVtZW50UmVjdC5yaWdodCxcbiAgICAgICAgICAgIGJvdHRvbTogZWxlbWVudFJlY3QuYm90dG9tLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRoZSByZWN0YW5nbGUgb2YgdGhlIGVsZW1lbnQgZXhwYW5kZWQgdG8gY29udGFpbiBpdHMgY2hpbGRyZW4gaW5jbHVkaW5nIG93biBtYXJnaW4gYW5kIGNoaWxkIG1hcmdpbnNcbiAgICAgICAgLy8gbWFyZ2lucyB3aWxsIGJlIGFkZGVkIGFmdGVyIHdlJ3ZlIHJlY2FsY3VsYXRlZCB0aGUgc2l6ZVxuICAgICAgICBvdXRlcjoge1xuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBleHBhbmQgcmVjdCB0byBmaXQgYWxsIGNoaWxkIHJlY3RhbmdsZXNcbiAgICBjaGlsZFZpZXdzXG4gICAgICAgIC5maWx0ZXIoY2hpbGRWaWV3ID0+ICFjaGlsZFZpZXcuaXNSZWN0SWdub3JlZCgpKVxuICAgICAgICAubWFwKGNoaWxkVmlldyA9PiBjaGlsZFZpZXcucmVjdClcbiAgICAgICAgLmZvckVhY2goY2hpbGRWaWV3UmVjdCA9PiB7XG4gICAgICAgICAgICBleHBhbmRSZWN0KHJlY3QuaW5uZXIsIHsgLi4uY2hpbGRWaWV3UmVjdC5pbm5lciB9KTtcbiAgICAgICAgICAgIGV4cGFuZFJlY3QocmVjdC5vdXRlciwgeyAuLi5jaGlsZFZpZXdSZWN0Lm91dGVyIH0pO1xuICAgICAgICB9KTtcblxuICAgIC8vIGNhbGN1bGF0ZSBpbm5lciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5pbm5lcik7XG5cbiAgICAvLyBhcHBlbmQgYWRkaXRpb25hbCBtYXJnaW4gKHRvcCBhbmQgbGVmdCBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpbiB0b3AgYW5kIGxlZnQgYXV0b21hdGljYWxseSlcbiAgICByZWN0Lm91dGVyLmJvdHRvbSArPSByZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuICAgIHJlY3Qub3V0ZXIucmlnaHQgKz0gcmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0O1xuXG4gICAgLy8gY2FsY3VsYXRlIG91dGVyIHdpZHRoIGFuZCBoZWlnaHRcbiAgICBjYWxjdWxhdGVSZWN0U2l6ZShyZWN0Lm91dGVyKTtcblxuICAgIHJldHVybiByZWN0O1xufTtcblxuY29uc3QgZXhwYW5kUmVjdCA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgLy8gYWRqdXN0IGZvciBwYXJlbnQgb2Zmc2V0XG4gICAgY2hpbGQudG9wICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQucmlnaHQgKz0gcGFyZW50LmxlZnQ7XG4gICAgY2hpbGQuYm90dG9tICs9IHBhcmVudC50b3A7XG4gICAgY2hpbGQubGVmdCArPSBwYXJlbnQubGVmdDtcblxuICAgIGlmIChjaGlsZC5ib3R0b20gPiBwYXJlbnQuYm90dG9tKSB7XG4gICAgICAgIHBhcmVudC5ib3R0b20gPSBjaGlsZC5ib3R0b207XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLnJpZ2h0ID4gcGFyZW50LnJpZ2h0KSB7XG4gICAgICAgIHBhcmVudC5yaWdodCA9IGNoaWxkLnJpZ2h0O1xuICAgIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVJlY3RTaXplID0gcmVjdCA9PiB7XG4gICAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgcmVjdC5oZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xufTtcblxuY29uc3QgaXNOdW1iZXIgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgcG9zaXRpb24gaXMgYXQgZGVzdGluYXRpb25cbiAqIEBwYXJhbSBwb3NpdGlvblxuICogQHBhcmFtIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gdmVsb2NpdHlcbiAqIEBwYXJhbSBlcnJvck1hcmdpblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IHRoZXJlWWV0ID0gKHBvc2l0aW9uLCBkZXN0aW5hdGlvbiwgdmVsb2NpdHksIGVycm9yTWFyZ2luID0gMC4wMDEpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMocG9zaXRpb24gLSBkZXN0aW5hdGlvbikgPCBlcnJvck1hcmdpbiAmJiBNYXRoLmFicyh2ZWxvY2l0eSkgPCBlcnJvck1hcmdpbjtcbn07XG5cbi8qKlxuICogU3ByaW5nIGFuaW1hdGlvblxuICovXG5jb25zdCBzcHJpbmcgPVxuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICh7IHN0aWZmbmVzcyA9IDAuNSwgZGFtcGluZyA9IDAuNzUsIG1hc3MgPSAxMCB9ID0ge30pID0+XG4gICAgICAgIC8vIG1ldGhvZCBkZWZpbml0aW9uXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICBsZXQgcmVzdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGVzIHNwcmluZyBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGUgPSAodHMsIHNraXBUb0VuZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaW4gcmVzdCwgZG9uJ3QgYW5pbWF0ZVxuICAgICAgICAgICAgICAgIGlmIChyZXN0aW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIGF0IGxlYXN0IGEgdGFyZ2V0IG9yIHBvc2l0aW9uIHRvIGRvIHNwcmluZ3kgdGhpbmdzXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNOdW1iZXIodGFyZ2V0KSAmJiBpc051bWJlcihwb3NpdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgc3ByaW5nIGZvcmNlXG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IC0ocG9zaXRpb24gLSB0YXJnZXQpICogc3RpZmZuZXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHZlbG9jaXR5IGJ5IGFkZGluZyBmb3JjZSBiYXNlZCBvbiBtYXNzXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKz0gZiAvIG1hc3M7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gYnkgYWRkaW5nIHZlbG9jaXR5XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gdmVsb2NpdHk7XG5cbiAgICAgICAgICAgICAgICAvLyBzbG93IGRvd24gYmFzZWQgb24gYW1vdW50IG9mIGRhbXBpbmdcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSAqPSBkYW1waW5nO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UndmUgYXJyaXZlZCBpZiB3ZSdyZSBuZWFyIHRhcmdldCBhbmQgb3VyIHZlbG9jaXR5IGlzIG5lYXIgemVyb1xuICAgICAgICAgICAgICAgIGlmICh0aGVyZVlldChwb3NpdGlvbiwgdGFyZ2V0LCB2ZWxvY2l0eSkgfHwgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uZVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvZ3Jlc3MgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbmV3IHRhcmdldCB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHNldFRhcmdldCA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50bHkgaGFzIG5vIHBvc2l0aW9uLCBzZXQgdGFyZ2V0IGFuZCBwb3NpdGlvbiB0byB0aGlzIHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSAmJiAhaXNOdW1iZXIocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbmV4dCB0YXJnZXQgdmFsdWUgd2lsbCBub3QgYmUgYW5pbWF0ZWQgdG9cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGxldCBzdGFydCBtb3ZpbmcgdG8gdGFyZ2V0XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGF0IHRhcmdldFxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdGFyZ2V0IHx8IHR5cGVvZiB0YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdyByZXN0aW5nIGFzIHRhcmdldCBpcyBjdXJyZW50IHBvc2l0aW9uLCBzdG9wIG1vdmluZ1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gbmVlZCAnYXBpJyB0byBjYWxsIG9udXBkYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCBhcGkgPSBjcmVhdGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlLFxuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICBzZXQ6IHNldFRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcmVzdGluZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9udXBkYXRlOiB2YWx1ZSA9PiB7fSxcbiAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiB2YWx1ZSA9PiB7fSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG5jb25zdCBlYXNlTGluZWFyID0gdCA9PiB0O1xuY29uc3QgZWFzZUluT3V0UXVhZCA9IHQgPT4gKHQgPCAwLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdCk7XG5cbmNvbnN0IHR3ZWVuID1cbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgICh7IGR1cmF0aW9uID0gNTAwLCBlYXNpbmcgPSBlYXNlSW5PdXRRdWFkLCBkZWxheSA9IDAgfSA9IHt9KSA9PlxuICAgICAgICAvLyBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHQ7XG4gICAgICAgICAgICBsZXQgcDtcbiAgICAgICAgICAgIGxldCByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCByZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGUgPSAodHMsIHNraXBUb0VuZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RpbmcgfHwgdGFyZ2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHMgLSBzdGFydCA8IGRlbGF5KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB0ID0gdHMgLSBzdGFydCAtIGRlbGF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gZHVyYXRpb24gfHwgc2tpcFRvRW5kU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHAgPSByZXZlcnNlID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZShwICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSB0IC8gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbnVwZGF0ZSgodCA+PSAwID8gZWFzaW5nKHJldmVyc2UgPyAxIC0gcCA6IHApIDogMCkgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG5lZWQgJ2FwaScgdG8gY2FsbCBvbnVwZGF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgY29uc3QgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiAocmV2ZXJzZSA/IDAgOiB0YXJnZXQpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8gdHdlZW4gdG8gYSBzbWFsbGVyIHZhbHVlIGFuZCBoYXZlIGEgY3VycmVudCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIDwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IHR3ZWVuaW5nIHRvIGEgc21hbGxlciB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0J3MgZ28hXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcmVzdGluZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9udXBkYXRlOiB2YWx1ZSA9PiB7fSxcbiAgICAgICAgICAgICAgICBvbmNvbXBsZXRlOiB2YWx1ZSA9PiB7fSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgICB9O1xuXG5jb25zdCBhbmltYXRvciA9IHtcbiAgICBzcHJpbmcsXG4gICAgdHdlZW4sXG59O1xuXG4vKlxuIHsgdHlwZTogJ3NwcmluZycsIHN0aWZmbmVzczogLjUsIGRhbXBpbmc6IC43NSwgbWFzczogMTAgfTtcbiB7IHRyYW5zbGF0aW9uOiB7IHR5cGU6ICdzcHJpbmcnLCAuLi4gfSwgLi4uIH1cbiB7IHRyYW5zbGF0aW9uOiB7IHg6IHsgdHlwZTogJ3NwcmluZycsIC4uLiB9IH0gfVxuKi9cbmNvbnN0IGNyZWF0ZUFuaW1hdG9yID0gKGRlZmluaXRpb24sIGNhdGVnb3J5LCBwcm9wZXJ0eSkgPT4ge1xuICAgIC8vIGRlZmF1bHQgaXMgc2luZ2xlIGRlZmluaXRpb25cbiAgICAvLyB3ZSBjaGVjayBpZiB0cmFuc2Zvcm0gaXMgc2V0LCBpZiBzbywgd2UgY2hlY2sgaWYgcHJvcGVydHkgaXMgc2V0XG4gICAgY29uc3QgZGVmID1cbiAgICAgICAgZGVmaW5pdGlvbltjYXRlZ29yeV0gJiYgdHlwZW9mIGRlZmluaXRpb25bY2F0ZWdvcnldW3Byb3BlcnR5XSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gZGVmaW5pdGlvbltjYXRlZ29yeV1bcHJvcGVydHldXG4gICAgICAgICAgICA6IGRlZmluaXRpb25bY2F0ZWdvcnldIHx8IGRlZmluaXRpb247XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGRlZiA9PT0gJ3N0cmluZycgPyBkZWYgOiBkZWYudHlwZTtcbiAgICBjb25zdCBwcm9wcyA9IHR5cGVvZiBkZWYgPT09ICdvYmplY3QnID8geyAuLi5kZWYgfSA6IHt9O1xuXG4gICAgcmV0dXJuIGFuaW1hdG9yW3R5cGVdID8gYW5pbWF0b3JbdHlwZV0ocHJvcHMpIDogbnVsbDtcbn07XG5cbmNvbnN0IGFkZEdldFNldCA9IChrZXlzLCBvYmosIHByb3BzLCBvdmVyd3JpdGUgPSBmYWxzZSkgPT4ge1xuICAgIG9iaiA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iaiA6IFtvYmpdO1xuICAgIG9iai5mb3JFYWNoKG8gPT4ge1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCBuYW1lID0ga2V5O1xuICAgICAgICAgICAgbGV0IGdldHRlciA9ICgpID0+IHByb3BzW2tleV07XG4gICAgICAgICAgICBsZXQgc2V0dGVyID0gdmFsdWUgPT4gKHByb3BzW2tleV0gPSB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBrZXkua2V5O1xuICAgICAgICAgICAgICAgIGdldHRlciA9IGtleS5nZXR0ZXIgfHwgZ2V0dGVyO1xuICAgICAgICAgICAgICAgIHNldHRlciA9IGtleS5zZXR0ZXIgfHwgc2V0dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob1tuYW1lXSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgICAgICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vLyBhZGQgdG8gc3RhdGUsXG4vLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVycyB0byBpbnRlcm5hbCBhbmQgZXh0ZXJuYWwgYXBpIChpZiBub3Qgc2V0KVxuLy8gc2V0dXAgYW5pbWF0b3JzXG5cbmNvbnN0IGFuaW1hdGlvbnMgPSAoeyBtaXhpbkNvbmZpZywgdmlld1Byb3BzLCB2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSSB9KSA9PiB7XG4gICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgaW5pdGlhbFByb3BzID0geyAuLi52aWV3UHJvcHMgfTtcblxuICAgIC8vIGxpc3Qgb2YgYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgLy8gc2V0dXAgYW5pbWF0b3JzXG4gICAgZm9yaW4obWl4aW5Db25maWcsIChwcm9wZXJ0eSwgYW5pbWF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gY3JlYXRlQW5pbWF0b3IoYW5pbWF0aW9uKTtcbiAgICAgICAgaWYgKCFhbmltYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgYW5pbWF0b3IgdXBkYXRlcywgdXBkYXRlIHRoZSB2aWV3IHN0YXRlIHZhbHVlXG4gICAgICAgIGFuaW1hdG9yLm9udXBkYXRlID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgdmlld1Byb3BzW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNldCBhbmltYXRvciB0YXJnZXRcbiAgICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gaW5pdGlhbFByb3BzW3Byb3BlcnR5XTtcblxuICAgICAgICAvLyB3aGVuIHZhbHVlIGlzIHNldCwgc2V0IHRoZSBhbmltYXRvciB0YXJnZXQgdmFsdWVcbiAgICAgICAgY29uc3QgcHJvcCA9IHtcbiAgICAgICAgICAgIGtleTogcHJvcGVydHksXG4gICAgICAgICAgICBzZXR0ZXI6IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGF0IHRhcmdldCwgd2UgZG9uZSFcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3IudGFyZ2V0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYW5pbWF0b3IudGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0dGVyOiAoKSA9PiB2aWV3UHJvcHNbcHJvcGVydHldLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIGFkZEdldFNldChbcHJvcF0sIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0IGZvciBlYXN5IHVwZGF0aW5nIGZyb20gdGhlIF93cml0ZSBtZXRob2RcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdG9yKTtcbiAgICB9KTtcblxuICAgIC8vIGV4cG9zZSBpbnRlcm5hbCB3cml0ZSBhcGlcbiAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogdHMgPT4ge1xuICAgICAgICAgICAgbGV0IHNraXBUb0VuZFN0YXRlID0gZG9jdW1lbnQuaGlkZGVuO1xuICAgICAgICAgICAgbGV0IHJlc3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5mb3JFYWNoKGFuaW1hdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbmltYXRpb24ucmVzdGluZykgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5pbnRlcnBvbGF0ZSh0cywgc2tpcFRvRW5kU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge30sXG4gICAgfTtcbn07XG5cbmNvbnN0IGFkZEV2ZW50ID0gZWxlbWVudCA9PiAodHlwZSwgZm4pID0+IHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xufTtcblxuY29uc3QgcmVtb3ZlRXZlbnQgPSBlbGVtZW50ID0+ICh0eXBlLCBmbikgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbik7XG59O1xuXG4vLyBtaXhpblxuY29uc3QgbGlzdGVuZXJzID0gKHtcbiAgICBtaXhpbkNvbmZpZyxcbiAgICB2aWV3UHJvcHMsXG4gICAgdmlld0ludGVybmFsQVBJLFxuICAgIHZpZXdFeHRlcm5hbEFQSSxcbiAgICB2aWV3U3RhdGUsXG4gICAgdmlldyxcbn0pID0+IHtcbiAgICBjb25zdCBldmVudHMgPSBbXTtcblxuICAgIGNvbnN0IGFkZCA9IGFkZEV2ZW50KHZpZXcuZWxlbWVudCk7XG4gICAgY29uc3QgcmVtb3ZlID0gcmVtb3ZlRXZlbnQodmlldy5lbGVtZW50KTtcblxuICAgIHZpZXdFeHRlcm5hbEFQSS5vbiA9ICh0eXBlLCBmbikgPT4ge1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZm4sXG4gICAgICAgIH0pO1xuICAgICAgICBhZGQodHlwZSwgZm4pO1xuICAgIH07XG5cbiAgICB2aWV3RXh0ZXJuYWxBUEkub2ZmID0gKHR5cGUsIGZuKSA9PiB7XG4gICAgICAgIGV2ZW50cy5zcGxpY2UoZXZlbnRzLmZpbmRJbmRleChldmVudCA9PiBldmVudC50eXBlID09PSB0eXBlICYmIGV2ZW50LmZuID09PSBmbiksIDEpO1xuICAgICAgICByZW1vdmUodHlwZSwgZm4pO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gbm90IGJ1c3lcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKGV2ZW50LnR5cGUsIGV2ZW50LmZuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG4vLyBhZGQgdG8gZXh0ZXJuYWwgYXBpIGFuZCBsaW5rIHRvIHByb3BzXG5cbmNvbnN0IGFwaXMgPSAoeyBtaXhpbkNvbmZpZywgdmlld1Byb3BzLCB2aWV3RXh0ZXJuYWxBUEkgfSkgPT4ge1xuICAgIGFkZEdldFNldChtaXhpbkNvbmZpZywgdmlld0V4dGVybmFsQVBJLCB2aWV3UHJvcHMpO1xufTtcblxuY29uc3QgaXNEZWZpbmVkID0gdmFsdWUgPT4gdmFsdWUgIT0gbnVsbDtcblxuLy8gYWRkIHRvIHN0YXRlLFxuLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnMgdG8gaW50ZXJuYWwgYW5kIGV4dGVybmFsIGFwaSAoaWYgbm90IHNldClcbi8vIHNldCBpbml0aWFsIHN0YXRlIGJhc2VkIG9uIHByb3BzIGluIHZpZXdQcm9wc1xuLy8gYXBwbHkgYXMgdHJhbnNmb3JtcyBlYWNoIGZyYW1lXG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgc2NhbGVYOiAxLFxuICAgIHNjYWxlWTogMSxcbiAgICB0cmFuc2xhdGVYOiAwLFxuICAgIHRyYW5zbGF0ZVk6IDAsXG4gICAgcm90YXRlWDogMCxcbiAgICByb3RhdGVZOiAwLFxuICAgIHJvdGF0ZVo6IDAsXG4gICAgb3JpZ2luWDogMCxcbiAgICBvcmlnaW5ZOiAwLFxufTtcblxuY29uc3Qgc3R5bGVzID0gKHsgbWl4aW5Db25maWcsIHZpZXdQcm9wcywgdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEksIHZpZXcgfSkgPT4ge1xuICAgIC8vIGluaXRpYWwgcHJvcHNcbiAgICBjb25zdCBpbml0aWFsUHJvcHMgPSB7IC4uLnZpZXdQcm9wcyB9O1xuXG4gICAgLy8gY3VycmVudCBwcm9wc1xuICAgIGNvbnN0IGN1cnJlbnRQcm9wcyA9IHt9O1xuXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhvc2UgcHJvcGVydGllcyB0byB0aGUgZXh0ZXJuYWwgQVBJIGFuZCBsaW5rIHRoZW0gdG8gdGhlIHZpZXdTdGF0ZVxuICAgIGFkZEdldFNldChtaXhpbkNvbmZpZywgW3ZpZXdJbnRlcm5hbEFQSSwgdmlld0V4dGVybmFsQVBJXSwgdmlld1Byb3BzKTtcblxuICAgIC8vIG92ZXJyaWRlIHJlY3Qgb24gaW50ZXJuYWwgYW5kIGV4dGVybmFsIHJlY3QgZ2V0dGVyIHNvIGl0IHRha2VzIGluIGFjY291bnQgdHJhbnNmb3Jtc1xuICAgIGNvbnN0IGdldE9mZnNldCA9ICgpID0+IFt2aWV3UHJvcHNbJ3RyYW5zbGF0ZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3RyYW5zbGF0ZVknXSB8fCAwXTtcbiAgICBjb25zdCBnZXRTY2FsZSA9ICgpID0+IFt2aWV3UHJvcHNbJ3NjYWxlWCddIHx8IDAsIHZpZXdQcm9wc1snc2NhbGVZJ10gfHwgMF07XG4gICAgY29uc3QgZ2V0UmVjdCA9ICgpID0+XG4gICAgICAgIHZpZXcucmVjdCA/IGdldFZpZXdSZWN0KHZpZXcucmVjdCwgdmlldy5jaGlsZFZpZXdzLCBnZXRPZmZzZXQoKSwgZ2V0U2NhbGUoKSkgOiBudWxsO1xuICAgIHZpZXdJbnRlcm5hbEFQSS5yZWN0ID0geyBnZXQ6IGdldFJlY3QgfTtcbiAgICB2aWV3RXh0ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG5cbiAgICAvLyBhcHBseSB2aWV3IHByb3BzXG4gICAgbWl4aW5Db25maWcuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB2aWV3UHJvcHNba2V5XSA9XG4gICAgICAgICAgICB0eXBlb2YgaW5pdGlhbFByb3BzW2tleV0gPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHNba2V5XSA6IGluaXRpYWxQcm9wc1trZXldO1xuICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlIGFwaVxuICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBzZWUgaWYgcHJvcHMgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAoIXByb3BzSGF2ZUNoYW5nZWQoY3VycmVudFByb3BzLCB2aWV3UHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlcyBlbGVtZW50IHRvIGNvcnJlY3QgcG9zaXRpb24gb24gc2NyZWVuXG4gICAgICAgICAgICBhcHBseVN0eWxlcyh2aWV3LmVsZW1lbnQsIHZpZXdQcm9wcyk7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIG5ldyB0cmFuc2Zvcm1zXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cnJlbnRQcm9wcywgeyAuLi52aWV3UHJvcHMgfSk7XG5cbiAgICAgICAgICAgIC8vIG5vIGxvbmdlciBidXN5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge30sXG4gICAgfTtcbn07XG5cbmNvbnN0IHByb3BzSGF2ZUNoYW5nZWQgPSAoY3VycmVudFByb3BzLCBuZXdQcm9wcykgPT4ge1xuICAgIC8vIGRpZmZlcmVudCBhbW91bnQgb2Yga2V5c1xuICAgIGlmIChPYmplY3Qua2V5cyhjdXJyZW50UHJvcHMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMobmV3UHJvcHMpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBsZXRzIGFuYWx5emUgdGhlIGluZGl2aWR1YWwgcHJvcHNcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKG5ld1Byb3BzW3Byb3BdICE9PSBjdXJyZW50UHJvcHNbcHJvcF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgYXBwbHlTdHlsZXMgPSAoXG4gICAgZWxlbWVudCxcbiAgICB7XG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgICB0cmFuc2xhdGVYLFxuICAgICAgICB0cmFuc2xhdGVZLFxuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWSxcbiAgICAgICAgcm90YXRlWCxcbiAgICAgICAgcm90YXRlWSxcbiAgICAgICAgcm90YXRlWixcbiAgICAgICAgb3JpZ2luWCxcbiAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICB9XG4pID0+IHtcbiAgICBsZXQgdHJhbnNmb3JtcyA9ICcnO1xuICAgIGxldCBzdHlsZXMgPSAnJztcblxuICAgIC8vIGhhbmRsZSB0cmFuc2Zvcm0gb3JpZ2luXG4gICAgaWYgKGlzRGVmaW5lZChvcmlnaW5YKSB8fCBpc0RlZmluZWQob3JpZ2luWSkpIHtcbiAgICAgICAgc3R5bGVzICs9IGB0cmFuc2Zvcm0tb3JpZ2luOiAke29yaWdpblggfHwgMH1weCAke29yaWdpblkgfHwgMH1weDtgO1xuICAgIH1cblxuICAgIC8vIHRyYW5zZm9ybSBvcmRlciBpcyByZWxldmFudFxuICAgIC8vIDAuIHBlcnNwZWN0aXZlXG4gICAgaWYgKGlzRGVmaW5lZChwZXJzcGVjdGl2ZSkpIHtcbiAgICAgICAgdHJhbnNmb3JtcyArPSBgcGVyc3BlY3RpdmUoJHtwZXJzcGVjdGl2ZX1weCkgYDtcbiAgICB9XG5cbiAgICAvLyAxLiB0cmFuc2xhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHRyYW5zbGF0ZVgpIHx8IGlzRGVmaW5lZCh0cmFuc2xhdGVZKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGB0cmFuc2xhdGUzZCgke3RyYW5zbGF0ZVggfHwgMH1weCwgJHt0cmFuc2xhdGVZIHx8IDB9cHgsIDApIGA7XG4gICAgfVxuXG4gICAgLy8gMi4gc2NhbGVcbiAgICBpZiAoaXNEZWZpbmVkKHNjYWxlWCkgfHwgaXNEZWZpbmVkKHNjYWxlWSkpIHtcbiAgICAgICAgdHJhbnNmb3JtcyArPSBgc2NhbGUzZCgke2lzRGVmaW5lZChzY2FsZVgpID8gc2NhbGVYIDogMX0sICR7XG4gICAgICAgICAgICBpc0RlZmluZWQoc2NhbGVZKSA/IHNjYWxlWSA6IDFcbiAgICAgICAgfSwgMSkgYDtcbiAgICB9XG5cbiAgICAvLyAzLiByb3RhdGVcbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVopKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHJvdGF0ZVooJHtyb3RhdGVafXJhZCkgYDtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVgpKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHJvdGF0ZVgoJHtyb3RhdGVYfXJhZCkgYDtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWZpbmVkKHJvdGF0ZVkpKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHJvdGF0ZVkoJHtyb3RhdGVZfXJhZCkgYDtcbiAgICB9XG5cbiAgICAvLyBhZGQgdHJhbnNmb3Jtc1xuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgICBzdHlsZXMgKz0gYHRyYW5zZm9ybToke3RyYW5zZm9ybXN9O2A7XG4gICAgfVxuXG4gICAgLy8gYWRkIG9wYWNpdHlcbiAgICBpZiAoaXNEZWZpbmVkKG9wYWNpdHkpKSB7XG4gICAgICAgIHN0eWxlcyArPSBgb3BhY2l0eToke29wYWNpdHl9O2A7XG5cbiAgICAgICAgLy8gaWYgd2UgcmVhY2ggemVybywgd2UgbWFrZSB0aGUgZWxlbWVudCBpbmFjY2Vzc2libGVcbiAgICAgICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBgdmlzaWJpbGl0eTpoaWRkZW47YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIGJlbG93IDEwMCUgb3BhY2l0eSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgY2xpY2tlZFxuICAgICAgICBpZiAob3BhY2l0eSA8IDEpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBgcG9pbnRlci1ldmVudHM6bm9uZTtgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIGhlaWdodFxuICAgIGlmIChpc0RlZmluZWQoaGVpZ2h0KSkge1xuICAgICAgICBzdHlsZXMgKz0gYGhlaWdodDoke2hlaWdodH1weDtgO1xuICAgIH1cblxuICAgIC8vIGFkZCB3aWR0aFxuICAgIGlmIChpc0RlZmluZWQod2lkdGgpKSB7XG4gICAgICAgIHN0eWxlcyArPSBgd2lkdGg6JHt3aWR0aH1weDtgO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHN0eWxlc1xuICAgIGNvbnN0IGVsZW1lbnRDdXJyZW50U3R5bGUgPSBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgfHwgJyc7XG5cbiAgICAvLyBpZiBuZXcgc3R5bGVzIGRvZXMgbm90IG1hdGNoIGN1cnJlbnQgc3R5bGVzLCBsZXRzIHVwZGF0ZSFcbiAgICBpZiAoc3R5bGVzLmxlbmd0aCAhPT0gZWxlbWVudEN1cnJlbnRTdHlsZS5sZW5ndGggfHwgc3R5bGVzICE9PSBlbGVtZW50Q3VycmVudFN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHN0eWxlcztcbiAgICAgICAgLy8gc3RvcmUgY3VycmVudCBzdHlsZXMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSB0byBuZXcgc3R5bGVzIGxhdGVyIG9uXG4gICAgICAgIC8vIF9ub3RfIGdldHRpbmcgdGhlIHN0eWxlIHZhbHVlIGlzIGZhc3RlclxuICAgICAgICBlbGVtZW50LmVsZW1lbnRDdXJyZW50U3R5bGUgPSBzdHlsZXM7XG4gICAgfVxufTtcblxuY29uc3QgTWl4aW5zID0ge1xuICAgIHN0eWxlcyxcbiAgICBsaXN0ZW5lcnMsXG4gICAgYW5pbWF0aW9ucyxcbiAgICBhcGlzLFxufTtcblxuY29uc3QgdXBkYXRlUmVjdCA9IChyZWN0ID0ge30sIGVsZW1lbnQgPSB7fSwgc3R5bGUgPSB7fSkgPT4ge1xuICAgIGlmICghZWxlbWVudC5sYXlvdXRDYWxjdWxhdGVkKSB7XG4gICAgICAgIHJlY3QucGFkZGluZ1RvcCA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xuICAgICAgICByZWN0Lm1hcmdpblRvcCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpblRvcCwgMTApIHx8IDA7XG4gICAgICAgIHJlY3QubWFyZ2luUmlnaHQgPSBwYXJzZUludChzdHlsZS5tYXJnaW5SaWdodCwgMTApIHx8IDA7XG4gICAgICAgIHJlY3QubWFyZ2luQm90dG9tID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luQm90dG9tLCAxMCkgfHwgMDtcbiAgICAgICAgcmVjdC5tYXJnaW5MZWZ0ID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luTGVmdCwgMTApIHx8IDA7XG4gICAgICAgIGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmVjdC5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgcmVjdC50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCB8fCAwO1xuICAgIHJlY3Qud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwO1xuXG4gICAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGg7XG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0O1xuXG4gICAgcmVjdC5zY3JvbGxUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcblxuICAgIHJlY3QuaGlkZGVuID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbmNvbnN0IGNyZWF0ZVZpZXcgPVxuICAgIC8vIGRlZmF1bHQgdmlldyBkZWZpbml0aW9uXG4gICAgKHtcbiAgICAgICAgLy8gZWxlbWVudCBkZWZpbml0aW9uXG4gICAgICAgIHRhZyA9ICdkaXYnLFxuICAgICAgICBuYW1lID0gbnVsbCxcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9LFxuXG4gICAgICAgIC8vIHZpZXcgaW50ZXJhY3Rpb25cbiAgICAgICAgcmVhZCA9ICgpID0+IHt9LFxuICAgICAgICB3cml0ZSA9ICgpID0+IHt9LFxuICAgICAgICBjcmVhdGUgPSAoKSA9PiB7fSxcbiAgICAgICAgZGVzdHJveSA9ICgpID0+IHt9LFxuXG4gICAgICAgIC8vIGhvb2tzXG4gICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkID0gKGNoaWxkLCBhY3Rpb25zKSA9PiBhY3Rpb25zLFxuICAgICAgICBkaWRDcmVhdGVWaWV3ID0gKCkgPT4ge30sXG4gICAgICAgIGRpZFdyaXRlVmlldyA9ICgpID0+IHt9LFxuXG4gICAgICAgIC8vIHJlY3QgcmVsYXRlZFxuICAgICAgICBpZ25vcmVSZWN0ID0gZmFsc2UsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGUgPSBmYWxzZSxcblxuICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgbWl4aW5zID0gW10sXG4gICAgfSA9IHt9KSA9PiAoXG4gICAgICAgIC8vIGVhY2ggdmlldyByZXF1aXJlcyByZWZlcmVuY2UgdG8gc3RvcmVcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIC8vIHNwZWNpZmljIHByb3BlcnRpZXMgZm9yIHRoaXMgdmlld1xuICAgICAgICBwcm9wcyA9IHt9XG4gICAgKSA9PiB7XG4gICAgICAgIC8vIHJvb3QgZWxlbWVudCBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodGFnLCBgZmlsZXBvbmQtLSR7bmFtZX1gLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICAvLyBzdHlsZSByZWZlcmVuY2Ugc2hvdWxkIGFsc28gbm90IGJlIGNoYW5nZWRcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuICAgICAgICAvLyBlbGVtZW50IHJlY3RhbmdsZVxuICAgICAgICBjb25zdCByZWN0ID0gdXBkYXRlUmVjdCgpO1xuICAgICAgICBsZXQgZnJhbWVSZWN0ID0gbnVsbDtcblxuICAgICAgICAvLyByZXN0IHN0YXRlXG4gICAgICAgIGxldCBpc1Jlc3RpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBwcmV0dHkgc2VsZiBleHBsYW5hdG9yeVxuICAgICAgICBjb25zdCBjaGlsZFZpZXdzID0gW107XG5cbiAgICAgICAgLy8gbG9hZGVkIG1peGluc1xuICAgICAgICBjb25zdCBhY3RpdmVNaXhpbnMgPSBbXTtcblxuICAgICAgICAvLyByZWZlcmVuY2VzIHRvIGNyZWF0ZWQgY2hpbGRyZW5cbiAgICAgICAgY29uc3QgcmVmID0ge307XG5cbiAgICAgICAgLy8gc3RhdGUgdXNlZCBmb3IgZWFjaCBpbnN0YW5jZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHt9O1xuXG4gICAgICAgIC8vIGxpc3Qgb2Ygd3JpdGVycyB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGlzIHZpZXdcbiAgICAgICAgY29uc3Qgd3JpdGVycyA9IFtcbiAgICAgICAgICAgIHdyaXRlLCAvLyBkZWZhdWx0IHdyaXRlclxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHJlYWRlcnMgPSBbXG4gICAgICAgICAgICByZWFkLCAvLyBkZWZhdWx0IHJlYWRlclxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGRlc3Ryb3llcnMgPSBbXG4gICAgICAgICAgICBkZXN0cm95LCAvLyBkZWZhdWx0IGRlc3Ryb3lcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBjb3JlIHZpZXcgbWV0aG9kc1xuICAgICAgICBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcbiAgICAgICAgY29uc3QgZ2V0Q2hpbGRWaWV3cyA9ICgpID0+IGNoaWxkVmlld3MuY29uY2F0KCk7XG4gICAgICAgIGNvbnN0IGdldFJlZmVyZW5jZSA9ICgpID0+IHJlZjtcbiAgICAgICAgY29uc3QgY3JlYXRlQ2hpbGRWaWV3ID0gc3RvcmUgPT4gKHZpZXcsIHByb3BzKSA9PiB2aWV3KHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIGNvbnN0IGdldFJlY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJhbWVSZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lUmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYW1lUmVjdCA9IGdldFZpZXdSZWN0KHJlY3QsIGNoaWxkVmlld3MsIFswLCAwXSwgWzEsIDFdKTtcbiAgICAgICAgICAgIHJldHVybiBmcmFtZVJlY3Q7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFN0eWxlID0gKCkgPT4gc3R5bGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWQgZGF0YSBmcm9tIERPTVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgX3JlYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBmcmFtZVJlY3QgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyByZWFkIGNoaWxkIHZpZXdzXG4gICAgICAgICAgICBjaGlsZFZpZXdzLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuX3JlYWQoKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZSA9ICEoaWdub3JlUmVjdFVwZGF0ZSAmJiByZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVSZWN0KHJlY3QsIGVsZW1lbnQsIHN0eWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVhZGVyc1xuICAgICAgICAgICAgY29uc3QgYXBpID0geyByb290OiBpbnRlcm5hbEFQSSwgcHJvcHMsIHJlY3QgfTtcbiAgICAgICAgICAgIHJlYWRlcnMuZm9yRWFjaChyZWFkZXIgPT4gcmVhZGVyKGFwaSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZSBkYXRhIHRvIERPTVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgX3dyaXRlID0gKHRzLCBmcmFtZUFjdGlvbnMsIHNob3VsZE9wdGltaXplKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBubyBhY3Rpb25zLCB3ZSBhc3N1bWUgdGhhdCB0aGUgdmlldyBpcyByZXN0aW5nXG4gICAgICAgICAgICBsZXQgcmVzdGluZyA9IGZyYW1lQWN0aW9ucy5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgICAgIC8vIHdyaXRlcnNcbiAgICAgICAgICAgIHdyaXRlcnMuZm9yRWFjaCh3cml0ZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlclJlc3RpbmcgPSB3cml0ZXIoe1xuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IGZyYW1lQWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlclJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcnVuIG1peGluc1xuICAgICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2gobWl4aW4gPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbWl4aW5zIGlzIHN0aWxsIGJ1c3kgYWZ0ZXIgd3JpdGUgb3BlcmF0aW9uLCB3ZSBhcmUgbm90IHJlc3RpbmdcbiAgICAgICAgICAgICAgICBjb25zdCBtaXhpblJlc3RpbmcgPSBtaXhpbi53cml0ZSh0cyk7XG4gICAgICAgICAgICAgICAgaWYgKG1peGluUmVzdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGVzIGNoaWxkIHZpZXdzIHRoYXQgYXJlIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGUgRE9NXG4gICAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjaGlsZCA9PiAhIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGEgY2hpbGQgdmlldyBpcyBub3QgcmVzdGluZywgd2UgYXJlIG5vdCByZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUmVzdGluZyA9IGNoaWxkLl93cml0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQoY2hpbGQsIGZyYW1lQWN0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRPcHRpbWl6ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkUmVzdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCBuZXcgZWxlbWVudHMgdG8gRE9NIGFuZCB1cGRhdGUgdGhvc2VcbiAgICAgICAgICAgIGNoaWxkVmlld3NcbiAgICAgICAgICAgICAgICAvLy5maWx0ZXIoY2hpbGQgPT4gIWNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIHRvIERPTVxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCByZWFkIChuZWVkIHRvIGtub3cgdGhlIHNpemUgb2YgdGhlc2UgZWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLl9yZWFkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtY2FsbCB3cml0ZVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5fd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGFkZGVkIHNvbXRoaW5nIHRvIHRoZSBkb20sIG5vIHJlc3RcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgcmVzdGluZyBzdGF0ZVxuICAgICAgICAgICAgaXNSZXN0aW5nID0gcmVzdGluZztcblxuICAgICAgICAgICAgZGlkV3JpdGVWaWV3KHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBmcmFtZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0cyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBsZXQgcGFyZW50IGtub3cgaWYgd2UgYXJlIHJlc3RpbmdcbiAgICAgICAgICAgIHJldHVybiByZXN0aW5nO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IF9kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlTWl4aW5zLmZvckVhY2gobWl4aW4gPT4gbWl4aW4uZGVzdHJveSgpKTtcbiAgICAgICAgICAgIGRlc3Ryb3llcnMuZm9yRWFjaChkZXN0cm95ZXIgPT4ge1xuICAgICAgICAgICAgICAgIGRlc3Ryb3llcih7IHJvb3Q6IGludGVybmFsQVBJLCBwcm9wcyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLl9kZXN0cm95KCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNoYXJlZEFQSVxuICAgICAgICBjb25zdCBzaGFyZWRBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0U3R5bGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRWaWV3czoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0Q2hpbGRWaWV3cyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHJpdmF0ZSBBUEkgZGVmaW5pdGlvblxuICAgICAgICBjb25zdCBpbnRlcm5hbEFQSURlZmluaXRpb24gPSB7XG4gICAgICAgICAgICAuLi5zaGFyZWRBUElEZWZpbml0aW9uLFxuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0UmVjdCxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGFjY2VzcyB0byBjdXN0b20gY2hpbGRyZW4gcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBnZXRSZWZlcmVuY2UsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBkb20gbW9kaWZpZXJzXG4gICAgICAgICAgICBpczogbmVlZGxlID0+IG5hbWUgPT09IG5lZWRsZSxcbiAgICAgICAgICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZChlbGVtZW50KSxcbiAgICAgICAgICAgIGNyZWF0ZUNoaWxkVmlldzogY3JlYXRlQ2hpbGRWaWV3KHN0b3JlKSxcbiAgICAgICAgICAgIGxpbmtWaWV3OiB2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5saW5rVmlldzogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5zcGxpY2UoY2hpbGRWaWV3cy5pbmRleE9mKHZpZXcpLCAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBlbmRDaGlsZFZpZXc6IGFwcGVuZENoaWxkVmlldyhlbGVtZW50LCBjaGlsZFZpZXdzKSxcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkVmlldzogcmVtb3ZlQ2hpbGRWaWV3KGVsZW1lbnQsIGNoaWxkVmlld3MpLFxuICAgICAgICAgICAgcmVnaXN0ZXJXcml0ZXI6IHdyaXRlciA9PiB3cml0ZXJzLnB1c2god3JpdGVyKSxcbiAgICAgICAgICAgIHJlZ2lzdGVyUmVhZGVyOiByZWFkZXIgPT4gcmVhZGVycy5wdXNoKHJlYWRlciksXG4gICAgICAgICAgICByZWdpc3RlckRlc3Ryb3llcjogZGVzdHJveWVyID0+IGRlc3Ryb3llcnMucHVzaChkZXN0cm95ZXIpLFxuICAgICAgICAgICAgaW52YWxpZGF0ZUxheW91dDogKCkgPT4gKGVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCA9IGZhbHNlKSxcblxuICAgICAgICAgICAgLy8gYWNjZXNzIHRvIGRhdGEgc3RvcmVcbiAgICAgICAgICAgIGRpc3BhdGNoOiBzdG9yZS5kaXNwYXRjaCxcbiAgICAgICAgICAgIHF1ZXJ5OiBzdG9yZS5xdWVyeSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwdWJsaWMgdmlldyBBUEkgbWV0aG9kc1xuICAgICAgICBjb25zdCBleHRlcm5hbEFQSURlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBnZXRFbGVtZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkVmlld3M6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldENoaWxkVmlld3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0UmVjdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN0aW5nOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpc1Jlc3RpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNSZWN0SWdub3JlZDogKCkgPT4gaWdub3JlUmVjdCxcbiAgICAgICAgICAgIF9yZWFkLFxuICAgICAgICAgICAgX3dyaXRlLFxuICAgICAgICAgICAgX2Rlc3Ryb3ksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWl4aW4gQVBJIG1ldGhvZHNcbiAgICAgICAgY29uc3QgbWl4aW5BUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uc2hhcmVkQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHJlY3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBtaXhpbiBmdW5jdGlvbmFsaXR5XG4gICAgICAgIE9iamVjdC5rZXlzKG1peGlucylcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBzdHlsZXMgdG8gdGhlIGJhY2sgb2YgdGhlIG1peGluIGxpc3QgKHNvIGFkanVzdG1lbnRzIG9mIG90aGVyIG1peGlucyBhcmUgYXBwbGllZCB0byB0aGUgcHJvcHMgY29ycmVjdGx5KVxuICAgICAgICAgICAgICAgIGlmIChhID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIgPT09ICdzdHlsZXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXhpbkFQSSA9IE1peGluc1trZXldKHtcbiAgICAgICAgICAgICAgICAgICAgbWl4aW5Db25maWc6IG1peGluc1trZXldLFxuICAgICAgICAgICAgICAgICAgICB2aWV3UHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgICAgICAgICB2aWV3U3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB2aWV3SW50ZXJuYWxBUEk6IGludGVybmFsQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdmlld0V4dGVybmFsQVBJOiBleHRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNyZWF0ZU9iamVjdChtaXhpbkFQSURlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1peGluQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU1peGlucy5wdXNoKG1peGluQVBJKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgcHJpdmF0ZSBhcGlcbiAgICAgICAgY29uc3QgaW50ZXJuYWxBUEkgPSBjcmVhdGVPYmplY3QoaW50ZXJuYWxBUElEZWZpbml0aW9uKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIHZpZXdcbiAgICAgICAgY3JlYXRlKHtcbiAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFwcGVuZCBjcmVhdGVkIGNoaWxkIHZpZXdzIHRvIHJvb3Qgbm9kZVxuICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gZ2V0Q2hpbGRDb3VudChlbGVtZW50KTsgLy8gbmVlZCB0byBrbm93IHRoZSBjdXJyZW50IGNoaWxkIGNvdW50IHNvIGFwcGVuZGluZyBoYXBwZW5zIGluIGNvcnJlY3Qgb3JkZXJcbiAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGludGVybmFsQVBJLmFwcGVuZENoaWxkKGNoaWxkLmVsZW1lbnQsIGNoaWxkQ291bnQgKyBpbmRleCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNhbGwgZGlkIGNyZWF0ZVxuICAgICAgICBkaWRDcmVhdGVWaWV3KGludGVybmFsQVBJKTtcblxuICAgICAgICAvLyBleHBvc2UgcHVibGljIGFwaVxuICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0KGV4dGVybmFsQVBJRGVmaW5pdGlvbik7XG4gICAgfTtcblxuY29uc3QgY3JlYXRlUGFpbnRlciA9IChyZWFkLCB3cml0ZSwgZnBzID0gNjApID0+IHtcbiAgICBjb25zdCBuYW1lID0gJ19fZnJhbWVQYWludGVyJztcblxuICAgIC8vIHNldCBnbG9iYWwgcGFpbnRlclxuICAgIGlmICh3aW5kb3dbbmFtZV0pIHtcbiAgICAgICAgd2luZG93W25hbWVdLnJlYWRlcnMucHVzaChyZWFkKTtcbiAgICAgICAgd2luZG93W25hbWVdLndyaXRlcnMucHVzaCh3cml0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aW5kb3dbbmFtZV0gPSB7XG4gICAgICAgIHJlYWRlcnM6IFtyZWFkXSxcbiAgICAgICAgd3JpdGVyczogW3dyaXRlXSxcbiAgICB9O1xuXG4gICAgY29uc3QgcGFpbnRlciA9IHdpbmRvd1tuYW1lXTtcblxuICAgIGNvbnN0IGludGVydmFsID0gMTAwMCAvIGZwcztcbiAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgbGV0IGlkID0gbnVsbDtcbiAgICBsZXQgcmVxdWVzdFRpY2sgPSBudWxsO1xuICAgIGxldCBjYW5jZWxUaWNrID0gbnVsbDtcblxuICAgIGNvbnN0IHNldFRpbWVyVHlwZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSAoKSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKSwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgY2FuY2VsVGljayA9ICgpID0+IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSAoKSA9PiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICAgICAgICAgICAgY2FuY2VsVGljayA9ICgpID0+IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbFRpY2spIGNhbmNlbFRpY2soKTtcbiAgICAgICAgc2V0VGltZXJUeXBlKCk7XG4gICAgICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdGljayA9IHRzID0+IHtcbiAgICAgICAgLy8gcXVldWUgbmV4dCB0aWNrXG4gICAgICAgIGlkID0gcmVxdWVzdFRpY2sodGljayk7XG5cbiAgICAgICAgLy8gbGltaXQgZnBzXG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IHRzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVsdGEgPSB0cyAtIGxhc3Q7XG5cbiAgICAgICAgaWYgKGRlbHRhIDw9IGludGVydmFsKSB7XG4gICAgICAgICAgICAvLyBza2lwIGZyYW1lXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGlnbiBuZXh0IGZyYW1lXG4gICAgICAgIGxhc3QgPSB0cyAtIChkZWx0YSAlIGludGVydmFsKTtcblxuICAgICAgICAvLyB1cGRhdGUgdmlld1xuICAgICAgICBwYWludGVyLnJlYWRlcnMuZm9yRWFjaChyZWFkID0+IHJlYWQoKSk7XG4gICAgICAgIHBhaW50ZXIud3JpdGVycy5mb3JFYWNoKHdyaXRlID0+IHdyaXRlKHRzKSk7XG4gICAgfTtcblxuICAgIHNldFRpbWVyVHlwZSgpO1xuICAgIHRpY2socGVyZm9ybWFuY2Uubm93KCkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF1c2U6ICgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbFRpY2soaWQpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCBjcmVhdGVSb3V0ZSA9IChyb3V0ZXMsIGZuKSA9PiAoeyByb290LCBwcm9wcywgYWN0aW9ucyA9IFtdLCB0aW1lc3RhbXAsIHNob3VsZE9wdGltaXplIH0pID0+IHtcbiAgICBhY3Rpb25zXG4gICAgICAgIC5maWx0ZXIoYWN0aW9uID0+IHJvdXRlc1thY3Rpb24udHlwZV0pXG4gICAgICAgIC5mb3JFYWNoKGFjdGlvbiA9PlxuICAgICAgICAgICAgcm91dGVzW2FjdGlvbi50eXBlXSh7IHJvb3QsIHByb3BzLCBhY3Rpb246IGFjdGlvbi5kYXRhLCB0aW1lc3RhbXAsIHNob3VsZE9wdGltaXplIH0pXG4gICAgICAgICk7XG4gICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMsIHRpbWVzdGFtcCwgc2hvdWxkT3B0aW1pemUgfSk7XG4gICAgfVxufTtcblxuY29uc3QgaW5zZXJ0QmVmb3JlID0gKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpID0+XG4gICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcblxuY29uc3QgaW5zZXJ0QWZ0ZXIgPSAobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkgPT4ge1xuICAgIHJldHVybiByZWZlcmVuY2VOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xufTtcblxuY29uc3QgaXNBcnJheSA9IHZhbHVlID0+IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG5jb25zdCBpc0VtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT0gbnVsbDtcblxuY29uc3QgdHJpbSA9IHN0ciA9PiBzdHIudHJpbSgpO1xuXG5jb25zdCB0b1N0cmluZyA9IHZhbHVlID0+ICcnICsgdmFsdWU7XG5cbmNvbnN0IHRvQXJyYXkgPSAodmFsdWUsIHNwbGl0dGVyID0gJywnKSA9PiB7XG4gICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKVxuICAgICAgICAuc3BsaXQoc3BsaXR0ZXIpXG4gICAgICAgIC5tYXAodHJpbSlcbiAgICAgICAgLmZpbHRlcihzdHIgPT4gc3RyLmxlbmd0aCk7XG59O1xuXG5jb25zdCBpc0Jvb2xlYW4gPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcblxuY29uc3QgdG9Cb29sZWFuID0gdmFsdWUgPT4gKGlzQm9vbGVhbih2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlID09PSAndHJ1ZScpO1xuXG5jb25zdCBpc1N0cmluZyA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG5cbmNvbnN0IHRvTnVtYmVyID0gdmFsdWUgPT5cbiAgICBpc051bWJlcih2YWx1ZSkgPyB2YWx1ZSA6IGlzU3RyaW5nKHZhbHVlKSA/IHRvU3RyaW5nKHZhbHVlKS5yZXBsYWNlKC9bYS16XSsvZ2ksICcnKSA6IDA7XG5cbmNvbnN0IHRvSW50ID0gdmFsdWUgPT4gcGFyc2VJbnQodG9OdW1iZXIodmFsdWUpLCAxMCk7XG5cbmNvbnN0IHRvRmxvYXQgPSB2YWx1ZSA9PiBwYXJzZUZsb2F0KHRvTnVtYmVyKHZhbHVlKSk7XG5cbmNvbnN0IGlzSW50ID0gdmFsdWUgPT4gaXNOdW1iZXIodmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG5cbmNvbnN0IHRvQnl0ZXMgPSAodmFsdWUsIGJhc2UgPSAxMDAwKSA9PiB7XG4gICAgLy8gaXMgaW4gYnl0ZXNcbiAgICBpZiAoaXNJbnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpcyBuYXR1cmFsIGZpbGUgc2l6ZVxuICAgIGxldCBuYXR1cmFsRmlsZVNpemUgPSB0b1N0cmluZyh2YWx1ZSkudHJpbSgpO1xuXG4gICAgLy8gaWYgaXMgdmFsdWUgaW4gbWVnYWJ5dGVzXG4gICAgaWYgKC9NQiQvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL01CJGkvLCAnJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gdG9JbnQobmF0dXJhbEZpbGVTaXplKSAqIGJhc2UgKiBiYXNlO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIHZhbHVlIGluIGtpbG9ieXRlc1xuICAgIGlmICgvS0IvaS50ZXN0KG5hdHVyYWxGaWxlU2l6ZSkpIHtcbiAgICAgICAgbmF0dXJhbEZpbGVTaXplID0gbmF0dXJhbEZpbGVTaXplLnJlcGxhY2UoL0tCJGkvLCAnJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gdG9JbnQobmF0dXJhbEZpbGVTaXplKSAqIGJhc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSk7XG59O1xuXG5jb25zdCBpc0Z1bmN0aW9uID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCB0b0Z1bmN0aW9uUmVmZXJlbmNlID0gc3RyaW5nID0+IHtcbiAgICBsZXQgcmVmID0gc2VsZjtcbiAgICBsZXQgbGV2ZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgbGV0IGxldmVsID0gbnVsbDtcbiAgICB3aGlsZSAoKGxldmVsID0gbGV2ZWxzLnNoaWZ0KCkpKSB7XG4gICAgICAgIHJlZiA9IHJlZltsZXZlbF07XG4gICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufTtcblxuY29uc3QgbWV0aG9kcyA9IHtcbiAgICBwcm9jZXNzOiAnUE9TVCcsXG4gICAgcGF0Y2g6ICdQQVRDSCcsXG4gICAgcmV2ZXJ0OiAnREVMRVRFJyxcbiAgICBmZXRjaDogJ0dFVCcsXG4gICAgcmVzdG9yZTogJ0dFVCcsXG4gICAgbG9hZDogJ0dFVCcsXG59O1xuXG5jb25zdCBjcmVhdGVTZXJ2ZXJBUEkgPSBvdXRsaW5lID0+IHtcbiAgICBjb25zdCBhcGkgPSB7fTtcblxuICAgIGFwaS51cmwgPSBpc1N0cmluZyhvdXRsaW5lKSA/IG91dGxpbmUgOiBvdXRsaW5lLnVybCB8fCAnJztcbiAgICBhcGkudGltZW91dCA9IG91dGxpbmUudGltZW91dCA/IHBhcnNlSW50KG91dGxpbmUudGltZW91dCwgMTApIDogMDtcbiAgICBhcGkuaGVhZGVycyA9IG91dGxpbmUuaGVhZGVycyA/IG91dGxpbmUuaGVhZGVycyA6IHt9O1xuXG4gICAgZm9yaW4obWV0aG9kcywga2V5ID0+IHtcbiAgICAgICAgYXBpW2tleV0gPSBjcmVhdGVBY3Rpb24oa2V5LCBvdXRsaW5lW2tleV0sIG1ldGhvZHNba2V5XSwgYXBpLnRpbWVvdXQsIGFwaS5oZWFkZXJzKTtcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBwcm9jZXNzIGlmIG5vIHVybCBvciBwcm9jZXNzIG9uIG91dGxpbmVcbiAgICBhcGkucHJvY2VzcyA9IG91dGxpbmUucHJvY2VzcyB8fCBpc1N0cmluZyhvdXRsaW5lKSB8fCBvdXRsaW5lLnVybCA/IGFwaS5wcm9jZXNzIDogbnVsbDtcblxuICAgIC8vIHNwZWNpYWwgdHJlYXRtZW50IGZvciByZW1vdmVcbiAgICBhcGkucmVtb3ZlID0gb3V0bGluZS5yZW1vdmUgfHwgbnVsbDtcblxuICAgIC8vIHJlbW92ZSBnZW5lcmljIGhlYWRlcnMgZnJvbSBhcGkgb2JqZWN0XG4gICAgZGVsZXRlIGFwaS5oZWFkZXJzO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbmNvbnN0IGNyZWF0ZUFjdGlvbiA9IChuYW1lLCBvdXRsaW5lLCBtZXRob2QsIHRpbWVvdXQsIGhlYWRlcnMpID0+IHtcbiAgICAvLyBpcyBleHBsaWNpdGVseSBzZXQgdG8gbnVsbCBzbyBkaXNhYmxlXG4gICAgaWYgKG91dGxpbmUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgY3VzdG9tIGZ1bmN0aW9uLCBkb25lISBEZXYgaGFuZGxlcyBldmVyeXRoaW5nLlxuICAgIGlmICh0eXBlb2Ygb3V0bGluZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gb3V0bGluZTtcbiAgICB9XG5cbiAgICAvLyBidWlsZCBhY3Rpb24gb2JqZWN0XG4gICAgY29uc3QgYWN0aW9uID0ge1xuICAgICAgICB1cmw6IG1ldGhvZCA9PT0gJ0dFVCcgfHwgbWV0aG9kID09PSAnUEFUQ0gnID8gYD8ke25hbWV9PWAgOiAnJyxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICB0aW1lb3V0LFxuICAgICAgICBvbmxvYWQ6IG51bGwsXG4gICAgICAgIG9uZGF0YTogbnVsbCxcbiAgICAgICAgb25lcnJvcjogbnVsbCxcbiAgICB9O1xuXG4gICAgLy8gaXMgYSBzaW5nbGUgdXJsXG4gICAgaWYgKGlzU3RyaW5nKG91dGxpbmUpKSB7XG4gICAgICAgIGFjdGlvbi51cmwgPSBvdXRsaW5lO1xuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZVxuICAgIE9iamVjdC5hc3NpZ24oYWN0aW9uLCBvdXRsaW5lKTtcblxuICAgIC8vIHNlZSBpZiBzaG91bGQgcmVmb3JtYXQgaGVhZGVycztcbiAgICBpZiAoaXNTdHJpbmcoYWN0aW9uLmhlYWRlcnMpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYWN0aW9uLmhlYWRlcnMuc3BsaXQoLzooLispLyk7XG4gICAgICAgIGFjdGlvbi5oZWFkZXJzID0ge1xuICAgICAgICAgICAgaGVhZGVyOiBwYXJ0c1swXSxcbiAgICAgICAgICAgIHZhbHVlOiBwYXJ0c1sxXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBpZiBpcyBib29sIHdpdGhDcmVkZW50aWFsc1xuICAgIGFjdGlvbi53aXRoQ3JlZGVudGlhbHMgPSB0b0Jvb2xlYW4oYWN0aW9uLndpdGhDcmVkZW50aWFscyk7XG5cbiAgICByZXR1cm4gYWN0aW9uO1xufTtcblxuY29uc3QgdG9TZXJ2ZXJBUEkgPSB2YWx1ZSA9PiBjcmVhdGVTZXJ2ZXJBUEkodmFsdWUpO1xuXG5jb25zdCBpc051bGwgPSB2YWx1ZSA9PiB2YWx1ZSA9PT0gbnVsbDtcblxuY29uc3QgaXNPYmplY3QgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuXG5jb25zdCBpc0FQSSA9IHZhbHVlID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgaXNTdHJpbmcodmFsdWUudXJsKSAmJlxuICAgICAgICBpc09iamVjdCh2YWx1ZS5wcm9jZXNzKSAmJlxuICAgICAgICBpc09iamVjdCh2YWx1ZS5yZXZlcnQpICYmXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlLnJlc3RvcmUpICYmXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlLmZldGNoKVxuICAgICk7XG59O1xuXG5jb25zdCBnZXRUeXBlID0gdmFsdWUgPT4ge1xuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG5cbiAgICBpZiAoaXNOdWxsKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdpbnQnO1xuICAgIH1cblxuICAgIGlmICgvXlswLTldKyA/KD86R0J8TUJ8S0IpJC9naS50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ2J5dGVzJztcbiAgICB9XG5cbiAgICBpZiAoaXNBUEkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnYXBpJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlO1xufTtcblxuY29uc3QgcmVwbGFjZVNpbmdsZVF1b3RlcyA9IHN0ciA9PlxuICAgIHN0clxuICAgICAgICAucmVwbGFjZSgve1xccyonL2csICd7XCInKVxuICAgICAgICAucmVwbGFjZSgvJ1xccyp9L2csICdcIn0nKVxuICAgICAgICAucmVwbGFjZSgvJ1xccyo6L2csICdcIjonKVxuICAgICAgICAucmVwbGFjZSgvOlxccyonL2csICc6XCInKVxuICAgICAgICAucmVwbGFjZSgvLFxccyonL2csICcsXCInKVxuICAgICAgICAucmVwbGFjZSgvJ1xccyosL2csICdcIiwnKTtcblxuY29uc3QgY29udmVyc2lvblRhYmxlID0ge1xuICAgIGFycmF5OiB0b0FycmF5LFxuICAgIGJvb2xlYW46IHRvQm9vbGVhbixcbiAgICBpbnQ6IHZhbHVlID0+IChnZXRUeXBlKHZhbHVlKSA9PT0gJ2J5dGVzJyA/IHRvQnl0ZXModmFsdWUpIDogdG9JbnQodmFsdWUpKSxcbiAgICBudW1iZXI6IHRvRmxvYXQsXG4gICAgZmxvYXQ6IHRvRmxvYXQsXG4gICAgYnl0ZXM6IHRvQnl0ZXMsXG4gICAgc3RyaW5nOiB2YWx1ZSA9PiAoaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IHRvU3RyaW5nKHZhbHVlKSksXG4gICAgZnVuY3Rpb246IHZhbHVlID0+IHRvRnVuY3Rpb25SZWZlcmVuY2UodmFsdWUpLFxuICAgIHNlcnZlcmFwaTogdG9TZXJ2ZXJBUEksXG4gICAgb2JqZWN0OiB2YWx1ZSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXBsYWNlU2luZ2xlUXVvdGVzKHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmNvbnN0IGNvbnZlcnRUbyA9ICh2YWx1ZSwgdHlwZSkgPT4gY29udmVyc2lvblRhYmxlW3R5cGVdKHZhbHVlKTtcblxuY29uc3QgZ2V0VmFsdWVCeVR5cGUgPSAobmV3VmFsdWUsIGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKSA9PiB7XG4gICAgLy8gY2FuIGFsd2F5cyBhc3NpZ24gZGVmYXVsdCB2YWx1ZVxuICAgIGlmIChuZXdWYWx1ZSA9PT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIG5ldyB2YWx1ZVxuICAgIGxldCBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKG5ld1ZhbHVlKTtcblxuICAgIC8vIGlzIHZhbGlkIHR5cGU/XG4gICAgaWYgKG5ld1ZhbHVlVHlwZSAhPT0gdmFsdWVUeXBlKSB7XG4gICAgICAgIC8vIGlzIHN0cmluZyBpbnB1dCwgbGV0J3MgYXR0ZW1wdCB0byBjb252ZXJ0XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gY29udmVydFRvKG5ld1ZhbHVlLCB2YWx1ZVR5cGUpO1xuXG4gICAgICAgIC8vIHdoYXQgaXMgdGhlIHR5cGUgbm93XG4gICAgICAgIG5ld1ZhbHVlVHlwZSA9IGdldFR5cGUoY29udmVydGVkVmFsdWUpO1xuXG4gICAgICAgIC8vIG5vIHZhbGlkIGNvbnZlcnNpb25zIGZvdW5kXG4gICAgICAgIGlmIChjb252ZXJ0ZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgYFRyeWluZyB0byBhc3NpZ24gdmFsdWUgd2l0aCBpbmNvcnJlY3QgdHlwZSB0byBcIiR7b3B0aW9ufVwiLCBhbGxvd2VkIHR5cGU6IFwiJHt2YWx1ZVR5cGV9XCJgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFzc2lnbiBuZXcgdmFsdWVcbiAgICByZXR1cm4gbmV3VmFsdWU7XG59O1xuXG5jb25zdCBjcmVhdGVPcHRpb24gPSAoZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpID0+IHtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogKCkgPT4gY3VycmVudFZhbHVlLFxuICAgICAgICBzZXQ6IG5ld1ZhbHVlID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGdldFZhbHVlQnlUeXBlKG5ld1ZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3JpbihvcHRpb25zLCBwcm9wID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uRGVmaW5pdGlvbiA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgIG9ialtwcm9wXSA9IGNyZWF0ZU9wdGlvbihvcHRpb25EZWZpbml0aW9uWzBdLCBvcHRpb25EZWZpbml0aW9uWzFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0KG9iaik7XG59O1xuXG5jb25zdCBjcmVhdGVJbml0aWFsU3RhdGUgPSBvcHRpb25zID0+ICh7XG4gICAgLy8gbW9kZWxcbiAgICBpdGVtczogW10sXG5cbiAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIGNhbGxpbmcgdXBkYXRlIGl0ZW1zXG4gICAgbGlzdFVwZGF0ZVRpbWVvdXQ6IG51bGwsXG5cbiAgICAvLyB0aW1lb3V0IHVzZWQgZm9yIHN0YWNraW5nIG1ldGFkYXRhIHVwZGF0ZXNcbiAgICBpdGVtVXBkYXRlVGltZW91dDogbnVsbCxcblxuICAgIC8vIHF1ZXVlIG9mIGl0ZW1zIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkXG4gICAgcHJvY2Vzc2luZ1F1ZXVlOiBbXSxcblxuICAgIC8vIG9wdGlvbnNcbiAgICBvcHRpb25zOiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpLFxufSk7XG5cbmNvbnN0IGZyb21DYW1lbHMgPSAoc3RyaW5nLCBzZXBhcmF0b3IgPSAnLScpID0+XG4gICAgc3RyaW5nXG4gICAgICAgIC5zcGxpdCgvKD89W0EtWl0pLylcbiAgICAgICAgLm1hcChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcblxuY29uc3QgY3JlYXRlT3B0aW9uQVBJID0gKHN0b3JlLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yaW4ob3B0aW9ucywga2V5ID0+IHtcbiAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHN0b3JlLmdldFN0YXRlKCkub3B0aW9uc1trZXldLFxuICAgICAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goYFNFVF8ke2Zyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCl9YCwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IGNyZWF0ZU9wdGlvbkFjdGlvbnMgPSBvcHRpb25zID0+IChkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSA9PiB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yaW4ob3B0aW9ucywga2V5ID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgb2JqW2BTRVRfJHtuYW1lfWBdID0gYWN0aW9uID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhdGUub3B0aW9uc1trZXldID0gYWN0aW9uLnZhbHVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vcGUsIGZhaWxlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBzdWNjZXNzZnVsbHkgc2V0IHRoZSB2YWx1ZSBvZiB0aGlzIG9wdGlvblxuICAgICAgICAgICAgZGlzcGF0Y2goYERJRF9TRVRfJHtuYW1lfWAsIHsgdmFsdWU6IHN0YXRlLm9wdGlvbnNba2V5XSB9KTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuY29uc3QgY3JlYXRlT3B0aW9uUXVlcmllcyA9IG9wdGlvbnMgPT4gc3RhdGUgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGtleSA9PiB7XG4gICAgICAgIG9ialtgR0VUXyR7ZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKX1gXSA9IGFjdGlvbiA9PiBzdGF0ZS5vcHRpb25zW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IEludGVyYWN0aW9uTWV0aG9kID0ge1xuICAgIEFQSTogMSxcbiAgICBEUk9QOiAyLFxuICAgIEJST1dTRTogMyxcbiAgICBQQVNURTogNCxcbiAgICBOT05FOiA1LFxufTtcblxuY29uc3QgZ2V0VW5pcXVlSWQgPSAoKSA9PlxuICAgIE1hdGgucmFuZG9tKClcbiAgICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgICAuc3Vic3RyaW5nKDIsIDExKTtcblxuY29uc3QgYXJyYXlSZW1vdmUgPSAoYXJyLCBpbmRleCkgPT4gYXJyLnNwbGljZShpbmRleCwgMSk7XG5cbmNvbnN0IHJ1biA9IChjYiwgc3luYykgPT4ge1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKDEpLnRoZW4oY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgIH1cbn07XG5cbmNvbnN0IG9uID0gKCkgPT4ge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgIGNvbnN0IG9mZiA9IChldmVudCwgY2IpID0+IHtcbiAgICAgICAgYXJyYXlSZW1vdmUoXG4gICAgICAgICAgICBsaXN0ZW5lcnMsXG4gICAgICAgICAgICBsaXN0ZW5lcnMuZmluZEluZGV4KGxpc3RlbmVyID0+IGxpc3RlbmVyLmV2ZW50ID09PSBldmVudCAmJiAobGlzdGVuZXIuY2IgPT09IGNiIHx8ICFjYikpXG4gICAgICAgICk7XG4gICAgfTtcbiAgICBjb25zdCBmaXJlID0gKGV2ZW50LCBhcmdzLCBzeW5jKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyc1xuICAgICAgICAgICAgLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQpXG4gICAgICAgICAgICAubWFwKGxpc3RlbmVyID0+IGxpc3RlbmVyLmNiKVxuICAgICAgICAgICAgLmZvckVhY2goY2IgPT4gcnVuKCgpID0+IGNiKC4uLmFyZ3MpLCBzeW5jKSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaXJlU3luYzogKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBmaXJlKGV2ZW50LCBhcmdzLCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmlyZTogKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBmaXJlKGV2ZW50LCBhcmdzLCBmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiAoZXZlbnQsIGNiKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCh7IGV2ZW50LCBjYiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PbmNlOiAoZXZlbnQsIGNiKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgY2I6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9mZihldmVudCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICBjYiguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZixcbiAgICB9O1xufTtcblxuY29uc3QgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCA9IChzcmMsIHRhcmdldCwgZXhjbHVkZWQpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAgIC5maWx0ZXIocHJvcGVydHkgPT4gIWV4Y2x1ZGVkLmluY2x1ZGVzKHByb3BlcnR5KSlcbiAgICAgICAgLmZvckVhY2goa2V5ID0+XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBrZXkpKVxuICAgICAgICApO1xufTtcblxuY29uc3QgUFJJVkFURSA9IFtcbiAgICAnZmlyZScsXG4gICAgJ3Byb2Nlc3MnLFxuICAgICdyZXZlcnQnLFxuICAgICdsb2FkJyxcbiAgICAnb24nLFxuICAgICdvZmYnLFxuICAgICdvbk9uY2UnLFxuICAgICdyZXRyeUxvYWQnLFxuICAgICdleHRlbmQnLFxuICAgICdhcmNoaXZlJyxcbiAgICAnYXJjaGl2ZWQnLFxuICAgICdyZWxlYXNlJyxcbiAgICAncmVsZWFzZWQnLFxuICAgICdyZXF1ZXN0UHJvY2Vzc2luZycsXG4gICAgJ2ZyZWV6ZScsXG5dO1xuXG5jb25zdCBjcmVhdGVJdGVtQVBJID0gaXRlbSA9PiB7XG4gICAgY29uc3QgYXBpID0ge307XG4gICAgY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdChpdGVtLCBhcGksIFBSSVZBVEUpO1xuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCByZW1vdmVSZWxlYXNlZEl0ZW1zID0gaXRlbXMgPT4ge1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnJlbGVhc2VkKSB7XG4gICAgICAgICAgICBhcnJheVJlbW92ZShpdGVtcywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBJdGVtU3RhdHVzID0ge1xuICAgIElOSVQ6IDEsXG4gICAgSURMRTogMixcbiAgICBQUk9DRVNTSU5HX1FVRVVFRDogOSxcbiAgICBQUk9DRVNTSU5HOiAzLFxuICAgIFBST0NFU1NJTkdfQ09NUExFVEU6IDUsXG4gICAgUFJPQ0VTU0lOR19FUlJPUjogNixcbiAgICBQUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogMTAsXG4gICAgTE9BRElORzogNyxcbiAgICBMT0FEX0VSUk9SOiA4LFxufTtcblxuY29uc3QgRmlsZU9yaWdpbiA9IHtcbiAgICBJTlBVVDogMSxcbiAgICBMSU1CTzogMixcbiAgICBMT0NBTDogMyxcbn07XG5cbmNvbnN0IGdldE5vbk51bWVyaWMgPSBzdHIgPT4gL1teMC05XSsvLmV4ZWMoc3RyKTtcblxuY29uc3QgZ2V0RGVjaW1hbFNlcGFyYXRvciA9ICgpID0+IGdldE5vbk51bWVyaWMoKDEuMSkudG9Mb2NhbGVTdHJpbmcoKSlbMF07XG5cbmNvbnN0IGdldFRob3VzYW5kc1NlcGFyYXRvciA9ICgpID0+IHtcbiAgICAvLyBBZGRlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcmV0dXJuIHRoZSB0aG91c2FuZHMgc2VwYXJhdG9yIChoYXBwZW5kIG9uIG5hdGl2ZSBicm93c2VyIEFuZHJvaWQgNC40LjQpXG4gICAgLy8gV2UgY2hlY2sgYWdhaW5zdCB0aGUgbm9ybWFsIHRvU3RyaW5nIG91dHB1dCBhbmQgaWYgdGhleSdyZSB0aGUgc2FtZSByZXR1cm4gYSBjb21tYSB3aGVuIGRlY2ltYWwgc2VwYXJhdG9yIGlzIGEgZG90XG4gICAgY29uc3QgZGVjaW1hbFNlcGFyYXRvciA9IGdldERlY2ltYWxTZXBhcmF0b3IoKTtcbiAgICBjb25zdCB0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yID0gKDEwMDAuMCkudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICBjb25zdCB0aG91c2FuZHNTdHJpbmdXaXRob3V0U2VwYXJhdG9yID0gKDEwMDAuMCkudG9TdHJpbmcoKTtcbiAgICBpZiAodGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciAhPT0gdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gZ2V0Tm9uTnVtZXJpYyh0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWxTZXBhcmF0b3IgPT09ICcuJyA/ICcsJyA6ICcuJztcbn07XG5cbmNvbnN0IFR5cGUgPSB7XG4gICAgQk9PTEVBTjogJ2Jvb2xlYW4nLFxuICAgIElOVDogJ2ludCcsXG4gICAgTlVNQkVSOiAnbnVtYmVyJyxcbiAgICBTVFJJTkc6ICdzdHJpbmcnLFxuICAgIEFSUkFZOiAnYXJyYXknLFxuICAgIE9CSkVDVDogJ29iamVjdCcsXG4gICAgRlVOQ1RJT046ICdmdW5jdGlvbicsXG4gICAgQUNUSU9OOiAnYWN0aW9uJyxcbiAgICBTRVJWRVJfQVBJOiAnc2VydmVyYXBpJyxcbiAgICBSRUdFWDogJ3JlZ2V4Jyxcbn07XG5cbi8vIGFsbCByZWdpc3RlcmVkIGZpbHRlcnNcbmNvbnN0IGZpbHRlcnMgPSBbXTtcblxuLy8gbG9vcHMgb3ZlciBtYXRjaGluZyBmaWx0ZXJzIGFuZCBwYXNzZXMgb3B0aW9ucyB0byBlYWNoIGZpbHRlciwgcmV0dXJuaW5nIHRoZSBtYXBwZWQgcmVzdWx0c1xuY29uc3QgYXBwbHlGaWx0ZXJDaGFpbiA9IChrZXksIHZhbHVlLCB1dGlscykgPT5cbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGZpbmQgbWF0Y2hpbmcgZmlsdGVycyBmb3IgdGhpcyBrZXlcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdGaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoZiA9PiBmLmtleSA9PT0ga2V5KS5tYXAoZiA9PiBmLmNiKTtcblxuICAgICAgICAvLyByZXNvbHZlIG5vd1xuICAgICAgICBpZiAobWF0Y2hpbmdGaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIgdG8ga2ljayB0aGluZ3Mgb2ZcbiAgICAgICAgY29uc3QgaW5pdGlhbEZpbHRlciA9IG1hdGNoaW5nRmlsdGVycy5zaGlmdCgpO1xuXG4gICAgICAgIC8vIGNoYWluIGZpbHRlcnNcbiAgICAgICAgbWF0Y2hpbmdGaWx0ZXJzXG4gICAgICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBwcm9taXNlcyBwYXNzaW5nIHZhbHVlIHRvIG5leHQgcHJvbWlzZVxuICAgICAgICAgICAgICAgIChjdXJyZW50LCBuZXh0KSA9PiBjdXJyZW50LnRoZW4odmFsdWUgPT4gbmV4dCh2YWx1ZSwgdXRpbHMpKSxcblxuICAgICAgICAgICAgICAgIC8vIGNhbGwgaW5pdGlhbCBmaWx0ZXIsIHdpbGwgcmV0dXJuIGEgcHJvbWlzZVxuICAgICAgICAgICAgICAgIGluaXRpYWxGaWx0ZXIodmFsdWUsIHV0aWxzKVxuXG4gICAgICAgICAgICAgICAgLy8gYWxsIGV4ZWN1dGVkXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAudGhlbih2YWx1ZSA9PiByZXNvbHZlKHZhbHVlKSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiByZWplY3QoZXJyb3IpKTtcbiAgICB9KTtcblxuY29uc3QgYXBwbHlGaWx0ZXJzID0gKGtleSwgdmFsdWUsIHV0aWxzKSA9PlxuICAgIGZpbHRlcnMuZmlsdGVyKGYgPT4gZi5rZXkgPT09IGtleSkubWFwKGYgPT4gZi5jYih2YWx1ZSwgdXRpbHMpKTtcblxuLy8gYWRkcyBhIG5ldyBmaWx0ZXIgdG8gdGhlIGxpc3RcbmNvbnN0IGFkZEZpbHRlciA9IChrZXksIGNiKSA9PiBmaWx0ZXJzLnB1c2goeyBrZXksIGNiIH0pO1xuXG5jb25zdCBleHRlbmREZWZhdWx0T3B0aW9ucyA9IGFkZGl0aW9uYWxPcHRpb25zID0+IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcblxuY29uc3QgZ2V0T3B0aW9ucyA9ICgpID0+ICh7IC4uLmRlZmF1bHRPcHRpb25zIH0pO1xuXG5jb25zdCBzZXRPcHRpb25zID0gb3B0cyA9PiB7XG4gICAgZm9yaW4ob3B0cywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgLy8ga2V5IGRvZXMgbm90IGV4aXN0LCBzbyB0aGlzIG9wdGlvbiBjYW5ub3QgYmUgc2V0XG4gICAgICAgIGlmICghZGVmYXVsdE9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMF0gPSBnZXRWYWx1ZUJ5VHlwZShcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XVswXSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMV1cbiAgICAgICAgKTtcbiAgICB9KTtcbn07XG5cbi8vIGRlZmF1bHQgb3B0aW9ucyBvbiBhcHBcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8vIHRoZSBpZCB0byBhZGQgdG8gdGhlIHJvb3QgZWxlbWVudFxuICAgIGlkOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaW5wdXQgZmllbGQgbmFtZSB0byB1c2VcbiAgICBuYW1lOiBbJ2ZpbGVwb25kJywgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gZGlzYWJsZSB0aGUgZmllbGRcbiAgICBkaXNhYmxlZDogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLFxuXG4gICAgLy8gY2xhc3NuYW1lIHRvIHB1dCBvbiB3cmFwcGVyXG4gICAgY2xhc3NOYW1lOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gaXMgdGhlIGZpZWxkIHJlcXVpcmVkXG4gICAgcmVxdWlyZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEFsbG93IG1lZGlhIGNhcHR1cmUgd2hlbiB2YWx1ZSBpcyBzZXRcbiAgICBjYXB0dXJlTWV0aG9kOiBbbnVsbCwgVHlwZS5TVFJJTkddLFxuICAgIC8vIC0gXCJjYW1lcmFcIiwgXCJtaWNyb3Bob25lXCIgb3IgXCJjYW1jb3JkZXJcIixcbiAgICAvLyAtIERvZXMgbm90IHdvcmsgd2l0aCBtdWx0aXBsZSBvbiBhcHBsZSBkZXZpY2VzXG4gICAgLy8gLSBJZiBzZXQsIGFjY2VwdGVkRmlsZVR5cGVzIG11c3QgYmUgbWFkZSB0byBtYXRjaCB3aXRoIG1lZGlhIHdpbGRjYXJkIFwiaW1hZ2UvKlwiLCBcImF1ZGlvLypcIiBvciBcInZpZGVvLypcIlxuXG4gICAgLy8gc3luYyBgYWNjZXB0ZWRGaWxlVHlwZXNgIHByb3BlcnR5IHdpdGggYGFjY2VwdGAgYXR0cmlidXRlXG4gICAgYWxsb3dTeW5jQWNjZXB0QXR0cmlidXRlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIEZlYXR1cmUgdG9nZ2xlc1xuICAgIGFsbG93RHJvcDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIG9mIGZpbGVzXG4gICAgYWxsb3dCcm93c2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBicm93c2luZyB0aGUgZmlsZSBzeXN0ZW1cbiAgICBhbGxvd1Bhc3RlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcGFzdGluZyBmaWxlc1xuICAgIGFsbG93TXVsdGlwbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgbXVsdGlwbGUgZmlsZXMgKGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIG11bHRpcGxlIGF0dHJpYnV0ZSBpcyBhbHNvIHJlcXVpcmVkIG9uIGlucHV0IHRvIGFsbG93IG11bHRpcGxlKVxuICAgIGFsbG93UmVwbGFjZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IGRyb3BwaW5nIGEgZmlsZSBvbiBvdGhlciBmaWxlIHRvIHJlcGxhY2UgaXQgKG9ubHkgd29ya3Mgd2hlbiBtdWx0aXBsZSBpcyBzZXQgdG8gZmFsc2UpXG4gICAgYWxsb3dSZXZlcnQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byByZXZlcnQgZmlsZSB1cGxvYWRcbiAgICBhbGxvd1JlbW92ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHVzZXIgdG8gcmVtb3ZlIGEgZmlsZVxuICAgIGFsbG93UHJvY2VzczogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93cyB1c2VyIHRvIHByb2Nlc3MgYSBmaWxlLCB3aGVuIHNldCB0byBmYWxzZSwgdGhpcyByZW1vdmVzIHRoZSBmaWxlIHVwbG9hZCBidXR0b25cbiAgICBhbGxvd1Jlb3JkZXI6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgcmVvcmRlcmluZyBvZiBmaWxlc1xuICAgIGFsbG93RGlyZWN0b3JpZXNPbmx5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG9ubHkgc2VsZWN0aW5nIGRpcmVjdG9yaWVzIHdpdGggYnJvd3NlIChubyBzdXBwb3J0IGZvciBmaWx0ZXJpbmcgZG5kIGF0IHRoaXMgcG9pbnQpXG5cbiAgICAvLyBUcnkgc3RvcmUgZmlsZSBpZiBgc2VydmVyYCBub3Qgc2V0XG4gICAgc3RvcmVBc0ZpbGU6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIFJldmVydCBtb2RlXG4gICAgZm9yY2VSZXZlcnQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvICdmb3JjZScgdG8gcmVxdWlyZSB0aGUgZmlsZSB0byBiZSByZXZlcnRlZCBiZWZvcmUgcmVtb3ZhbFxuXG4gICAgLy8gSW5wdXQgcmVxdWlyZW1lbnRzXG4gICAgbWF4RmlsZXM6IFtudWxsLCBUeXBlLklOVF0sIC8vIE1heCBudW1iZXIgb2YgZmlsZXNcbiAgICBjaGVja1ZhbGlkaXR5OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZXMgY3VzdG9tIHZhbGlkaXR5IG1lc3NhZ2VzXG5cbiAgICAvLyBXaGVyZSB0byBwdXQgZmlsZVxuICAgIGl0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb206IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTZXQgdG8gZmFsc2UgdG8gYWx3YXlzIGFkZCBpdGVtcyB0byBiZWdpbiBvciBlbmQgb2YgbGlzdFxuICAgIGl0ZW1JbnNlcnRMb2NhdGlvbjogWydiZWZvcmUnLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaW5kZXggaW4gbGlzdCB0byBhZGQgaXRlbXMgdGhhdCBoYXZlIGJlZW4gZHJvcHBlZCBhdCB0aGUgdG9wIG9mIHRoZSBsaXN0XG4gICAgaXRlbUluc2VydEludGVydmFsOiBbNzUsIFR5cGUuSU5UXSxcblxuICAgIC8vIERyYWcgJ24gRHJvcCByZWxhdGVkXG4gICAgZHJvcE9uUGFnZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBvZiBmaWxlcyBhbnl3aGVyZSBvbiBwYWdlIChwcmV2ZW50cyBicm93c2VyIGZyb20gb3BlbmluZyBmaWxlIGlmIGRyb3BwZWQgb3V0c2lkZSBvZiBVcClcbiAgICBkcm9wT25FbGVtZW50OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gRHJvcCBuZWVkcyB0byBoYXBwZW4gb24gZWxlbWVudCAoc2V0IHRvIGZhbHNlIHRvIGFsc28gbG9hZCBkcm9wcyBvdXRzaWRlIG9mIFVwKVxuICAgIGRyb3BWYWxpZGF0aW9uOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZSBvciBkaXNhYmxlIHZhbGlkYXRpbmcgZmlsZXMgb24gZHJvcFxuICAgIGlnbm9yZWRGaWxlczogW1snLmRzX3N0b3JlJywgJ3RodW1icy5kYicsICdkZXNrdG9wLmluaSddLCBUeXBlLkFSUkFZXSxcblxuICAgIC8vIFVwbG9hZCByZWxhdGVkXG4gICAgaW5zdGFudFVwbG9hZDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIFNob3VsZCB1cGxvYWQgZmlsZXMgaW1tZWRpYXRlbHkgb24gZHJvcFxuICAgIG1heFBhcmFsbGVsVXBsb2FkczogWzIsIFR5cGUuSU5UXSwgLy8gTWF4aW11bSBmaWxlcyB0byB1cGxvYWQgaW4gcGFyYWxsZWxcbiAgICBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbjogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIGlmIHRydWUgdXBsb2FkcyB0YWtlIGF0IGxlYXN0IDc1MCBtcywgdGhpcyBlbnN1cmVzIHRoZSB1c2VyIHNlZXMgdGhlIHVwbG9hZCBwcm9ncmVzcyBnaXZpbmcgdHJ1c3QgdGhlIHVwbG9hZCBhY3R1YWxseSBoYXBwZW5lZFxuXG4gICAgLy8gQ2h1bmtzXG4gICAgY2h1bmtVcGxvYWRzOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEVuYWJsZSBjaHVua2VkIHVwbG9hZHNcbiAgICBjaHVua0ZvcmNlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEZvcmNlIHVzZSBvZiBjaHVuayB1cGxvYWRzIGV2ZW4gZm9yIGZpbGVzIHNtYWxsZXIgdGhhbiBjaHVuayBzaXplXG4gICAgY2h1bmtTaXplOiBbNTAwMDAwMCwgVHlwZS5JTlRdLCAvLyBTaXplIG9mIGNodW5rcyAoNU1CIGRlZmF1bHQpXG4gICAgY2h1bmtSZXRyeURlbGF5czogW1s1MDAsIDEwMDAsIDMwMDBdLCBUeXBlLkFSUkFZXSwgLy8gQW1vdW50IG9mIHRpbWVzIHRvIHJldHJ5IHVwbG9hZCBvZiBhIGNodW5rIHdoZW4gaXQgZmFpbHNcblxuICAgIC8vIFRoZSBzZXJ2ZXIgYXBpIGVuZCBwb2ludHMgdG8gdXNlIGZvciB1cGxvYWRpbmcgKHNlZSBkb2NzKVxuICAgIHNlcnZlcjogW251bGwsIFR5cGUuU0VSVkVSX0FQSV0sXG5cbiAgICAvLyBGaWxlIHNpemUgY2FsY3VsYXRpb25zLCBjYW4gc2V0IHRvIDEwMjQsIHRoaXMgaXMgb25seSB1c2VkIGZvciBkaXNwbGF5LCBwcm9wZXJ0aWVzIHVzZSBmaWxlIHNpemUgYmFzZSAxMDAwXG4gICAgZmlsZVNpemVCYXNlOiBbMTAwMCwgVHlwZS5JTlRdLFxuXG4gICAgLy8gTGFiZWxzIGFuZCBzdGF0dXMgbWVzc2FnZXNcbiAgICBsYWJlbEZpbGVTaXplQnl0ZXM6IFsnYnl0ZXMnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZUtpbG9ieXRlczogWydLQicsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVTaXplTWVnYWJ5dGVzOiBbJ01CJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVNpemVHaWdhYnl0ZXM6IFsnR0InLCBUeXBlLlNUUklOR10sXG5cbiAgICBsYWJlbERlY2ltYWxTZXBhcmF0b3I6IFtnZXREZWNpbWFsU2VwYXJhdG9yKCksIFR5cGUuU1RSSU5HXSwgLy8gRGVmYXVsdCBpcyBsb2NhbGUgc2VwYXJhdG9yXG4gICAgbGFiZWxUaG91c2FuZHNTZXBhcmF0b3I6IFtnZXRUaG91c2FuZHNTZXBhcmF0b3IoKSwgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGlzIGxvY2FsZSBzZXBhcmF0b3JcblxuICAgIGxhYmVsSWRsZTogW1xuICAgICAgICAnRHJhZyAmIERyb3AgeW91ciBmaWxlcyBvciA8c3BhbiBjbGFzcz1cImZpbGVwb25kLS1sYWJlbC1hY3Rpb25cIj5Ccm93c2U8L3NwYW4+JyxcbiAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgXSxcbiAgICBsYWJlbEludmFsaWRGaWVsZDogWydGaWVsZCBjb250YWlucyBpbnZhbGlkIGZpbGVzJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVdhaXRpbmdGb3JTaXplOiBbJ1dhaXRpbmcgZm9yIHNpemUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZTogWydTaXplIG5vdCBhdmFpbGFibGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRTaW5ndWxhcjogWydmaWxlIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQ291bnRQbHVyYWw6IFsnZmlsZXMgaW4gbGlzdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVMb2FkaW5nOiBbJ0xvYWRpbmcnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlQWRkZWQ6IFsnQWRkZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgbGFiZWxGaWxlTG9hZEVycm9yOiBbJ0Vycm9yIGR1cmluZyBsb2FkJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVJlbW92ZWQ6IFsnUmVtb3ZlZCcsIFR5cGUuU1RSSU5HXSwgLy8gYXNzaXN0aXZlIG9ubHlcbiAgICBsYWJlbEZpbGVSZW1vdmVFcnJvcjogWydFcnJvciBkdXJpbmcgcmVtb3ZlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3Npbmc6IFsnVXBsb2FkaW5nJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZTogWydVcGxvYWQgY29tcGxldGUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Fib3J0ZWQ6IFsnVXBsb2FkIGNhbmNlbGxlZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHVwbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJldmVydCcsIFR5cGUuU1RSSU5HXSxcblxuICAgIGxhYmVsVGFwVG9DYW5jZWw6IFsndGFwIHRvIGNhbmNlbCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbFRhcFRvUmV0cnk6IFsndGFwIHRvIHJldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsVGFwVG9VbmRvOiBbJ3RhcCB0byB1bmRvJywgVHlwZS5TVFJJTkddLFxuXG4gICAgbGFiZWxCdXR0b25SZW1vdmVJdGVtOiBbJ1JlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbUxvYWQ6IFsnQWJvcnQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogWydDYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25VbmRvSXRlbVByb2Nlc3Npbmc6IFsnVW5kbycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IFsnUmV0cnknLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25Qcm9jZXNzSXRlbTogWydVcGxvYWQnLCBUeXBlLlNUUklOR10sXG5cbiAgICAvLyBtYWtlIHN1cmUgd2lkdGggYW5kIGhlaWdodCBwbHVzIHZpZXdwb3ggYXJlIGV2ZW4gbnVtYmVycyBzbyBpY29ucyBhcmUgbmljZWx5IGNlbnRlcmVkXG4gICAgaWNvblJlbW92ZTogW1xuICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTEuNTg2IDEzbC0yLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQgMS40MTRMMTMgMTQuNDE0bDIuMjkzIDIuMjkzYTEgMSAwIDAgMCAxLjQxNC0xLjQxNEwxNC40MTQgMTNsMi4yOTMtMi4yOTNhMSAxIDAgMCAwLTEuNDE0LTEuNDE0TDEzIDExLjU4NmwtMi4yOTMtMi4yOTNhMSAxIDAgMCAwLTEuNDE0IDEuNDE0TDExLjU4NiAxM3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICBUeXBlLlNUUklORyxcbiAgICBdLFxuICAgIGljb25Qcm9jZXNzOiBbXG4gICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xNCAxMC40MTR2My41ODVhMSAxIDAgMCAxLTIgMHYtMy41ODVsLTEuMjkzIDEuMjkzYTEgMSAwIDAgMS0xLjQxNC0xLjQxNWwzLTNhMSAxIDAgMCAxIDEuNDE0IDBsMyAzYTEgMSAwIDAgMS0xLjQxNCAxLjQxNUwxNCAxMC40MTR6TTkgMThhMSAxIDAgMCAxIDAtMmg4YTEgMSAwIDAgMSAwIDJIOXpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiLz48L3N2Zz4nLFxuICAgICAgICBUeXBlLlNUUklORyxcbiAgICBdLFxuICAgIGljb25SZXRyeTogW1xuICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTAuODEgOS4xODVsLS4wMzguMDJBNC45OTcgNC45OTcgMCAwIDAgOCAxMy42ODNhNSA1IDAgMCAwIDUgNSA1IDUgMCAwIDAgNS01IDEgMSAwIDAgMSAyIDBBNyA3IDAgMSAxIDkuNzIyIDcuNDk2bC0uODQyLS4yMWEuOTk5Ljk5OSAwIDEgMSAuNDg0LTEuOTRsMy4yMy44MDZjLjUzNS4xMzMuODYuNjc1LjczIDEuMjFsLS44MDQgMy4yMzNhLjk5Ny45OTcgMCAwIDEtMS4yMS43My45OTcuOTk3IDAgMCAxLS43My0xLjIxbC4yMy0uOTI4di0uMDAyelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgIFR5cGUuU1RSSU5HLFxuICAgIF0sXG4gICAgaWNvblVuZG86IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTkuMTg1IDEwLjgxbC4wMi0uMDM4QTQuOTk3IDQuOTk3IDAgMCAxIDEzLjY4MyA4YTUgNSAwIDAgMSA1IDUgNSA1IDAgMCAxLTUgNSAxIDEgMCAwIDAgMCAyQTcgNyAwIDEgMCA3LjQ5NiA5LjcyMmwtLjIxLS44NDJhLjk5OS45OTkgMCAxIDAtMS45NC40ODRsLjgwNiAzLjIzYy4xMzMuNTM1LjY3NS44NiAxLjIxLjczbDMuMjMzLS44MDNhLjk5Ny45OTcgMCAwIDAgLjczLTEuMjEuOTk3Ljk5NyAwIDAgMC0xLjIxLS43M2wtLjkyOC4yMy0uMDAyLS4wMDF6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgXSxcbiAgICBpY29uRG9uZTogW1xuICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTguMjkzIDkuMjkzYTEgMSAwIDAgMSAxLjQxNCAxLjQxNGwtNy4wMDIgN2ExIDEgMCAwIDEtMS40MTQgMGwtMy45OTgtNGExIDEgMCAxIDEgMS40MTQtMS40MTRMMTIgMTUuNTg2bDYuMjk0LTYuMjkzelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgIFR5cGUuU1RSSU5HLFxuICAgIF0sXG5cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIG9uaW5pdDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ud2FybmluZzogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uZXJyb3I6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFjdGl2YXRlZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uaW5pdGZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFkZGZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uYWRkZmlsZXByb2dyZXNzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hZGRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXN0YXJ0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXByb2dyZXNzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZWFib3J0OiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXJldmVydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByb2Nlc3NmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucmVtb3ZlZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJlcGFyZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnVwZGF0ZWZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25yZW9yZGVyZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcblxuICAgIC8vIGhvb2tzXG4gICAgYmVmb3JlRHJvcEZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBiZWZvcmVBZGRGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgYmVmb3JlUmVtb3ZlRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIGJlZm9yZVByZXBhcmVGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAvLyBzdHlsZXNcbiAgICBzdHlsZVBhbmVsTGF5b3V0OiBbbnVsbCwgVHlwZS5TVFJJTkddLCAvLyBudWxsICdpbnRlZ3JhdGVkJywgJ2NvbXBhY3QnLCAnY2lyY2xlJ1xuICAgIHN0eWxlUGFuZWxBc3BlY3RSYXRpbzogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCBvciAnMzoyJyBvciAxXG4gICAgc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbzogW251bGwsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUJ1dHRvblJlbW92ZUl0ZW1Qb3NpdGlvbjogWydsZWZ0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlQnV0dG9uUHJvY2Vzc0l0ZW1Qb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUxvYWRJbmRpY2F0b3JQb3NpdGlvbjogWydyaWdodCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZVByb2dyZXNzSW5kaWNhdG9yUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtQWxpZ246IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIGN1c3RvbSBpbml0aWFsIGZpbGVzIGFycmF5XG4gICAgZmlsZXM6IFtbXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAvLyBzaG93IHN1cHBvcnQgYnkgZGlzcGxheWluZyBjcmVkaXRzXG4gICAgY3JlZGl0czogW1snaHR0cHM6Ly9wcWluYS5ubC8nLCAnUG93ZXJlZCBieSBQUUlOQSddLCBUeXBlLkFSUkFZXSxcbn07XG5cbmNvbnN0IGdldEl0ZW1CeVF1ZXJ5ID0gKGl0ZW1zLCBxdWVyeSkgPT4ge1xuICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgaWYgKGlzRW1wdHkocXVlcnkpKSB7XG4gICAgICAgIHJldHVybiBpdGVtc1swXSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIHF1ZXJ5IGlzIGluZGV4XG4gICAgaWYgKGlzSW50KHF1ZXJ5KSkge1xuICAgICAgICByZXR1cm4gaXRlbXNbcXVlcnldIHx8IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgcXVlcnkgaXMgaXRlbSwgZ2V0IHRoZSBpZFxuICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHF1ZXJ5ID0gcXVlcnkuaWQ7XG4gICAgfVxuXG4gICAgLy8gYXNzdW1lIHF1ZXJ5IGlzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRlbSBieSBpZFxuICAgIHJldHVybiBpdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pZCA9PT0gcXVlcnkpIHx8IG51bGw7XG59O1xuXG5jb25zdCBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nID0gYXNwZWN0UmF0aW8gPT4ge1xuICAgIGlmIChpc0VtcHR5KGFzcGVjdFJhdGlvKSkge1xuICAgICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmICgvOi8udGVzdChhc3BlY3RSYXRpbykpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBhc3BlY3RSYXRpby5zcGxpdCgnOicpO1xuICAgICAgICByZXR1cm4gcGFydHNbMV0gLyBwYXJ0c1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoYXNwZWN0UmF0aW8pO1xufTtcblxuY29uc3QgZ2V0QWN0aXZlSXRlbXMgPSBpdGVtcyA9PiBpdGVtcy5maWx0ZXIoaXRlbSA9PiAhaXRlbS5hcmNoaXZlZCk7XG5cbmNvbnN0IFN0YXR1cyA9IHtcbiAgICBFTVBUWTogMCxcbiAgICBJRExFOiAxLCAvLyB3YWl0aW5nXG4gICAgRVJST1I6IDIsIC8vIGEgZmlsZSBpcyBpbiBlcnJvciBzdGF0ZVxuICAgIEJVU1k6IDMsIC8vIGJ1c3kgcHJvY2Vzc2luZyBvciBsb2FkaW5nXG4gICAgUkVBRFk6IDQsIC8vIGFsbCBmaWxlcyB1cGxvYWRlZFxufTtcblxubGV0IHJlcyA9IG51bGw7XG5jb25zdCBjYW5VcGRhdGVGaWxlSW5wdXQgPSAoKSA9PiB7XG4gICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gbmV3IERhdGFUcmFuc2ZlcigpO1xuICAgICAgICAgICAgZGF0YVRyYW5zZmVyLml0ZW1zLmFkZChuZXcgRmlsZShbJ2hlbGxvIHdvcmxkJ10sICdUaGlzX1dvcmtzLnR4dCcpKTtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndHlwZScsICdmaWxlJyk7XG4gICAgICAgICAgICBlbC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICAgICAgICAgIHJlcyA9IGVsLmZpbGVzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxuY29uc3QgSVRFTV9FUlJPUiA9IFtcbiAgICBJdGVtU3RhdHVzLkxPQURfRVJST1IsXG4gICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IsXG5dO1xuY29uc3QgSVRFTV9CVVNZID0gW1xuICAgIEl0ZW1TdGF0dXMuTE9BRElORyxcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkcsXG4gICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCxcbiAgICBJdGVtU3RhdHVzLklOSVQsXG5dO1xuY29uc3QgSVRFTV9SRUFEWSA9IFtJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEVdO1xuXG5jb25zdCBpc0l0ZW1JbkVycm9yU3RhdGUgPSBpdGVtID0+IElURU1fRVJST1IuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuY29uc3QgaXNJdGVtSW5CdXN5U3RhdGUgPSBpdGVtID0+IElURU1fQlVTWS5pbmNsdWRlcyhpdGVtLnN0YXR1cyk7XG5jb25zdCBpc0l0ZW1JblJlYWR5U3RhdGUgPSBpdGVtID0+IElURU1fUkVBRFkuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuXG5jb25zdCBpc0FzeW5jID0gc3RhdGUgPT5cbiAgICBpc09iamVjdChzdGF0ZS5vcHRpb25zLnNlcnZlcikgJiZcbiAgICAoaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIucHJvY2VzcykgfHwgaXNGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci5wcm9jZXNzKSk7XG5cbmNvbnN0IHF1ZXJpZXMgPSBzdGF0ZSA9PiAoe1xuICAgIEdFVF9TVEFUVVM6ICgpID0+IHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG5cbiAgICAgICAgY29uc3QgeyBFTVBUWSwgRVJST1IsIEJVU1ksIElETEUsIFJFQURZIH0gPSBTdGF0dXM7XG5cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluRXJyb3JTdGF0ZSkpIHJldHVybiBFUlJPUjtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkJ1c3lTdGF0ZSkpIHJldHVybiBCVVNZO1xuXG4gICAgICAgIGlmIChpdGVtcy5zb21lKGlzSXRlbUluUmVhZHlTdGF0ZSkpIHJldHVybiBSRUFEWTtcblxuICAgICAgICByZXR1cm4gSURMRTtcbiAgICB9LFxuXG4gICAgR0VUX0lURU06IHF1ZXJ5ID0+IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSksXG5cbiAgICBHRVRfQUNUSVZFX0lURU06IHF1ZXJ5ID0+IGdldEl0ZW1CeVF1ZXJ5KGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSwgcXVlcnkpLFxuXG4gICAgR0VUX0FDVElWRV9JVEVNUzogKCkgPT4gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLFxuXG4gICAgR0VUX0lURU1TOiAoKSA9PiBzdGF0ZS5pdGVtcyxcblxuICAgIEdFVF9JVEVNX05BTUU6IHF1ZXJ5ID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlbmFtZSA6IG51bGw7XG4gICAgfSxcblxuICAgIEdFVF9JVEVNX1NJWkU6IHF1ZXJ5ID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIHJldHVybiBpdGVtID8gaXRlbS5maWxlU2l6ZSA6IG51bGw7XG4gICAgfSxcblxuICAgIEdFVF9TVFlMRVM6ICgpID0+XG4gICAgICAgIE9iamVjdC5rZXlzKHN0YXRlLm9wdGlvbnMpXG4gICAgICAgICAgICAuZmlsdGVyKGtleSA9PiAvXnN0eWxlLy50ZXN0KGtleSkpXG4gICAgICAgICAgICAubWFwKG9wdGlvbiA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdGlvbixcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RhdGUub3B0aW9uc1tvcHRpb25dLFxuICAgICAgICAgICAgfSkpLFxuXG4gICAgR0VUX1BBTkVMX0FTUEVDVF9SQVRJTzogKCkgPT4ge1xuICAgICAgICBjb25zdCBpc1NoYXBlQ2lyY2xlID0gL2NpcmNsZS8udGVzdChzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxMYXlvdXQpO1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IGlzU2hhcGVDaXJjbGVcbiAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgOiBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nKHN0YXRlLm9wdGlvbnMuc3R5bGVQYW5lbEFzcGVjdFJhdGlvKTtcbiAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH0sXG5cbiAgICBHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU86ICgpID0+IHN0YXRlLm9wdGlvbnMuc3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbyxcblxuICAgIEdFVF9JVEVNU19CWV9TVEFUVVM6IHN0YXR1cyA9PlxuICAgICAgICBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zdGF0dXMgPT09IHN0YXR1cyksXG5cbiAgICBHRVRfVE9UQUxfSVRFTVM6ICgpID0+IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGgsXG5cbiAgICBTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQ6ICgpID0+XG4gICAgICAgIHN0YXRlLm9wdGlvbnMuc3RvcmVBc0ZpbGUgJiYgY2FuVXBkYXRlRmlsZUlucHV0KCkgJiYgIWlzQXN5bmMoc3RhdGUpLFxuXG4gICAgSVNfQVNZTkM6ICgpID0+IGlzQXN5bmMoc3RhdGUpLFxuXG4gICAgR0VUX0ZJTEVfU0laRV9MQUJFTFM6IHF1ZXJ5ID0+ICh7XG4gICAgICAgIGxhYmVsQnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0JZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbEtpbG9ieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfS0lMT0JZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbE1lZ2FieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfTUVHQUJZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbEdpZ2FieXRlczogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1NJWkVfR0lHQUJZVEVTJykgfHwgdW5kZWZpbmVkLFxuICAgIH0pLFxufSk7XG5cbmNvbnN0IGhhc1Jvb21Gb3JJdGVtID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmxlbmd0aDtcblxuICAgIC8vIGlmIGNhbm5vdCBoYXZlIG11bHRpcGxlIGl0ZW1zLCB0byBhZGQgb25lIGl0ZW0gaXQgc2hvdWxkIGN1cnJlbnRseSBub3QgY29udGFpbiBpdGVtc1xuICAgIGlmICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBjb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBpZiBhbGxvd3MgbXVsdGlwbGUgaXRlbXMsIHdlIGNoZWNrIGlmIGEgbWF4IGl0ZW0gY291bnQgaGFzIGJlZW4gc2V0LCBpZiBub3QsIHRoZXJlJ3Mgbm8gbGltaXRcbiAgICBjb25zdCBtYXhGaWxlQ291bnQgPSBzdGF0ZS5vcHRpb25zLm1heEZpbGVzO1xuICAgIGlmIChtYXhGaWxlQ291bnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UgY2hlY2sgaWYgdGhlIGN1cnJlbnQgY291bnQgaXMgc21hbGxlciB0aGFuIHRoZSBtYXggY291bnQsIGlmIHNvLCBhbm90aGVyIGZpbGUgY2FuIHN0aWxsIGJlIGFkZGVkXG4gICAgaWYgKGNvdW50IDwgbWF4RmlsZUNvdW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgcm9vbSBmb3IgYW5vdGhlciBmaWxlXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgbGltaXQgPSAodmFsdWUsIG1pbiwgbWF4KSA9PiBNYXRoLm1heChNYXRoLm1pbihtYXgsIHZhbHVlKSwgbWluKTtcblxuY29uc3QgYXJyYXlJbnNlcnQgPSAoYXJyLCBpbmRleCwgaXRlbSkgPT4gYXJyLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG5cbmNvbnN0IGluc2VydEl0ZW0gPSAoaXRlbXMsIGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgaWYgKGlzRW1wdHkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaW5kZXggaXMgdW5kZWZpbmVkLCBhcHBlbmRcbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvLyBsaW1pdCB0aGUgaW5kZXggdG8gdGhlIHNpemUgb2YgdGhlIGl0ZW1zIGFycmF5XG4gICAgaW5kZXggPSBsaW1pdChpbmRleCwgMCwgaXRlbXMubGVuZ3RoKTtcblxuICAgIC8vIGFkZCBpdGVtIHRvIGFycmF5XG4gICAgYXJyYXlJbnNlcnQoaXRlbXMsIGluZGV4LCBpdGVtKTtcblxuICAgIC8vIGV4cG9zZVxuICAgIHJldHVybiBpdGVtO1xufTtcblxuY29uc3QgaXNCYXNlNjREYXRhVVJJID0gc3RyID0+XG4gICAgL15cXHMqZGF0YTooW2Etel0rXFwvW2EtejAtOS0rLl0rKDtbYS16LV0rPVthLXowLTktXSspPyk/KDtiYXNlNjQpPywoW2EtejAtOSEkJicsKCkqKzs9XFwtLl9+OkBcXC8/JVxcc10qKVxccyokL2kudGVzdChcbiAgICAgICAgc3RyXG4gICAgKTtcblxuY29uc3QgZ2V0RmlsZW5hbWVGcm9tVVJMID0gdXJsID0+XG4gICAgYCR7dXJsfWBcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLnBvcCgpXG4gICAgICAgIC5zcGxpdCgnPycpXG4gICAgICAgIC5zaGlmdCgpO1xuXG5jb25zdCBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUgPSBuYW1lID0+IG5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcblxuY29uc3QgZ3Vlc3N0aW1hdGVFeHRlbnNpb24gPSB0eXBlID0+IHtcbiAgICAvLyBpZiBubyBleHRlbnNpb24gc3VwcGxpZWQsIGV4aXQgaGVyZVxuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIGdldCBzdWJ0eXBlXG4gICAgY29uc3Qgc3VidHlwZSA9IHR5cGUuc3BsaXQoJy8nKS5wb3AoKTtcblxuICAgIC8vIGlzIHN2ZyBzdWJ0eXBlXG4gICAgaWYgKC9zdmcvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICdzdmcnO1xuICAgIH1cblxuICAgIGlmICgvemlwfGNvbXByZXNzZWQvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICd6aXAnO1xuICAgIH1cblxuICAgIGlmICgvcGxhaW4vLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgcmV0dXJuICd0eHQnO1xuICAgIH1cblxuICAgIGlmICgvbXN3b3JkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnZG9jJztcbiAgICB9XG5cbiAgICAvLyBpZiBpcyB2YWxpZCBzdWJ0eXBlXG4gICAgaWYgKC9bYS16XSsvLnRlc3Qoc3VidHlwZSkpIHtcbiAgICAgICAgLy8gYWx3YXlzIHVzZSBqcGcgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdWJ0eXBlID09PSAnanBlZycpIHtcbiAgICAgICAgICAgIHJldHVybiAnanBnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBzdWJ0eXBlXG4gICAgICAgIHJldHVybiBzdWJ0eXBlO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbn07XG5cbmNvbnN0IGxlZnRQYWQgPSAodmFsdWUsIHBhZGRpbmcgPSAnJykgPT4gKHBhZGRpbmcgKyB2YWx1ZSkuc2xpY2UoLXBhZGRpbmcubGVuZ3RoKTtcblxuY29uc3QgZ2V0RGF0ZVN0cmluZyA9IChkYXRlID0gbmV3IERhdGUoKSkgPT5cbiAgICBgJHtkYXRlLmdldEZ1bGxZZWFyKCl9LSR7bGVmdFBhZChkYXRlLmdldE1vbnRoKCkgKyAxLCAnMDAnKX0tJHtsZWZ0UGFkKFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgJzAwJ1xuICAgICl9XyR7bGVmdFBhZChkYXRlLmdldEhvdXJzKCksICcwMCcpfS0ke2xlZnRQYWQoZGF0ZS5nZXRNaW51dGVzKCksICcwMCcpfS0ke2xlZnRQYWQoXG4gICAgICAgIGRhdGUuZ2V0U2Vjb25kcygpLFxuICAgICAgICAnMDAnXG4gICAgKX1gO1xuXG5jb25zdCBnZXRGaWxlRnJvbUJsb2IgPSAoYmxvYiwgZmlsZW5hbWUsIHR5cGUgPSBudWxsLCBleHRlbnNpb24gPSBudWxsKSA9PiB7XG4gICAgY29uc3QgZmlsZSA9XG4gICAgICAgIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBibG9iLnNsaWNlKDAsIGJsb2Iuc2l6ZSwgdHlwZSlcbiAgICAgICAgICAgIDogYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIGJsb2IudHlwZSk7XG4gICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlID0gbmV3IERhdGUoKTtcblxuICAgIC8vIGNvcHkgcmVsYXRpdmUgcGF0aFxuICAgIGlmIChibG9iLl9yZWxhdGl2ZVBhdGgpIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGJsb2IuX3JlbGF0aXZlUGF0aDtcblxuICAgIC8vIGlmIGJsb2IgaGFzIG5hbWUgcHJvcGVydHksIHVzZSBhcyBmaWxlbmFtZSBpZiBubyBmaWxlbmFtZSBzdXBwbGllZFxuICAgIGlmICghaXNTdHJpbmcoZmlsZW5hbWUpKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZ2V0RGF0ZVN0cmluZygpO1xuICAgIH1cblxuICAgIC8vIGlmIGZpbGVuYW1lIHN1cHBsaWVkIGJ1dCBubyBleHRlbnNpb24gYW5kIGZpbGVuYW1lIGhhcyBleHRlbnNpb25cbiAgICBpZiAoZmlsZW5hbWUgJiYgZXh0ZW5zaW9uID09PSBudWxsICYmIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShmaWxlbmFtZSkpIHtcbiAgICAgICAgZmlsZS5uYW1lID0gZmlsZW5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uIHx8IGd1ZXNzdGltYXRlRXh0ZW5zaW9uKGZpbGUudHlwZSk7XG4gICAgICAgIGZpbGUubmFtZSA9IGZpbGVuYW1lICsgKGV4dGVuc2lvbiA/ICcuJyArIGV4dGVuc2lvbiA6ICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZTtcbn07XG5cbmNvbnN0IGdldEJsb2JCdWlsZGVyID0gKCkgPT4ge1xuICAgIHJldHVybiAod2luZG93LkJsb2JCdWlsZGVyID1cbiAgICAgICAgd2luZG93LkJsb2JCdWlsZGVyIHx8XG4gICAgICAgIHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fFxuICAgICAgICB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgd2luZG93Lk1TQmxvYkJ1aWxkZXIpO1xufTtcblxuY29uc3QgY3JlYXRlQmxvYiA9IChhcnJheUJ1ZmZlciwgbWltZVR5cGUpID0+IHtcbiAgICBjb25zdCBCQiA9IGdldEJsb2JCdWlsZGVyKCk7XG5cbiAgICBpZiAoQkIpIHtcbiAgICAgICAgY29uc3QgYmIgPSBuZXcgQkIoKTtcbiAgICAgICAgYmIuYXBwZW5kKGFycmF5QnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGJiLmdldEJsb2IobWltZVR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICAgIHR5cGU6IG1pbWVUeXBlLFxuICAgIH0pO1xufTtcblxuY29uc3QgZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlID0gKGJ5dGVTdHJpbmcsIG1pbWVUeXBlKSA9PiB7XG4gICAgY29uc3QgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZVN0cmluZy5sZW5ndGgpO1xuICAgIGNvbnN0IGlhID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVCbG9iKGFiLCBtaW1lVHlwZSk7XG59O1xuXG5jb25zdCBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJID0gZGF0YVVSSSA9PiB7XG4gICAgcmV0dXJuICgvXmRhdGE6KC4rKTsvLmV4ZWMoZGF0YVVSSSkgfHwgW10pWzFdIHx8IG51bGw7XG59O1xuXG5jb25zdCBnZXRCYXNlNjREYXRhRnJvbUJhc2U2NERhdGFVUkkgPSBkYXRhVVJJID0+IHtcbiAgICAvLyBnZXQgZGF0YSBwYXJ0IG9mIHN0cmluZyAocmVtb3ZlIGRhdGE6aW1hZ2UvanBlZy4uLiwpXG4gICAgY29uc3QgZGF0YSA9IGRhdGFVUkkuc3BsaXQoJywnKVsxXTtcblxuICAgIC8vIHJlbW92ZSBhbnkgd2hpdGVzcGFjZSBhcyB0aGF0IGNhdXNlcyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IgaW4gSUVcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKC9cXHMvZywgJycpO1xufTtcblxuY29uc3QgZ2V0Qnl0ZVN0cmluZ0Zyb21CYXNlNjREYXRhVVJJID0gZGF0YVVSSSA9PiB7XG4gICAgcmV0dXJuIGF0b2IoZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpKTtcbn07XG5cbmNvbnN0IGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSSA9IGRhdGFVUkkgPT4ge1xuICAgIGNvbnN0IG1pbWVUeXBlID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcbiAgICBjb25zdCBieXRlU3RyaW5nID0gZ2V0Qnl0ZVN0cmluZ0Zyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpO1xuXG4gICAgcmV0dXJuIGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZShieXRlU3RyaW5nLCBtaW1lVHlwZSk7XG59O1xuXG5jb25zdCBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkgPSAoZGF0YVVSSSwgZmlsZW5hbWUsIGV4dGVuc2lvbikgPT4ge1xuICAgIHJldHVybiBnZXRGaWxlRnJvbUJsb2IoZ2V0QmxvYkZyb21CYXNlNjREYXRhVVJJKGRhdGFVUkkpLCBmaWxlbmFtZSwgbnVsbCwgZXh0ZW5zaW9uKTtcbn07XG5cbmNvbnN0IGdldEZpbGVOYW1lRnJvbUhlYWRlciA9IGhlYWRlciA9PiB7XG4gICAgLy8gdGVzdCBpZiBpcyBjb250ZW50IGRpc3Bvc2l0aW9uIGhlYWRlciwgaWYgbm90IGV4aXRcbiAgICBpZiAoIS9eY29udGVudC1kaXNwb3NpdGlvbjovaS50ZXN0KGhlYWRlcikpIHJldHVybiBudWxsO1xuXG4gICAgLy8gZ2V0IGZpbGVuYW1lIHBhcnRzXG4gICAgY29uc3QgbWF0Y2hlcyA9IGhlYWRlclxuICAgICAgICAuc3BsaXQoL2ZpbGVuYW1lPXxmaWxlbmFtZVxcKj0uKycnLylcbiAgICAgICAgLnNwbGljZSgxKVxuICAgICAgICAubWFwKG5hbWUgPT4gbmFtZS50cmltKCkucmVwbGFjZSgvXltcIiddfFs7XCInXXswLDJ9JC9nLCAnJykpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLmxlbmd0aCk7XG5cbiAgICByZXR1cm4gbWF0Y2hlcy5sZW5ndGggPyBkZWNvZGVVUkkobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdKSA6IG51bGw7XG59O1xuXG5jb25zdCBnZXRGaWxlU2l6ZUZyb21IZWFkZXIgPSBoZWFkZXIgPT4ge1xuICAgIGlmICgvY29udGVudC1sZW5ndGg6L2kudGVzdChoZWFkZXIpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBoZWFkZXIubWF0Y2goL1swLTldKy8pWzBdO1xuICAgICAgICByZXR1cm4gc2l6ZSA/IHBhcnNlSW50KHNpemUsIDEwKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIgPSBoZWFkZXIgPT4ge1xuICAgIGlmICgveC1jb250ZW50LXRyYW5zZmVyLWlkOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICBjb25zdCBpZCA9IChoZWFkZXIuc3BsaXQoJzonKVsxXSB8fCAnJykudHJpbSgpO1xuICAgICAgICByZXR1cm4gaWQgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzID0gaGVhZGVycyA9PiB7XG4gICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICBzaXplOiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCByb3dzID0gaGVhZGVycy5zcGxpdCgnXFxuJyk7XG4gICAgZm9yIChsZXQgaGVhZGVyIG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldEZpbGVOYW1lRnJvbUhlYWRlcihoZWFkZXIpO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgaW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGdldEZpbGVTaXplRnJvbUhlYWRlcihoZWFkZXIpO1xuICAgICAgICBpZiAoc2l6ZSkge1xuICAgICAgICAgICAgaW5mby5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc291cmNlID0gZ2V0VHJhbmZzZXJJZEZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaW5mby5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xufTtcblxuY29uc3QgY3JlYXRlRmlsZUxvYWRlciA9IGZldGNoRm4gPT4ge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIHNpemU6IG51bGwsXG4gICAgICAgIHRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IGdldFByb2dyZXNzID0gKCkgPT4gc3RhdGUucHJvZ3Jlc3M7XG4gICAgY29uc3QgYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZXF1ZXN0ICYmIHN0YXRlLnJlcXVlc3QuYWJvcnQpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2FkIHNvdXJjZVxuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VcbiAgICAgICAgY29uc3Qgc291cmNlID0gc3RhdGUuc291cmNlO1xuXG4gICAgICAgIGFwaS5maXJlKCdpbml0Jywgc291cmNlKTtcblxuICAgICAgICAvLyBMb2FkIEZpbGVzXG4gICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICAgICAgLy8gTG9hZCBibG9icywgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgZ2V0RmlsZUZyb21CbG9iKHNvdXJjZSwgc291cmNlLm5hbWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICAgICAgLy8gTG9hZCBiYXNlIDY0LCBzZXQgZGVmYXVsdCBuYW1lIHRvIGN1cnJlbnQgZGF0ZVxuICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkoc291cmNlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWFsIGFzIGlmIGlzIGV4dGVybmFsIFVSTCwgbGV0J3MgbG9hZCBpdCFcbiAgICAgICAgICAgIGxvYWRVUkwoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBsb2FkcyBhIHVybFxuICAgIGNvbnN0IGxvYWRVUkwgPSB1cmwgPT4ge1xuICAgICAgICAvLyBpcyByZW1vdGUgdXJsIGFuZCBubyBmZXRjaCBtZXRob2Qgc3VwcGxpZWRcbiAgICAgICAgaWYgKCFmZXRjaEZuKSB7XG4gICAgICAgICAgICBhcGkuZmlyZSgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBib2R5OiBcIkNhbid0IGxvYWQgVVJMXCIsXG4gICAgICAgICAgICAgICAgY29kZTogNDAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgICBzdGF0ZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIGxvYWQgZmlsZVxuICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gZmV0Y2hGbihcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIHR1cm4gYmxvYiByZXNwb25zZSBpbnRvIGEgZmlsZVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBnZXRGaWxlRnJvbUJsb2IocmVzcG9uc2UsIHJlc3BvbnNlLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGhhcyByZWNlaXZlZCBibG9iLCB3ZSBnbyB3aXRoIGJsb2IsIGlmIG5vIHJlc3BvbnNlLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSBpbnN0YW5jZW9mIEJsb2IgPyByZXNwb25zZSA6IHJlc3BvbnNlID8gcmVzcG9uc2UuYm9keSA6IG51bGxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoY29tcHV0YWJsZSwgY3VycmVudCwgdG90YWwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0ZWQgc29tZSBtZXRhIGRhdGEgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zaXplID0gdG90YWw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSBwcm9ncmVzcywgd2UncmUgbm90IGdvaW5nIHRvIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwcm9ncmVzcyBwZXJjZW50YWdlXG4gICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjdXJyZW50IC8gdG90YWw7XG5cbiAgICAgICAgICAgICAgICAvLyBleHBvc2VcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgncHJvZ3Jlc3MnLCBzdGF0ZS5wcm9ncmVzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdhYm9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlaW5mbyA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNwb25zZSA9PT0gJ3N0cmluZycgPyByZXNwb25zZSA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdtZXRhJywge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0ZS5zaXplIHx8IGZpbGVpbmZvLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlaW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZpbGVpbmZvLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICAuLi5vbigpLFxuICAgICAgICBzZXRTb3VyY2U6IHNvdXJjZSA9PiAoc3RhdGUuc291cmNlID0gc291cmNlKSxcbiAgICAgICAgZ2V0UHJvZ3Jlc3MsIC8vIGZpbGUgbG9hZCBwcm9ncmVzc1xuICAgICAgICBhYm9ydCwgLy8gYWJvcnQgZmlsZSBsb2FkXG4gICAgICAgIGxvYWQsIC8vIHN0YXJ0IGxvYWRcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbmNvbnN0IGlzR2V0ID0gbWV0aG9kID0+IC9HRVR8SEVBRC8udGVzdChtZXRob2QpO1xuXG5jb25zdCBzZW5kUmVxdWVzdCA9IChkYXRhLCB1cmwsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIG9uaGVhZGVyczogKCkgPT4ge30sXG4gICAgICAgIG9ucHJvZ3Jlc3M6ICgpID0+IHt9LFxuICAgICAgICBvbmxvYWQ6ICgpID0+IHt9LFxuICAgICAgICBvbnRpbWVvdXQ6ICgpID0+IHt9LFxuICAgICAgICBvbmVycm9yOiAoKSA9PiB7fSxcbiAgICAgICAgb25hYm9ydDogKCkgPT4ge30sXG4gICAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyB0aW1lb3V0IGlkZW50aWZpZXIsIG9ubHkgdXNlZCB3aGVuIHRpbWVvdXQgaXMgZGVmaW5lZFxuICAgIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gICAgbGV0IGhlYWRlcnNSZWNlaXZlZCA9IGZhbHNlO1xuXG4gICAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gZW5jb2RlIHVybFxuICAgIHVybCA9IGVuY29kZVVSSSh1cmwpO1xuXG4gICAgLy8gaWYgbWV0aG9kIGlzIEdFVCwgYWRkIGFueSByZWNlaXZlZCBkYXRhIHRvIHVybFxuXG4gICAgaWYgKGlzR2V0KG9wdGlvbnMubWV0aG9kKSAmJiBkYXRhKSB7XG4gICAgICAgIHVybCA9IGAke3VybH0ke2VuY29kZVVSSUNvbXBvbmVudCh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogSlNPTi5zdHJpbmdpZnkoZGF0YSkpfWA7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHJlcXVlc3RcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIHByb2dyZXNzIG9mIGxvYWRcbiAgICBjb25zdCBwcm9jZXNzID0gaXNHZXQob3B0aW9ucy5tZXRob2QpID8geGhyIDogeGhyLnVwbG9hZDtcbiAgICBwcm9jZXNzLm9ucHJvZ3Jlc3MgPSBlID0+IHtcbiAgICAgICAgLy8gbm8gcHJvZ3Jlc3MgZXZlbnQgd2hlbiBhYm9ydGVkICggb25wcm9ncmVzcyBpcyBjYWxsZWQgb25jZSBhZnRlciBhYm9ydCgpIClcbiAgICAgICAgaWYgKGFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwaS5vbnByb2dyZXNzKGUubGVuZ3RoQ29tcHV0YWJsZSwgZS5sb2FkZWQsIGUudG90YWwpO1xuICAgIH07XG5cbiAgICAvLyB0cmllcyB0byBnZXQgaGVhZGVyIGluZm8gdG8gdGhlIGFwcCBhcyBmYXN0IGFzIHBvc3NpYmxlXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgLy8gbm90IGludGVyZXN0aW5nIGluIHRoZXNlIHN0YXRlcyAoJ3Vuc2VudCcgYW5kICdvcGVuZW5kJyBhcyB0aGV5IGRvbid0IGdpdmUgdXMgYW55IGFkZGl0aW9uYWwgaW5mbylcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gc2VydmVyIHJlc3BvbnNlXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVhZGVyc1JlY2VpdmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJzUmVjZWl2ZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIHdlJ3ZlIHByb2JhYmx5IHJlY2VpdmVkIHNvbWUgdXNlZnVsIGRhdGEgaW4gcmVzcG9uc2UgaGVhZGVyc1xuICAgICAgICBhcGkub25oZWFkZXJzKHhocik7XG4gICAgfTtcblxuICAgIC8vIGxvYWQgc3VjY2Vzc2Z1bFxuICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIGlzIGNsYXNzaWZpZWQgYXMgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgIGFwaS5vbmxvYWQoeGhyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwaS5vbmVycm9yKHhocik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZXJyb3IgZHVyaW5nIGxvYWRcbiAgICB4aHIub25lcnJvciA9ICgpID0+IGFwaS5vbmVycm9yKHhocik7XG5cbiAgICAvLyByZXF1ZXN0IGFib3J0ZWRcbiAgICB4aHIub25hYm9ydCA9ICgpID0+IHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGFwaS5vbmFib3J0KCk7XG4gICAgfTtcblxuICAgIC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHhoci5vbnRpbWVvdXQgPSAoKSA9PiBhcGkub250aW1lb3V0KHhocik7XG5cbiAgICAvLyBvcGVuIHVwIG9wZW4gdXAhXG4gICAgeGhyLm9wZW4ob3B0aW9ucy5tZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICAvLyBzZXQgdGltZW91dCBpZiBkZWZpbmVkIChkbyBpdCBhZnRlciBvcGVuIHNvIElFMTEgcGxheXMgYmFsbClcbiAgICBpZiAoaXNJbnQob3B0aW9ucy50aW1lb3V0KSkge1xuICAgICAgICB4aHIudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBhZGQgaGVhZGVyc1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLmhlYWRlcnNba2V5XSkpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8vIHNldCB0eXBlIG9mIHJlc3BvbnNlXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBzZXQgY3JlZGVudGlhbHNcbiAgICBpZiAob3B0aW9ucy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gbGV0J3Mgc2VuZCBvdXIgZGF0YVxuICAgIHhoci5zZW5kKGRhdGEpO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbmNvbnN0IGNyZWF0ZVJlc3BvbnNlID0gKHR5cGUsIGNvZGUsIGJvZHksIGhlYWRlcnMpID0+ICh7XG4gICAgdHlwZSxcbiAgICBjb2RlLFxuICAgIGJvZHksXG4gICAgaGVhZGVycyxcbn0pO1xuXG5jb25zdCBjcmVhdGVUaW1lb3V0UmVzcG9uc2UgPSBjYiA9PiB4aHIgPT4ge1xuICAgIGNiKGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdUaW1lb3V0JywgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG59O1xuXG5jb25zdCBoYXNRUyA9IHN0ciA9PiAvXFw/Ly50ZXN0KHN0cik7XG5jb25zdCBidWlsZFVSTCA9ICguLi5wYXJ0cykgPT4ge1xuICAgIGxldCB1cmwgPSAnJztcbiAgICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgICAgICB1cmwgKz0gaGFzUVModXJsKSAmJiBoYXNRUyhwYXJ0KSA/IHBhcnQucmVwbGFjZSgvXFw/LywgJyYnKSA6IHBhcnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHVybDtcbn07XG5cbmNvbnN0IGNyZWF0ZUZldGNoRnVuY3Rpb24gPSAoYXBpVXJsID0gJycsIGFjdGlvbikgPT4ge1xuICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8vIG5vIGFjdGlvbiBzdXBwbGllZFxuICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgb25sb2FkIGhhbmxkZXJcbiAgICBjb25zdCBvbmxvYWQgPSBhY3Rpb24ub25sb2FkIHx8IChyZXMgPT4gcmVzKTtcbiAgICBjb25zdCBvbmVycm9yID0gYWN0aW9uLm9uZXJyb3IgfHwgKHJlcyA9PiBudWxsKTtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gKHVybCwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgaGVhZGVycykgPT4ge1xuICAgICAgICAvLyBkbyBsb2NhbCBvciByZW1vdGUgcmVxdWVzdCBiYXNlZCBvbiBpZiB0aGUgdXJsIGlzIGV4dGVybmFsXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZW5kUmVxdWVzdCh1cmwsIGJ1aWxkVVJMKGFwaVVybCwgYWN0aW9uLnVybCksIHtcbiAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IHhociA9PiB7XG4gICAgICAgICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAgICAgLy8gZ2V0IGZpbGVuYW1lXG4gICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgICAgICBsb2FkKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnbG9hZCcsXG4gICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5tZXRob2QgPT09ICdIRUFEJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGdldEZpbGVGcm9tQmxvYihvbmxvYWQoeGhyLnJlc3BvbnNlKSwgZmlsZW5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IHhociA9PiB7XG4gICAgICAgICAgICBoZWFkZXJzKGNyZWF0ZVJlc3BvbnNlKCdoZWFkZXJzJywgeGhyLnN0YXR1cywgbnVsbCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAgICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG59O1xuXG5jb25zdCBDaHVua1N0YXR1cyA9IHtcbiAgICBRVUVVRUQ6IDAsXG4gICAgQ09NUExFVEU6IDEsXG4gICAgUFJPQ0VTU0lORzogMixcbiAgICBFUlJPUjogMyxcbiAgICBXQUlUSU5HOiA0LFxufTtcblxuLypcbmZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgYWJvcnQ6KCkgPT4ge31cbiAgfVxufVxuKi9cblxuLy8gYXBpVXJsLCBhY3Rpb24sIG5hbWUsIGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2Zlciwgb3B0aW9uc1xuY29uc3QgcHJvY2Vzc0ZpbGVDaHVua2VkID0gKFxuICAgIGFwaVVybCxcbiAgICBhY3Rpb24sXG4gICAgbmFtZSxcbiAgICBmaWxlLFxuICAgIG1ldGFkYXRhLFxuICAgIGxvYWQsXG4gICAgZXJyb3IsXG4gICAgcHJvZ3Jlc3MsXG4gICAgYWJvcnQsXG4gICAgdHJhbnNmZXIsXG4gICAgb3B0aW9uc1xuKSA9PiB7XG4gICAgLy8gYWxsIGNodW5rc1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGNvbnN0IHsgY2h1bmtUcmFuc2ZlcklkLCBjaHVua1NlcnZlciwgY2h1bmtTaXplLCBjaHVua1JldHJ5RGVsYXlzIH0gPSBvcHRpb25zO1xuXG4gICAgLy8gZGVmYXVsdCBzdGF0ZVxuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBzZXJ2ZXJJZDogY2h1bmtUcmFuc2ZlcklkLFxuICAgICAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5kbGVyc1xuICAgIGNvbnN0IG9uZGF0YSA9IGFjdGlvbi5vbmRhdGEgfHwgKGZkID0+IGZkKTtcbiAgICBjb25zdCBvbmxvYWQgPVxuICAgICAgICBhY3Rpb24ub25sb2FkIHx8XG4gICAgICAgICgoeGhyLCBtZXRob2QpID0+XG4gICAgICAgICAgICBtZXRob2QgPT09ICdIRUFEJyA/IHhoci5nZXRSZXNwb25zZUhlYWRlcignVXBsb2FkLU9mZnNldCcpIDogeGhyLnJlc3BvbnNlKTtcbiAgICBjb25zdCBvbmVycm9yID0gYWN0aW9uLm9uZXJyb3IgfHwgKHJlcyA9PiBudWxsKTtcblxuICAgIC8vIGNyZWF0ZSBzZXJ2ZXIgaG9va1xuICAgIGNvbnN0IHJlcXVlc3RUcmFuc2ZlcklkID0gY2IgPT4ge1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICAgICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkgZm9ybURhdGEuYXBwZW5kKG5hbWUsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9XG4gICAgICAgICAgICB0eXBlb2YgYWN0aW9uLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKGZpbGUsIG1ldGFkYXRhKVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uYWN0aW9uLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZW5kUmVxdWVzdChvbmRhdGEoZm9ybURhdGEpLCBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLCByZXF1ZXN0UGFyYW1zKTtcblxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IHhociA9PiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHhociA9PlxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlcXVlc3RUcmFuc2Zlck9mZnNldCA9IGNiID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFVybCA9IGJ1aWxkVVJMKGFwaVVybCwgY2h1bmtTZXJ2ZXIudXJsLCBzdGF0ZS5zZXJ2ZXJJZCk7XG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9XG4gICAgICAgICAgICB0eXBlb2YgYWN0aW9uLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGFjdGlvbi5oZWFkZXJzKHN0YXRlLnNlcnZlcklkKVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbi5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIG1ldGhvZDogJ0hFQUQnLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzZW5kUmVxdWVzdChudWxsLCByZXF1ZXN0VXJsLCByZXF1ZXN0UGFyYW1zKTtcblxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IHhociA9PiBjYihvbmxvYWQoeGhyLCByZXF1ZXN0UGFyYW1zLm1ldGhvZCkpO1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHhociA9PlxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBjaHVua3NcbiAgICBjb25zdCBsYXN0Q2h1bmtJbmRleCA9IE1hdGguZmxvb3IoZmlsZS5zaXplIC8gY2h1bmtTaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0Q2h1bmtJbmRleDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGkgKiBjaHVua1NpemU7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBmaWxlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtTaXplLCAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpO1xuICAgICAgICBjaHVua3NbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHNpemU6IGRhdGEuc2l6ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgICAgICByZXRyaWVzOiBbLi4uY2h1bmtSZXRyeURlbGF5c10sXG4gICAgICAgICAgICBzdGF0dXM6IENodW5rU3RhdHVzLlFVRVVFRCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgICAgICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzID0gKCkgPT4gbG9hZChzdGF0ZS5zZXJ2ZXJJZCk7XG5cbiAgICBjb25zdCBjYW5Qcm9jZXNzQ2h1bmsgPSBjaHVuayA9PlxuICAgICAgICBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlFVRVVFRCB8fCBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLkVSUk9SO1xuXG4gICAgY29uc3QgcHJvY2Vzc0NodW5rID0gY2h1bmsgPT4ge1xuICAgICAgICAvLyBwcm9jZXNzaW5nIGlzIHBhdXNlZCwgd2FpdCBoZXJlXG4gICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgLy8gZ2V0IG5leHQgY2h1bmsgdG8gcHJvY2Vzc1xuICAgICAgICBjaHVuayA9IGNodW5rIHx8IGNodW5rcy5maW5kKGNhblByb2Nlc3NDaHVuayk7XG5cbiAgICAgICAgLy8gbm8gbW9yZSBjaHVua3MgdG8gcHJvY2Vzc1xuICAgICAgICBpZiAoIWNodW5rKSB7XG4gICAgICAgICAgICAvLyBhbGwgZG9uZT9cbiAgICAgICAgICAgIGlmIChjaHVua3MuZXZlcnkoY2h1bmsgPT4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5DT01QTEVURSkpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVByb2Nlc3NpbmdDaHVua3MoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gY2h1bmsgdG8gaGFuZGxlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgcHJvY2Vzc2luZyB0aGlzIGNodW5rXG4gICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLlBST0NFU1NJTkc7XG4gICAgICAgIGNodW5rLnByb2dyZXNzID0gbnVsbDtcblxuICAgICAgICAvLyBhbGxvdyBwYXJzaW5nIG9mIGZvcm1kYXRhXG4gICAgICAgIGNvbnN0IG9uZGF0YSA9IGNodW5rU2VydmVyLm9uZGF0YSB8fCAoZmQgPT4gZmQpO1xuICAgICAgICBjb25zdCBvbmVycm9yID0gY2h1bmtTZXJ2ZXIub25lcnJvciB8fCAocmVzID0+IG51bGwpO1xuICAgICAgICBjb25zdCBvbmxvYWQgPSBjaHVua1NlcnZlci5vbmxvYWQgfHwgKCgpID0+IHt9KTtcblxuICAgICAgICAvLyBzZW5kIHJlcXVlc3Qgb2JqZWN0XG4gICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBidWlsZFVSTChhcGlVcmwsIGNodW5rU2VydmVyLnVybCwgc3RhdGUuc2VydmVySWQpO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICAgICAgdHlwZW9mIGNodW5rU2VydmVyLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGNodW5rU2VydmVyLmhlYWRlcnMoY2h1bmspXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uY2h1bmtTZXJ2ZXIuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogY2h1bmsub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICdVcGxvYWQtTmFtZSc6IGZpbGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IChjaHVuay5yZXF1ZXN0ID0gc2VuZFJlcXVlc3Qob25kYXRhKGNodW5rLmRhdGEpLCByZXF1ZXN0VXJsLCB7XG4gICAgICAgICAgICAuLi5jaHVua1NlcnZlcixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IHhociA9PiB7XG4gICAgICAgICAgICAvLyBhbGxvdyBob29raW5nIGludG8gcmVxdWVzdCByZXN1bHRcbiAgICAgICAgICAgIG9ubG9hZCh4aHIsIGNodW5rLmluZGV4LCBjaHVua3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgcmVxdWVzdCByZWZlcmVuY2VcbiAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIG1vcmUgY2h1bmtzXG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gKGxlbmd0aENvbXB1dGFibGUsIGxvYWRlZCwgdG90YWwpID0+IHtcbiAgICAgICAgICAgIGNodW5rLnByb2dyZXNzID0gbGVuZ3RoQ29tcHV0YWJsZSA/IGxvYWRlZCA6IG51bGw7XG4gICAgICAgICAgICB1cGRhdGVUb3RhbFByb2dyZXNzKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICBjaHVuay5lcnJvciA9IG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGlmICghcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSB4aHIgPT4ge1xuICAgICAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghcmV0cnlQcm9jZXNzQ2h1bmsoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKSh4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25hYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLlFVRVVFRDtcbiAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmV0cnlQcm9jZXNzQ2h1bmsgPSBjaHVuayA9PiB7XG4gICAgICAgIC8vIG5vIG1vcmUgcmV0cmllcyBsZWZ0XG4gICAgICAgIGlmIChjaHVuay5yZXRyaWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIG5ldyByZXRyeVxuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5XQUlUSU5HO1xuICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmsudGltZW91dCk7XG4gICAgICAgIGNodW5rLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0sIGNodW5rLnJldHJpZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gcmV0cnlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZVRvdGFsUHJvZ3Jlc3MgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCBwcm9ncmVzcyBmcmFjdGlvblxuICAgICAgICBjb25zdCB0b3RhbEJ5dGVzVHJhbnNmZXJlZCA9IGNodW5rcy5yZWR1Y2UoKHAsIGNodW5rKSA9PiB7XG4gICAgICAgICAgICBpZiAocCA9PT0gbnVsbCB8fCBjaHVuay5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcCArIGNodW5rLnByb2dyZXNzO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICAvLyBjYW4ndCBjb21wdXRlIHByb2dyZXNzXG4gICAgICAgIGlmICh0b3RhbEJ5dGVzVHJhbnNmZXJlZCA9PT0gbnVsbCkgcmV0dXJuIHByb2dyZXNzKGZhbHNlLCAwLCAwKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcHJvZ3Jlc3MgdmFsdWVzXG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IGNodW5rcy5yZWR1Y2UoKHRvdGFsLCBjaHVuaykgPT4gdG90YWwgKyBjaHVuay5zaXplLCAwKTtcblxuICAgICAgICAvLyBjYW4gdXBkYXRlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgICBwcm9ncmVzcyh0cnVlLCB0b3RhbEJ5dGVzVHJhbnNmZXJlZCwgdG90YWxTaXplKTtcbiAgICB9O1xuXG4gICAgLy8gcHJvY2VzcyBuZXcgY2h1bmtzXG4gICAgY29uc3QgcHJvY2Vzc0NodW5rcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWxQcm9jZXNzaW5nID0gY2h1bmtzLmZpbHRlcihjaHVuayA9PiBjaHVuay5zdGF0dXMgPT09IENodW5rU3RhdHVzLlBST0NFU1NJTkcpXG4gICAgICAgICAgICAubGVuZ3RoO1xuICAgICAgICBpZiAodG90YWxQcm9jZXNzaW5nID49IDEpIHJldHVybjtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFib3J0Q2h1bmtzID0gKCkgPT4ge1xuICAgICAgICBjaHVua3MuZm9yRWFjaChjaHVuayA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmsudGltZW91dCk7XG4gICAgICAgICAgICBpZiAoY2h1bmsucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNodW5rLnJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGxldCdzIGdvIVxuICAgIGlmICghc3RhdGUuc2VydmVySWQpIHtcbiAgICAgICAgcmVxdWVzdFRyYW5zZmVySWQoc2VydmVySWQgPT4ge1xuICAgICAgICAgICAgLy8gc3RvcCBoZXJlIGlmIGFib3J0ZWQsIG1pZ2h0IGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiByZXF1ZXN0IGFuZCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFib3J0ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gcGFzcyBiYWNrIHRvIGl0ZW0gc28gd2UgY2FuIHVzZSBpdCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgICAgICAgdHJhbnNmZXIoc2VydmVySWQpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBpbnRlcm5hbGx5XG4gICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJJZCA9IHNlcnZlcklkO1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0VHJhbnNmZXJPZmZzZXQob2Zmc2V0ID0+IHtcbiAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG1hcmsgY2h1bmtzIHdpdGggbG93ZXIgb2Zmc2V0IGFzIGNvbXBsZXRlXG4gICAgICAgICAgICBjaHVua3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGNodW5rID0+IGNodW5rLm9mZnNldCA8IG9mZnNldClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGNodW5rLnNpemU7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWJvcnQ6ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYWJvcnRDaHVua3MoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuLypcbmZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgKGZpbGUsIG1ldGFkYXRhLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICBhYm9ydDooKSA9PiB7fVxuICB9XG59XG4qL1xuY29uc3QgY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uID0gKGFwaVVybCwgYWN0aW9uLCBuYW1lLCBvcHRpb25zKSA9PiAoXG4gICAgZmlsZSxcbiAgICBtZXRhZGF0YSxcbiAgICBsb2FkLFxuICAgIGVycm9yLFxuICAgIHByb2dyZXNzLFxuICAgIGFib3J0LFxuICAgIHRyYW5zZmVyXG4pID0+IHtcbiAgICAvLyBubyBmaWxlIHJlY2VpdmVkXG4gICAgaWYgKCFmaWxlKSByZXR1cm47XG5cbiAgICAvLyBpZiB3YXMgcGFzc2VkIGEgZmlsZSwgYW5kIHdlIGNhbiBjaHVuayBpdCwgZXhpdCBoZXJlXG4gICAgY29uc3QgY2FuQ2h1bmtVcGxvYWQgPSBvcHRpb25zLmNodW5rVXBsb2FkcztcbiAgICBjb25zdCBzaG91bGRDaHVua1VwbG9hZCA9IGNhbkNodW5rVXBsb2FkICYmIGZpbGUuc2l6ZSA+IG9wdGlvbnMuY2h1bmtTaXplO1xuICAgIGNvbnN0IHdpbGxDaHVua1VwbG9hZCA9IGNhbkNodW5rVXBsb2FkICYmIChzaG91bGRDaHVua1VwbG9hZCB8fCBvcHRpb25zLmNodW5rRm9yY2UpO1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYiAmJiB3aWxsQ2h1bmtVcGxvYWQpXG4gICAgICAgIHJldHVybiBwcm9jZXNzRmlsZUNodW5rZWQoXG4gICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbG9hZCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgIHRyYW5zZmVyLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgLy8gc2V0IGhhbmRsZXJzXG4gICAgY29uc3Qgb25kYXRhID0gYWN0aW9uLm9uZGF0YSB8fCAoZmQgPT4gZmQpO1xuICAgIGNvbnN0IG9ubG9hZCA9IGFjdGlvbi5vbmxvYWQgfHwgKHJlcyA9PiByZXMpO1xuICAgIGNvbnN0IG9uZXJyb3IgPSBhY3Rpb24ub25lcnJvciB8fCAocmVzID0+IG51bGwpO1xuXG4gICAgY29uc3QgaGVhZGVycyA9XG4gICAgICAgIHR5cGVvZiBhY3Rpb24uaGVhZGVycyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhmaWxlLCBtZXRhZGF0YSkgfHwge31cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgLi4uYWN0aW9uLmhlYWRlcnMsXG4gICAgICAgICAgICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgIGhlYWRlcnMsXG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBmb3JtZGF0YSBvYmplY3RcbiAgICB2YXIgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgIC8vIGFkZCBtZXRhZGF0YSB1bmRlciBzYW1lIG5hbWVcbiAgICBpZiAoaXNPYmplY3QobWV0YWRhdGEpKSB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIFR1cm4gaW50byBhbiBhcnJheSBvZiBvYmplY3RzIHNvIG5vIG1hdHRlciB3aGF0IHRoZSBpbnB1dCwgd2UgY2FuIGhhbmRsZSBpdCB0aGUgc2FtZSB3YXlcbiAgICAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgPyBbeyBuYW1lOiBudWxsLCBmaWxlIH1dIDogZmlsZSkuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGl0ZW0uZmlsZSxcbiAgICAgICAgICAgIGl0ZW0ubmFtZSA9PT0gbnVsbCA/IGl0ZW0uZmlsZS5uYW1lIDogYCR7aXRlbS5uYW1lfSR7aXRlbS5maWxlLm5hbWV9YFxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgIGNvbnN0IHJlcXVlc3QgPSBzZW5kUmVxdWVzdChvbmRhdGEoZm9ybURhdGEpLCBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLCByZXF1ZXN0UGFyYW1zKTtcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IHhociA9PiB7XG4gICAgICAgIGxvYWQoY3JlYXRlUmVzcG9uc2UoJ2xvYWQnLCB4aHIuc3RhdHVzLCBvbmxvYWQoeGhyLnJlc3BvbnNlKSwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25lcnJvciA9IHhociA9PiB7XG4gICAgICAgIGVycm9yKFxuICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5jb25zdCBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbiA9IChhcGlVcmwgPSAnJywgYWN0aW9uLCBuYW1lLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gY3VzdG9tIGhhbmRsZXIgKHNob3VsZCBhbHNvIGhhbmRsZSBmaWxlLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MgYW5kIGFib3J0KVxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSByZXR1cm4gKC4uLnBhcmFtcykgPT4gYWN0aW9uKG5hbWUsIC4uLnBhcmFtcywgb3B0aW9ucyk7XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHJldHVybiBudWxsO1xuXG4gICAgLy8gaW50ZXJuYWwgaGFuZGxlclxuICAgIHJldHVybiBjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24oYXBpVXJsLCBhY3Rpb24sIG5hbWUsIG9wdGlvbnMpO1xufTtcblxuLypcbiBmdW5jdGlvbiBzaWduYXR1cmU6XG4gKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHsgfVxuICovXG5jb25zdCBjcmVhdGVSZXZlcnRGdW5jdGlvbiA9IChhcGlVcmwgPSAnJywgYWN0aW9uKSA9PiB7XG4gICAgLy8gaXMgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWQsIHJldHVybiBzdHViIGZ1bmN0aW9uLCBpbnRlcmZhY2Ugd2lsbCB3b3JrLCBidXQgZmlsZSB3b24ndCBiZSByZW1vdmVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSB7XG4gICAgICAgIHJldHVybiAodW5pcXVlRmlsZUlkLCBsb2FkKSA9PiBsb2FkKCk7XG4gICAgfVxuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5sZGVyXG4gICAgY29uc3Qgb25sb2FkID0gYWN0aW9uLm9ubG9hZCB8fCAocmVzID0+IHJlcyk7XG4gICAgY29uc3Qgb25lcnJvciA9IGFjdGlvbi5vbmVycm9yIHx8IChyZXMgPT4gbnVsbCk7XG5cbiAgICAvLyBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybiAodW5pcXVlRmlsZUlkLCBsb2FkLCBlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3QoXG4gICAgICAgICAgICB1bmlxdWVGaWxlSWQsXG4gICAgICAgICAgICBhcGlVcmwgKyBhY3Rpb24udXJsLFxuICAgICAgICAgICAgYWN0aW9uIC8vIGNvbnRhaW5zIG1ldGhvZCwgaGVhZGVycyBhbmQgd2l0aENyZWRlbnRpYWxzIHByb3BlcnRpZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICAgICAgbG9hZChcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKSxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIG9uZXJyb3IoeGhyLnJlc3BvbnNlKSB8fCB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfTtcbn07XG5cbmNvbnN0IGdldFJhbmRvbU51bWJlciA9IChtaW4gPSAwLCBtYXggPSAxKSA9PiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XG5cbmNvbnN0IGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IChcbiAgICBjYixcbiAgICBkdXJhdGlvbiA9IDEwMDAsXG4gICAgb2Zmc2V0ID0gMCxcbiAgICB0aWNrTWluID0gMjUsXG4gICAgdGlja01heCA9IDI1MFxuKSA9PiB7XG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICAgIGxldCBydW50aW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICBsZXQgZGVsYXkgPSBnZXRSYW5kb21OdW1iZXIodGlja01pbiwgdGlja01heCk7XG5cbiAgICAgICAgaWYgKHJ1bnRpbWUgKyBkZWxheSA+IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICBkZWxheSA9IHJ1bnRpbWUgKyBkZWxheSAtIGR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByb2dyZXNzID0gcnVudGltZSAvIGR1cmF0aW9uO1xuICAgICAgICBpZiAocHJvZ3Jlc3MgPj0gMSB8fCBkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIGNiKDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IocHJvZ3Jlc3MpO1xuXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIGRlbGF5KTtcbiAgICB9O1xuXG4gICAgaWYgKGR1cmF0aW9uID4gMCkgdGljaygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xlYXI6ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlRmlsZVByb2Nlc3NvciA9IChwcm9jZXNzRm4sIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICBwZXJjZWl2ZWRQcm9ncmVzczogMCxcbiAgICAgICAgcGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyOiBudWxsLFxuICAgICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgICAgdGltZXN0YW1wOiBudWxsLFxuICAgICAgICBwZXJjZWl2ZWREdXJhdGlvbjogMCxcbiAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgIHJlc3BvbnNlOiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCB7IGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uIH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgcHJvY2VzcyA9IChmaWxlLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9ncmVzc0ZuID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UndmUgbm90IHlldCBzdGFydGVkIHRoZSByZWFsIGRvd25sb2FkLCBzdG9wIGhlcmVcbiAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IG1pZ2h0IG5vdCBnbyB0aHJvdWdoLCBmb3IgaW5zdGFuY2UsIHRoZXJlIG1pZ2h0IGJlIHNvbWUgc2VydmVyIHRyb3VibGVcbiAgICAgICAgICAgIC8vIGlmIHN0YXRlLnByb2dyZXNzIGlzIG51bGwsIHRoZSBzZXJ2ZXIgZG9lcyBub3QgYWxsb3cgY29tcHV0aW5nIHByb2dyZXNzIGFuZCB3ZSBzaG93IHRoZSBzcGlubmVyIGluc3RlYWRcbiAgICAgICAgICAgIGlmIChzdGF0ZS5kdXJhdGlvbiA9PT0gMCB8fCBzdGF0ZS5wcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBhcyB3ZSdyZSBub3cgcHJvY2Vzc2luZywgZmlyZSB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICAgIGFwaS5maXJlKCdwcm9ncmVzcycsIGFwaS5nZXRQcm9ncmVzcygpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjb21wbGV0ZUZuID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQtcGVyY2VpdmVkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbGV0J3Mgc3RhcnQgcHJvY2Vzc2luZ1xuICAgICAgICBhcGkuZmlyZSgnc3RhcnQnKTtcblxuICAgICAgICAvLyBzZXQgcmVxdWVzdCBzdGFydFxuICAgICAgICBzdGF0ZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBwZXJjZWl2ZWQgcGVyZm9ybWFuY2UgcHJvZ3Jlc3MgaW5kaWNhdG9yXG4gICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciA9IGNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcihcbiAgICAgICAgICAgIHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgIHByb2dyZXNzRm4oKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGZha2UgcHJvZ3Jlc3MgaXMgZG9uZSwgYW5kIGEgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsXG4gICAgICAgICAgICAgICAgLy8gYW5kIHdlJ3ZlIG5vdCB5ZXQgY2FsbGVkIHRoZSBjb21wbGV0ZSBtZXRob2RcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUucmVzcG9uc2UgJiYgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEgJiYgIXN0YXRlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcmFuZG9tIGRlbGF5IGFzIGluIGEgbGlzdCBvZiBmaWxlcyB5b3Ugc3RhcnQgbm90aWNpbmdcbiAgICAgICAgICAgIC8vIGZpbGVzIHVwbG9hZGluZyBhdCB0aGUgZXhhY3Qgc2FtZSBzcGVlZFxuICAgICAgICAgICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gPyBnZXRSYW5kb21OdW1iZXIoNzUwLCAxNTAwKSA6IDBcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZW1lbWJlciByZXF1ZXN0IHNvIHdlIGNhbiBhYm9ydCBpdCBsYXRlclxuICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gcHJvY2Vzc0ZuKFxuICAgICAgICAgICAgLy8gdGhlIGZpbGUgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgZmlsZSxcblxuICAgICAgICAgICAgLy8gdGhlIG1ldGFkYXRhIHRvIHNlbmQgYWxvbmdcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuXG4gICAgICAgICAgICAvLyBjYWxsYmFja3MgKGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIHRyYW5zZmVyKVxuICAgICAgICAgICAgLy8gbG9hZCBleHBlY3RzIHRoZSBib2R5IHRvIGJlIGEgc2VydmVyIGlkIGlmXG4gICAgICAgICAgICAvLyB5b3Ugd2FudCB0byBtYWtlIHVzZSBvZiByZXZlcnRcbiAgICAgICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBwdXQgdGhlIHJlc3BvbnNlIGluIHN0YXRlIHNvIHdlIGNhbiBhY2Nlc3NcbiAgICAgICAgICAgICAgICAvLyBpdCBvdXRzaWRlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBpc09iamVjdChyZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgPyByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGAke3Jlc3BvbnNlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBwcm9ncmVzcyB0byAxIGFzIHdlJ3JlIG5vdyBkb25lXG4gICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsIGxvYWQgaXMgZG9uZSBsZXQncyBzaGFyZSByZXN1bHRzXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzdGF0ZS5yZXNwb25zZS5ib2R5KTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSByZWFsbHkgZG9uZVxuICAgICAgICAgICAgICAgIC8vIGlmIHBlcmNlaXZlZCBwcm9ncmVzcyBpcyAxICggd2FpdCBmb3IgcGVyY2VpdmVkIHByb2dyZXNzIHRvIGNvbXBsZXRlIClcbiAgICAgICAgICAgICAgICAvLyBvciBpZiBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBwcm9ncmVzcyAoIG51bGwgKVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIChhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiAmJiBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9PT0gMSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGVycm9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIHR5cGUsIGNvZGUsIGJvZHlcbiAgICAgICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAvLyBjYW5jZWwgdXBkYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIG90aGVycyBhYm91dCB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGAke2Vycm9yfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gYWN0dWFsIHByb2Nlc3NpbmcgcHJvZ3Jlc3NcbiAgICAgICAgICAgIChjb21wdXRhYmxlLCBjdXJyZW50LCB0b3RhbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhY3R1YWwgZHVyYXRpb25cbiAgICAgICAgICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgc3RhdGUucHJvZ3Jlc3MgPSBjb21wdXRhYmxlID8gY3VycmVudCAvIHRvdGFsIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIHByb2dyZXNzRm4oKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGFib3J0IGRvZXMgbm90IGV4cGVjdCBhIHZhbHVlXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcCB1cGRhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJlIHRoZSBhYm9ydCBldmVudCBzbyB3ZSBjYW4gc3dpdGNoIHZpc3VhbHNcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnYWJvcnQnLCBzdGF0ZS5yZXNwb25zZSA/IHN0YXRlLnJlc3BvbnNlLmJvZHkgOiBudWxsKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpZCBmb3IgdGhpcyB0cmFuc2ZlclxuICAgICAgICAgICAgdHJhbnNmZXJJZCA9PiB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgICAvLyBubyByZXF1ZXN0IHJ1bm5pbmcsIGNhbid0IGFib3J0XG4gICAgICAgIGlmICghc3RhdGUucmVxdWVzdCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAvLyBhYm9ydCBhY3R1YWwgcmVxdWVzdFxuICAgICAgICBpZiAoc3RhdGUucmVxdWVzdC5hYm9ydCkgc3RhdGUucmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAgIC8vIGlmIGhhcyByZXNwb25zZSBvYmplY3QsIHdlJ3ZlIGNvbXBsZXRlZCB0aGUgcmVxdWVzdFxuICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQcm9ncmVzcyA9IDA7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzID0gMDtcbiAgICAgICAgc3RhdGUudGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24gPSAwO1xuICAgICAgICBzdGF0ZS5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHN0YXRlLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICBzdGF0ZS5yZXNwb25zZSA9IG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IGdldFByb2dyZXNzID0gYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb25cbiAgICAgICAgPyAoKSA9PiAoc3RhdGUucHJvZ3Jlc3MgPyBNYXRoLm1pbihzdGF0ZS5wcm9ncmVzcywgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MpIDogbnVsbClcbiAgICAgICAgOiAoKSA9PiBzdGF0ZS5wcm9ncmVzcyB8fCBudWxsO1xuXG4gICAgY29uc3QgZ2V0RHVyYXRpb24gPSBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvblxuICAgICAgICA/ICgpID0+IE1hdGgubWluKHN0YXRlLmR1cmF0aW9uLCBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbilcbiAgICAgICAgOiAoKSA9PiBzdGF0ZS5kdXJhdGlvbjtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgLi4ub24oKSxcbiAgICAgICAgcHJvY2VzcywgLy8gc3RhcnQgcHJvY2Vzc2luZyBmaWxlXG4gICAgICAgIGFib3J0LCAvLyBhYm9ydCBhY3RpdmUgcHJvY2VzcyByZXF1ZXN0XG4gICAgICAgIGdldFByb2dyZXNzLFxuICAgICAgICBnZXREdXJhdGlvbixcbiAgICAgICAgcmVzZXQsXG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24gPSBuYW1lID0+IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGFzdEluZGV4T2YoJy4nKSkgfHwgbmFtZTtcblxuY29uc3QgY3JlYXRlRmlsZVN0dWIgPSBzb3VyY2UgPT4ge1xuICAgIGxldCBkYXRhID0gW3NvdXJjZS5uYW1lLCBzb3VyY2Uuc2l6ZSwgc291cmNlLnR5cGVdO1xuXG4gICAgLy8gaXMgYmxvYiBvciBiYXNlNjQsIHRoZW4gd2UgbmVlZCB0byBzZXQgdGhlIG5hbWVcbiAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgQmxvYiB8fCBpc0Jhc2U2NERhdGFVUkkoc291cmNlKSkge1xuICAgICAgICBkYXRhWzBdID0gc291cmNlLm5hbWUgfHwgZ2V0RGF0ZVN0cmluZygpO1xuICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgLy8gaWYgaXMgYmFzZTY0IGRhdGEgdXJpIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgYW5kIHR5cGVcbiAgICAgICAgZGF0YVsxXSA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGRhdGFbMl0gPSBnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgICAgIC8vIHVybFxuICAgICAgICBkYXRhWzBdID0gZ2V0RmlsZW5hbWVGcm9tVVJMKHNvdXJjZSk7XG4gICAgICAgIGRhdGFbMV0gPSAwO1xuICAgICAgICBkYXRhWzJdID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGF0YVswXSxcbiAgICAgICAgc2l6ZTogZGF0YVsxXSxcbiAgICAgICAgdHlwZTogZGF0YVsyXSxcbiAgICB9O1xufTtcblxuY29uc3QgaXNGaWxlID0gdmFsdWUgPT4gISEodmFsdWUgaW5zdGFuY2VvZiBGaWxlIHx8ICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgdmFsdWUubmFtZSkpO1xuXG5jb25zdCBkZWVwQ2xvbmVPYmplY3QgPSBzcmMgPT4ge1xuICAgIGlmICghaXNPYmplY3Qoc3JjKSkgcmV0dXJuIHNyYztcbiAgICBjb25zdCB0YXJnZXQgPSBpc0FycmF5KHNyYykgPyBbXSA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNyYykge1xuICAgICAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdiA9IHNyY1trZXldO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHYgJiYgaXNPYmplY3QodikgPyBkZWVwQ2xvbmVPYmplY3QodikgOiB2O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuY29uc3QgY3JlYXRlSXRlbSA9IChvcmlnaW4gPSBudWxsLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0gbnVsbCwgZmlsZSA9IG51bGwpID0+IHtcbiAgICAvLyB1bmlxdWUgaWQgZm9yIHRoaXMgaXRlbSwgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgaXRlbSBhY3Jvc3Mgdmlld3NcbiAgICBjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpdGVtIHN0YXRlXG4gICAgICovXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIC8vIGlzIGFyY2hpdmVkXG4gICAgICAgIGFyY2hpdmVkOiBmYWxzZSxcblxuICAgICAgICAvLyBpZiBpcyBmcm96ZW4sIG5vIGxvbmdlciBmaXJlcyBldmVudHNcbiAgICAgICAgZnJvemVuOiBmYWxzZSxcblxuICAgICAgICAvLyByZW1vdmVkIGZyb20gdmlld1xuICAgICAgICByZWxlYXNlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gb3JpZ2luYWwgc291cmNlXG4gICAgICAgIHNvdXJjZTogbnVsbCxcblxuICAgICAgICAvLyBmaWxlIG1vZGVsIHJlZmVyZW5jZVxuICAgICAgICBmaWxlLFxuXG4gICAgICAgIC8vIGlkIG9mIGZpbGUgb24gc2VydmVyXG4gICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2UsXG5cbiAgICAgICAgLy8gaWQgb2YgZmlsZSB0cmFuc2ZlciBvbiBzZXJ2ZXJcbiAgICAgICAgdHJhbnNmZXJJZDogbnVsbCxcblxuICAgICAgICAvLyBpcyBhYm9ydGVkXG4gICAgICAgIHByb2Nlc3NpbmdBYm9ydGVkOiBmYWxzZSxcblxuICAgICAgICAvLyBjdXJyZW50IGl0ZW0gc3RhdHVzXG4gICAgICAgIHN0YXR1czogc2VydmVyRmlsZVJlZmVyZW5jZSA/IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSA6IEl0ZW1TdGF0dXMuSU5JVCxcblxuICAgICAgICAvLyBhY3RpdmUgcHJvY2Vzc2VzXG4gICAgICAgIGFjdGl2ZUxvYWRlcjogbnVsbCxcbiAgICAgICAgYWN0aXZlUHJvY2Vzc29yOiBudWxsLFxuICAgIH07XG5cbiAgICAvLyBjYWxsYmFjayB1c2VkIHdoZW4gYWJvcnQgcHJvY2Vzc2luZyBpcyBjYWxsZWQgdG8gbGluayBiYWNrIHRvIHRoZSByZXNvbHZlIG1ldGhvZFxuICAgIGxldCBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWxseSBhZGRlZCBpdGVtIG1ldGFkYXRhXG4gICAgICovXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7fTtcblxuICAgIC8vIGl0ZW0gZGF0YVxuICAgIGNvbnN0IHNldFN0YXR1cyA9IHN0YXR1cyA9PiAoc3RhdGUuc3RhdHVzID0gc3RhdHVzKTtcblxuICAgIC8vIGZpcmUgZXZlbnQgdW5sZXNzIHRoZSBpdGVtIGhhcyBiZWVuIGFyY2hpdmVkXG4gICAgY29uc3QgZmlyZSA9IChldmVudCwgLi4ucGFyYW1zKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWxlYXNlZCB8fCBzdGF0ZS5mcm96ZW4pIHJldHVybjtcbiAgICAgICAgYXBpLmZpcmUoZXZlbnQsIC4uLnBhcmFtcyk7XG4gICAgfTtcblxuICAgIC8vIGZpbGUgZGF0YVxuICAgIGNvbnN0IGdldEZpbGVFeHRlbnNpb24gPSAoKSA9PiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoc3RhdGUuZmlsZS5uYW1lKTtcbiAgICBjb25zdCBnZXRGaWxlVHlwZSA9ICgpID0+IHN0YXRlLmZpbGUudHlwZTtcbiAgICBjb25zdCBnZXRGaWxlU2l6ZSA9ICgpID0+IHN0YXRlLmZpbGUuc2l6ZTtcbiAgICBjb25zdCBnZXRGaWxlID0gKCkgPT4gc3RhdGUuZmlsZTtcblxuICAgIC8vXG4gICAgLy8gbG9naWMgdG8gbG9hZCBhIGZpbGVcbiAgICAvL1xuICAgIGNvbnN0IGxvYWQgPSAoc291cmNlLCBsb2FkZXIsIG9ubG9hZCkgPT4ge1xuICAgICAgICAvLyByZW1lbWJlciB0aGUgb3JpZ2luYWwgaXRlbSBzb3VyY2VcbiAgICAgICAgc3RhdGUuc291cmNlID0gc291cmNlO1xuXG4gICAgICAgIC8vIHNvdXJjZSBpcyBrbm93blxuICAgICAgICBhcGkuZmlyZVN5bmMoJ2luaXQnKTtcblxuICAgICAgICAvLyBmaWxlIHN0dWIgaXMgYWxyZWFkeSB0aGVyZVxuICAgICAgICBpZiAoc3RhdGUuZmlsZSkge1xuICAgICAgICAgICAgYXBpLmZpcmVTeW5jKCdsb2FkLXNraXAnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBhIHN0dWIgZmlsZSBvYmplY3Qgd2hpbGUgbG9hZGluZyB0aGUgYWN0dWFsIGRhdGFcbiAgICAgICAgc3RhdGUuZmlsZSA9IGNyZWF0ZUZpbGVTdHViKHNvdXJjZSk7XG5cbiAgICAgICAgLy8gc3RhcnRzIGxvYWRpbmdcbiAgICAgICAgbG9hZGVyLm9uKCdpbml0JywgKCkgPT4ge1xuICAgICAgICAgICAgZmlyZSgnbG9hZC1pbml0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlJ2V2ZSByZWNlaXZlZCBhIHNpemUgaW5kaWNhdGlvbiwgbGV0J3MgdXBkYXRlIHRoZSBzdHViXG4gICAgICAgIGxvYWRlci5vbignbWV0YScsIG1ldGEgPT4ge1xuICAgICAgICAgICAgLy8gc2V0IHNpemUgb2YgZmlsZSBzdHViXG4gICAgICAgICAgICBzdGF0ZS5maWxlLnNpemUgPSBtZXRhLnNpemU7XG5cbiAgICAgICAgICAgIC8vIHNldCBuYW1lIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgc3RhdGUuZmlsZS5maWxlbmFtZSA9IG1ldGEuZmlsZW5hbWU7XG5cbiAgICAgICAgICAgIC8vIGlmIGhhcyByZWNlaXZlZCBzb3VyY2UsIHdlIGRvbmVcbiAgICAgICAgICAgIGlmIChtZXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIG9yaWdpbiA9IEZpbGVPcmlnaW4uTElNQk87XG4gICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG1ldGEuc291cmNlO1xuICAgICAgICAgICAgICAgIHN0YXRlLnN0YXR1cyA9IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2l6ZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhlIGZpbGUgaXMgbm93IGxvYWRpbmcgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHByb2dyZXNzIGluZGljYXRvcnNcbiAgICAgICAgbG9hZGVyLm9uKCdwcm9ncmVzcycsIHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURJTkcpO1xuXG4gICAgICAgICAgICBmaXJlKCdsb2FkLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhbiBlcnJvciB3YXMgdGhyb3duIHdoaWxlIGxvYWRpbmcgdGhlIGZpbGUsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIGVycm9yIHN0YXRlXG4gICAgICAgIGxvYWRlci5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcblxuICAgICAgICAgICAgZmlyZSgnbG9hZC1yZXF1ZXN0LWVycm9yJywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB1c2VyIG9yIGFub3RoZXIgcHJvY2VzcyBhYm9ydGVkIHRoZSBmaWxlIGxvYWQgKGNhbm5vdCByZXRyeSlcbiAgICAgICAgbG9hZGVyLm9uKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklOSVQpO1xuICAgICAgICAgICAgZmlyZSgnbG9hZC1hYm9ydCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBkb25lIGxvYWRpbmdcbiAgICAgICAgbG9hZGVyLm9uKCdsb2FkJywgZmlsZSA9PiB7XG4gICAgICAgICAgICAvLyBhcyB3ZSd2ZSBub3cgbG9hZGVkIHRoZSBmaWxlIHRoZSBsb2FkZXIgaXMgbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiBmaWxlIGhhcyBsb2FkZWQgc3VjY2VzZnVsbHlcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNldCAocG9zc2libHkpIHRyYW5zZm9ybWVkIGZpbGVcbiAgICAgICAgICAgICAgICBzdGF0ZS5maWxlID0gaXNGaWxlKHJlc3VsdCkgPyByZXN1bHQgOiBzdGF0ZS5maWxlO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gPT09IEZpbGVPcmlnaW4uTElNQk8gJiYgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IG9yaWdpbmFsIGZpbGVcbiAgICAgICAgICAgICAgICBzdGF0ZS5maWxlID0gZmlsZTtcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLW1ldGEnKTtcblxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLkxPQURfRVJST1IpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ2xvYWQtZmlsZS1lcnJvcicsIHJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzZXJ2ZXIgZmlsZSByZWZlcmVuY2UsIHdlIGRvbid0IG5lZWQgdG8gY2FsbCB0aGUgb25sb2FkIG1ldGhvZFxuICAgICAgICAgICAgaWYgKHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzKGZpbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gc2VydmVyIGlkLCBsZXQncyBnaXZlIHRoaXMgZmlsZSB0aGUgZnVsbCB0cmVhdG1lbnRcbiAgICAgICAgICAgIG9ubG9hZChmaWxlLCBzdWNjZXNzLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCBsb2FkZXIgc291cmNlIGRhdGFcbiAgICAgICAgbG9hZGVyLnNldFNvdXJjZShzb3VyY2UpO1xuXG4gICAgICAgIC8vIHNldCBhcyBhY3RpdmUgbG9hZGVyXG4gICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlciA9IGxvYWRlcjtcblxuICAgICAgICAvLyBsb2FkIHRoZSBzb3VyY2UgZGF0YVxuICAgICAgICBsb2FkZXIubG9hZCgpO1xuICAgIH07XG5cbiAgICBjb25zdCByZXRyeUxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyLmxvYWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWJvcnRMb2FkID0gKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUuYWN0aXZlTG9hZGVyKSB7XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgICAgZmlyZSgnbG9hZC1hYm9ydCcpO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIGxvZ2ljIHRvIHByb2Nlc3MgYSBmaWxlXG4gICAgLy9cbiAgICBjb25zdCBwcm9jZXNzID0gKHByb2Nlc3Nvciwgb25wcm9jZXNzKSA9PiB7XG4gICAgICAgIC8vIHByb2Nlc3Npbmcgd2FzIGFib3J0ZWRcbiAgICAgICAgaWYgKHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkKSB7XG4gICAgICAgICAgICBzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IHByb2Nlc3NpbmdcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lORyk7XG5cbiAgICAgICAgLy8gcmVzZXQgYWJvcnQgY2FsbGJhY2tcbiAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgICAgICAvLyBpZiBubyBmaWxlIGxvYWRlZCB3ZSdsbCB3YWl0IGZvciB0aGUgbG9hZCBldmVudFxuICAgICAgICBpZiAoIShzdGF0ZS5maWxlIGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgIGFwaS5vbignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzKHByb2Nlc3Nvciwgb25wcm9jZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dXAgcHJvY2Vzc29yXG4gICAgICAgIHByb2Nlc3Nvci5vbignbG9hZCcsIHNlcnZlckZpbGVSZWZlcmVuY2UgPT4ge1xuICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXJ0IHRoZSB1cGxvYWRcbiAgICAgICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRyYW5zZmVyIGlkXG4gICAgICAgIHByb2Nlc3Nvci5vbigndHJhbnNmZXInLCB0cmFuc2ZlcklkID0+IHtcbiAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gdHJhbnNmZXJJZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvY2Vzc29yLm9uKCdsb2FkLXBlcmNlaXZlZCcsIHNlcnZlckZpbGVSZWZlcmVuY2UgPT4ge1xuICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHJlcXVpcmVkXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlciB0aGUgdXBsb2FkXG4gICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtY29tcGxldGUnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvY2Vzc29yLm9uKCdzdGFydCcsICgpID0+IHtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3Mtc3RhcnQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvY2Vzc29yLm9uKCdlcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0VSUk9SKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignYWJvcnQnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGlmIGZpbGUgd2FzIHVwbG9hZGVkIGJ1dCBwcm9jZXNzaW5nIHdhcyBjYW5jZWxsZWQgZHVyaW5nIHBlcmNlaXZlZCBwcm9jZXNzb3IgdGltZSBzdG9yZSBmaWxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IHNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1hYm9ydCcpO1xuXG4gICAgICAgICAgICAvLyBoYXMgdGltZW91dCBzbyBkb2Vzbid0IGludGVyZmVyZSB3aXRoIHJlbW92ZSBhY3Rpb25cbiAgICAgICAgICAgIGlmIChhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvY2Vzc29yLm9uKCdwcm9ncmVzcycsIHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBwcm9ncmVzcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdoZW4gc3VjY2Vzc2Z1bGx5IHRyYW5zZm9ybWVkXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBmaWxlID0+IHtcbiAgICAgICAgICAgIC8vIGlmIHdhcyBhcmNoaXZlZCBpbiB0aGUgbWVhbiB0aW1lLCBkb24ndCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAoc3RhdGUuYXJjaGl2ZWQpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gcHJvY2VzcyBmaWxlIVxuICAgICAgICAgICAgcHJvY2Vzc29yLnByb2Nlc3MoZmlsZSwgeyAuLi5tZXRhZGF0YSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgdHJhbnNmb3JtIHBoYXNlXG4gICAgICAgIGNvbnN0IGVycm9yID0gY29uc29sZS5lcnJvcjtcblxuICAgICAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHRoZSBmaWxlXG4gICAgICAgIG9ucHJvY2VzcyhzdGF0ZS5maWxlLCBzdWNjZXNzLCBlcnJvcik7XG5cbiAgICAgICAgLy8gc2V0IGFzIGFjdGl2ZSBwcm9jZXNzb3JcbiAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0UHJvY2Vzc2luZyA9ICgpID0+IHtcbiAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpO1xuICAgIH07XG5cbiAgICBjb25zdCBhYm9ydFByb2Nlc3NpbmcgPSAoKSA9PlxuICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmICghc3RhdGUuYWN0aXZlUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1hYm9ydCcpO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3Nvci5hYm9ydCgpO1xuICAgICAgICB9KTtcblxuICAgIC8vXG4gICAgLy8gbG9naWMgdG8gcmV2ZXJ0IGEgcHJvY2Vzc2VkIGZpbGVcbiAgICAvL1xuICAgIGNvbnN0IHJldmVydCA9IChyZXZlcnRGaWxlVXBsb2FkLCBmb3JjZVJldmVydCkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gYSBjb21wbGV0ZWQgdXBsb2FkIHdpbGwgaGF2ZSBhIHNlcnZlckZpbGVSZWZlcmVuY2UsIGEgZmFpbGVkIGNodW5rZWQgdXBsb2FkIHdoZXJlXG4gICAgICAgICAgICAvLyBnZXR0aW5nIGEgc2VydmVySWQgc3VjY2VlZGVkIGJ1dCA+PTAgY2h1bmtzIGhhdmUgYmVlbiB1cGxvYWRlZCB3aWxsIGhhdmUgdHJhbnNmZXJJZCBzZXRcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclRyYW5zZmVySWQgPVxuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGwgPyBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlIDogc3RhdGUudHJhbnNmZXJJZDtcblxuICAgICAgICAgICAgLy8gY2Fubm90IHJldmVydCB3aXRob3V0IGEgc2VydmVyIGlkIGZvciB0aGlzIHByb2Nlc3NcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJUcmFuc2ZlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV2ZXJ0IHRoZSB1cGxvYWQgKGZpcmUgYW5kIGZvcmdldClcbiAgICAgICAgICAgIHJldmVydEZpbGVVcGxvYWQoXG4gICAgICAgICAgICAgICAgc2VydmVyVHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGZpbGUgc2VydmVyIGlkIGFuZCB0cmFuc2ZlciBpZCBhcyBub3cgaXQncyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyYW5zZmVySWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNldCBlcnJvciBzdGF0ZSB3aGVuIHJldmVydGluZyBpcyBvcHRpb25hbCwgaXQgd2lsbCBhbHdheXMgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmV2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBvaCBubyBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXJldmVydC1lcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgZXZlbnRcbiAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBleHBvc2VkIG1ldGhvZHNcbiAgICBjb25zdCBzZXRNZXRhZGF0YSA9IChrZXksIHZhbHVlLCBzaWxlbnQpID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCByb290ID0ga2V5c1swXTtcbiAgICAgICAgY29uc3QgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICAgIGxldCBkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gKGRhdGEgPSBkYXRhW2tleV0pKTtcblxuICAgICAgICAvLyBjb21wYXJlIG9sZCB2YWx1ZSBhZ2FpbnN0IG5ldyB2YWx1ZSwgaWYgdGhleSdyZSB0aGUgc2FtZSwgd2UncmUgbm90IHVwZGF0aW5nXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShkYXRhW2xhc3RdKSA9PT0gSlNPTi5zdHJpbmdpZnkodmFsdWUpKSByZXR1cm47XG5cbiAgICAgICAgLy8gdXBkYXRlIHZhbHVlXG4gICAgICAgIGRhdGFbbGFzdF0gPSB2YWx1ZTtcblxuICAgICAgICAvLyBmaXJlIHVwZGF0ZVxuICAgICAgICBmaXJlKCdtZXRhZGF0YS11cGRhdGUnLCB7XG4gICAgICAgICAgICBrZXk6IHJvb3QsXG4gICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFbcm9vdF0sXG4gICAgICAgICAgICBzaWxlbnQsXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRNZXRhZGF0YSA9IGtleSA9PiBkZWVwQ2xvbmVPYmplY3Qoa2V5ID8gbWV0YWRhdGFba2V5XSA6IG1ldGFkYXRhKTtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgaWQ6IHsgZ2V0OiAoKSA9PiBpZCB9LFxuICAgICAgICBvcmlnaW46IHsgZ2V0OiAoKSA9PiBvcmlnaW4sIHNldDogdmFsdWUgPT4gKG9yaWdpbiA9IHZhbHVlKSB9LFxuICAgICAgICBzZXJ2ZXJJZDogeyBnZXQ6ICgpID0+IHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgfSxcbiAgICAgICAgdHJhbnNmZXJJZDogeyBnZXQ6ICgpID0+IHN0YXRlLnRyYW5zZmVySWQgfSxcbiAgICAgICAgc3RhdHVzOiB7IGdldDogKCkgPT4gc3RhdGUuc3RhdHVzIH0sXG4gICAgICAgIGZpbGVuYW1lOiB7IGdldDogKCkgPT4gc3RhdGUuZmlsZS5uYW1lIH0sXG4gICAgICAgIGZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbjogeyBnZXQ6ICgpID0+IGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbihzdGF0ZS5maWxlLm5hbWUpIH0sXG4gICAgICAgIGZpbGVFeHRlbnNpb246IHsgZ2V0OiBnZXRGaWxlRXh0ZW5zaW9uIH0sXG4gICAgICAgIGZpbGVUeXBlOiB7IGdldDogZ2V0RmlsZVR5cGUgfSxcbiAgICAgICAgZmlsZVNpemU6IHsgZ2V0OiBnZXRGaWxlU2l6ZSB9LFxuICAgICAgICBmaWxlOiB7IGdldDogZ2V0RmlsZSB9LFxuICAgICAgICByZWxhdGl2ZVBhdGg6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5maWxlLl9yZWxhdGl2ZVBhdGggfSxcblxuICAgICAgICBzb3VyY2U6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5zb3VyY2UgfSxcblxuICAgICAgICBnZXRNZXRhZGF0YSxcbiAgICAgICAgc2V0TWV0YWRhdGE6IChrZXksIHZhbHVlLCBzaWxlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGtleTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldE1ldGFkYXRhKGtleSwgZGF0YVtrZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1ldGFkYXRhKGtleSwgdmFsdWUsIHNpbGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kOiAobmFtZSwgaGFuZGxlcikgPT4gKGl0ZW1BUElbbmFtZV0gPSBoYW5kbGVyKSxcblxuICAgICAgICBhYm9ydExvYWQsXG4gICAgICAgIHJldHJ5TG9hZCxcbiAgICAgICAgcmVxdWVzdFByb2Nlc3NpbmcsXG4gICAgICAgIGFib3J0UHJvY2Vzc2luZyxcblxuICAgICAgICBsb2FkLFxuICAgICAgICBwcm9jZXNzLFxuICAgICAgICByZXZlcnQsXG5cbiAgICAgICAgLi4ub24oKSxcblxuICAgICAgICBmcmVlemU6ICgpID0+IChzdGF0ZS5mcm96ZW4gPSB0cnVlKSxcblxuICAgICAgICByZWxlYXNlOiAoKSA9PiAoc3RhdGUucmVsZWFzZWQgPSB0cnVlKSxcbiAgICAgICAgcmVsZWFzZWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5yZWxlYXNlZCB9LFxuXG4gICAgICAgIGFyY2hpdmU6ICgpID0+IChzdGF0ZS5hcmNoaXZlZCA9IHRydWUpLFxuICAgICAgICBhcmNoaXZlZDogeyBnZXQ6ICgpID0+IHN0YXRlLmFyY2hpdmVkIH0sXG5cbiAgICAgICAgLy8gcmVwbGFjZSBzb3VyY2UgYW5kIGZpbGUgb2JqZWN0XG4gICAgICAgIHNldEZpbGU6IGZpbGUgPT4gKHN0YXRlLmZpbGUgPSBmaWxlKSxcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRlIGl0IGhlcmUgaW5zdGVhZCBvZiByZXR1cm5pbmcgaXQgaW5zdGFudGx5IHNvIHdlIGNhbiBleHRlbmQgaXQgbGF0ZXJcbiAgICBjb25zdCBpdGVtQVBJID0gY3JlYXRlT2JqZWN0KGFwaSk7XG5cbiAgICByZXR1cm4gaXRlbUFQSTtcbn07XG5cbmNvbnN0IGdldEl0ZW1JbmRleEJ5UXVlcnkgPSAoaXRlbXMsIHF1ZXJ5KSA9PiB7XG4gICAgLy8ganVzdCByZXR1cm4gZmlyc3QgaW5kZXhcbiAgICBpZiAoaXNFbXB0eShxdWVyeSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gaW52YWxpZCBxdWVyaWVzXG4gICAgaWYgKCFpc1N0cmluZyhxdWVyeSkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBpdGVtIGJ5IGlkIChvciAtMSBpZiBub3QgZm91bmQpXG4gICAgcmV0dXJuIGl0ZW1zLmZpbmRJbmRleChpdGVtID0+IGl0ZW0uaWQgPT09IHF1ZXJ5KTtcbn07XG5cbmNvbnN0IGdldEl0ZW1CeUlkID0gKGl0ZW1zLCBpdGVtSWQpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGdldEl0ZW1JbmRleEJ5UXVlcnkoaXRlbXMsIGl0ZW1JZCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBpdGVtc1tpbmRleF0gfHwgbnVsbDtcbn07XG5cbmNvbnN0IGZldGNoQmxvYiA9ICh1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgdXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2Jsb2InLFxuICAgIH0pO1xuXG4gICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICAvLyBnZXQgaGVhZGVyc1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXG4gICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGdldEZpbGVJbmZvRnJvbUhlYWRlcnMoaGVhZGVycykubmFtZSB8fCBnZXRGaWxlbmFtZUZyb21VUkwodXJsKTtcblxuICAgICAgICAvLyBjcmVhdGUgcmVzcG9uc2VcbiAgICAgICAgbG9hZChjcmVhdGVSZXNwb25zZSgnbG9hZCcsIHhoci5zdGF0dXMsIGdldEZpbGVGcm9tQmxvYih4aHIucmVzcG9uc2UsIGZpbGVuYW1lKSwgaGVhZGVycykpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT4ge1xuICAgICAgICBlcnJvcihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCB4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25oZWFkZXJzID0geGhyID0+IHtcbiAgICAgICAgaGVhZGVycyhjcmVhdGVSZXNwb25zZSgnaGVhZGVycycsIHhoci5zdGF0dXMsIG51bGwsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcik7XG4gICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgcmVxdWVzdC5vbmFib3J0ID0gYWJvcnQ7XG5cbiAgICAvLyBzaG91bGQgcmV0dXJuIHJlcXVlc3RcbiAgICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbmNvbnN0IGdldERvbWFpbkZyb21VUkwgPSB1cmwgPT4ge1xuICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgICB1cmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIHVybDtcbiAgICB9XG4gICAgcmV0dXJuIHVybFxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgnYmxvYjonLCAnJylcbiAgICAgICAgLnJlcGxhY2UoLyhbYS16XSk/OlxcL1xcLy8sICckMScpXG4gICAgICAgIC5zcGxpdCgnLycpWzBdO1xufTtcblxuY29uc3QgaXNFeHRlcm5hbFVSTCA9IHVybCA9PlxuICAgICh1cmwuaW5kZXhPZignOicpID4gLTEgfHwgdXJsLmluZGV4T2YoJy8vJykgPiAtMSkgJiZcbiAgICBnZXREb21haW5Gcm9tVVJMKGxvY2F0aW9uLmhyZWYpICE9PSBnZXREb21haW5Gcm9tVVJMKHVybCk7XG5cbmNvbnN0IGR5bmFtaWNMYWJlbCA9IGxhYmVsID0+ICguLi5wYXJhbXMpID0+IChpc0Z1bmN0aW9uKGxhYmVsKSA/IGxhYmVsKC4uLnBhcmFtcykgOiBsYWJlbCk7XG5cbmNvbnN0IGlzTW9ja0l0ZW0gPSBpdGVtID0+ICFpc0ZpbGUoaXRlbS5maWxlKTtcblxuY29uc3QgbGlzdFVwZGF0ZWQgPSAoZGlzcGF0Y2gsIHN0YXRlKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLmxpc3RVcGRhdGVUaW1lb3V0KTtcbiAgICBzdGF0ZS5saXN0VXBkYXRlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNUycsIHsgaXRlbXM6IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSB9KTtcbiAgICB9LCAwKTtcbn07XG5cbmNvbnN0IG9wdGlvbmFsUHJvbWlzZSA9IChmbiwgLi4ucGFyYW1zKSA9PlxuICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLnBhcmFtcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5jb25zdCBzb3J0SXRlbXMgPSAoc3RhdGUsIGNvbXBhcmUpID0+IHtcbiAgICBzdGF0ZS5pdGVtcy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGNyZWF0ZUl0ZW1BUEkoYSksIGNyZWF0ZUl0ZW1BUEkoYikpKTtcbn07XG5cbi8vIHJldHVybnMgaXRlbSBiYXNlZCBvbiBzdGF0ZVxuY29uc3QgZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUgPSAoc3RhdGUsIGl0ZW1IYW5kbGVyKSA9PiAoe1xuICAgIHF1ZXJ5LFxuICAgIHN1Y2Nlc3MgPSAoKSA9PiB7fSxcbiAgICBmYWlsdXJlID0gKCkgPT4ge30sXG4gICAgLi4ub3B0aW9uc1xufSA9IHt9KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbUhhbmRsZXIoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5jb25zdCBhY3Rpb25zID0gKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpID0+ICh7XG4gICAgLyoqXG4gICAgICogQWJvcnRzIGFsbCBvbmdvaW5nIHByb2Nlc3Nlc1xuICAgICAqL1xuICAgIEFCT1JUX0FMTDogKCkgPT4ge1xuICAgICAgICBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uZnJlZXplKCk7XG4gICAgICAgICAgICBpdGVtLmFib3J0TG9hZCgpO1xuICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgaW5pdGlhbCBmaWxlc1xuICAgICAqL1xuICAgIERJRF9TRVRfRklMRVM6ICh7IHZhbHVlID0gW10gfSkgPT4ge1xuICAgICAgICAvLyBtYXAgdmFsdWVzIHRvIGZpbGUgb2JqZWN0c1xuICAgICAgICBjb25zdCBmaWxlcyA9IHZhbHVlLm1hcChmaWxlID0+ICh7XG4gICAgICAgICAgICBzb3VyY2U6IGZpbGUuc291cmNlID8gZmlsZS5zb3VyY2UgOiBmaWxlLFxuICAgICAgICAgICAgb3B0aW9uczogZmlsZS5vcHRpb25zLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gbG9vcCBvdmVyIGZpbGVzLCBpZiBmaWxlIGlzIGluIGxpc3QsIGxlYXZlIGl0IGJlLCBpZiBub3QsIHJlbW92ZVxuICAgICAgICAvLyB0ZXN0IGlmIGl0ZW1zIHNob3VsZCBiZSBtb3ZlZFxuICAgICAgICBsZXQgYWN0aXZlSXRlbXMgPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyk7XG5cbiAgICAgICAgYWN0aXZlSXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIGlmIGl0ZW0gbm90IGlzIGluIG5ldyB2YWx1ZSwgcmVtb3ZlXG4gICAgICAgICAgICBpZiAoIWZpbGVzLmZpbmQoZmlsZSA9PiBmaWxlLnNvdXJjZSA9PT0gaXRlbS5zb3VyY2UgfHwgZmlsZS5zb3VyY2UgPT09IGl0ZW0uZmlsZSkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLCByZW1vdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgbmV3IGZpbGVzXG4gICAgICAgIGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgZmlsZSBpcyBhbHJlYWR5IGluIGxpc3RcbiAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5zb3VyY2UgPT09IGZpbGUuc291cmNlIHx8IGl0ZW0uZmlsZSA9PT0gZmlsZS5zb3VyY2UpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gbm90IGluIGxpc3QsIGFkZFxuICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgIC4uLmZpbGUsXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLk5PTkUsXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIERJRF9VUERBVEVfSVRFTV9NRVRBREFUQTogKHsgaWQsIGFjdGlvbiwgY2hhbmdlIH0pID0+IHtcbiAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgaWYgKGNoYW5nZS5zaWxlbnQpIHJldHVybjtcblxuICAgICAgICAvLyBpZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaW4gY2xvc2Ugc3VjY2Vzc2lvbiB3ZSBjb21iaW5lZCBhbGwgY2FsbHMgdG9nZXRoZXIgdG8gc2F2ZSByZXNvdXJjZXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0KTtcbiAgICAgICAgc3RhdGUuaXRlbVVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlJZChzdGF0ZS5pdGVtcywgaWQpO1xuXG4gICAgICAgICAgICAvLyBvbmx5IHJldmVydCBhbmQgYXR0ZW1wdCB0byB1cGxvYWQgd2hlbiB3ZSdyZSB1cGxvYWRpbmcgdG8gYSBzZXJ2ZXJcbiAgICAgICAgICAgIGlmICghcXVlcnkoJ0lTX0FTWU5DJykpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgd2UgdXBkYXRlIHRoZSBvdXRwdXQgZGF0YVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSxcbiAgICAgICAgICAgICAgICB9KS50aGVuKHNob3VsZFByZXBhcmVPdXRwdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVByZXBhcmVGaWxlID0gcXVlcnkoJ0dFVF9CRUZPUkVfUFJFUEFSRV9GSUxFJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVQcmVwYXJlRmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXQgPSBiZWZvcmVQcmVwYXJlRmlsZShpdGVtLCBzaG91bGRQcmVwYXJlT3V0cHV0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFByZXBhcmVPdXRwdXQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQsIGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGlzIGxvY2FsIGl0ZW0gd2UgbmVlZCB0byBlbmFibGUgdXBsb2FkIGJ1dHRvbiBzbyBjaGFuZ2UgY2FuIGJlIHByb3BhZ2F0ZWQgdG8gc2VydmVyXG4gICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yIGFzeW5jIHNjZW5hcmlvc1xuICAgICAgICAgICAgY29uc3QgdXBsb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHdlIHB1c2ggdGhpcyBmb3J3YXJkIGEgYml0IHNvIHRoZSBpbnRlcmZhY2UgaXMgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgICAgICAgICAgfSwgMzIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgcmV2ZXJ0ID0gZG9VcGxvYWQgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogKCkgPT4ge30pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBhYm9ydCA9IGRvVXBsb2FkID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4oZG9VcGxvYWQgPyB1cGxvYWQgOiAoKSA9PiB7fSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBzaG91bGQgcmUtdXBsb2FkIHRoZSBmaWxlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnQoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY3VycmVudGx5IHVwbG9hZGluZywgY2FuY2VsIHVwbG9hZFxuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJvcnQoc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgICAgIHVwbG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgTU9WRV9JVEVNOiAoeyBxdWVyeSwgaW5kZXggfSkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIHF1ZXJ5KTtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHN0YXRlLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGluZGV4ID0gbGltaXQoaW5kZXgsIDAsIHN0YXRlLml0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSBpbmRleCkgcmV0dXJuO1xuICAgICAgICBzdGF0ZS5pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIHN0YXRlLml0ZW1zLnNwbGljZShjdXJyZW50SW5kZXgsIDEpWzBdKTtcbiAgICB9LFxuXG4gICAgU09SVDogKHsgY29tcGFyZSB9KSA9PiB7XG4gICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgY29tcGFyZSk7XG4gICAgICAgIGRpc3BhdGNoKCdESURfU09SVF9JVEVNUycsIHtcbiAgICAgICAgICAgIGl0ZW1zOiBxdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgQUREX0lURU1TOiAoeyBpdGVtcywgaW5kZXgsIGludGVyYWN0aW9uTWV0aG9kLCBzdWNjZXNzID0gKCkgPT4ge30sIGZhaWx1cmUgPSAoKSA9PiB7fSB9KSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSBpbmRleDtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICAgICAgY29uc3QgdG90YWxJdGVtcyA9IHF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluc2VydExvY2F0aW9uID09PSAnYmVmb3JlJyA/IDAgOiB0b3RhbEl0ZW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWdub3JlZEZpbGVzID0gcXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRGaWxlID0gc291cmNlID0+XG4gICAgICAgICAgICBpc0ZpbGUoc291cmNlKSA/ICFpZ25vcmVkRmlsZXMuaW5jbHVkZXMoc291cmNlLm5hbWUudG9Mb3dlckNhc2UoKSkgOiAhaXNFbXB0eShzb3VyY2UpO1xuICAgICAgICBjb25zdCB2YWxpZEl0ZW1zID0gaXRlbXMuZmlsdGVyKGlzVmFsaWRGaWxlKTtcblxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IHZhbGlkSXRlbXMubWFwKFxuICAgICAgICAgICAgc291cmNlID0+XG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQUREX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLnNvdXJjZSB8fCBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCsrLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogc291cmNlLm9wdGlvbnMgfHwge30sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAudGhlbihzdWNjZXNzKVxuICAgICAgICAgICAgLmNhdGNoKGZhaWx1cmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc291cmNlXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICogQHBhcmFtIGludGVyYWN0aW9uTWV0aG9kXG4gICAgICovXG4gICAgQUREX0lURU06ICh7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgIHN1Y2Nlc3MgPSAoKSA9PiB7fSxcbiAgICAgICAgZmFpbHVyZSA9ICgpID0+IHt9LFxuICAgICAgICBvcHRpb25zID0ge30sXG4gICAgfSkgPT4ge1xuICAgICAgICAvLyBpZiBubyBzb3VyY2Ugc3VwcGxpZWRcbiAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlKSkge1xuICAgICAgICAgICAgZmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdObyBzb3VyY2UnKSxcbiAgICAgICAgICAgICAgICBmaWxlOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGludmFsaWQgZmlsZSBpdGVtcywgdXNlZCB0byBmaWx0ZXIgZHJvcHBlZCBkaXJlY3RvcnkgY29udGVudHNcbiAgICAgICAgaWYgKGlzRmlsZShzb3VyY2UpICYmIHN0YXRlLm9wdGlvbnMuaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAvLyBmYWlsIHNpbGVudGx5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0ZXN0IGlmIHRoZXJlJ3Mgc3RpbGwgcm9vbSBpbiB0aGUgbGlzdCBvZiBmaWxlc1xuICAgICAgICBpZiAoIWhhc1Jvb21Gb3JJdGVtKHN0YXRlKSkge1xuICAgICAgICAgICAgLy8gaWYgbXVsdGlwbGUgYWxsb3dlZCwgd2UgY2FuJ3QgcmVwbGFjZVxuICAgICAgICAgICAgLy8gb3IgaWYgb25seSBhIHNpbmdsZSBpdGVtIGlzIGFsbG93ZWQgYnV0IHdlJ3JlIG5vdCBhbGxvd2VkIHRvIHJlcGxhY2UgaXQgd2UgZXhpdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSB8fFxuICAgICAgICAgICAgICAgICghc3RhdGUub3B0aW9ucy5hbGxvd011bHRpcGxlICYmICFzdGF0ZS5vcHRpb25zLmFsbG93UmVwbGFjZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyk7XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvciwgZmlsZTogbnVsbCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbGV0J3MgcmVwbGFjZSB0aGUgaXRlbVxuICAgICAgICAgICAgLy8gaWQgb2YgZmlyc3QgaXRlbSB3ZSdyZSBhYm91dCB0byByZW1vdmVcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcylbMF07XG5cbiAgICAgICAgICAgIC8vIGlmIGhhcyBiZWVuIHByb2Nlc3NlZCByZW1vdmUgaXQgZnJvbSB0aGUgc2VydmVyIGFzIHdlbGxcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcmNlUmV2ZXJ0ID0gcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKTtcbiAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgICAgICAgICBmb3JjZVJldmVydFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gYWRkIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge30pOyAvLyBubyBuZWVkIHRvIGhhbmRsZSB0aGlzIGNhdGNoIHN0YXRlIGZvciBub3dcblxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVJldmVydCkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgZmlyc3QgaXRlbSBhcyBpdCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoaXMgaXRlbVxuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZXJlIGRpZCB0aGUgZmlsZSBvcmlnaW5hdGVcbiAgICAgICAgY29uc3Qgb3JpZ2luID1cbiAgICAgICAgICAgIG9wdGlvbnMudHlwZSA9PT0gJ2xvY2FsJ1xuICAgICAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MT0NBTFxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnbGltYm8nXG4gICAgICAgICAgICAgICAgPyBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgICAgOiBGaWxlT3JpZ2luLklOUFVUO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBibGFuayBpdGVtXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVJdGVtKFxuICAgICAgICAgICAgLy8gd2hlcmUgZGlkIHRoaXMgZmlsZSBjb21lIGZyb21cbiAgICAgICAgICAgIG9yaWdpbixcblxuICAgICAgICAgICAgLy8gYW4gaW5wdXQgZmlsZSBuZXZlciBoYXMgYSBzZXJ2ZXIgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVCA/IG51bGwgOiBzb3VyY2UsXG5cbiAgICAgICAgICAgIC8vIGZpbGUgbW9jayBkYXRhLCBpZiBkZWZpbmVkXG4gICAgICAgICAgICBvcHRpb25zLmZpbGVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBzZXQgaW5pdGlhbCBtZXRhIGRhdGFcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5tZXRhZGF0YSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaXRlbS5zZXRNZXRhZGF0YShrZXksIG9wdGlvbnMubWV0YWRhdGFba2V5XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZWQgdGhlIGl0ZW0sIGxldCBwbHVnaW5zIGFkZCBtZXRob2RzXG4gICAgICAgIGFwcGx5RmlsdGVycygnRElEX0NSRUFURV9JVEVNJywgaXRlbSwgeyBxdWVyeSwgZGlzcGF0Y2ggfSk7XG5cbiAgICAgICAgLy8gd2hlcmUgdG8gaW5zZXJ0IG5ldyBpdGVtc1xuICAgICAgICBjb25zdCBpdGVtSW5zZXJ0TG9jYXRpb24gPSBxdWVyeSgnR0VUX0lURU1fSU5TRVJUX0xPQ0FUSU9OJyk7XG5cbiAgICAgICAgLy8gYWRqdXN0IGluZGV4IGlmIGlzIG5vdCBhbGxvd2VkIHRvIHBpY2sgbG9jYXRpb25cbiAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLml0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb20pIHtcbiAgICAgICAgICAgIGluZGV4ID0gaXRlbUluc2VydExvY2F0aW9uID09PSAnYmVmb3JlJyA/IC0xIDogc3RhdGUuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGl0ZW0gdG8gbGlzdFxuICAgICAgICBpbnNlcnRJdGVtKHN0YXRlLml0ZW1zLCBpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGl0ZW1JbnNlcnRMb2NhdGlvbikgJiYgc291cmNlKSB7XG4gICAgICAgICAgICBzb3J0SXRlbXMoc3RhdGUsIGl0ZW1JbnNlcnRMb2NhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgYSBxdWljayByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gaWRcbiAgICAgICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuXG4gICAgICAgIC8vIG9ic2VydmUgaXRlbSBldmVudHNcbiAgICAgICAgaXRlbS5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfSU5JVF9JVEVNJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1pbml0JywgKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9TVEFSVF9JVEVNX0xPQUQnLCB7IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLW1ldGEnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEEnLCB7IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXByb2dyZXNzJywgcHJvZ3Jlc3MgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTJywgeyBpZCwgcHJvZ3Jlc3MgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1haW5TdGF0dXMgPSBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVMb2FkRXJyb3IpKGVycm9yKTtcblxuICAgICAgICAgICAgLy8gaXMgY2xpZW50IGVycm9yLCBubyB3YXkgdG8gcmVjb3ZlclxuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPj0gNDAwICYmIGVycm9yLmNvZGUgPCA1MDApIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWI6IGAke2Vycm9yLmNvZGV9ICgke2Vycm9yLmJvZHl9KWAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyByZWplY3QgdGhlIGZpbGUgc28gY2FuIGJlIGRlYWx0IHdpdGggdGhyb3VnaCBBUElcbiAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpcyBwb3NzaWJsZSBzZXJ2ZXIgZXJyb3IsIHNvIG1pZ2h0IGJlIHBvc3NpYmxlIHRvIHJldHJ5XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbjogbWFpblN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtZmlsZS1lcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9JTlZBTElEJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBlcnJvci5zdGF0dXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvcjogZXJyb3Iuc3RhdHVzLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLWFib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtc2tpcCcsICgpID0+IHtcbiAgICAgICAgICAgIGl0ZW0ub24oJ21ldGFkYXRhLXVwZGF0ZScsIGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbGUoaXRlbS5maWxlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQURBVEEnLCB7IGlkLCBjaGFuZ2UgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2goJ0NPTVBMRVRFX0xPQURfSVRFTScsIHtcbiAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVBZGQgPSBzaG91bGRBZGQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG5vIHNob3VsZCBub3QgYWRkIHRoaXMgZmlsZVxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBub3cgaW50ZXJlc3RlZCBpbiBtZXRhZGF0YSB1cGRhdGVzXG4gICAgICAgICAgICAgICAgaXRlbS5vbignbWV0YWRhdGEtdXBkYXRlJywgY2hhbmdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBREFUQScsIHsgaWQsIGNoYW5nZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGxldCBwbHVnaW5zIGRlY2lkZSBpZiB0aGUgb3V0cHV0IGRhdGEgc2hvdWxkIGJlIHByZXBhcmVkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB3ZSdsbCBkbyB0aGlzIGFuZCB3YWl0IGZvciBpZGxlIHN0YXRlXG4gICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignU0hPVUxEX1BSRVBBUkVfT1VUUFVUJywgZmFsc2UsIHsgaXRlbSwgcXVlcnkgfSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUHJlcGFyZU91dHB1dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbHVnaW5zIGRldGVybWluZWQgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCAob3Igbm90KSwgY2FuIGJlIGFkanVzdGVkIHdpdGggYmVmb3JlUHJlcGFyZU91dHB1dCBob29rXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZVByZXBhcmVGaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXQgPSBiZWZvcmVQcmVwYXJlRmlsZShpdGVtLCBzaG91bGRQcmVwYXJlT3V0cHV0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZENvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdDT01QTEVURV9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJlcGFyZU91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlkbGUgc3RhdGUgYW5kIHRoZW4gcnVuIFBSRVBBUkVfT1VUUFVUXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSRVFVRVNUX1BSRVBBUkVfT1VUUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkLCBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGl0ZW0gbG9hZGVkLCBhbGxvdyBwbHVnaW5zIHRvXG4gICAgICAgICAgICAvLyAtIHJlYWQgZGF0YSAocXVpY2tseSlcbiAgICAgICAgICAgIC8vIC0gYWRkIG1ldGFkYXRhXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdESURfTE9BRF9JVEVNJywgaXRlbSwgeyBxdWVyeSwgZGlzcGF0Y2ggfSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsUHJvbWlzZShxdWVyeSgnR0VUX0JFRk9SRV9BRERfRklMRScpLCBjcmVhdGVJdGVtQVBJKGl0ZW0pKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQWRkXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAhZS5lcnJvciB8fCAhZS5zdGF0dXMpIHJldHVybiBoYW5kbGVBZGQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGUuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1zdGFydCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1wcm9ncmVzcycsIHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUycsIHsgaWQsIHByb2dyZXNzIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdwcm9jZXNzLWVycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvcikoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1yZXZlcnQtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1haW46IGR5bmFtaWNMYWJlbChzdGF0ZS5vcHRpb25zLmxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvcikoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1jb21wbGV0ZScsIHNlcnZlckZpbGVSZWZlcmVuY2UgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7IGlkLCB2YWx1ZTogc2VydmVyRmlsZVJlZmVyZW5jZSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1hYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1yZXZlcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLCB7IGlkIH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7IGlkLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbGV0IHZpZXcga25vdyB0aGUgaXRlbSBoYXMgYmVlbiBpbnNlcnRlZFxuICAgICAgICBkaXNwYXRjaCgnRElEX0FERF9JVEVNJywgeyBpZCwgaW5kZXgsIGludGVyYWN0aW9uTWV0aG9kIH0pO1xuXG4gICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG5cbiAgICAgICAgLy8gc3RhcnQgbG9hZGluZyB0aGUgc291cmNlXG4gICAgICAgIGNvbnN0IHsgdXJsLCBsb2FkLCByZXN0b3JlLCBmZXRjaCB9ID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXIgfHwge307XG5cbiAgICAgICAgaXRlbS5sb2FkKFxuICAgICAgICAgICAgc291cmNlLFxuXG4gICAgICAgICAgICAvLyB0aGlzIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGxvYWRzIHRoZSBmaWxlIGJhc2VkIG9uIHRoZSB0eXBlIG9mIGZpbGUgKHN0cmluZywgYmFzZTY0LCBibG9iLCBmaWxlKSBhbmQgbG9jYXRpb24gb2YgZmlsZSAobG9jYWwsIHJlbW90ZSwgbGltYm8pXG4gICAgICAgICAgICBjcmVhdGVGaWxlTG9hZGVyKFxuICAgICAgICAgICAgICAgIG9yaWdpbiA9PT0gRmlsZU9yaWdpbi5JTlBVVFxuICAgICAgICAgICAgICAgICAgICA/IC8vIGlucHV0LCBpZiBpcyByZW1vdGUsIHNlZSBpZiBzaG91bGQgdXNlIGN1c3RvbSBmZXRjaCwgZWxzZSB1c2UgZGVmYXVsdCBmZXRjaEJsb2JcbiAgICAgICAgICAgICAgICAgICAgICBpc1N0cmluZyhzb3VyY2UpICYmIGlzRXh0ZXJuYWxVUkwoc291cmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGZldGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHJlbW90ZSB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmV0Y2hCbG9iIC8vIHRyeSB0byBmZXRjaCB1cmxcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBsaW1ibyBvciBsb2NhbFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uTElNQk9cbiAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgcmVzdG9yZSkgLy8gbGltYm9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVGZXRjaEZ1bmN0aW9uKHVybCwgbG9hZCkgLy8gbG9jYWxcbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGxvYWRlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgZmlsdGVyc1xuICAgICAgICAgICAgKGZpbGUsIHN1Y2Nlc3MsIGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbGV0J3MgcHJvY2VzcyB0aGUgZmlsZVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0xPQURfRklMRScsIGZpbGUsIHsgcXVlcnkgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgUkVRVUVTVF9QUkVQQVJFX09VVFBVVDogKHsgaXRlbSwgc3VjY2VzcywgZmFpbHVyZSA9ICgpID0+IHt9IH0pID0+IHtcbiAgICAgICAgLy8gZXJyb3IgcmVzcG9uc2UgaWYgaXRlbSBhcmNoaXZlZFxuICAgICAgICBjb25zdCBlcnIgPSB7XG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgMCwgJ0l0ZW0gbm90IGZvdW5kJyksXG4gICAgICAgICAgICBmaWxlOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgd2FpdGluZyB0byBiZSBwcmVwYXJlZFxuICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignUFJFUEFSRV9PVVRQVVQnLCBpdGVtLmZpbGUsIHsgcXVlcnksIGl0ZW0gfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQ09NUExFVEVfUFJFUEFSRV9PVVRQVVQnLCByZXN1bHQsIHsgcXVlcnksIGl0ZW0gfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGhhbmRsZSBhcmNoaXZlZCBpdGVtcywgYW4gaXRlbSBjb3VsZCBoYXZlIGJlZW4gYXJjaGl2ZWQgKGxvYWQgYWJvcnRlZCkgd2hpbGUgYmVpbmcgcHJlcGFyZWRcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hcmNoaXZlZCkgcmV0dXJuIGZhaWx1cmUoZXJyKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgc3VjY2VzcyhyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBDT01QTEVURV9MT0FEX0lURU06ICh7IGl0ZW0sIGRhdGEgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN1Y2Nlc3MsIHNvdXJjZSB9ID0gZGF0YTtcblxuICAgICAgICAvLyBzb3J0IGl0ZW1zIGluIGxpc3RcbiAgICAgICAgY29uc3QgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihpdGVtSW5zZXJ0TG9jYXRpb24pICYmIHNvdXJjZSkge1xuICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IGludGVyZmFjZSBrbm93IHRoZSBpdGVtIGhhcyBsb2FkZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpdGVtIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBsb2FkZWQgYW5kIGFkZGVkIHRvIHRoZVxuICAgICAgICAvLyBsaXN0IG9mIGl0ZW1zIHNvIGNhbiBub3cgYmUgc2FmZWx5IHJldHVybmVkIGZvciB1c2VcbiAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbG9jYWwgc2VydmVyIGZpbGUgd2UgbmVlZCB0byBzaG93IGEgZGlmZmVyZW50IHN0YXRlXG4gICAgICAgIGlmIChpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0xPQ0FMX0lURU0nLCB7IGlkOiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXMgYSB0ZW1wIHNlcnZlciBmaWxlIHdlIHByZXZlbnQgYXN5bmMgdXBsb2FkIGNhbGwgaGVyZSAoYXMgdGhlIGZpbGUgaXMgYWxyZWFkeSBvbiB0aGUgc2VydmVyKVxuICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTElNQk8pIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0RFRklORV9WQUxVRScsIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbS5zZXJ2ZXJJZCB8fCBzb3VyY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlkIHdlIGFyZSBhbGxvd2VkIHRvIHVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseSwgbGV0cyBkbyBpdFxuICAgICAgICBpZiAocXVlcnkoJ0lTX0FTWU5DJykgJiYgc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFJFVFJZX0lURU1fTE9BRDogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICAvLyB0cnkgbG9hZGluZyB0aGUgc291cmNlIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgaXRlbS5yZXRyeUxvYWQoKTtcbiAgICB9KSxcblxuICAgIFJFUVVFU1RfSVRFTV9QUkVQQVJFOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9QUkVQQVJFX09VVFBVVCcsIHsgaWQ6IGl0ZW0uaWQsIGZpbGUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICB9KSxcblxuICAgIFJFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUpID0+IHtcbiAgICAgICAgLy8gY2Fubm90IGJlIHF1ZXVlZCAob3IgaXMgYWxyZWFkeSBxdWV1ZWQpXG4gICAgICAgIGNvbnN0IGl0ZW1DYW5CZVF1ZXVlZEZvclByb2Nlc3NpbmcgPVxuICAgICAgICAgICAgLy8gd2FpdGluZyBmb3Igc29tZXRoaW5nXG4gICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFIHx8XG4gICAgICAgICAgICAvLyBwcm9jZXNzaW5nIHdlbnQgd3JvbmcgZWFybGllclxuICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUjtcblxuICAgICAgICAvLyBub3QgcmVhZHkgdG8gYmUgcHJvY2Vzc2VkXG4gICAgICAgIGlmICghaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc05vdyA9ICgpID0+XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSwgc3VjY2VzcywgZmFpbHVyZSB9KTtcblxuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9ICgpID0+IChkb2N1bWVudC5oaWRkZW4gPyBwcm9jZXNzTm93KCkgOiBzZXRUaW1lb3V0KHByb2Nlc3NOb3csIDMyKSk7XG5cbiAgICAgICAgICAgIC8vIGlmIGFscmVhZHkgZG9uZSBwcm9jZXNzaW5nIG9yIHRyaWVkIHRvIHJldmVydCBidXQgZGlkbid0IHdvcmssIHRyeSBhZ2FpblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgfHxcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocHJvY2VzcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHt9KTsgLy8gZG9uJ3QgY29udGludWUgd2l0aCBwcm9jZXNzaW5nIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4ocHJvY2Vzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFscmVhZHkgcXVldWVkIGZvciBwcm9jZXNzaW5nXG4gICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1FVRVVFRCkgcmV0dXJuO1xuXG4gICAgICAgIGl0ZW0ucmVxdWVzdFByb2Nlc3NpbmcoKTtcblxuICAgICAgICBkaXNwYXRjaCgnRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICBkaXNwYXRjaCgnUFJPQ0VTU19JVEVNJywgeyBxdWVyeTogaXRlbSwgc3VjY2VzcywgZmFpbHVyZSB9LCB0cnVlKTtcbiAgICB9KSxcblxuICAgIFBST0NFU1NfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIChpdGVtLCBzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1heFBhcmFsbGVsVXBsb2FkcyA9IHF1ZXJ5KCdHRVRfTUFYX1BBUkFMTEVMX1VQTE9BRFMnKTtcbiAgICAgICAgY29uc3QgdG90YWxDdXJyZW50VXBsb2FkcyA9IHF1ZXJ5KCdHRVRfSVRFTVNfQllfU1RBVFVTJywgSXRlbVN0YXR1cy5QUk9DRVNTSU5HKS5sZW5ndGg7XG5cbiAgICAgICAgLy8gcXVldWUgYW5kIHdhaXQgdGlsbCBxdWV1ZSBpcyBmcmVlZCB1cFxuICAgICAgICBpZiAodG90YWxDdXJyZW50VXBsb2FkcyA9PT0gbWF4UGFyYWxsZWxVcGxvYWRzKSB7XG4gICAgICAgICAgICAvLyBxdWV1ZSBmb3IgbGF0ZXIgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZmFpbHVyZSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBzdG9wIGl0IVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2FzIG5vdCBxdWV1ZWQgb3IgaXMgYWxyZWFkeSBwcm9jZXNzaW5nIGV4aXQgaGVyZVxuICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NOZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZXVkIGl0ZW1zXG4gICAgICAgICAgICBjb25zdCBxdWV1ZUVudHJ5ID0gc3RhdGUucHJvY2Vzc2luZ1F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIC8vIG5vIGl0ZW1zIGxlZnRcbiAgICAgICAgICAgIGlmICghcXVldWVFbnRyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBnZXQgaXRlbSByZWZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN1Y2Nlc3MsIGZhaWx1cmUgfSA9IHF1ZXVlRW50cnk7XG4gICAgICAgICAgICBjb25zdCBpdGVtUmVmZXJlbmNlID0gZ2V0SXRlbUJ5UXVlcnkoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgLy8gaWYgaXRlbSB3YXMgYXJjaGl2ZWQgd2hpbGUgaW4gcXVldWUsIGp1bXAgdG8gbmV4dFxuICAgICAgICAgICAgaWYgKCFpdGVtUmVmZXJlbmNlIHx8IGl0ZW1SZWZlcmVuY2UuYXJjaGl2ZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJvY2VzcyBxdWV1ZWQgaXRlbVxuICAgICAgICAgICAgZGlzcGF0Y2goJ1BST0NFU1NfSVRFTScsIHsgcXVlcnk6IGlkLCBzdWNjZXNzLCBmYWlsdXJlIH0sIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHdlIGRvbmUgZnVuY3Rpb25cbiAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtY29tcGxldGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcblxuICAgICAgICAgICAgLy8gaWYgb3JpZ2luIGlzIGxvY2FsLCBhbmQgd2UncmUgaW5zdGFudCB1cGxvYWRpbmcsIHRyaWdnZXIgcmVtb3ZlIG9mIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyBhcyByZXZlcnQgd2lsbCByZW1vdmUgZmlsZSBmcm9tIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICAgICAgY29uc3QgaW5zdGFudFVwbG9hZCA9IHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZDtcbiAgICAgICAgICAgIGlmIChpbnN0YW50VXBsb2FkICYmIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMICYmIGlzRnVuY3Rpb24oc2VydmVyLnJlbW92ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub29wID0gKCkgPT4ge307XG4gICAgICAgICAgICAgICAgaXRlbS5vcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJlbW92ZShpdGVtLnNvdXJjZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFsbCBpdGVtcyBwcm9jZXNzZWQ/IE5vIGVycm9ycz9cbiAgICAgICAgICAgIGNvbnN0IGFsbEl0ZW1zUHJvY2Vzc2VkID1cbiAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSkubGVuZ3RoID09PVxuICAgICAgICAgICAgICAgIHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhbGxJdGVtc1Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSBlcnJvciBmdW5jdGlvblxuICAgICAgICBpdGVtLm9uT25jZSgncHJvY2Vzcy1lcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIGZhaWx1cmUoeyBlcnJvciwgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHN0YXJ0IGZpbGUgcHJvY2Vzc2luZ1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc3RhdGUub3B0aW9ucztcbiAgICAgICAgaXRlbS5wcm9jZXNzKFxuICAgICAgICAgICAgY3JlYXRlRmlsZVByb2Nlc3NvcihcbiAgICAgICAgICAgICAgICBjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbihvcHRpb25zLnNlcnZlci51cmwsIG9wdGlvbnMuc2VydmVyLnByb2Nlc3MsIG9wdGlvbnMubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBjaHVua1RyYW5zZmVySWQ6IGl0ZW0udHJhbnNmZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtTZXJ2ZXI6IG9wdGlvbnMuc2VydmVyLnBhdGNoLFxuICAgICAgICAgICAgICAgICAgICBjaHVua1VwbG9hZHM6IG9wdGlvbnMuY2h1bmtVcGxvYWRzLFxuICAgICAgICAgICAgICAgICAgICBjaHVua0ZvcmNlOiBvcHRpb25zLmNodW5rRm9yY2UsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rU2l6ZTogb3B0aW9ucy5jaHVua1NpemUsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rUmV0cnlEZWxheXM6IG9wdGlvbnMuY2h1bmtSZXRyeURlbGF5cyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uOiBxdWVyeSgnR0VUX0FMTE9XX01JTklNVU1fVVBMT0FEX0RVUkFUSU9OJyksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSBmaWxlIGlzIGFib3V0IHRvIGJlIHByb2Nlc3NlZCBzbyBpdCBjYW4gYmUgcGlwZWQgdGhyb3VnaCB0aGUgdHJhbnNmb3JtIGZpbHRlcnNcbiAgICAgICAgICAgIChmaWxlLCBzdWNjZXNzLCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHBsdWdpbnMgdG8gYWx0ZXIgdGhlIGZpbGUgZGF0YVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgZmlsZSwgeyBxdWVyeSwgaXRlbSB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0pLFxuXG4gICAgUkVUUllfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgfSksXG5cbiAgICBSRVFVRVNUX1JFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIG9wdGlvbmFsUHJvbWlzZShxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpLCBjcmVhdGVJdGVtQVBJKGl0ZW0pKS50aGVuKHNob3VsZFJlbW92ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgUkVMRUFTRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0ucmVsZWFzZSgpO1xuICAgIH0pLFxuXG4gICAgUkVNT1ZFX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCAoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmVGcm9tVmlldyA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGdldCBpZCByZWZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcblxuICAgICAgICAgICAgLy8gYXJjaGl2ZSB0aGUgaXRlbSwgdGhpcyBkb2VzIG5vdCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICAgICAgZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKS5hcmNoaXZlKCk7XG5cbiAgICAgICAgICAgIC8vIHRlbGwgdGhlIHZpZXcgdGhlIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRU1PVkVfSVRFTScsIHsgZXJyb3I6IG51bGwsIGlkLCBpdGVtIH0pO1xuXG4gICAgICAgICAgICAvLyBub3cgdGhlIGxpc3QgaGFzIGJlZW4gbW9kaWZpZWRcbiAgICAgICAgICAgIGxpc3RVcGRhdGVkKGRpc3BhdGNoLCBzdGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIGNvcnJlY3RseSByZW1vdmVkXG4gICAgICAgICAgICBzdWNjZXNzKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsb2NhbCBmaWxlIGFuZCB0aGUgYHNlcnZlci5yZW1vdmVgIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQsXG4gICAgICAgIC8vIHNlbmQgc291cmNlIHRoZXJlIHNvIGRldiBjYW4gcmVtb3ZlIGZpbGUgZnJvbSBzZXJ2ZXJcbiAgICAgICAgY29uc3Qgc2VydmVyID0gc3RhdGUub3B0aW9ucy5zZXJ2ZXI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMICYmXG4gICAgICAgICAgICBzZXJ2ZXIgJiZcbiAgICAgICAgICAgIGlzRnVuY3Rpb24oc2VydmVyLnJlbW92ZSkgJiZcbiAgICAgICAgICAgIG9wdGlvbnMucmVtb3ZlICE9PSBmYWxzZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9SRU1PVkUnLCB7IGlkOiBpdGVtLmlkIH0pO1xuXG4gICAgICAgICAgICBzZXJ2ZXIucmVtb3ZlKFxuICAgICAgICAgICAgICAgIGl0ZW0uc291cmNlLFxuICAgICAgICAgICAgICAgICgpID0+IHJlbW92ZUZyb21WaWV3KCksXG4gICAgICAgICAgICAgICAgc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsIHN0YXR1cywgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVSZW1vdmVFcnJvcikoc3RhdHVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHN0YXRlLm9wdGlvbnMubGFiZWxUYXBUb1JldHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGlzIHJlcXVlc3RpbmcgcmV2ZXJ0IGFuZCBjYW4gcmV2ZXJ0IG5lZWQgdG8gY2FsbCByZXZlcnQgaGFuZGxlciAobm90IGNhbGxpbmcgcmVxdWVzdF8gYmVjYXVzZSB0aGF0IHdvdWxkIGFsc28gdHJpZ2dlciBiZWZvcmVSZW1vdmVIb29rKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChvcHRpb25zLnJldmVydCAmJiBpdGVtLm9yaWdpbiAhPT0gRmlsZU9yaWdpbi5MT0NBTCAmJiBpdGVtLnNlcnZlcklkICE9PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlmIGNodW5rZWQgdXBsb2FkcyBhcmUgZW5hYmxlZCBhbmQgd2UncmUgdXBsb2FkaW5nIGluIGNodW5rcyBmb3IgdGhpcyBzcGVjaWZpYyBmaWxlXG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgdGhlIGZpbGUgaXNuJ3QgYmlnIGVub3VnaCBmb3IgY2h1bmtlZCB1cGxvYWRzIGJ1dCBjaHVua0ZvcmNlIGlzIHNldCB0aGVuIGNhbGxcbiAgICAgICAgICAgICAgICAvLyByZXZlcnQgYmVmb3JlIHJlbW92aW5nIGZyb20gdGhlIHZpZXcuLi5cbiAgICAgICAgICAgICAgICAoc3RhdGUub3B0aW9ucy5jaHVua1VwbG9hZHMgJiYgaXRlbS5maWxlLnNpemUgPiBzdGF0ZS5vcHRpb25zLmNodW5rU2l6ZSkgfHxcbiAgICAgICAgICAgICAgICAoc3RhdGUub3B0aW9ucy5jaHVua1VwbG9hZHMgJiYgc3RhdGUub3B0aW9ucy5jaHVua0ZvcmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbiBub3cgc2FmZWx5IHJlbW92ZSBmcm9tIHZpZXdcbiAgICAgICAgICAgIHJlbW92ZUZyb21WaWV3KCk7XG4gICAgICAgIH1cbiAgICB9KSxcblxuICAgIEFCT1JUX0lURU1fTE9BRDogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBpdGVtLmFib3J0TG9hZCgpO1xuICAgIH0pLFxuXG4gICAgQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIC8vIHRlc3QgaWYgaXMgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKGl0ZW0uc2VydmVySWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFib3J0XG4gICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSksXG5cbiAgICBSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtID0+IHtcbiAgICAgICAgLy8gbm90IGluc3RhbnQgdXBsb2FkaW5nLCByZXZlcnQgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKCFzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlJ3JlIGluc3RhbnQgdXBsb2FkaW5nIHRoZSBmaWxlIHdpbGwgYWxzbyBiZSByZW1vdmVkIGlmIHdlIHJldmVydCxcbiAgICAgICAgLy8gc28gaWYgYSBiZWZvcmUgcmVtb3ZlIGZpbGUgaG9vayBpcyBkZWZpbmVkIHdlIG5lZWQgdG8gcnVuIGl0IG5vd1xuICAgICAgICBjb25zdCBoYW5kbGVSZXZlcnQgPSBzaG91bGRSZXZlcnQgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGRSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBmbiA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1JFTU9WRV9GSUxFJyk7XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXF1ZXN0UmVtb3ZlUmVzdWx0ID0gZm4oY3JlYXRlSXRlbUFQSShpdGVtKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0UmVtb3ZlUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXZlcnQocmVxdWVzdFJlbW92ZVJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3RSZW1vdmVSZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVxdWVzdFJlbW92ZVJlc3VsdC50aGVuKGhhbmRsZVJldmVydCk7XG4gICAgICAgIH1cbiAgICB9KSxcblxuICAgIFJFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtID0+IHtcbiAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydCksXG4gICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgIClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZW1vdmUgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQgfHwgaXNNb2NrSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7XG4gICAgfSksXG5cbiAgICBTRVRfT1BUSU9OUzogKHsgb3B0aW9ucyB9KSA9PiB7XG4gICAgICAgIC8vIGdldCBhbGwga2V5cyBwYXNzZWRcbiAgICAgICAgY29uc3Qgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGdldCBwcmlvcml0aXplZCBrZXllZCB0byBpbmNsdWRlIChyZW1vdmUgb25jZSBub3QgaW4gb3B0aW9ucyBvYmplY3QpXG4gICAgICAgIGNvbnN0IHByaW9yaXRpemVkT3B0aW9uS2V5cyA9IFByaW9yaXRpemVkT3B0aW9ucy5maWx0ZXIoa2V5ID0+IG9wdGlvbktleXMuaW5jbHVkZXMoa2V5KSk7XG5cbiAgICAgICAgLy8gb3JkZXIgdGhlIGtleXMsIHByaW9yaXRpemVkIGZpcnN0LCB0aGVuIHJlc3RcbiAgICAgICAgY29uc3Qgb3JkZXJlZE9wdGlvbktleXMgPSBbXG4gICAgICAgICAgICAvLyBhZGQgcHJpb3JpdGl6ZWQgZmlyc3QgaWYgcGFzc2VkIHRvIG9wdGlvbnMsIGVsc2UgcmVtb3ZlXG4gICAgICAgICAgICAuLi5wcmlvcml0aXplZE9wdGlvbktleXMsXG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgZHVwbGljYXRlIGtleXNcbiAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcihrZXkgPT4gIXByaW9yaXRpemVkT3B0aW9uS2V5cy5pbmNsdWRlcyhrZXkpKSxcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBkaXNwYXRjaCBzZXQgZXZlbnQgZm9yIGVhY2ggb3B0aW9uXG4gICAgICAgIG9yZGVyZWRPcHRpb25LZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGBTRVRfJHtmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpfWAsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1trZXldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59KTtcblxuY29uc3QgUHJpb3JpdGl6ZWRPcHRpb25zID0gW1xuICAgICdzZXJ2ZXInLCAvLyBtdXN0IGJlIHByb2Nlc3NlZCBiZWZvcmUgXCJmaWxlc1wiXG5dO1xuXG5jb25zdCBmb3JtYXRGaWxlbmFtZSA9IG5hbWUgPT4gbmFtZTtcblxuY29uc3QgY3JlYXRlRWxlbWVudCQxID0gdGFnTmFtZSA9PiB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG59O1xuXG5jb25zdCB0ZXh0ID0gKG5vZGUsIHZhbHVlKSA9PiB7XG4gICAgbGV0IHRleHROb2RlID0gbm9kZS5jaGlsZE5vZGVzWzBdO1xuICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHRleHROb2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICB0ZXh0Tm9kZS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59O1xuXG5jb25zdCBwb2xhclRvQ2FydGVzaWFuID0gKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgYW5nbGVJbkRlZ3JlZXMpID0+IHtcbiAgICBjb25zdCBhbmdsZUluUmFkaWFucyA9ICgoKGFuZ2xlSW5EZWdyZWVzICUgMzYwKSAtIDkwKSAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2VudGVyWCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICAgICAgeTogY2VudGVyWSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKSxcbiAgICB9O1xufTtcblxuY29uc3QgZGVzY3JpYmVBcmMgPSAoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYXJjU3dlZXApID0+IHtcbiAgICBjb25zdCBzdGFydCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kID0gcG9sYXJUb0NhcnRlc2lhbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICAgIHJldHVybiBbJ00nLCBzdGFydC54LCBzdGFydC55LCAnQScsIHJhZGl1cywgcmFkaXVzLCAwLCBhcmNTd2VlcCwgMCwgZW5kLngsIGVuZC55XS5qb2luKCcgJyk7XG59O1xuXG5jb25zdCBwZXJjZW50YWdlQXJjID0gKHgsIHksIHJhZGl1cywgZnJvbSwgdG8pID0+IHtcbiAgICBsZXQgYXJjU3dlZXAgPSAxO1xuICAgIGlmICh0byA+IGZyb20gJiYgdG8gLSBmcm9tIDw9IDAuNSkge1xuICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgfVxuICAgIGlmIChmcm9tID4gdG8gJiYgZnJvbSAtIHRvID49IDAuNSkge1xuICAgICAgICBhcmNTd2VlcCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmliZUFyYyhcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBNYXRoLm1pbigwLjk5OTksIGZyb20pICogMzYwLFxuICAgICAgICBNYXRoLm1pbigwLjk5OTksIHRvKSAqIDM2MCxcbiAgICAgICAgYXJjU3dlZXBcbiAgICApO1xufTtcblxuY29uc3QgY3JlYXRlID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIHN0YXJ0IGF0IDBcbiAgICBwcm9wcy5zcGluID0gZmFsc2U7XG4gICAgcHJvcHMucHJvZ3Jlc3MgPSAwO1xuICAgIHByb3BzLm9wYWNpdHkgPSAwO1xuXG4gICAgLy8gc3ZnXG4gICAgY29uc3Qgc3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG4gICAgcm9vdC5yZWYucGF0aCA9IGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCB7XG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAncm91bmQnLFxuICAgIH0pO1xuICAgIHN2Zy5hcHBlbmRDaGlsZChyb290LnJlZi5wYXRoKTtcblxuICAgIHJvb3QucmVmLnN2ZyA9IHN2ZztcblxuICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ZnKTtcbn07XG5cbmNvbnN0IHdyaXRlID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIGlmIChwcm9wcy5vcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuYWxpZ24pIHtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSBwcm9wcy5hbGlnbjtcbiAgICB9XG5cbiAgICAvLyBnZXQgd2lkdGggb2Ygc3Ryb2tlXG4gICAgY29uc3QgcmluZ1N0cm9rZVdpZHRoID0gcGFyc2VJbnQoYXR0cihyb290LnJlZi5wYXRoLCAnc3Ryb2tlLXdpZHRoJyksIDEwKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBzaXplIG9mIHJpbmdcbiAgICBjb25zdCBzaXplID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG5cbiAgICAvLyByaW5nIHN0YXRlXG4gICAgbGV0IHJpbmdGcm9tID0gMDtcbiAgICBsZXQgcmluZ1RvID0gMDtcblxuICAgIC8vIG5vdyBpbiBidXN5IG1vZGVcbiAgICBpZiAocHJvcHMuc3Bpbikge1xuICAgICAgICByaW5nRnJvbSA9IDA7XG4gICAgICAgIHJpbmdUbyA9IDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByaW5nRnJvbSA9IDA7XG4gICAgICAgIHJpbmdUbyA9IHByb3BzLnByb2dyZXNzO1xuICAgIH1cblxuICAgIC8vIGdldCBhcmMgcGF0aFxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcGVyY2VudGFnZUFyYyhzaXplLCBzaXplLCBzaXplIC0gcmluZ1N0cm9rZVdpZHRoLCByaW5nRnJvbSwgcmluZ1RvKTtcblxuICAgIC8vIHVwZGF0ZSBwcm9ncmVzcyBiYXJcbiAgICBhdHRyKHJvb3QucmVmLnBhdGgsICdkJywgY29vcmRpbmF0ZXMpO1xuXG4gICAgLy8gaGlkZSB3aGlsZSBjb250YWlucyAwIHZhbHVlXG4gICAgYXR0cihyb290LnJlZi5wYXRoLCAnc3Ryb2tlLW9wYWNpdHknLCBwcm9wcy5zcGluIHx8IHByb3BzLnByb2dyZXNzID4gMCA/IDEgOiAwKTtcbn07XG5cbmNvbnN0IHByb2dyZXNzSW5kaWNhdG9yID0gY3JlYXRlVmlldyh7XG4gICAgdGFnOiAnZGl2JyxcbiAgICBuYW1lOiAncHJvZ3Jlc3MtaW5kaWNhdG9yJyxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgY3JlYXRlLFxuICAgIHdyaXRlLFxuICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbJ3Byb2dyZXNzJywgJ3NwaW4nLCAnYWxpZ24nXSxcbiAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogNTAwIH0sXG4gICAgICAgICAgICBwcm9ncmVzczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzcHJpbmcnLFxuICAgICAgICAgICAgICAgIHN0aWZmbmVzczogMC45NSxcbiAgICAgICAgICAgICAgICBkYW1waW5nOiAwLjY1LFxuICAgICAgICAgICAgICAgIG1hc3M6IDEwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGNyZWF0ZSQxID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIHJvb3QuZWxlbWVudC5pbm5lckhUTUwgPSAocHJvcHMuaWNvbiB8fCAnJykgKyBgPHNwYW4+JHtwcm9wcy5sYWJlbH08L3NwYW4+YDtcblxuICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbn07XG5cbmNvbnN0IHdyaXRlJDEgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgY29uc3QgeyBpc0Rpc2FibGVkIH0gPSBwcm9wcztcbiAgICBjb25zdCBzaG91bGREaXNhYmxlID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJykgfHwgcHJvcHMub3BhY2l0eSA9PT0gMDtcblxuICAgIGlmIChzaG91bGREaXNhYmxlICYmICFpc0Rpc2FibGVkKSB7XG4gICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgfSBlbHNlIGlmICghc2hvdWxkRGlzYWJsZSAmJiBpc0Rpc2FibGVkKSB7XG4gICAgICAgIHByb3BzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB9XG59O1xuXG5jb25zdCBmaWxlQWN0aW9uQnV0dG9uID0gY3JlYXRlVmlldyh7XG4gICAgdGFnOiAnYnV0dG9uJyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgIH0sXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIG5hbWU6ICdmaWxlLWFjdGlvbi1idXR0b24nLFxuICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbJ2xhYmVsJ10sXG4gICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5lcnM6IHRydWUsXG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQxLFxuICAgIHdyaXRlOiB3cml0ZSQxLFxufSk7XG5cbmNvbnN0IHRvTmF0dXJhbEZpbGVTaXplID0gKGJ5dGVzLCBkZWNpbWFsU2VwYXJhdG9yID0gJy4nLCBiYXNlID0gMTAwMCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBsYWJlbEJ5dGVzID0gJ2J5dGVzJyxcbiAgICAgICAgbGFiZWxLaWxvYnl0ZXMgPSAnS0InLFxuICAgICAgICBsYWJlbE1lZ2FieXRlcyA9ICdNQicsXG4gICAgICAgIGxhYmVsR2lnYWJ5dGVzID0gJ0dCJyxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIC8vIG5vIG5lZ2F0aXZlIGJ5dGUgc2l6ZXNcbiAgICBieXRlcyA9IE1hdGgucm91bmQoTWF0aC5hYnMoYnl0ZXMpKTtcblxuICAgIGNvbnN0IEtCID0gYmFzZTtcbiAgICBjb25zdCBNQiA9IGJhc2UgKiBiYXNlO1xuICAgIGNvbnN0IEdCID0gYmFzZSAqIGJhc2UgKiBiYXNlO1xuXG4gICAgLy8ganVzdCBieXRlc1xuICAgIGlmIChieXRlcyA8IEtCKSB7XG4gICAgICAgIHJldHVybiBgJHtieXRlc30gJHtsYWJlbEJ5dGVzfWA7XG4gICAgfVxuXG4gICAgLy8ga2lsb2J5dGVzXG4gICAgaWYgKGJ5dGVzIDwgTUIpIHtcbiAgICAgICAgcmV0dXJuIGAke01hdGguZmxvb3IoYnl0ZXMgLyBLQil9ICR7bGFiZWxLaWxvYnl0ZXN9YDtcbiAgICB9XG5cbiAgICAvLyBtZWdhYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBHQikge1xuICAgICAgICByZXR1cm4gYCR7cmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIE1CLCAxLCBkZWNpbWFsU2VwYXJhdG9yKX0gJHtsYWJlbE1lZ2FieXRlc31gO1xuICAgIH1cblxuICAgIC8vIGdpZ2FieXRlc1xuICAgIHJldHVybiBgJHtyZW1vdmVEZWNpbWFsc1doZW5aZXJvKGJ5dGVzIC8gR0IsIDIsIGRlY2ltYWxTZXBhcmF0b3IpfSAke2xhYmVsR2lnYWJ5dGVzfWA7XG59O1xuXG5jb25zdCByZW1vdmVEZWNpbWFsc1doZW5aZXJvID0gKHZhbHVlLCBkZWNpbWFsQ291bnQsIHNlcGFyYXRvcikgPT4ge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAudG9GaXhlZChkZWNpbWFsQ291bnQpXG4gICAgICAgIC5zcGxpdCgnLicpXG4gICAgICAgIC5maWx0ZXIocGFydCA9PiBwYXJ0ICE9PSAnMCcpXG4gICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG59O1xuXG5jb25zdCBjcmVhdGUkMiA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBmaWxlbmFtZVxuICAgIGNvbnN0IGZpbGVOYW1lID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgZmlsZU5hbWUuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLWluZm8tbWFpbic7XG4gICAgLy8gaGlkZSBmb3Igc2NyZWVucmVhZGVyc1xuICAgIC8vIHRoZSBmaWxlIGlzIGNvbnRhaW5lZCBpbiBhIGZpZWxkc2V0IHdpdGggbGVnZW5kIHRoYXQgY29udGFpbnMgdGhlIGZpbGVuYW1lXG4gICAgLy8gbm8gbmVlZCB0byByZWFkIGl0IHR3aWNlXG4gICAgYXR0cihmaWxlTmFtZSwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICByb290LmFwcGVuZENoaWxkKGZpbGVOYW1lKTtcbiAgICByb290LnJlZi5maWxlTmFtZSA9IGZpbGVOYW1lO1xuXG4gICAgLy8gZmlsZXNpemVcbiAgICBjb25zdCBmaWxlU2l6ZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIGZpbGVTaXplLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLXN1Yic7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlU2l6ZSk7XG4gICAgcm9vdC5yZWYuZmlsZVNpemUgPSBmaWxlU2l6ZTtcblxuICAgIC8vIHNldCBpbml0aWFsIHZhbHVlc1xuICAgIHRleHQoZmlsZVNpemUsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1dBSVRJTkdfRk9SX1NJWkUnKSk7XG4gICAgdGV4dChmaWxlTmFtZSwgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSkpO1xufTtcblxuY29uc3QgdXBkYXRlRmlsZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICB0ZXh0KFxuICAgICAgICByb290LnJlZi5maWxlU2l6ZSxcbiAgICAgICAgdG9OYXR1cmFsRmlsZVNpemUoXG4gICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9TSVpFJywgcHJvcHMuaWQpLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9CQVNFJyksXG4gICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfRklMRV9TSVpFX0xBQkVMUycsIHJvb3QucXVlcnkpXG4gICAgICAgIClcbiAgICApO1xuICAgIHRleHQocm9vdC5yZWYuZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbn07XG5cbmNvbnN0IHVwZGF0ZUZpbGVTaXplT25FcnJvciA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBpZiBzaXplIGlzIGF2YWlsYWJsZSBkb24ndCBmYWxsYmFjayB0byB1bmtub3duIHNpemUgbWVzc2FnZVxuICAgIGlmIChpc0ludChyb290LnF1ZXJ5KCdHRVRfSVRFTV9TSVpFJywgcHJvcHMuaWQpKSkge1xuICAgICAgICB1cGRhdGVGaWxlKHsgcm9vdCwgcHJvcHMgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0ZXh0KHJvb3QucmVmLmZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX05PVF9BVkFJTEFCTEUnKSk7XG59O1xuXG5jb25zdCBmaWxlSW5mbyA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdmaWxlLWluZm8nLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfTE9BRF9JVEVNOiB1cGRhdGVGaWxlLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fTUVUQTogdXBkYXRlRmlsZSxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogdXBkYXRlRmlsZVNpemVPbkVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IsXG4gICAgfSksXG4gICAgZGlkQ3JlYXRlVmlldzogcm9vdCA9PiB7XG4gICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCB7IC4uLnJvb3QsIHZpZXc6IHJvb3QgfSk7XG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQyLFxuICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5jb25zdCB0b1BlcmNlbnRhZ2UgPSB2YWx1ZSA9PiBNYXRoLnJvdW5kKHZhbHVlICogMTAwKTtcblxuY29uc3QgY3JlYXRlJDMgPSAoeyByb290IH0pID0+IHtcbiAgICAvLyBtYWluIHN0YXR1c1xuICAgIGNvbnN0IG1haW4gPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBtYWluLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtbWFpbic7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChtYWluKTtcbiAgICByb290LnJlZi5tYWluID0gbWFpbjtcblxuICAgIC8vIHN1YiBzdGF0dXNcbiAgICBjb25zdCBzdWIgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBzdWIuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1maWxlLXN0YXR1cy1zdWInO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoc3ViKTtcbiAgICByb290LnJlZi5zdWIgPSBzdWI7XG5cbiAgICBkaWRTZXRJdGVtTG9hZFByb2dyZXNzKHsgcm9vdCwgYWN0aW9uOiB7IHByb2dyZXNzOiBudWxsIH0gfSk7XG59O1xuXG5jb25zdCBkaWRTZXRJdGVtTG9hZFByb2dyZXNzID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCB0aXRsZSA9XG4gICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9MT0FESU5HJylcbiAgICAgICAgICAgIDogYCR7cm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpfSAke3RvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpfSVgO1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbn07XG5cbmNvbnN0IGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IHRpdGxlID1cbiAgICAgICAgYWN0aW9uLnByb2dyZXNzID09PSBudWxsXG4gICAgICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkcnKVxuICAgICAgICAgICAgOiBgJHtyb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJyl9ICR7dG9QZXJjZW50YWdlKGFjdGlvbi5wcm9ncmVzcyl9JWA7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCB0aXRsZSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fQ0FOQ0VMJykpO1xufTtcblxuY29uc3QgZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJykpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbn07XG5cbmNvbnN0IGRpZEFib3J0SXRlbVByb2Nlc3NpbmcgPSAoeyByb290IH0pID0+IHtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQUJPUlRFRCcpKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19SRVRSWScpKTtcbn07XG5cbmNvbnN0IGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcgPSAoeyByb290IH0pID0+IHtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1BST0NFU1NJTkdfQ09NUExFVEUnKSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fVU5ETycpKTtcbn07XG5cbmNvbnN0IGNsZWFyID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCAnJyk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsICcnKTtcbn07XG5cbmNvbnN0IGVycm9yID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIGFjdGlvbi5zdGF0dXMubWFpbik7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIGFjdGlvbi5zdGF0dXMuc3ViKTtcbn07XG5cbmNvbnN0IGZpbGVTdGF0dXMgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZmlsZS1zdGF0dXMnLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICB3cml0ZTogY3JlYXRlUm91dGUoe1xuICAgICAgICBESURfTE9BRF9JVEVNOiBjbGVhcixcbiAgICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGNsZWFyLFxuICAgICAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogZGlkQWJvcnRJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogZGlkQ29tcGxldGVJdGVtUHJvY2Vzc2luZyxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGRpZFNldEl0ZW1Qcm9jZXNzUHJvZ3Jlc3MsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiBkaWRTZXRJdGVtTG9hZFByb2dyZXNzLFxuICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBlcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogZXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IGVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogZXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogZXJyb3IsXG4gICAgfSksXG4gICAgZGlkQ3JlYXRlVmlldzogcm9vdCA9PiB7XG4gICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCB7IC4uLnJvb3QsIHZpZXc6IHJvb3QgfSk7XG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSQzLFxuICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuLyoqXG4gKiBCdXR0b24gZGVmaW5pdGlvbnMgZm9yIHRoZSBmaWxlIHZpZXdcbiAqL1xuXG5jb25zdCBCdXR0b25zID0ge1xuICAgIEFib3J0SXRlbUxvYWQ6IHtcbiAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRCcsXG4gICAgICAgIGFjdGlvbjogJ0FCT1JUX0lURU1fTE9BRCcsXG4gICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tYWJvcnQtaXRlbS1sb2FkJyxcbiAgICAgICAgYWxpZ246ICdMT0FEX0lORElDQVRPUl9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXRyeUl0ZW1Mb2FkOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX0xPQUQnLFxuICAgICAgICBhY3Rpb246ICdSRVRSWV9JVEVNX0xPQUQnLFxuICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tbG9hZCcsXG4gICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZW1vdmVJdGVtOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTScsXG4gICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfUkVNT1ZFX0lURU0nLFxuICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVNT1ZFJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZW1vdmUtaXRlbScsXG4gICAgICAgIGFsaWduOiAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJywgLy8gbGVmdFxuICAgIH0sXG4gICAgUHJvY2Vzc0l0ZW06IHtcbiAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1BST0NFU1NfSVRFTScsXG4gICAgICAgIGFjdGlvbjogJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1BST0NFU1MnLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXByb2Nlc3MtaXRlbScsXG4gICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBBYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9SRVRSWV9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICBhY3Rpb246ICdSRVRSWV9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICBpY29uOiAnR0VUX0lDT05fUkVUUlknLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldHJ5LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgfSxcbiAgICBSZXZlcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fVU5ET19JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICBhY3Rpb246ICdSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICBpY29uOiAnR0VUX0lDT05fVU5ETycsXG4gICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmV2ZXJ0LWl0ZW0tcHJvY2Vzc2luZycsXG4gICAgICAgIGFsaWduOiAnQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTicsIC8vIHJpZ2h0XG4gICAgfSxcbn07XG5cbi8vIG1ha2UgYSBsaXN0IG9mIGJ1dHRvbnMsIHdlIGNhbiB0aGVuIHJlbW92ZSBidXR0b25zIGZyb20gdGhpcyBsaXN0IGlmIHRoZXkncmUgZGlzYWJsZWRcbmNvbnN0IEJ1dHRvbktleXMgPSBbXTtcbmZvcmluKEJ1dHRvbnMsIGtleSA9PiB7XG4gICAgQnV0dG9uS2V5cy5wdXNoKGtleSk7XG59KTtcblxuY29uc3QgY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgPSByb290ID0+IHtcbiAgICBpZiAoZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQocm9vdCkgPT09ICdyaWdodCcpIHJldHVybiAwO1xuICAgIGNvbnN0IGJ1dHRvblJlY3QgPSByb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudDtcbiAgICByZXR1cm4gYnV0dG9uUmVjdC5oaWRkZW4gPyBudWxsIDogYnV0dG9uUmVjdC53aWR0aCArIGJ1dHRvblJlY3QubGVmdDtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZUJ1dHRvbldpZHRoID0gcm9vdCA9PiB7XG4gICAgY29uc3QgYnV0dG9uUmVjdCA9IHJvb3QucmVmLmJ1dHRvbkFib3J0SXRlbUxvYWQucmVjdC5lbGVtZW50O1xuICAgIHJldHVybiBidXR0b25SZWN0LndpZHRoO1xufTtcblxuLy8gRm9yY2Ugb24gZnVsbCBwaXhlbHMgc28gdGV4dCBzdGF5cyBjcmlwc1xuY29uc3QgY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0ID0gcm9vdCA9PlxuICAgIE1hdGguZmxvb3Iocm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0IC8gNCk7XG5jb25zdCBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCA9IHJvb3QgPT5cbiAgICBNYXRoLmZsb29yKHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50LmxlZnQgLyAyKTtcblxuY29uc3QgZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCA9IHJvb3QgPT4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OJyk7XG5jb25zdCBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50ID0gcm9vdCA9PiByb290LnF1ZXJ5KCdHRVRfU1RZTEVfUFJPR1JFU1NfSU5ESUNBVE9SX1BPU0lUSU9OJyk7XG5jb25zdCBnZXRSZW1vdmVJbmRpY2F0b3JBbGlnbWVudCA9IHJvb3QgPT4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicpO1xuXG5jb25zdCBEZWZhdWx0U3R5bGUgPSB7XG4gICAgYnV0dG9uQWJvcnRJdGVtTG9hZDogeyBvcGFjaXR5OiAwIH0sXG4gICAgYnV0dG9uUmV0cnlJdGVtTG9hZDogeyBvcGFjaXR5OiAwIH0sXG4gICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAwIH0sXG4gICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgfSxcbiAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQgfSxcbiAgICBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgc2NhbGVYOiAwLjc1LCBzY2FsZVk6IDAuNzUgfSxcbiAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbiAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogMCwgdHJhbnNsYXRlWTogMCwgb3BhY2l0eTogMCB9LFxufTtcblxuY29uc3QgSWRsZVN0eWxlID0ge1xuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG59O1xuXG5jb25zdCBQcm9jZXNzaW5nU3R5bGUgPSB7XG4gICAgYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxufTtcblxuY29uc3QgU3R5bGVNYXAgPSB7XG4gICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDoge1xuICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQsIG9wYWNpdHk6IDEgfSxcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IHtcbiAgICAgICAgYnV0dG9uQWJvcnRJdGVtTG9hZDogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGxvYWRQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfSxcbiAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiB7XG4gICAgICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgIH0sXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiB7XG4gICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxLCBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMCB9LFxuICAgIH0sXG4gICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiB7XG4gICAgICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAwLCBhbGlnbjogZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgfSxcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEsIHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgfSxcbiAgICBESURfTE9BRF9JVEVNOiBJZGxlU3R5bGUsXG4gICAgRElEX0xPQURfTE9DQUxfSVRFTToge1xuICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogUHJvY2Vzc2luZ1N0eWxlLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICB9LFxuICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGJ1dHRvblJldHJ5SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgfSxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjoge1xuICAgICAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgb3BhY2l0eTogMSB9LFxuICAgIH0sXG4gICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzoge1xuICAgICAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgYnV0dG9uUHJvY2Vzc0l0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfSxcbiAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogSWRsZVN0eWxlLFxufTtcblxuLy8gY29tcGxldGUgaW5kaWNhdG9yIHZpZXdcbmNvbnN0IHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gcm9vdC5xdWVyeSgnR0VUX0lDT05fRE9ORScpO1xuICAgIH0sXG4gICAgbmFtZTogJ3Byb2Nlc3NpbmctY29tcGxldGUtaW5kaWNhdG9yJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsnc2NhbGVYJywgJ3NjYWxlWScsICdvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHNjYWxlWDogJ3NwcmluZycsXG4gICAgICAgICAgICBzY2FsZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICovXG5jb25zdCBjcmVhdGUkNCA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBjb3B5IEJ1dHRvbnMgb2JqZWN0XG4gICAgY29uc3QgTG9jYWxCdXR0b25zID0gT2JqZWN0LmtleXMoQnV0dG9ucykucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XG4gICAgICAgIHByZXZbY3Vycl0gPSB7IC4uLkJ1dHRvbnNbY3Vycl0gfTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xuXG4gICAgY29uc3QgeyBpZCB9ID0gcHJvcHM7XG5cbiAgICAvLyBhbGxvdyByZXZlcnRpbmcgdXBsb2FkXG4gICAgY29uc3QgYWxsb3dSZXZlcnQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVWRVJUJyk7XG5cbiAgICAvLyBhbGxvdyByZW1vdmUgZmlsZVxuICAgIGNvbnN0IGFsbG93UmVtb3ZlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFTU9WRScpO1xuXG4gICAgLy8gYWxsb3cgcHJvY2Vzc2luZyB1cGxvYWRcbiAgICBjb25zdCBhbGxvd1Byb2Nlc3MgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUFJPQ0VTUycpO1xuXG4gICAgLy8gaXMgaW5zdGFudCB1cGxvYWRpbmcsIG5lZWQgdGhpcyB0byBkZXRlcm1pbmUgdGhlIGljb24gb2YgdGhlIHVuZG8gYnV0dG9uXG4gICAgY29uc3QgaW5zdGFudFVwbG9hZCA9IHJvb3QucXVlcnkoJ0dFVF9JTlNUQU5UX1VQTE9BRCcpO1xuXG4gICAgLy8gaXMgYXN5bmMgc2V0IHVwXG4gICAgY29uc3QgaXNBc3luYyA9IHJvb3QucXVlcnkoJ0lTX0FTWU5DJyk7XG5cbiAgICAvLyBzaG91bGQgYWxpZ24gcmVtb3ZlIGl0ZW0gYnV0dG9uc1xuICAgIGNvbnN0IGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiA9IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fQUxJR04nKTtcblxuICAgIC8vIGVuYWJsZWQgYnV0dG9ucyBhcnJheVxuICAgIGxldCBidXR0b25GaWx0ZXI7XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgaWYgKGFsbG93UHJvY2VzcyAmJiAhYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHJldmVydCBidXR0b25cbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGtleSA9PiAhL1JldmVydEl0ZW1Qcm9jZXNzaW5nLy50ZXN0KGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93UHJvY2VzcyAmJiBhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgLy8gb25seSByZW1vdmUgcHJvY2VzcyBidXR0b25cbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGtleSA9PiAhL1Byb2Nlc3NJdGVtfFJldHJ5SXRlbVByb2Nlc3Npbmd8QWJvcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIHByb2Nlc3MgYnV0dG9uc1xuICAgICAgICAgICAgYnV0dG9uRmlsdGVyID0ga2V5ID0+ICEvUHJvY2Vzcy8udGVzdChrZXkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gcHJvY2VzcyBjb250cm9scyBhdmFpbGFibGVcbiAgICAgICAgYnV0dG9uRmlsdGVyID0ga2V5ID0+ICEvUHJvY2Vzcy8udGVzdChrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGVuYWJsZWRCdXR0b25zID0gYnV0dG9uRmlsdGVyID8gQnV0dG9uS2V5cy5maWx0ZXIoYnV0dG9uRmlsdGVyKSA6IEJ1dHRvbktleXMuY29uY2F0KCk7XG5cbiAgICAvLyB1cGRhdGUgaWNvbiBhbmQgbGFiZWwgZm9yIHJldmVydCBidXR0b24gd2hlbiBpbnN0YW50IHVwbG9hZGluZ1xuICAgIGlmIChpbnN0YW50VXBsb2FkICYmIGFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5sYWJlbCA9ICdHRVRfTEFCRUxfQlVUVE9OX1JFTU9WRV9JVEVNJztcbiAgICAgICAgTG9jYWxCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmljb24gPSAnR0VUX0lDT05fUkVNT1ZFJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbGFzdCBidXR0b24gKHJldmVydCkgaWYgbm90IGFsbG93ZWRcbiAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBtYXAuaW5mby50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBtYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgIG1hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgfVxuXG4gICAgLy8gc2hvdWxkIGFsaWduIGNlbnRlclxuICAgIGlmIChpc0FzeW5jICYmICFhbGxvd1Byb2Nlc3MpIHtcbiAgICAgICAgW1xuICAgICAgICAgICAgJ0RJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgJ0RJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgICAgICAnRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1MnLFxuICAgICAgICAgICAgJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InLFxuICAgICAgICBdLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIFN0eWxlTWFwW2tleV0uc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgIH0pO1xuICAgICAgICBTdHlsZU1hcFsnRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUiddLnN0YXR1cy50cmFuc2xhdGVYID0gY2FsY3VsYXRlQnV0dG9uV2lkdGg7XG4gICAgfVxuXG4gICAgLy8gbW92ZSByZW1vdmUgYnV0dG9uIHRvIHJpZ2h0XG4gICAgaWYgKGFsaWduUmVtb3ZlSXRlbUJ1dHRvbiAmJiBhbGxvd1JldmVydCkge1xuICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10uYWxpZ24gPSAnQlVUVE9OX1JFTU9WRV9JVEVNX1BPU0lUSU9OJztcbiAgICAgICAgY29uc3QgbWFwID0gU3R5bGVNYXBbJ0RJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkcnXTtcbiAgICAgICAgbWFwLmluZm8udHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0O1xuICAgICAgICBtYXAuc3RhdHVzLnRyYW5zbGF0ZVkgPSBjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQ7XG4gICAgICAgIG1hcC5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IgPSB7IG9wYWNpdHk6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgfVxuXG4gICAgLy8gc2hvdy9oaWRlIFJlbW92ZUl0ZW0gYnV0dG9uXG4gICAgaWYgKCFhbGxvd1JlbW92ZSkge1xuICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JlbW92ZUl0ZW0nXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSBidXR0b24gdmlld3NcbiAgICBmb3JpbihMb2NhbEJ1dHRvbnMsIChrZXksIGRlZmluaXRpb24pID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIGJ1dHRvblxuICAgICAgICBjb25zdCBidXR0b25WaWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUFjdGlvbkJ1dHRvbiwge1xuICAgICAgICAgICAgbGFiZWw6IHJvb3QucXVlcnkoZGVmaW5pdGlvbi5sYWJlbCksXG4gICAgICAgICAgICBpY29uOiByb290LnF1ZXJ5KGRlZmluaXRpb24uaWNvbiksXG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG91bGQgYmUgYXBwZW5kZWQ/XG4gICAgICAgIGlmIChlbmFibGVkQnV0dG9ucy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkVmlldyhidXR0b25WaWV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBwb3NpdGlvbiBhdHRyaWJ1dGVcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmRhdGFzZXQuYWxpZ24gPSByb290LnF1ZXJ5KGBHRVRfU1RZTEVfJHtkZWZpbml0aW9uLmFsaWdufWApO1xuXG4gICAgICAgIC8vIGFkZCBjbGFzc1xuICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChkZWZpbml0aW9uLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGludGVyYWN0aW9uc1xuICAgICAgICBidXR0b25WaWV3Lm9uKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKGRlZmluaXRpb24uYWN0aW9uLCB7IHF1ZXJ5OiBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2V0IHJlZmVyZW5jZVxuICAgICAgICByb290LnJlZltgYnV0dG9uJHtrZXl9YF0gPSBidXR0b25WaWV3O1xuICAgIH0pO1xuXG4gICAgLy8gY2hlY2ttYXJrXG4gICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvclZpZXcpXG4gICAgKTtcbiAgICByb290LnJlZi5wcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3IuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcm9vdC5xdWVyeShcbiAgICAgICAgYEdFVF9TVFlMRV9CVVRUT05fUFJPQ0VTU19JVEVNX1BPU0lUSU9OYFxuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgZmlsZSBpbmZvIHZpZXdcbiAgICByb290LnJlZi5pbmZvID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZUluZm8sIHsgaWQgfSkpO1xuXG4gICAgLy8gY3JlYXRlIGZpbGUgc3RhdHVzIHZpZXdcbiAgICByb290LnJlZi5zdGF0dXMgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlU3RhdHVzLCB7IGlkIH0pKTtcblxuICAgIC8vIGFkZCBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgY29uc3QgbG9hZEluZGljYXRvclZpZXcgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcocHJvZ3Jlc3NJbmRpY2F0b3IsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBhbGlnbjogcm9vdC5xdWVyeShgR0VUX1NUWUxFX0xPQURfSU5ESUNBVE9SX1BPU0lUSU9OYCksXG4gICAgICAgIH0pXG4gICAgKTtcbiAgICBsb2FkSW5kaWNhdG9yVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1sb2FkLWluZGljYXRvcicpO1xuICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvciA9IGxvYWRJbmRpY2F0b3JWaWV3O1xuXG4gICAgY29uc3QgcHJvZ3Jlc3NJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoYEdFVF9TVFlMRV9QUk9HUkVTU19JTkRJQ0FUT1JfUE9TSVRJT05gKSxcbiAgICAgICAgfSlcbiAgICApO1xuICAgIHByb2dyZXNzSW5kaWNhdG9yVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1wcm9jZXNzLWluZGljYXRvcicpO1xuICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvciA9IHByb2dyZXNzSW5kaWNhdG9yVmlldztcblxuICAgIC8vIGN1cnJlbnQgYWN0aXZlIHN0eWxlc1xuICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcyA9IFtdO1xufTtcblxuY29uc3Qgd3JpdGUkMiA9ICh7IHJvb3QsIGFjdGlvbnMsIHByb3BzIH0pID0+IHtcbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUoeyByb290LCBhY3Rpb25zLCBwcm9wcyB9KTtcblxuICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAuY29uY2F0KClcbiAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKSlcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAuZmluZChhY3Rpb24gPT4gU3R5bGVNYXBbYWN0aW9uLnR5cGVdKTtcblxuICAgIC8vIGEgbmV3IGFjdGlvbiBoYXBwZW5lZCwgbGV0J3MgZ2V0IHRoZSBtYXRjaGluZyBzdHlsZXNcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIGRlZmluZSBuZXcgYWN0aXZlIHN0eWxlc1xuICAgICAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcblxuICAgICAgICBjb25zdCBzdHlsZXNUb0FwcGx5ID0gU3R5bGVNYXBbYWN0aW9uLnR5cGVdO1xuICAgICAgICBmb3JpbihEZWZhdWx0U3R5bGUsIChuYW1lLCBkZWZhdWx0U3R5bGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBnZXQgcmVmZXJlbmNlIHRvIGNvbnRyb2xcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wgPSByb290LnJlZltuYW1lXTtcblxuICAgICAgICAgICAgLy8gbG9vcCBvdmVyIGFsbCBzdHlsZXMgZm9yIHRoaXMgY29udHJvbFxuICAgICAgICAgICAgZm9yaW4oZGVmYXVsdFN0eWxlcywgKGtleSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNUb0FwcGx5W25hbWVdICYmIHR5cGVvZiBzdHlsZXNUb0FwcGx5W25hbWVdW2tleV0gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN0eWxlc1RvQXBwbHlbbmFtZV1ba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzLnB1c2goeyBjb250cm9sLCBrZXksIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFjdGl2ZSBzdHlsZXMgdG8gZWxlbWVudFxuICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5mb3JFYWNoKCh7IGNvbnRyb2wsIGtleSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICBjb250cm9sW2tleV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZShyb290KSA6IHZhbHVlO1xuICAgIH0pO1xufTtcblxuY29uc3Qgcm91dGUgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgIH0sXG4gICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEOiAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Mb2FkLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgIH0sXG4gICAgRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMOiAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgICByb290LnJlZi5idXR0b25BYm9ydEl0ZW1SZW1vdmFsLmxhYmVsID0gYWN0aW9uLnZhbHVlO1xuICAgIH0sXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSB0cnVlO1xuICAgICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSAwO1xuICAgIH0sXG4gICAgRElEX1NUQVJUX0lURU1fTE9BRDogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTOiAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IGZhbHNlO1xuICAgICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IucHJvZ3Jlc3MgPSBhY3Rpb24ucHJvZ3Jlc3M7XG4gICAgfSxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gYWN0aW9uLnByb2dyZXNzO1xuICAgIH0sXG59KTtcblxuY29uc3QgZmlsZSA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDQsXG4gICAgd3JpdGU6IHdyaXRlJDIsXG4gICAgZGlkQ3JlYXRlVmlldzogcm9vdCA9PiB7XG4gICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCB7IC4uLnJvb3QsIHZpZXc6IHJvb3QgfSk7XG4gICAgfSxcbiAgICBuYW1lOiAnZmlsZScsXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAqL1xuY29uc3QgY3JlYXRlJDUgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gZmlsZW5hbWVcbiAgICByb290LnJlZi5maWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnbGVnZW5kJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChyb290LnJlZi5maWxlTmFtZSk7XG5cbiAgICAvLyBmaWxlIGFwcGVuZGVkXG4gICAgcm9vdC5yZWYuZmlsZSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGUsIHsgaWQ6IHByb3BzLmlkIH0pKTtcblxuICAgIC8vIGRhdGEgaGFzIG1vdmVkIHRvIGRhdGEuanNcbiAgICByb290LnJlZi5kYXRhID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERhdGEgc3RvcmFnZVxuICovXG5jb25zdCBkaWRMb2FkSXRlbSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyB1cGRhdGVzIHRoZSBsZWdlbmQgb2YgdGhlIGZpZWxkc2V0IHNvIHNjcmVlbnJlYWRlcnMgY2FuIGJldHRlciBncm91cCBidXR0b25zXG4gICAgdGV4dChyb290LnJlZi5maWxlTmFtZSwgZm9ybWF0RmlsZW5hbWUocm9vdC5xdWVyeSgnR0VUX0lURU1fTkFNRScsIHByb3BzLmlkKSkpO1xufTtcblxuY29uc3QgZmlsZVdyYXBwZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ1LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0sXG4gICAgfSksXG4gICAgZGlkQ3JlYXRlVmlldzogcm9vdCA9PiB7XG4gICAgICAgIGFwcGx5RmlsdGVycygnQ1JFQVRFX1ZJRVcnLCB7IC4uLnJvb3QsIHZpZXc6IHJvb3QgfSk7XG4gICAgfSxcbiAgICB0YWc6ICdmaWVsZHNldCcsXG4gICAgbmFtZTogJ2ZpbGUtd3JhcHBlcicsXG59KTtcblxuY29uc3QgUEFORUxfU1BSSU5HX1BST1BTID0geyB0eXBlOiAnc3ByaW5nJywgZGFtcGluZzogMC42LCBtYXNzOiA3IH07XG5cbmNvbnN0IGNyZWF0ZSQ2ID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ3RvcCcsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdjZW50ZXInLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjYWxlWTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWTogUEFORUxfU1BSSU5HX1BST1BTLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVknLCAnc2NhbGVZJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnYm90dG9tJyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtaXhpbnM6IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIF0uZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgY3JlYXRlU2VjdGlvbihyb290LCBzZWN0aW9uLCBwcm9wcy5uYW1lKTtcbiAgICB9KTtcblxuICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGBmaWxlcG9uZC0tJHtwcm9wcy5uYW1lfWApO1xuXG4gICAgcm9vdC5yZWYuc2NhbGFibGUgPSBudWxsO1xufTtcblxuY29uc3QgY3JlYXRlU2VjdGlvbiA9IChyb290LCBzZWN0aW9uLCBjbGFzc05hbWUpID0+IHtcbiAgICBjb25zdCB2aWV3Q29uc3RydWN0b3IgPSBjcmVhdGVWaWV3KHtcbiAgICAgICAgbmFtZTogYHBhbmVsLSR7c2VjdGlvbi5uYW1lfSBmaWxlcG9uZC0tJHtjbGFzc05hbWV9YCxcbiAgICAgICAgbWl4aW5zOiBzZWN0aW9uLm1peGlucyxcbiAgICAgICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHZpZXcgPSByb290LmNyZWF0ZUNoaWxkVmlldyh2aWV3Q29uc3RydWN0b3IsIHNlY3Rpb24ucHJvcHMpO1xuXG4gICAgcm9vdC5yZWZbc2VjdGlvbi5uYW1lXSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHZpZXcpO1xufTtcblxuY29uc3Qgd3JpdGUkMyA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyB1cGRhdGUgc2NhbGFibGUgc3RhdGVcbiAgICBpZiAocm9vdC5yZWYuc2NhbGFibGUgPT09IG51bGwgfHwgcHJvcHMuc2NhbGFibGUgIT09IHJvb3QucmVmLnNjYWxhYmxlKSB7XG4gICAgICAgIHJvb3QucmVmLnNjYWxhYmxlID0gaXNCb29sZWFuKHByb3BzLnNjYWxhYmxlKSA/IHByb3BzLnNjYWxhYmxlIDogdHJ1ZTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuc2NhbGFibGUgPSByb290LnJlZi5zY2FsYWJsZTtcbiAgICB9XG5cbiAgICAvLyBubyBoZWlnaHQsIGNhbid0IHNldFxuICAgIGlmICghcHJvcHMuaGVpZ2h0KSByZXR1cm47XG5cbiAgICAvLyBnZXQgY2hpbGQgcmVjdHNcbiAgICBjb25zdCB0b3BSZWN0ID0gcm9vdC5yZWYudG9wLnJlY3QuZWxlbWVudDtcbiAgICBjb25zdCBib3R0b21SZWN0ID0gcm9vdC5yZWYuYm90dG9tLnJlY3QuZWxlbWVudDtcblxuICAgIC8vIG1ha2Ugc3VyZSBoZWlnaHQgbmV2ZXIgaXMgc21hbGxlciB0aGFuIGJvdHRvbSBhbmQgdG9wIHNlY2l0b24gaGVpZ2h0cyBjb21iaW5lZCAod2lsbCBwcm9iYWJseSBuZXZlciBoYXBwZW4sIGJ1dCB3aG8ga25vd3MpXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgodG9wUmVjdC5oZWlnaHQgKyBib3R0b21SZWN0LmhlaWdodCwgcHJvcHMuaGVpZ2h0KTtcblxuICAgIC8vIG9mZnNldCBjZW50ZXIgcGFydFxuICAgIHJvb3QucmVmLmNlbnRlci50cmFuc2xhdGVZID0gdG9wUmVjdC5oZWlnaHQ7XG5cbiAgICAvLyBzY2FsZSBjZW50ZXIgcGFydFxuICAgIC8vIHVzZSBtYXRoIGNlaWwgdG8gcHJldmVudCB0cmFuc3BhcmVudCBsaW5lcyBiZWNhdXNlIG9mIHJvdW5kaW5nIGVycm9yc1xuICAgIHJvb3QucmVmLmNlbnRlci5zY2FsZVkgPSAoaGVpZ2h0IC0gdG9wUmVjdC5oZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodCkgLyAxMDA7XG5cbiAgICAvLyBvZmZzZXQgYm90dG9tIHBhcnRcbiAgICByb290LnJlZi5ib3R0b20udHJhbnNsYXRlWSA9IGhlaWdodCAtIGJvdHRvbVJlY3QuaGVpZ2h0O1xufTtcblxuY29uc3QgcGFuZWwgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAncGFuZWwnLFxuICAgIHJlYWQ6ICh7IHJvb3QsIHByb3BzIH0pID0+IChwcm9wcy5oZWlnaHRDdXJyZW50ID0gcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkpLFxuICAgIHdyaXRlOiB3cml0ZSQzLFxuICAgIGNyZWF0ZTogY3JlYXRlJDYsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydoZWlnaHQnLCAnaGVpZ2h0Q3VycmVudCcsICdzY2FsYWJsZSddLFxuICAgIH0sXG59KTtcblxuY29uc3QgY3JlYXRlRHJhZ0hlbHBlciA9IGl0ZW1zID0+IHtcbiAgICBjb25zdCBpdGVtSWRzID0gaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5pZCk7XG4gICAgbGV0IHByZXZJbmRleCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRJbmRleDogaW5kZXggPT4ge1xuICAgICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEluZGV4OiAoKSA9PiBwcmV2SW5kZXgsXG4gICAgICAgIGdldEl0ZW1JbmRleDogaXRlbSA9PiBpdGVtSWRzLmluZGV4T2YoaXRlbS5pZCksXG4gICAgfTtcbn07XG5cbmNvbnN0IElURU1fVFJBTlNMQVRFX1NQUklORyA9IHtcbiAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICBzdGlmZm5lc3M6IDAuNzUsXG4gICAgZGFtcGluZzogMC40NSxcbiAgICBtYXNzOiAxMCxcbn07XG5cbmNvbnN0IElURU1fU0NBTEVfU1BSSU5HID0gJ3NwcmluZyc7XG5cbmNvbnN0IFN0YXRlTWFwID0ge1xuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6ICdidXN5JyxcbiAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogJ2xvYWRpbmcnLFxuICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6ICdsb2FkLWludmFsaWQnLFxuICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6ICdsb2FkLWVycm9yJyxcbiAgICBESURfTE9BRF9JVEVNOiAnaWRsZScsXG4gICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiAncmVtb3ZlLWVycm9yJyxcbiAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6ICdidXN5JyxcbiAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiAnYnVzeSBwcm9jZXNzaW5nJyxcbiAgICBESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkc6ICdidXN5IHByb2Nlc3NpbmcnLFxuICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiAncHJvY2Vzc2luZycsXG4gICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogJ3Byb2Nlc3NpbmctY29tcGxldGUnLFxuICAgIERJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1I6ICdwcm9jZXNzaW5nLWVycm9yJyxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUjogJ3Byb2Nlc3NpbmctcmV2ZXJ0LWVycm9yJyxcbiAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiAnY2FuY2VsbGVkJyxcbiAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogJ2lkbGUnLFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAqL1xuY29uc3QgY3JlYXRlJDcgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gc2VsZWN0XG4gICAgcm9vdC5yZWYuaGFuZGxlQ2xpY2sgPSBlID0+IHJvb3QuZGlzcGF0Y2goJ0RJRF9BQ1RJVkFURV9JVEVNJywgeyBpZDogcHJvcHMuaWQgfSk7XG5cbiAgICAvLyBzZXQgaWRcbiAgICByb290LmVsZW1lbnQuaWQgPSBgZmlsZXBvbmQtLWl0ZW0tJHtwcm9wcy5pZH1gO1xuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcblxuICAgIC8vIGZpbGUgdmlld1xuICAgIHJvb3QucmVmLmNvbnRhaW5lciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVXcmFwcGVyLCB7IGlkOiBwcm9wcy5pZCB9KSk7XG5cbiAgICAvLyBmaWxlIHBhbmVsXG4gICAgcm9vdC5yZWYucGFuZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhwYW5lbCwgeyBuYW1lOiAnaXRlbS1wYW5lbCcgfSkpO1xuXG4gICAgLy8gZGVmYXVsdCBzdGFydCBoZWlnaHRcbiAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSBudWxsO1xuXG4gICAgLy8gYnkgZGVmYXVsdCBub3QgbWFya2VkIGZvciByZW1vdmFsXG4gICAgcHJvcHMubWFya2VkRm9yUmVtb3ZhbCA9IGZhbHNlO1xuXG4gICAgLy8gaWYgbm90IGFsbG93ZWQgdG8gcmVvcmRlciBmaWxlIGl0ZW1zLCBleGl0IGhlcmVcbiAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU9SREVSJykpIHJldHVybjtcblxuICAgIC8vIHNldCB0byBpZGxlIHNvIHNob3dzIGdyYWIgY3Vyc29yXG4gICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuXG4gICAgY29uc3QgZ3JhYiA9IGUgPT4ge1xuICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgbGV0IHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luID0ge1xuICAgICAgICAgICAgeDogZS5wYWdlWCxcbiAgICAgICAgICAgIHk6IGUucGFnZVksXG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IHtcbiAgICAgICAgICAgIHg6IHJvb3QudHJhbnNsYXRlWCxcbiAgICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWSxcbiAgICAgICAgfTtcblxuICAgICAgICBwcm9wcy5kcmFnQ2VudGVyID0ge1xuICAgICAgICAgICAgeDogZS5vZmZzZXRYLFxuICAgICAgICAgICAgeTogZS5vZmZzZXRZLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRyYWdTdGF0ZSA9IGNyZWF0ZURyYWdIZWxwZXIocm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpKTtcblxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfR1JBQl9JVEVNJywgeyBpZDogcHJvcHMuaWQsIGRyYWdTdGF0ZSB9KTtcblxuICAgICAgICBjb25zdCBkcmFnID0gZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWUuaXNQcmltYXJ5KSByZXR1cm47XG5cbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgeDogZS5wYWdlWCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgIHk6IGUucGFnZVkgLSBvcmlnaW4ueSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGlmIGRyYWdnZWQgc3RvcCBsaXN0ZW5pbmcgdG8gY2xpY2tzLCB3aWxsIHJlLWFkZCB3aGVuIGRvbmUgZHJhZ2dpbmdcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPVxuICAgICAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQueCAqIHByb3BzLmRyYWdPZmZzZXQueCArIHByb3BzLmRyYWdPZmZzZXQueSAqIHByb3BzLmRyYWdPZmZzZXQueTtcbiAgICAgICAgICAgIGlmIChkaXN0ID4gMTYgJiYgIXJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RSQUdfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGUgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZHJvcCA9IGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGUucGFnZVggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgY2FuY2VsKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZHJhZyk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBkcm9wKTtcblxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1BfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGxpc3RlbmluZyB0byBjbGlja3MgYWdhaW5cbiAgICAgICAgICAgIGlmIChyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgY2FuY2VsKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBkcmFnKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG4gICAgfTtcblxuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGdyYWIpO1xufTtcblxuY29uc3Qgcm91dGUkMSA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfVVBEQVRFX1BBTkVMX0hFSUdIVDogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBhY3Rpb24uaGVpZ2h0O1xuICAgIH0sXG59KTtcblxuY29uc3Qgd3JpdGUkNCA9IGNyZWF0ZVJvdXRlKFxuICAgIHtcbiAgICAgICAgRElEX0dSQUJfSVRFTTogKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgICAgICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICAgICAgeTogcm9vdC50cmFuc2xhdGVZLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgRElEX0RSQUdfSVRFTTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJhZyc7XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9EUk9QX0lURU06ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgICAgICAgIHByb3BzLmRyYWdPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgcHJvcHMuZHJhZ09yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kcmFnU3RhdGUgPSAnZHJvcCc7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAoeyByb290LCBhY3Rpb25zLCBwcm9wcywgc2hvdWxkT3B0aW1pemUgfSkgPT4ge1xuICAgICAgICBpZiAocm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID09PSAnZHJvcCcpIHtcbiAgICAgICAgICAgIGlmIChyb290LnNjYWxlWCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2lkbGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VsZWN0IGxhc3Qgc3RhdGUgY2hhbmdlIGFjdGlvblxuICAgICAgICBsZXQgYWN0aW9uID0gYWN0aW9uc1xuICAgICAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiAvXkRJRF8vLnRlc3QoYWN0aW9uLnR5cGUpKVxuICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgLmZpbmQoYWN0aW9uID0+IFN0YXRlTWFwW2FjdGlvbi50eXBlXSk7XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byBzZXQgc2FtZSBzdGF0ZSB0d2ljZVxuICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlICE9PSBwcm9wcy5jdXJyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIHNldCBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICBwcm9wcy5jdXJyZW50U3RhdGUgPSBhY3Rpb24udHlwZTtcblxuICAgICAgICAgICAgLy8gc2V0IHN0YXRlXG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5maWxlcG9uZEl0ZW1TdGF0ZSA9IFN0YXRlTWFwW3Byb3BzLmN1cnJlbnRTdGF0ZV0gfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID1cbiAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9JVEVNX1BBTkVMX0FTUEVDVF9SQVRJTycpIHx8IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICAgICAgaWYgKCFhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgcm91dGUkMSh7IHJvb3QsIGFjdGlvbnMsIHByb3BzIH0pO1xuICAgICAgICAgICAgaWYgKCFyb290LmhlaWdodCAmJiByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICByb290LmhlaWdodCA9IHJvb3QucmVmLmNvbnRhaW5lci5yZWN0LmVsZW1lbnQuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlY3QuZWxlbWVudC53aWR0aCAqIGFzcGVjdFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3luYyBwYW5lbCBoZWlnaHQgd2l0aCBpdGVtIGhlaWdodFxuICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhbmVsLmhlaWdodCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSByb290LmhlaWdodDtcbiAgICB9XG4pO1xuXG5jb25zdCBpdGVtID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkNyxcbiAgICB3cml0ZTogd3JpdGUkNCxcbiAgICBkZXN0cm95OiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnUkVMRUFTRV9JVEVNJywgeyBxdWVyeTogcHJvcHMuaWQgfSk7XG4gICAgfSxcbiAgICB0YWc6ICdsaScsXG4gICAgbmFtZTogJ2l0ZW0nLFxuICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbXG4gICAgICAgICAgICAnaWQnLFxuICAgICAgICAgICAgJ2ludGVyYWN0aW9uTWV0aG9kJyxcbiAgICAgICAgICAgICdtYXJrZWRGb3JSZW1vdmFsJyxcbiAgICAgICAgICAgICdzcGF3bkRhdGUnLFxuICAgICAgICAgICAgJ2RyYWdDZW50ZXInLFxuICAgICAgICAgICAgJ2RyYWdPcmlnaW4nLFxuICAgICAgICAgICAgJ2RyYWdPZmZzZXQnLFxuICAgICAgICBdLFxuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eScsICdoZWlnaHQnXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgc2NhbGVYOiBJVEVNX1NDQUxFX1NQUklORyxcbiAgICAgICAgICAgIHNjYWxlWTogSVRFTV9TQ0FMRV9TUFJJTkcsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiBJVEVNX1RSQU5TTEFURV9TUFJJTkcsXG4gICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAxNTAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbnZhciBnZXRJdGVtc1BlclJvdyA9IChob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCkgPT4ge1xuICAgIC8vIGFkZCBvbmUgcGl4ZWwgbGVld2F5LCB3aGVuIHVzaW5nIHBlcmNlbnRhZ2VzIGZvciBpdGVtIHdpZHRoIHRvdGFsIGl0ZW1zIGNhbiBiZSAxLjk5IHBlciByb3dcblxuICAgIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLmZsb29yKChob3Jpem9udGFsU3BhY2UgKyAxKSAvIGl0ZW1XaWR0aCkpO1xufTtcblxuY29uc3QgZ2V0SXRlbUluZGV4QnlQb3NpdGlvbiA9ICh2aWV3LCBjaGlsZHJlbiwgcG9zaXRpb25JblZpZXcpID0+IHtcbiAgICBpZiAoIXBvc2l0aW9uSW5WaWV3KSByZXR1cm47XG5cbiAgICBjb25zdCBob3Jpem9udGFsU3BhY2UgPSB2aWV3LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAvLyBjb25zdCBjaGlsZHJlbiA9IHZpZXcuY2hpbGRWaWV3cztcbiAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBsYXN0ID0gbnVsbDtcblxuICAgIC8vIC0xLCBkb24ndCBtb3ZlIGl0ZW1zIHRvIGFjY29tb2RhdGUgKGVpdGhlciBhZGQgdG8gdG9wIG9yIGJvdHRvbSlcbiAgICBpZiAobCA9PT0gMCB8fCBwb3NpdGlvbkluVmlldy50b3AgPCBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQudG9wKSByZXR1cm4gLTE7XG5cbiAgICAvLyBsZXQncyBnZXQgdGhlIGl0ZW0gd2lkdGhcbiAgICBjb25zdCBpdGVtID0gY2hpbGRyZW5bMF07XG4gICAgY29uc3QgaXRlbVJlY3QgPSBpdGVtLnJlY3QuZWxlbWVudDtcbiAgICBjb25zdCBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGl0ZW1SZWN0Lm1hcmdpbkxlZnQgKyBpdGVtUmVjdC5tYXJnaW5SaWdodDtcbiAgICBjb25zdCBpdGVtV2lkdGggPSBpdGVtUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgIGNvbnN0IGl0ZW1zUGVyUm93ID0gZ2V0SXRlbXNQZXJSb3coaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGw7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRNaWQgPSBjaGlsZC5yZWN0Lm91dGVyLnRvcCArIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgKiAwLjU7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRNaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfVxuXG4gICAgLy8gZ3JpZFxuICAgIGNvbnN0IGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGl0ZW1SZWN0Lm1hcmdpblRvcCArIGl0ZW1SZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gaXRlbVJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4WCA9IGluZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICAgIGNvbnN0IGluZGV4WSA9IE1hdGguZmxvb3IoaW5kZXggLyBpdGVtc1BlclJvdyk7XG5cbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGluZGV4WSAqIGl0ZW1IZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgaXRlbVRvcCA9IG9mZnNldFkgLSBpdGVtUmVjdC5tYXJnaW5Ub3A7XG4gICAgICAgIGNvbnN0IGl0ZW1SaWdodCA9IG9mZnNldFggKyBpdGVtV2lkdGg7XG4gICAgICAgIGNvbnN0IGl0ZW1Cb3R0b20gPSBvZmZzZXRZICsgaXRlbUhlaWdodCArIGl0ZW1SZWN0Lm1hcmdpbkJvdHRvbTtcblxuICAgICAgICBpZiAocG9zaXRpb25JblZpZXcudG9wIDwgaXRlbUJvdHRvbSAmJiBwb3NpdGlvbkluVmlldy50b3AgPiBpdGVtVG9wKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25JblZpZXcubGVmdCA8IGl0ZW1SaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggIT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IGluZGV4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBsO1xufTtcblxuY29uc3QgZHJvcEFyZWFEaW1lbnNpb25zID0ge1xuICAgIGhlaWdodDogMCxcbiAgICB3aWR0aDogMCxcbiAgICBnZXQgZ2V0SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcbiAgICBzZXQgc2V0SGVpZ2h0KHZhbCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDAgfHwgdmFsID09PSAwKSB0aGlzLmhlaWdodCA9IHZhbDtcbiAgICB9LFxuICAgIGdldCBnZXRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcbiAgICBzZXQgc2V0V2lkdGgodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy53aWR0aCA9IHZhbDtcbiAgICB9LFxuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKGhlaWdodCwgd2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IGhlaWdodCA9PT0gMCkgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwIHx8IHdpZHRoID09PSAwKSB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgfSxcbn07XG5cbmNvbnN0IGNyZWF0ZSQ4ID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgLy8gbmVlZCB0byBzZXQgcm9sZSB0byBsaXN0IGFzIG90aGVyd2lzZSBpdCB3b24ndCBiZSByZWFkIGFzIGEgbGlzdCBieSBWb2ljZU92ZXJcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ3JvbGUnLCAnbGlzdCcpO1xuXG4gICAgcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGUgPSBEYXRlLm5vdygpO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IGl0ZW1cbiAqIEBwYXJhbSByb290XG4gKiBAcGFyYW0gYWN0aW9uXG4gKi9cbmNvbnN0IGFkZEl0ZW1WaWV3ID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCB7IGlkLCBpbmRleCwgaW50ZXJhY3Rpb25NZXRob2QgfSA9IGFjdGlvbjtcblxuICAgIHJvb3QucmVmLmFkZEluZGV4ID0gaW5kZXg7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGxldCBzcGF3bkRhdGUgPSBub3c7XG4gICAgbGV0IG9wYWNpdHkgPSAxO1xuXG4gICAgaWYgKGludGVyYWN0aW9uTWV0aG9kICE9PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgICBjb25zdCBjb29sZG93biA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9JTlRFUlZBTCcpO1xuICAgICAgICBjb25zdCBkaXN0ID0gbm93IC0gcm9vdC5yZWYubGFzdEl0ZW1TcGFud0RhdGU7XG4gICAgICAgIHNwYXduRGF0ZSA9IGRpc3QgPCBjb29sZG93biA/IG5vdyArIChjb29sZG93biAtIGRpc3QpIDogbm93O1xuICAgIH1cblxuICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gc3Bhd25EYXRlO1xuXG4gICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KFxuICAgICAgICAgICAgLy8gdmlldyB0eXBlXG4gICAgICAgICAgICBpdGVtLFxuXG4gICAgICAgICAgICAvLyBwcm9wc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNwYXduRGF0ZSxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5LFxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBpbmRleFxuICAgICk7XG59O1xuXG5jb25zdCBtb3ZlSXRlbSA9IChpdGVtLCB4LCB5LCB2eCA9IDAsIHZ5ID0gMSkgPT4ge1xuICAgIC8vIHNldCB0byBudWxsIHRvIHJlbW92ZSBhbmltYXRpb24gd2hpbGUgZHJhZ2dpbmdcbiAgICBpZiAoaXRlbS5kcmFnT2Zmc2V0KSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IGl0ZW0uZHJhZ09yaWdpbi54ICsgaXRlbS5kcmFnT2Zmc2V0Lng7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IGl0ZW0uZHJhZ09yaWdpbi55ICsgaXRlbS5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgIGl0ZW0uc2NhbGVYID0gMS4wMjU7XG4gICAgICAgIGl0ZW0uc2NhbGVZID0gMS4wMjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geDtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geTtcblxuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGl0ZW0uc3Bhd25EYXRlKSB7XG4gICAgICAgICAgICAvLyByZXZlYWwgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGl0ZW0ub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGludHJvSXRlbVZpZXcoaXRlbSwgeCwgeSwgdngsIHZ5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGlzIGRlZmF1bHQgc2NhbGUgZXZlcnkgZnJhbWVcbiAgICAgICAgICAgIGl0ZW0uc2NhbGVYID0gMTtcbiAgICAgICAgICAgIGl0ZW0uc2NhbGVZID0gMTtcbiAgICAgICAgICAgIGl0ZW0ub3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBpbnRyb0l0ZW1WaWV3ID0gKGl0ZW0sIHgsIHksIHZ4LCB2eSkgPT4ge1xuICAgIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5OT05FKSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5EUk9QKSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSB2eCAqIDIwO1xuXG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHkgLSB2eSAqIDEwO1xuXG4gICAgICAgIGl0ZW0uc2NhbGVYID0gMC44O1xuICAgICAgICBpdGVtLnNjYWxlWSA9IDAuODtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gMzA7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVYID0geCAtIDMwO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBleGlzdGluZyBpdGVtXG4gKiBAcGFyYW0gcm9vdFxuICogQHBhcmFtIGFjdGlvblxuICovXG5jb25zdCByZW1vdmVJdGVtVmlldyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgeyBpZCB9ID0gYWN0aW9uO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIGNvbnN0IHZpZXcgPSByb290LmNoaWxkVmlld3MuZmluZChjaGlsZCA9PiBjaGlsZC5pZCA9PT0gaWQpO1xuXG4gICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgIGlmICghdmlldykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYW5pbWF0ZSB2aWV3IG91dCBvZiB2aWV3XG4gICAgdmlldy5zY2FsZVggPSAwLjk7XG4gICAgdmlldy5zY2FsZVkgPSAwLjk7XG4gICAgdmlldy5vcGFjaXR5ID0gMDtcblxuICAgIC8vIG1hcmsgZm9yIHJlbW92YWxcbiAgICB2aWV3Lm1hcmtlZEZvclJlbW92YWwgPSB0cnVlO1xufTtcblxuY29uc3QgZ2V0SXRlbUhlaWdodCA9IGNoaWxkID0+XG4gICAgY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCArXG4gICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbSAqIDAuNSArXG4gICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblRvcCAqIDAuNTtcbmNvbnN0IGdldEl0ZW1XaWR0aCA9IGNoaWxkID0+XG4gICAgY2hpbGQucmVjdC5lbGVtZW50LndpZHRoICtcbiAgICBjaGlsZC5yZWN0LmVsZW1lbnQubWFyZ2luTGVmdCAqIDAuNSArXG4gICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpblJpZ2h0ICogMC41O1xuXG5jb25zdCBkcmFnSXRlbSA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgeyBpZCwgZHJhZ1N0YXRlIH0gPSBhY3Rpb247XG5cbiAgICAvLyByZWZlcmVuY2UgdG8gaXRlbVxuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIHsgaWQgfSk7XG5cbiAgICAvLyBnZXQgdGhlIHZpZXcgbWF0Y2hpbmcgdGhlIGdpdmVuIGlkXG4gICAgY29uc3QgdmlldyA9IHJvb3QuY2hpbGRWaWV3cy5maW5kKGNoaWxkID0+IGNoaWxkLmlkID09PSBpZCk7XG5cbiAgICBjb25zdCBudW1JdGVtcyA9IHJvb3QuY2hpbGRWaWV3cy5sZW5ndGg7XG4gICAgY29uc3Qgb2xkSW5kZXggPSBkcmFnU3RhdGUuZ2V0SXRlbUluZGV4KGl0ZW0pO1xuXG4gICAgLy8gaWYgbm8gdmlldyBmb3VuZCwgZXhpdFxuICAgIGlmICghdmlldykgcmV0dXJuO1xuXG4gICAgY29uc3QgZHJhZ1Bvc2l0aW9uID0ge1xuICAgICAgICB4OiB2aWV3LmRyYWdPcmlnaW4ueCArIHZpZXcuZHJhZ09mZnNldC54ICsgdmlldy5kcmFnQ2VudGVyLngsXG4gICAgICAgIHk6IHZpZXcuZHJhZ09yaWdpbi55ICsgdmlldy5kcmFnT2Zmc2V0LnkgKyB2aWV3LmRyYWdDZW50ZXIueSxcbiAgICB9O1xuXG4gICAgLy8gZ2V0IGRyYWcgYXJlYSBkaW1lbnNpb25zXG4gICAgY29uc3QgZHJhZ0hlaWdodCA9IGdldEl0ZW1IZWlnaHQodmlldyk7XG4gICAgY29uc3QgZHJhZ1dpZHRoID0gZ2V0SXRlbVdpZHRoKHZpZXcpO1xuXG4gICAgLy8gZ2V0IHJvd3MgYW5kIGNvbHVtbnMgKFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSByb3cgYW5kIG9uZSBjb2x1bW4gaWYgYSBmaWxlIGlzIHByZXNlbnQpXG4gICAgbGV0IGNvbHMgPSBNYXRoLmZsb29yKHJvb3QucmVjdC5vdXRlci53aWR0aCAvIGRyYWdXaWR0aCk7XG4gICAgaWYgKGNvbHMgPiBudW1JdGVtcykgY29scyA9IG51bUl0ZW1zO1xuXG4gICAgLy8gcm93cyBhcmUgdXNlZCB0byBmaW5kIHdoZW4gd2UgaGF2ZSBsZWZ0IHRoZSBwcmV2aWV3IGFyZWEgYm91bmRpbmcgYm94XG4gICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IobnVtSXRlbXMgLyBjb2xzICsgMSk7XG5cbiAgICBkcm9wQXJlYURpbWVuc2lvbnMuc2V0SGVpZ2h0ID0gZHJhZ0hlaWdodCAqIHJvd3M7XG4gICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldFdpZHRoID0gZHJhZ1dpZHRoICogY29scztcblxuICAgIC8vIGdldCBuZXcgaW5kZXggb2YgZHJhZ2dlZCBpdGVtXG4gICAgdmFyIGxvY2F0aW9uID0ge1xuICAgICAgICB5OiBNYXRoLmZsb29yKGRyYWdQb3NpdGlvbi55IC8gZHJhZ0hlaWdodCksXG4gICAgICAgIHg6IE1hdGguZmxvb3IoZHJhZ1Bvc2l0aW9uLnggLyBkcmFnV2lkdGgpLFxuICAgICAgICBnZXRHcmlkSW5kZXg6IGZ1bmN0aW9uIGdldEdyaWRJbmRleCgpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueSA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueSA8IDAgfHxcbiAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueCA+IGRyb3BBcmVhRGltZW5zaW9ucy5nZXRXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGRyYWdQb3NpdGlvbi54IDwgMFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnkgKiBjb2xzICsgdGhpcy54O1xuICAgICAgICB9LFxuICAgICAgICBnZXRDb2xJbmRleDogZnVuY3Rpb24gZ2V0Q29sSW5kZXgoKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKTtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoY2hpbGQgPT4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGl0ZW1zLm1hcChpdGVtID0+XG4gICAgICAgICAgICAgICAgdmlzaWJsZUNoaWxkcmVuLmZpbmQoY2hpbGRWaWV3ID0+IGNoaWxkVmlldy5pZCA9PT0gaXRlbS5pZClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBjaGlsZHJlbi5maW5kSW5kZXgoY2hpbGQgPT4gY2hpbGQgPT09IHZpZXcpO1xuICAgICAgICAgICAgY29uc3QgZHJhZ0hlaWdodCA9IGdldEl0ZW1IZWlnaHQodmlldyk7XG4gICAgICAgICAgICBjb25zdCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGlkeCA9IGw7XG4gICAgICAgICAgICBsZXQgY2hpbGRIZWlnaHQgPSAwO1xuICAgICAgICAgICAgbGV0IGNoaWxkQm90dG9tID0gMDtcbiAgICAgICAgICAgIGxldCBjaGlsZFRvcCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkSGVpZ2h0ID0gZ2V0SXRlbUhlaWdodChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgY2hpbGRUb3AgPSBjaGlsZEJvdHRvbTtcbiAgICAgICAgICAgICAgICBjaGlsZEJvdHRvbSA9IGNoaWxkVG9wICsgY2hpbGRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdQb3NpdGlvbi55IDwgY2hpbGRCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkVG9wICsgZHJhZ0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBnZXQgbmV3IGluZGV4XG4gICAgY29uc3QgaW5kZXggPSBjb2xzID4gMSA/IGxvY2F0aW9uLmdldEdyaWRJbmRleCgpIDogbG9jYXRpb24uZ2V0Q29sSW5kZXgoKTtcbiAgICByb290LmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5OiB2aWV3LCBpbmRleCB9KTtcblxuICAgIC8vIGlmIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBjaGFuZ2VkLCBkaXNwYXRjaCByZW9yZGVyIGFjdGlvblxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGRyYWdTdGF0ZS5nZXRJbmRleCgpO1xuXG4gICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgZHJhZ1N0YXRlLnNldEluZGV4KGluZGV4KTtcblxuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICByb290LmRpc3BhdGNoKCdESURfUkVPUkRFUl9JVEVNUycsIHtcbiAgICAgICAgICAgIGl0ZW1zOiByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyksXG4gICAgICAgICAgICBvcmlnaW46IG9sZEluZGV4LFxuICAgICAgICAgICAgdGFyZ2V0OiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhY3Rpb24gcm91dGVzXG4gKi9cbmNvbnN0IHJvdXRlJDIgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0FERF9JVEVNOiBhZGRJdGVtVmlldyxcbiAgICBESURfUkVNT1ZFX0lURU06IHJlbW92ZUl0ZW1WaWV3LFxuICAgIERJRF9EUkFHX0lURU06IGRyYWdJdGVtLFxufSk7XG5cbi8qKlxuICogV3JpdGUgdG8gdmlld1xuICogQHBhcmFtIHJvb3RcbiAqIEBwYXJhbSBhY3Rpb25zXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuY29uc3Qgd3JpdGUkNSA9ICh7IHJvb3QsIHByb3BzLCBhY3Rpb25zLCBzaG91bGRPcHRpbWl6ZSB9KSA9PiB7XG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlJDIoeyByb290LCBwcm9wcywgYWN0aW9ucyB9KTtcblxuICAgIGNvbnN0IHsgZHJhZ0Nvb3JkaW5hdGVzIH0gPSBwcm9wcztcblxuICAgIC8vIGF2YWlsYWJsZSBzcGFjZSBvbiBob3Jpem9udGFsIGF4aXNcbiAgICBjb25zdCBob3Jpem9udGFsU3BhY2UgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcblxuICAgIC8vIG9ubHkgZHJhdyBjaGlsZHJlbiB0aGF0IGhhdmUgZGltZW5zaW9uc1xuICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IHJvb3QuY2hpbGRWaWV3cy5maWx0ZXIoY2hpbGQgPT4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCk7XG5cbiAgICAvLyBzb3J0IGJhc2VkIG9uIGN1cnJlbnQgYWN0aXZlIGl0ZW1zXG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290XG4gICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgIC5tYXAoaXRlbSA9PiB2aXNpYmxlQ2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5pZCA9PT0gaXRlbS5pZCkpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtKTtcblxuICAgIC8vIGdldCBpbmRleFxuICAgIGNvbnN0IGRyYWdJbmRleCA9IGRyYWdDb29yZGluYXRlc1xuICAgICAgICA/IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24ocm9vdCwgY2hpbGRyZW4sIGRyYWdDb29yZGluYXRlcylcbiAgICAgICAgOiBudWxsO1xuXG4gICAgLy8gYWRkIGluZGV4IGlzIHVzZWQgdG8gcmVzZXJ2ZSB0aGUgZHJvcHBlZC9hZGRlZCBpdGVtIGluZGV4IHRpbGwgdGhlIGFjdHVhbCBpdGVtIGlzIHJlbmRlcmVkXG4gICAgY29uc3QgYWRkSW5kZXggPSByb290LnJlZi5hZGRJbmRleCB8fCBudWxsO1xuXG4gICAgLy8gYWRkIGluZGV4IG5vIGxvbmdlciBuZWVkZWQgdGlsbCBwb3NzaWJseSBuZXh0IGRyYXdcbiAgICByb290LnJlZi5hZGRJbmRleCA9IG51bGw7XG5cbiAgICBsZXQgZHJhZ0luZGV4T2Zmc2V0ID0gMDtcbiAgICBsZXQgcmVtb3ZlSW5kZXhPZmZzZXQgPSAwO1xuICAgIGxldCBhZGRJbmRleE9mZnNldCA9IDA7XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG4gICAgY29uc3QgaXRlbVZlcnRpY2FsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpblRvcCArIGNoaWxkUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgY29uc3QgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcbiAgICBjb25zdCBpdGVtV2lkdGggPSBjaGlsZFJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gY2hpbGRSZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICBjb25zdCBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgIC8vIHN0YWNrXG4gICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgIGxldCBvZmZzZXRZID0gMDtcbiAgICAgICAgbGV0IGRyYWdPZmZzZXQgPSAwO1xuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRyYWdJbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gaW5kZXggLSBkcmFnSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3QgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAtaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAtaXRlbVZlcnRpY2FsTWFyZ2luICogMC43NTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ09mZnNldCA9IGl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSBpdGVtVmVydGljYWxNYXJnaW4gKiAwLjI1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQubWFya2VkRm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgICAgIG1vdmVJdGVtKGNoaWxkLCAwLCBvZmZzZXRZICsgZHJhZ09mZnNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpdGVtSGVpZ2h0ID0gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcblxuICAgICAgICAgICAgbGV0IHZpc3VhbEhlaWdodCA9IGl0ZW1IZWlnaHQgKiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCA/IGNoaWxkLm9wYWNpdHkgOiAxKTtcblxuICAgICAgICAgICAgb2Zmc2V0WSArPSB2aXN1YWxIZWlnaHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBncmlkXG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBwcmV2WCA9IDA7XG4gICAgICAgIGxldCBwcmV2WSA9IDA7XG5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGRyYWdJbmRleCkge1xuICAgICAgICAgICAgICAgIGRyYWdJbmRleE9mZnNldCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gYWRkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBhZGRJbmRleE9mZnNldCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC41KSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlSW5kZXhPZmZzZXQgLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmlzdWFsSW5kZXggPSBpbmRleCArIGFkZEluZGV4T2Zmc2V0ICsgZHJhZ0luZGV4T2Zmc2V0ICsgcmVtb3ZlSW5kZXhPZmZzZXQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGluZGV4WCA9IHZpc3VhbEluZGV4ICUgaXRlbXNQZXJSb3c7XG4gICAgICAgICAgICBjb25zdCBpbmRleFkgPSBNYXRoLmZsb29yKHZpc3VhbEluZGV4IC8gaXRlbXNQZXJSb3cpO1xuXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gaW5kZXhYICogaXRlbVdpZHRoO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGluZGV4WSAqIGl0ZW1IZWlnaHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IHZlY3RvclggPSBNYXRoLnNpZ24ob2Zmc2V0WCAtIHByZXZYKTtcbiAgICAgICAgICAgIGNvbnN0IHZlY3RvclkgPSBNYXRoLnNpZ24ob2Zmc2V0WSAtIHByZXZZKTtcblxuICAgICAgICAgICAgcHJldlggPSBvZmZzZXRYO1xuICAgICAgICAgICAgcHJldlkgPSBvZmZzZXRZO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQubWFya2VkRm9yUmVtb3ZhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVYID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjaGlsZC50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW92ZUl0ZW0oY2hpbGQsIG9mZnNldFgsIG9mZnNldFksIHZlY3RvclgsIHZlY3RvclkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgYWN0aW9ucyB0aGF0IGFyZSBtZWFudCBzcGVjaWZpY2FsbHkgZm9yIGEgY2VydGFpbiBjaGlsZCBvZiB0aGUgbGlzdFxuICogQHBhcmFtIGNoaWxkXG4gKiBAcGFyYW0gYWN0aW9uc1xuICovXG5jb25zdCBmaWx0ZXJTZXRJdGVtQWN0aW9ucyA9IChjaGlsZCwgYWN0aW9ucykgPT5cbiAgICBhY3Rpb25zLmZpbHRlcihhY3Rpb24gPT4ge1xuICAgICAgICAvLyBpZiBhY3Rpb24gaGFzIGFuIGlkLCBmaWx0ZXIgb3V0IGFjdGlvbnMgdGhhdCBkb24ndCBoYXZlIHRoaXMgY2hpbGQgaWRcbiAgICAgICAgaWYgKGFjdGlvbi5kYXRhICYmIGFjdGlvbi5kYXRhLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuaWQgPT09IGFjdGlvbi5kYXRhLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxsb3cgYWxsIG90aGVyIGFjdGlvbnNcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbmNvbnN0IGxpc3QgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ4LFxuICAgIHdyaXRlOiB3cml0ZSQ1LFxuICAgIHRhZzogJ3VsJyxcbiAgICBuYW1lOiAnbGlzdCcsXG4gICAgZGlkV3JpdGVWaWV3OiAoeyByb290IH0pID0+IHtcbiAgICAgICAgcm9vdC5jaGlsZFZpZXdzXG4gICAgICAgICAgICAuZmlsdGVyKHZpZXcgPT4gdmlldy5tYXJrZWRGb3JSZW1vdmFsICYmIHZpZXcub3BhY2l0eSA9PT0gMCAmJiB2aWV3LnJlc3RpbmcpXG4gICAgICAgICAgICAuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcodmlldyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkOiBmaWx0ZXJTZXRJdGVtQWN0aW9ucyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydkcmFnQ29vcmRpbmF0ZXMnXSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGNyZWF0ZSQ5ID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIHJvb3QucmVmLmxpc3QgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhsaXN0KSk7XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgICBwcm9wcy5vdmVyZmxvd2luZyA9IGZhbHNlO1xufTtcblxuY29uc3Qgc3RvcmVEcmFnQ29vcmRpbmF0ZXMgPSAoeyByb290LCBwcm9wcywgYWN0aW9uIH0pID0+IHtcbiAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTl9GUkVFRE9NJykpIHJldHVybjtcbiAgICBwcm9wcy5kcmFnQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgIGxlZnQ6IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQgLSByb290LnJlZi5saXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgICB0b3A6XG4gICAgICAgICAgICBhY3Rpb24ucG9zaXRpb24uc2NvcGVUb3AgLVxuICAgICAgICAgICAgKHJvb3QucmVjdC5vdXRlci50b3AgKyByb290LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyByb290LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgIH07XG59O1xuXG5jb25zdCBjbGVhckRyYWdDb29yZGluYXRlcyA9ICh7IHByb3BzIH0pID0+IHtcbiAgICBwcm9wcy5kcmFnQ29vcmRpbmF0ZXMgPSBudWxsO1xufTtcblxuY29uc3Qgcm91dGUkMyA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogc3RvcmVEcmFnQ29vcmRpbmF0ZXMsXG4gICAgRElEX0VORF9EUkFHOiBjbGVhckRyYWdDb29yZGluYXRlcyxcbn0pO1xuXG5jb25zdCB3cml0ZSQ2ID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSkgPT4ge1xuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSQzKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSk7XG5cbiAgICAvLyBjdXJyZW50IGRyYWcgcG9zaXRpb25cbiAgICByb290LnJlZi5saXN0LmRyYWdDb29yZGluYXRlcyA9IHByb3BzLmRyYWdDb29yZGluYXRlcztcblxuICAgIC8vIGlmIGN1cnJlbnRseSBvdmVyZmxvd2luZyBidXQgbm8gbG9uZ2VyIHJlY2VpdmVkIG92ZXJmbG93XG4gICAgaWYgKHByb3BzLm92ZXJmbG93aW5nICYmICFwcm9wcy5vdmVyZmxvdykge1xuICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHJlc2V0IG92ZXJmbG93IHN0YXRlXG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnN0YXRlID0gJyc7XG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBpZiBpcyBub3Qgb3ZlcmZsb3dpbmcgY3VycmVudGx5IGJ1dCBkb2VzIHJlY2VpdmUgb3ZlcmZsb3cgdmFsdWVcbiAgICBpZiAocHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChwcm9wcy5vdmVyZmxvdyk7XG4gICAgICAgIGlmIChuZXdIZWlnaHQgIT09IHJvb3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICBwcm9wcy5vdmVyZmxvd2luZyA9IHRydWU7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICdvdmVyZmxvdyc7XG4gICAgICAgICAgICByb290LmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IGxpc3RTY3JvbGxlciA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDksXG4gICAgd3JpdGU6IHdyaXRlJDYsXG4gICAgbmFtZTogJ2xpc3Qtc2Nyb2xsZXInLFxuICAgIG1peGluczoge1xuICAgICAgICBhcGlzOiBbJ292ZXJmbG93JywgJ2RyYWdDb29yZGluYXRlcyddLFxuICAgICAgICBzdHlsZXM6IFsnaGVpZ2h0JywgJ3RyYW5zbGF0ZVknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBhdHRyVG9nZ2xlID0gKGVsZW1lbnQsIG5hbWUsIHN0YXRlLCBlbmFibGVkVmFsdWUgPSAnJykgPT4ge1xuICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBhdHRyKGVsZW1lbnQsIG5hbWUsIGVuYWJsZWRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxufTtcblxuY29uc3QgcmVzZXRGaWxlSW5wdXQgPSBpbnB1dCA9PiB7XG4gICAgLy8gbm8gdmFsdWUsIG5vIG5lZWQgdG8gcmVzZXRcbiAgICBpZiAoIWlucHV0IHx8IGlucHV0LnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZm9yIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIC8vIGZvciBJRTEwXG4gICAgaWYgKGlucHV0LnZhbHVlKSB7XG4gICAgICAgIC8vIHF1aWNrbHkgYXBwZW5kIGlucHV0IHRvIHRlbXAgZm9ybSBhbmQgcmVzZXQgZm9ybVxuICAgICAgICBjb25zdCBmb3JtID0gY3JlYXRlRWxlbWVudCQxKCdmb3JtJyk7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBpbnB1dC5wYXJlbnROb2RlO1xuICAgICAgICBjb25zdCByZWYgPSBpbnB1dC5uZXh0U2libGluZztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIGZvcm0ucmVzZXQoKTtcblxuICAgICAgICAvLyByZS1pbmplY3QgaW5wdXQgd2hlcmUgaXQgb3JpZ2luYWxseSB3YXNcbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5wdXQsIHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZSRhID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIHNldCBpZCBzbyBjYW4gYmUgcmVmZXJlbmNlZCBmcm9tIG91dHNpZGUgbGFiZWxzXG4gICAgcm9vdC5lbGVtZW50LmlkID0gYGZpbGVwb25kLS1icm93c2VyLSR7cHJvcHMuaWR9YDtcblxuICAgIC8vIHNldCBuYW1lIG9mIGVsZW1lbnQgKGlzIHJlbW92ZWQgd2hlbiBhIHZhbHVlIGlzIHNldClcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ25hbWUnLCByb290LnF1ZXJ5KCdHRVRfTkFNRScpKTtcblxuICAgIC8vIHdlIGhhdmUgdG8gbGluayB0aGlzIGVsZW1lbnQgdG8gdGhlIHN0YXR1cyBlbGVtZW50XG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWNvbnRyb2xzJywgYGZpbGVwb25kLS1hc3Npc3RhbnQtJHtwcm9wcy5pZH1gKTtcblxuICAgIC8vIHNldCBsYWJlbCwgd2UgdXNlIGxhYmVsbGVkIGJ5IGFzIG90aGVyd2lzZSB0aGUgc2NyZWVucmVhZGVyIGRvZXMgbm90IHJlYWQgdGhlIFwiYnJvd3NlXCIgdGV4dCBpbiB0aGUgbGFiZWwgKGFzIGl0IGhhcyB0YWJpbmRleDogMClcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGFiZWxsZWRieScsIGBmaWxlcG9uZC0tZHJvcC1sYWJlbC0ke3Byb3BzLmlkfWApO1xuXG4gICAgLy8gc2V0IGNvbmZpZ3VyYWJsZSBwcm9wc1xuICAgIHNldEFjY2VwdGVkRmlsZVR5cGVzKHsgcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUNDRVBURURfRklMRV9UWVBFUycpIH0gfSk7XG4gICAgdG9nZ2xlQWxsb3dNdWx0aXBsZSh7IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJykgfSB9KTtcbiAgICB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIoeyByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZJykgfSB9KTtcbiAgICB0b2dnbGVEaXNhYmxlZCh7IHJvb3QgfSk7XG4gICAgdG9nZ2xlUmVxdWlyZWQoeyByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9SRVFVSVJFRCcpIH0gfSk7XG4gICAgc2V0Q2FwdHVyZU1ldGhvZCh7IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0NBUFRVUkVfTUVUSE9EJykgfSB9KTtcblxuICAgIC8vIGhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgIHJvb3QucmVmLmhhbmRsZUNoYW5nZSA9IGUgPT4ge1xuICAgICAgICBpZiAoIXJvb3QuZWxlbWVudC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXh0cmFjdCBmaWxlcyBhbmQgbW92ZSB2YWx1ZSBvZiB3ZWJraXRSZWxhdGl2ZVBhdGggcGF0aCB0byBfcmVsYXRpdmVQYXRoXG4gICAgICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShyb290LmVsZW1lbnQuZmlsZXMpLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIGFkZCBhIGxpdHRsZSBkZWxheSBzbyB0aGUgT1MgZmlsZSBzZWxlY3Qgd2luZG93IGNhbiBtb3ZlIG91dCBvZiB0aGUgd2F5IGJlZm9yZSB3ZSBhZGQgb3VyIGZpbGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBsb2FkIGZpbGVzXG4gICAgICAgICAgICBwcm9wcy5vbmxvYWQoZmlsZXMpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBpbnB1dCwgaXQncyBqdXN0IGZvciBleHBvc2luZyBhIG1ldGhvZCB0byBkcm9wIGZpbGVzLCBzaG91bGQgbm90IHJldGFpbiBhbnkgc3RhdGVcbiAgICAgICAgICAgIHJlc2V0RmlsZUlucHV0KHJvb3QuZWxlbWVudCk7XG4gICAgICAgIH0sIDI1MCk7XG4gICAgfTtcblxuICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xufTtcblxuY29uc3Qgc2V0QWNjZXB0ZWRGaWxlVHlwZXMgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGlmICghcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1NZTkNfQUNDRVBUX0FUVFJJQlVURScpKSByZXR1cm47XG4gICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdhY2NlcHQnLCAhIWFjdGlvbi52YWx1ZSwgYWN0aW9uLnZhbHVlID8gYWN0aW9uLnZhbHVlLmpvaW4oJywnKSA6ICcnKTtcbn07XG5cbmNvbnN0IHRvZ2dsZUFsbG93TXVsdGlwbGUgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnbXVsdGlwbGUnLCBhY3Rpb24udmFsdWUpO1xufTtcblxuY29uc3QgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3dlYmtpdGRpcmVjdG9yeScsIGFjdGlvbi52YWx1ZSk7XG59O1xuXG5jb25zdCB0b2dnbGVEaXNhYmxlZCA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICBjb25zdCBkb2VzQWxsb3dCcm93c2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfQlJPV1NFJyk7XG4gICAgY29uc3QgZGlzYWJsZUZpZWxkID0gaXNEaXNhYmxlZCB8fCAhZG9lc0FsbG93QnJvd3NlO1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnZGlzYWJsZWQnLCBkaXNhYmxlRmllbGQpO1xufTtcblxuY29uc3QgdG9nZ2xlUmVxdWlyZWQgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIC8vIHdhbnQgdG8gcmVtb3ZlIHJlcXVpcmVkLCBhbHdheXMgcG9zc2libGVcbiAgICBpZiAoIWFjdGlvbi52YWx1ZSkge1xuICAgICAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgIH1cbiAgICAvLyBpZiB3YW50IHRvIG1ha2UgcmVxdWlyZWQsIG9ubHkgcG9zc2libGUgd2hlbiB6ZXJvIGl0ZW1zXG4gICAgZWxzZSBpZiAocm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJykgPT09IDApIHtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgIH1cbn07XG5cbmNvbnN0IHNldENhcHR1cmVNZXRob2QgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnY2FwdHVyZScsICEhYWN0aW9uLnZhbHVlLCBhY3Rpb24udmFsdWUgPT09IHRydWUgPyAnJyA6IGFjdGlvbi52YWx1ZSk7XG59O1xuXG5jb25zdCB1cGRhdGVSZXF1aXJlZFN0YXR1cyA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gcm9vdDtcbiAgICAvLyBhbHdheXMgcmVtb3ZlIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgd2hlbiBtb3JlIHRoYW4gemVybyBpdGVtc1xuICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKSA+IDApIHtcbiAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAncmVxdWlyZWQnLCBmYWxzZSk7XG4gICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ25hbWUnLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gc3RpbGwgaGFzIGl0ZW1zXG4gICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuICAgICAgICBsZXQgaGFzSW52YWxpZEZpZWxkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtc1tpXS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuTE9BRF9FUlJPUikge1xuICAgICAgICAgICAgICAgIGhhc0ludmFsaWRGaWVsZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHZhbGlkaXR5IHN0YXR1c1xuICAgICAgICByb290LmVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkoXG4gICAgICAgICAgICBoYXNJbnZhbGlkRmllbGQgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfSU5WQUxJRF9GSUVMRCcpIDogJydcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgYXR0clRvZ2dsZShlbGVtZW50LCAnbmFtZScsIHRydWUsIHJvb3QucXVlcnkoJ0dFVF9OQU1FJykpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgdmFsaWRhdGlvbiBtZXNzYWdlc1xuICAgICAgICBjb25zdCBzaG91bGRDaGVja1ZhbGlkaXR5ID0gcm9vdC5xdWVyeSgnR0VUX0NIRUNLX1ZBTElESVRZJyk7XG4gICAgICAgIGlmIChzaG91bGRDaGVja1ZhbGlkaXR5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEN1c3RvbVZhbGlkaXR5KCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWRkIHJlcXVpcmVkIGlmIHRoZSBmaWVsZCBoYXMgYmVlbiBkZWVtZWQgcmVxdWlyZWRcbiAgICAgICAgaWYgKHJvb3QucXVlcnkoJ0dFVF9SRVFVSVJFRCcpKSB7XG4gICAgICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICdyZXF1aXJlZCcsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgdXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIGNvbnN0IHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICBpZiAoIXNob3VsZENoZWNrVmFsaWRpdHkpIHJldHVybjtcbiAgICByb290LmVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkocm9vdC5xdWVyeSgnR0VUX0xBQkVMX0lOVkFMSURfRklFTEQnKSk7XG59O1xuXG5jb25zdCBicm93c2VyID0gY3JlYXRlVmlldyh7XG4gICAgdGFnOiAnaW5wdXQnLFxuICAgIG5hbWU6ICdicm93c2VyJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgfSxcbiAgICBjcmVhdGU6IGNyZWF0ZSRhLFxuICAgIGRlc3Ryb3k6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbiAgICB9LFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9MT0FEX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgICBESURfUkVNT1ZFX0lURU06IHVwZGF0ZVJlcXVpcmVkU3RhdHVzLFxuICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzLFxuXG4gICAgICAgIERJRF9TRVRfRElTQUJMRUQ6IHRvZ2dsZURpc2FibGVkLFxuICAgICAgICBESURfU0VUX0FMTE9XX0JST1dTRTogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgIERJRF9TRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWTogdG9nZ2xlRGlyZWN0b3J5RmlsdGVyLFxuICAgICAgICBESURfU0VUX0FMTE9XX01VTFRJUExFOiB0b2dnbGVBbGxvd011bHRpcGxlLFxuICAgICAgICBESURfU0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVM6IHNldEFjY2VwdGVkRmlsZVR5cGVzLFxuICAgICAgICBESURfU0VUX0NBUFRVUkVfTUVUSE9EOiBzZXRDYXB0dXJlTWV0aG9kLFxuICAgICAgICBESURfU0VUX1JFUVVJUkVEOiB0b2dnbGVSZXF1aXJlZCxcbiAgICB9KSxcbn0pO1xuXG5jb25zdCBLZXkgPSB7XG4gICAgRU5URVI6IDEzLFxuICAgIFNQQUNFOiAzMixcbn07XG5cbmNvbnN0IGNyZWF0ZSRiID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIGNyZWF0ZSB0aGUgbGFiZWwgYW5kIGxpbmsgaXQgdG8gdGhlIGZpbGUgYnJvd3NlclxuICAgIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudCQxKCdsYWJlbCcpO1xuICAgIGF0dHIobGFiZWwsICdmb3InLCBgZmlsZXBvbmQtLWJyb3dzZXItJHtwcm9wcy5pZH1gKTtcblxuICAgIC8vIHVzZSBmb3IgbGFiZWxpbmcgZmlsZSBpbnB1dCAoYXJpYS1sYWJlbGxlZGJ5IG9uIGZpbGUgaW5wdXQpXG4gICAgYXR0cihsYWJlbCwgJ2lkJywgYGZpbGVwb25kLS1kcm9wLWxhYmVsLSR7cHJvcHMuaWR9YCk7XG5cbiAgICAvLyBoYW5kbGUga2V5c1xuICAgIHJvb3QucmVmLmhhbmRsZUtleURvd24gPSBlID0+IHtcbiAgICAgICAgY29uc3QgaXNBY3RpdmF0aW9uS2V5ID0gZS5rZXlDb2RlID09PSBLZXkuRU5URVIgfHwgZS5rZXlDb2RlID09PSBLZXkuU1BBQ0U7XG4gICAgICAgIGlmICghaXNBY3RpdmF0aW9uS2V5KSByZXR1cm47XG4gICAgICAgIC8vIHN0b3BzIGZyb20gdHJpZ2dlcmluZyB0aGUgZWxlbWVudCBhIHNlY29uZCB0aW1lXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBjbGljayBsaW5rICh3aWxsIHRoZW4gaW4gdHVybiBhY3RpdmF0ZSBmaWxlIGlucHV0KVxuICAgICAgICByb290LnJlZi5sYWJlbC5jbGljaygpO1xuICAgIH07XG5cbiAgICByb290LnJlZi5oYW5kbGVDbGljayA9IGUgPT4ge1xuICAgICAgICBjb25zdCBpc0xhYmVsQ2xpY2sgPSBlLnRhcmdldCA9PT0gbGFiZWwgfHwgbGFiZWwuY29udGFpbnMoZS50YXJnZXQpO1xuXG4gICAgICAgIC8vIGRvbid0IHdhbnQgdG8gY2xpY2sgdHdpY2VcbiAgICAgICAgaWYgKGlzTGFiZWxDbGljaykgcmV0dXJuO1xuXG4gICAgICAgIC8vIGNsaWNrIGxpbmsgKHdpbGwgdGhlbiBpbiB0dXJuIGFjdGl2YXRlIGZpbGUgaW5wdXQpXG4gICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgfTtcblxuICAgIC8vIGF0dGFjaCBldmVudHNcbiAgICBsYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuXG4gICAgLy8gdXBkYXRlXG4gICAgdXBkYXRlTGFiZWxWYWx1ZShsYWJlbCwgcHJvcHMuY2FwdGlvbik7XG5cbiAgICAvLyBhZGQhXG4gICAgcm9vdC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgcm9vdC5yZWYubGFiZWwgPSBsYWJlbDtcbn07XG5cbmNvbnN0IHVwZGF0ZUxhYmVsVmFsdWUgPSAobGFiZWwsIHZhbHVlKSA9PiB7XG4gICAgbGFiZWwuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgY29uc3QgY2xpY2thYmxlID0gbGFiZWwucXVlcnlTZWxlY3RvcignLmZpbGVwb25kLS1sYWJlbC1hY3Rpb24nKTtcbiAgICBpZiAoY2xpY2thYmxlKSB7XG4gICAgICAgIGF0dHIoY2xpY2thYmxlLCAndGFiaW5kZXgnLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkcm9wTGFiZWwgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJvcC1sYWJlbCcsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBjcmVhdGU6IGNyZWF0ZSRiLFxuICAgIGRlc3Ryb3k6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LnJlZi5sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgcm9vdC5yZWYuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKTtcbiAgICB9LFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9TRVRfTEFCRUxfSURMRTogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZUxhYmVsVmFsdWUocm9vdC5yZWYubGFiZWwsIGFjdGlvbi52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIHN0eWxlczogWydvcGFjaXR5JywgJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAxNTAgfSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBibG9iID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2RyaXAtYmxvYicsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknXSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgc2NhbGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHNjYWxlWTogJ3NwcmluZycsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMjUwIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBhZGRCbG9iID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgY29uc3QgY2VudGVyWCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuICAgIGNvbnN0IGNlbnRlclkgPSByb290LnJlY3QuZWxlbWVudC5oZWlnaHQgKiAwLjU7XG5cbiAgICByb290LnJlZi5ibG9iID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJsb2IsIHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICBzY2FsZVg6IDIuNSxcbiAgICAgICAgICAgIHNjYWxlWTogMi41LFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogY2VudGVyWCxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IGNlbnRlclksXG4gICAgICAgIH0pXG4gICAgKTtcbn07XG5cbmNvbnN0IG1vdmVCbG9iID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBpZiAoIXJvb3QucmVmLmJsb2IpIHtcbiAgICAgICAgYWRkQmxvYih7IHJvb3QgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290LnJlZi5ibG9iLnRyYW5zbGF0ZVggPSBhY3Rpb24ucG9zaXRpb24uc2NvcGVMZWZ0O1xuICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWSA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZVRvcDtcbiAgICByb290LnJlZi5ibG9iLnNjYWxlWCA9IDE7XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAxO1xuICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDE7XG59O1xuXG5jb25zdCBoaWRlQmxvYiA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIGlmICghcm9vdC5yZWYuYmxvYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG59O1xuXG5jb25zdCBleHBsb2RlQmxvYiA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIGlmICghcm9vdC5yZWYuYmxvYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMi41O1xuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVZID0gMi41O1xuICAgIHJvb3QucmVmLmJsb2Iub3BhY2l0eSA9IDA7XG59O1xuXG5jb25zdCB3cml0ZSQ3ID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSkgPT4ge1xuICAgIHJvdXRlJDQoeyByb290LCBwcm9wcywgYWN0aW9ucyB9KTtcblxuICAgIGNvbnN0IHsgYmxvYiB9ID0gcm9vdC5yZWY7XG5cbiAgICBpZiAoYWN0aW9ucy5sZW5ndGggPT09IDAgJiYgYmxvYiAmJiBibG9iLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcoYmxvYik7XG4gICAgICAgIHJvb3QucmVmLmJsb2IgPSBudWxsO1xuICAgIH1cbn07XG5cbmNvbnN0IHJvdXRlJDQgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0RSQUc6IG1vdmVCbG9iLFxuICAgIERJRF9EUk9QOiBleHBsb2RlQmxvYixcbiAgICBESURfRU5EX0RSQUc6IGhpZGVCbG9iLFxufSk7XG5cbmNvbnN0IGRyaXAgPSBjcmVhdGVWaWV3KHtcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgbmFtZTogJ2RyaXAnLFxuICAgIHdyaXRlOiB3cml0ZSQ3LFxufSk7XG5cbmNvbnN0IHNldElucHV0RmlsZXMgPSAoZWxlbWVudCwgZmlsZXMpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDcmVhdGUgYSBEYXRhVHJhbnNmZXIgaW5zdGFuY2UgYW5kIGFkZCBhIG5ld2x5IGNyZWF0ZWQgZmlsZVxuICAgICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBuZXcgRGF0YVRyYW5zZmVyKCk7XG4gICAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuaXRlbXMuYWRkKGZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuaXRlbXMuYWRkKFxuICAgICAgICAgICAgICAgICAgICBuZXcgRmlsZShbZmlsZV0sIGZpbGUubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFzc2lnbiB0aGUgRGF0YVRyYW5zZmVyIGZpbGVzIGxpc3QgdG8gdGhlIGZpbGUgaW5wdXRcbiAgICAgICAgZWxlbWVudC5maWxlcyA9IGRhdGFUcmFuc2Zlci5maWxlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGNyZWF0ZSRjID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgcm9vdC5yZWYuZmllbGRzID0ge307XG4gICAgY29uc3QgbGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGVnZW5kJyk7XG4gICAgbGVnZW5kLnRleHRDb250ZW50ID0gJ0ZpbGVzJztcbiAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQobGVnZW5kKTtcbn07XG5cbmNvbnN0IGdldEZpZWxkID0gKHJvb3QsIGlkKSA9PiByb290LnJlZi5maWVsZHNbaWRdO1xuXG5jb25zdCBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMgPSByb290ID0+IHtcbiAgICByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJykuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaWYgKCFyb290LnJlZi5maWVsZHNbaXRlbS5pZF0pIHJldHVybjtcbiAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKHJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBkaWRSZW9yZGVySXRlbXMgPSAoeyByb290IH0pID0+IHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyhyb290KTtcblxuY29uc3QgZGlkQWRkSXRlbSA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgZmlsZUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgY29uc3QgaXNMb2NhbEZpbGUgPSBmaWxlSXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUw7XG4gICAgY29uc3Qgc2hvdWxkVXNlRmlsZUlucHV0ID0gIWlzTG9jYWxGaWxlICYmIHJvb3QucXVlcnkoJ1NIT1VMRF9VUERBVEVfRklMRV9JTlBVVCcpO1xuICAgIGNvbnN0IGRhdGFDb250YWluZXIgPSBjcmVhdGVFbGVtZW50JDEoJ2lucHV0Jyk7XG4gICAgZGF0YUNvbnRhaW5lci50eXBlID0gc2hvdWxkVXNlRmlsZUlucHV0ID8gJ2ZpbGUnIDogJ2hpZGRlbic7XG4gICAgZGF0YUNvbnRhaW5lci5uYW1lID0gcm9vdC5xdWVyeSgnR0VUX05BTUUnKTtcbiAgICByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXSA9IGRhdGFDb250YWluZXI7XG4gICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xufTtcblxuY29uc3QgZGlkTG9hZEl0ZW0kMSA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgIGlmICghZmllbGQpIHJldHVybjtcblxuICAgIC8vIHN0b3JlIHNlcnZlciByZWYgaW4gaGlkZGVuIGlucHV0XG4gICAgaWYgKGFjdGlvbi5zZXJ2ZXJGaWxlUmVmZXJlbmNlICE9PSBudWxsKSBmaWVsZC52YWx1ZSA9IGFjdGlvbi5zZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgLy8gc3RvcmUgZmlsZSBpdGVtIGluIGZpbGUgaW5wdXRcbiAgICBpZiAoIXJvb3QucXVlcnkoJ1NIT1VMRF9VUERBVEVfRklMRV9JTlBVVCcpKSByZXR1cm47XG5cbiAgICBjb25zdCBmaWxlSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBzZXRJbnB1dEZpbGVzKGZpZWxkLCBbZmlsZUl0ZW0uZmlsZV0pO1xufTtcblxuY29uc3QgZGlkUHJlcGFyZU91dHB1dCA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgLy8gdGhpcyB0aW1lb3V0IHB1c2hlcyB0aGUgaGFuZGxlciBhZnRlciAnbG9hZCdcbiAgICBpZiAoIXJvb3QucXVlcnkoJ1NIT1VMRF9VUERBVEVfRklMRV9JTlBVVCcpKSByZXR1cm47XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICAgICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgICAgICBzZXRJbnB1dEZpbGVzKGZpZWxkLCBbYWN0aW9uLmZpbGVdKTtcbiAgICB9LCAwKTtcbn07XG5cbmNvbnN0IGRpZFNldERpc2FibGVkID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgcm9vdC5lbGVtZW50LmRpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG59O1xuXG5jb25zdCBkaWRSZW1vdmVJdGVtID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuICAgIGlmIChmaWVsZC5wYXJlbnROb2RlKSBmaWVsZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGZpZWxkKTtcbiAgICBkZWxldGUgcm9vdC5yZWYuZmllbGRzW2FjdGlvbi5pZF07XG59O1xuXG4vLyBvbmx5IHJ1bnMgZm9yIHNlcnZlciBmaWxlcy4gd2lsbCByZWZ1c2UgdG8gdXBkYXRlIHRoZSB2YWx1ZSBpZiB0aGUgZmllbGRcbi8vIGlzIGEgZmlsZSBmaWVsZFxuY29uc3QgZGlkRGVmaW5lVmFsdWUgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgaWYgKGFjdGlvbi52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBjbGVhciBmaWVsZCB2YWx1ZVxuICAgICAgICBmaWVsZC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0IGZpZWxkIHZhbHVlXG4gICAgICAgIGlmIChmaWVsZC50eXBlICE9ICdmaWxlJykge1xuICAgICAgICAgICAgZmllbGQudmFsdWUgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xufTtcblxuY29uc3Qgd3JpdGUkOCA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfU0VUX0RJU0FCTEVEOiBkaWRTZXREaXNhYmxlZCxcbiAgICBESURfQUREX0lURU06IGRpZEFkZEl0ZW0sXG4gICAgRElEX0xPQURfSVRFTTogZGlkTG9hZEl0ZW0kMSxcbiAgICBESURfUkVNT1ZFX0lURU06IGRpZFJlbW92ZUl0ZW0sXG4gICAgRElEX0RFRklORV9WQUxVRTogZGlkRGVmaW5lVmFsdWUsXG4gICAgRElEX1BSRVBBUkVfT1VUUFVUOiBkaWRQcmVwYXJlT3V0cHV0LFxuICAgIERJRF9SRU9SREVSX0lURU1TOiBkaWRSZW9yZGVySXRlbXMsXG4gICAgRElEX1NPUlRfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbn0pO1xuXG5jb25zdCBkYXRhID0gY3JlYXRlVmlldyh7XG4gICAgdGFnOiAnZmllbGRzZXQnLFxuICAgIG5hbWU6ICdkYXRhJyxcbiAgICBjcmVhdGU6IGNyZWF0ZSRjLFxuICAgIHdyaXRlOiB3cml0ZSQ4LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG59KTtcblxuY29uc3QgZ2V0Um9vdE5vZGUgPSBlbGVtZW50ID0+ICgnZ2V0Um9vdE5vZGUnIGluIGVsZW1lbnQgPyBlbGVtZW50LmdldFJvb3ROb2RlKCkgOiBkb2N1bWVudCk7XG5cbmNvbnN0IGltYWdlcyA9IFsnanBnJywgJ2pwZWcnLCAncG5nJywgJ2dpZicsICdibXAnLCAnd2VicCcsICdzdmcnLCAndGlmZiddO1xuY29uc3QgdGV4dCQxID0gWydjc3MnLCAnY3N2JywgJ2h0bWwnLCAndHh0J107XG5jb25zdCBtYXAgPSB7XG4gICAgemlwOiAnemlwfGNvbXByZXNzZWQnLFxuICAgIGVwdWI6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG59O1xuXG5jb25zdCBndWVzc3RpbWF0ZU1pbWVUeXBlID0gKGV4dGVuc2lvbiA9ICcnKSA9PiB7XG4gICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGltYWdlcy5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnaW1hZ2UvJyArIChleHRlbnNpb24gPT09ICdqcGcnID8gJ2pwZWcnIDogZXh0ZW5zaW9uID09PSAnc3ZnJyA/ICdzdmcreG1sJyA6IGV4dGVuc2lvbilcbiAgICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRleHQkMS5pbmNsdWRlcyhleHRlbnNpb24pKSB7XG4gICAgICAgIHJldHVybiAndGV4dC8nICsgZXh0ZW5zaW9uO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBbZXh0ZW5zaW9uXSB8fCAnJztcbn07XG5cbmNvbnN0IHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyA9IGRhdGFUcmFuc2ZlciA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gdHJ5IHRvIGdldCBsaW5rcyBmcm9tIHRyYW5zZmVyLCBpZiBmb3VuZCB3ZSdsbCBleGl0IGltbWVkaWF0ZWx5ICh1bmxlc3MgYSBmaWxlIGlzIGluIHRoZSBkYXRhVHJhbnNmZXIgYXMgd2VsbCwgdGhpcyBpcyBiZWNhdXNlIEZpcmVmb3ggY291bGQgcmVwcmVzZW50IHRoZSBmaWxlIGFzIGEgVVJMIGFuZCBhIGZpbGUgb2JqZWN0IGF0IHRoZSBzYW1lIHRpbWUpXG4gICAgICAgIGNvbnN0IGxpbmtzID0gZ2V0TGlua3MoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCAmJiAhaGFzRmlsZXMoZGF0YVRyYW5zZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUobGlua3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyeSB0byBnZXQgZmlsZXMgZnJvbSB0aGUgdHJhbnNmZXJcbiAgICAgICAgZ2V0RmlsZXMoZGF0YVRyYW5zZmVyKS50aGVuKHJlc29sdmUpO1xuICAgIH0pO1xuXG4vKipcbiAqIFRlc3QgaWYgZGF0YXRyYW5zZmVyIGhhcyBmaWxlc1xuICovXG5jb25zdCBoYXNGaWxlcyA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgaWYgKGRhdGFUcmFuc2Zlci5maWxlcykgcmV0dXJuIGRhdGFUcmFuc2Zlci5maWxlcy5sZW5ndGggPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgZmlsZXMgZnJvbSBhIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqL1xuY29uc3QgZ2V0RmlsZXMgPSBkYXRhVHJhbnNmZXIgPT5cbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIGdldCB0aGUgdHJhbnNmZXIgaXRlbXMgYXMgcHJvbWlzZXNcbiAgICAgICAgY29uc3QgcHJvbWlzZWRGaWxlcyA9IChkYXRhVHJhbnNmZXIuaXRlbXMgPyBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5pdGVtcykgOiBbXSlcblxuICAgICAgICAgICAgLy8gb25seSBrZWVwIGZpbGUgc3lzdGVtIGl0ZW1zIChmaWxlcyBhbmQgZGlyZWN0b3JpZXMpXG4gICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXNGaWxlU3lzdGVtSXRlbShpdGVtKSlcblxuICAgICAgICAgICAgLy8gbWFwIGVhY2ggaXRlbSB0byBwcm9taXNlXG4gICAgICAgICAgICAubWFwKGl0ZW0gPT4gZ2V0RmlsZXNGcm9tSXRlbShpdGVtKSk7XG5cbiAgICAgICAgLy8gaWYgaXMgZW1wdHksIHNlZSBpZiB3ZSBjYW4gZXh0cmFjdCBzb21lIGluZm8gZnJvbSB0aGUgZmlsZXMgcHJvcGVydHkgYXMgYSBmYWxsYmFja1xuICAgICAgICBpZiAoIXByb21pc2VkRmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB0ZXN0IGZvciBkaXJlY3RvcmllcyAoc2hvdWxkIG5vdCBiZSBhbGxvd2VkKVxuICAgICAgICAgICAgLy8gVXNlIEZpbGVSZWFkZXIsIHByb2JsZW0gaXMgdGhhdCB0aGUgZmlsZXMgcHJvcGVydHkgZ2V0cyBsb3N0IGluIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICByZXNvbHZlKGRhdGFUcmFuc2Zlci5maWxlcyA/IEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSA6IFtdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvbmUhXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VkRmlsZXMpXG4gICAgICAgICAgICAudGhlbihyZXR1cm5lZEZpbGVHcm91cHMgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGZsYXR0ZW4gZ3JvdXBzXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm5lZEZpbGVHcm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVzLnB1c2guYXBwbHkoZmlsZXMsIGdyb3VwKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIGRvbmUgKGZpbHRlciBvdXQgZW1wdHkgZmlsZXMpIVxuICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZpbGUgPT4gZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLl9yZWxhdGl2ZVBhdGgpIGZpbGUuX3JlbGF0aXZlUGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICB9KTtcblxuY29uc3QgaXNGaWxlU3lzdGVtSXRlbSA9IGl0ZW0gPT4ge1xuICAgIGlmIChpc0VudHJ5KGl0ZW0pKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZ2V0QXNFbnRyeShpdGVtKTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuaXNGaWxlIHx8IGVudHJ5LmlzRGlyZWN0b3J5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtLmtpbmQgPT09ICdmaWxlJztcbn07XG5cbmNvbnN0IGdldEZpbGVzRnJvbUl0ZW0gPSBpdGVtID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoaXNEaXJlY3RvcnlFbnRyeShpdGVtKSkge1xuICAgICAgICAgICAgZ2V0RmlsZXNJbkRpcmVjdG9yeShnZXRBc0VudHJ5KGl0ZW0pKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKFtpdGVtLmdldEFzRmlsZSgpXSk7XG4gICAgfSk7XG5cbmNvbnN0IGdldEZpbGVzSW5EaXJlY3RvcnkgPSBlbnRyeSA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBbXTtcblxuICAgICAgICAvLyB0aGUgdG90YWwgZW50cmllcyB0byByZWFkXG4gICAgICAgIGxldCBkaXJDb3VudGVyID0gMDtcbiAgICAgICAgbGV0IGZpbGVDb3VudGVyID0gMDtcblxuICAgICAgICBjb25zdCByZXNvbHZlSWZEb25lID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGVDb3VudGVyID09PSAwICYmIGRpckNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aGUgcmVjdXJzaXZlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlYWRFbnRyaWVzID0gZGlyRW50cnkgPT4ge1xuICAgICAgICAgICAgZGlyQ291bnRlcisrO1xuXG4gICAgICAgICAgICBjb25zdCBkaXJlY3RvcnlSZWFkZXIgPSBkaXJFbnRyeS5jcmVhdGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgLy8gZGlyZWN0b3JpZXMgYXJlIHJldHVybmVkIGluIGJhdGNoZXMsIHdlIG5lZWQgdG8gcHJvY2VzcyBhbGwgYmF0Y2hlcyBiZWZvcmUgd2UncmUgZG9uZVxuICAgICAgICAgICAgY29uc3QgcmVhZEJhdGNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRpcmVjdG9yeVJlYWRlci5yZWFkRW50cmllcyhlbnRyaWVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJDb3VudGVyLS07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgcmVhZCBtb3JlIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkRW50cmllcyhlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlYWQgYXMgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVDb3VudGVyKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5maWxlKGZpbGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWRGaWxlID0gY29ycmVjdE1pc3NpbmdGaWxlVHlwZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LmZ1bGxQYXRoKSBjb3JyZWN0ZWRGaWxlLl9yZWxhdGl2ZVBhdGggPSBlbnRyeS5mdWxsUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaChjb3JyZWN0ZWRGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUlmRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ2V0IG5leHQgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgcmVhZEJhdGNoKCk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIHJlYWQgZmlyc3QgYmF0Y2ggb2YgZmlsZXNcbiAgICAgICAgICAgIHJlYWRCYXRjaCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdvIVxuICAgICAgICByZWFkRW50cmllcyhlbnRyeSk7XG4gICAgfSk7XG5cbmNvbnN0IGNvcnJlY3RNaXNzaW5nRmlsZVR5cGUgPSBmaWxlID0+IHtcbiAgICBpZiAoZmlsZS50eXBlLmxlbmd0aCkgcmV0dXJuIGZpbGU7XG4gICAgY29uc3QgZGF0ZSA9IGZpbGUubGFzdE1vZGlmaWVkRGF0ZTtcbiAgICBjb25zdCBuYW1lID0gZmlsZS5uYW1lO1xuICAgIGNvbnN0IHR5cGUgPSBndWVzc3RpbWF0ZU1pbWVUeXBlKGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZShmaWxlLm5hbWUpKTtcbiAgICBpZiAoIXR5cGUubGVuZ3RoKSByZXR1cm4gZmlsZTtcbiAgICBmaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIHR5cGUpO1xuICAgIGZpbGUubmFtZSA9IG5hbWU7XG4gICAgZmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZGF0ZTtcbiAgICByZXR1cm4gZmlsZTtcbn07XG5cbmNvbnN0IGlzRGlyZWN0b3J5RW50cnkgPSBpdGVtID0+IGlzRW50cnkoaXRlbSkgJiYgKGdldEFzRW50cnkoaXRlbSkgfHwge30pLmlzRGlyZWN0b3J5O1xuXG5jb25zdCBpc0VudHJ5ID0gaXRlbSA9PiAnd2Via2l0R2V0QXNFbnRyeScgaW4gaXRlbTtcblxuY29uc3QgZ2V0QXNFbnRyeSA9IGl0ZW0gPT4gaXRlbS53ZWJraXRHZXRBc0VudHJ5KCk7XG5cbi8qKlxuICogRXh0cmFjdHMgbGlua3MgZnJvbSBhIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqL1xuY29uc3QgZ2V0TGlua3MgPSBkYXRhVHJhbnNmZXIgPT4ge1xuICAgIGxldCBsaW5rcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGxvb2sgaW4gbWV0YSBkYXRhIHByb3BlcnR5XG4gICAgICAgIGxpbmtzID0gZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgICAgICBpZiAobGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgICAgIH1cbiAgICAgICAgbGlua3MgPSBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEoZGF0YVRyYW5zZmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vcGUgbm9wZSBub3BlIChwcm9iYWJseSBJRSB0cm91YmxlKVxuICAgIH1cbiAgICByZXR1cm4gbGlua3M7XG59O1xuXG5jb25zdCBnZXRMaW5rc0Zyb21UcmFuc2ZlclVSTERhdGEgPSBkYXRhVHJhbnNmZXIgPT4ge1xuICAgIGxldCBkYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3VybCcpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuY29uc3QgZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YSA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgbGV0IGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gZGF0YS5tYXRjaCgvc3JjXFxzKj1cXHMqXCIoLis/KVwiLyk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gW21hdGNoZXNbMV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbmNvbnN0IGRyYWdORHJvcE9ic2VydmVycyA9IFtdO1xuXG5jb25zdCBldmVudFBvc2l0aW9uID0gZSA9PiAoe1xuICAgIHBhZ2VMZWZ0OiBlLnBhZ2VYLFxuICAgIHBhZ2VUb3A6IGUucGFnZVksXG4gICAgc2NvcGVMZWZ0OiBlLm9mZnNldFggfHwgZS5sYXllclgsXG4gICAgc2NvcGVUb3A6IGUub2Zmc2V0WSB8fCBlLmxheWVyWSxcbn0pO1xuXG5jb25zdCBjcmVhdGVEcmFnTkRyb3BDbGllbnQgPSAoZWxlbWVudCwgc2NvcGVUb09ic2VydmUsIGZpbHRlckVsZW1lbnQpID0+IHtcbiAgICBjb25zdCBvYnNlcnZlciA9IGdldERyYWdORHJvcE9ic2VydmVyKHNjb3BlVG9PYnNlcnZlKTtcblxuICAgIGNvbnN0IGNsaWVudCA9IHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgZmlsdGVyRWxlbWVudCxcbiAgICAgICAgc3RhdGU6IG51bGwsXG4gICAgICAgIG9uZHJvcDogKCkgPT4ge30sXG4gICAgICAgIG9uZW50ZXI6ICgpID0+IHt9LFxuICAgICAgICBvbmRyYWc6ICgpID0+IHt9LFxuICAgICAgICBvbmV4aXQ6ICgpID0+IHt9LFxuICAgICAgICBvbmxvYWQ6ICgpID0+IHt9LFxuICAgICAgICBhbGxvd2Ryb3A6ICgpID0+IHt9LFxuICAgIH07XG5cbiAgICBjbGllbnQuZGVzdHJveSA9IG9ic2VydmVyLmFkZExpc3RlbmVyKGNsaWVudCk7XG5cbiAgICByZXR1cm4gY2xpZW50O1xufTtcblxuY29uc3QgZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIgPSBlbGVtZW50ID0+IHtcbiAgICAvLyBzZWUgaWYgYWxyZWFkeSBleGlzdHMsIGlmIHNvLCByZXR1cm5cbiAgICBjb25zdCBvYnNlcnZlciA9IGRyYWdORHJvcE9ic2VydmVycy5maW5kKGl0ZW0gPT4gaXRlbS5lbGVtZW50ID09PSBlbGVtZW50KTtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBuZXcgb2JzZXJ2ZXIsIGRvZXMgbm90IHlldCBleGlzdCBmb3IgdGhpcyBlbGVtZW50XG4gICAgY29uc3QgbmV3T2JzZXJ2ZXIgPSBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlcihlbGVtZW50KTtcbiAgICBkcmFnTkRyb3BPYnNlcnZlcnMucHVzaChuZXdPYnNlcnZlcik7XG4gICAgcmV0dXJuIG5ld09ic2VydmVyO1xufTtcblxuY29uc3QgY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIgPSBlbGVtZW50ID0+IHtcbiAgICBjb25zdCBjbGllbnRzID0gW107XG5cbiAgICBjb25zdCByb3V0ZXMgPSB7XG4gICAgICAgIGRyYWdlbnRlcixcbiAgICAgICAgZHJhZ292ZXIsXG4gICAgICAgIGRyYWdsZWF2ZSxcbiAgICAgICAgZHJvcCxcbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlcnMgPSB7fTtcblxuICAgIGZvcmluKHJvdXRlcywgKGV2ZW50LCBjcmVhdGVIYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGNyZWF0ZUhhbmRsZXIoZWxlbWVudCwgY2xpZW50cyk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgYWRkTGlzdGVuZXI6IGNsaWVudCA9PiB7XG4gICAgICAgICAgICAvLyBhZGQgYXMgY2xpZW50XG4gICAgICAgICAgICBjbGllbnRzLnB1c2goY2xpZW50KTtcblxuICAgICAgICAgICAgLy8gcmV0dXJuIHJlbW92ZUxpc3RlbmVyIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjbGllbnRcbiAgICAgICAgICAgICAgICBjbGllbnRzLnNwbGljZShjbGllbnRzLmluZGV4T2YoY2xpZW50KSwgMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBubyBtb3JlIGNsaWVudHMsIGNsZWFuIHVwIG9ic2VydmVyXG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdORHJvcE9ic2VydmVycy5zcGxpY2UoZHJhZ05Ecm9wT2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3Jpbihyb3V0ZXMsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcnNbZXZlbnRdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBvYnNlcnZlcjtcbn07XG5cbmNvbnN0IGVsZW1lbnRGcm9tUG9pbnQgPSAocm9vdCwgcG9pbnQpID0+IHtcbiAgICBpZiAoISgnZWxlbWVudEZyb21Qb2ludCcgaW4gcm9vdCkpIHtcbiAgICAgICAgcm9vdCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcm9vdC5lbGVtZW50RnJvbVBvaW50KHBvaW50LngsIHBvaW50LnkpO1xufTtcblxuY29uc3QgaXNFdmVudFRhcmdldCA9IChlLCB0YXJnZXQpID0+IHtcbiAgICAvLyBnZXQgcm9vdFxuICAgIGNvbnN0IHJvb3QgPSBnZXRSb290Tm9kZSh0YXJnZXQpO1xuXG4gICAgLy8gZ2V0IGVsZW1lbnQgYXQgcG9zaXRpb25cbiAgICAvLyBpZiByb290IGlzIG5vdCBhY3R1YWwgc2hhZG93IERPTSBhbmQgZG9lcyBub3QgaGF2ZSBlbGVtZW50RnJvbVBvaW50IG1ldGhvZCwgdXNlIHRoZSBvbmUgb24gZG9jdW1lbnRcbiAgICBjb25zdCBlbGVtZW50QXRQb3NpdGlvbiA9IGVsZW1lbnRGcm9tUG9pbnQocm9vdCwge1xuICAgICAgICB4OiBlLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgICB5OiBlLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgIH0pO1xuXG4gICAgLy8gdGVzdCBpZiB0YXJnZXQgaXMgdGhlIGVsZW1lbnQgb3IgaWYgb25lIG9mIGl0cyBjaGlsZHJlbiBpc1xuICAgIHJldHVybiBlbGVtZW50QXRQb3NpdGlvbiA9PT0gdGFyZ2V0IHx8IHRhcmdldC5jb250YWlucyhlbGVtZW50QXRQb3NpdGlvbik7XG59O1xuXG5sZXQgaW5pdGlhbFRhcmdldCA9IG51bGw7XG5cbmNvbnN0IHNldERyb3BFZmZlY3QgPSAoZGF0YVRyYW5zZmVyLCBlZmZlY3QpID0+IHtcbiAgICAvLyBpcyBpbiB0cnkgY2F0Y2ggYXMgSUUxMSB3aWxsIHRocm93IGVycm9yIGlmIG5vdFxuICAgIHRyeSB7XG4gICAgICAgIGRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gZWZmZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHt9XG59O1xuXG5jb25zdCBkcmFnZW50ZXIgPSAocm9vdCwgY2xpZW50cykgPT4gZSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaW5pdGlhbFRhcmdldCA9IGUudGFyZ2V0O1xuXG4gICAgY2xpZW50cy5mb3JFYWNoKGNsaWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgb25lbnRlciB9ID0gY2xpZW50O1xuXG4gICAgICAgIGlmIChpc0V2ZW50VGFyZ2V0KGUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuXG4gICAgICAgICAgICAvLyBmaXJlIGVudGVyIGV2ZW50XG4gICAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBkcmFnb3ZlciA9IChyb290LCBjbGllbnRzKSA9PiBlID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oaXRlbXMgPT4ge1xuICAgICAgICBsZXQgb3ZlckRyb3BUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICBjbGllbnRzLnNvbWUoY2xpZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmlsdGVyRWxlbWVudCwgZWxlbWVudCwgb25lbnRlciwgb25leGl0LCBvbmRyYWcsIGFsbG93ZHJvcCB9ID0gY2xpZW50O1xuXG4gICAgICAgICAgICAvLyBieSBkZWZhdWx0IHdlIGNhbiBkcm9wXG4gICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ2NvcHknKTtcblxuICAgICAgICAgICAgLy8gYWxsb3cgdHJhbnNmZXIgb2YgdGhlc2UgaXRlbXNcbiAgICAgICAgICAgIGNvbnN0IGFsbG93c1RyYW5zZmVyID0gYWxsb3dkcm9wKGl0ZW1zKTtcblxuICAgICAgICAgICAgLy8gb25seSB1c2VkIHdoZW4gY2FuIGJlIGRyb3BwZWQgb24gcGFnZVxuICAgICAgICAgICAgaWYgKCFhbGxvd3NUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGFyZ2V0dGluZyB0aGlzIGNsaWVudFxuICAgICAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBvdmVyRHJvcFRhcmdldCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBoYWQgbm8gcHJldmlvdXMgc3RhdGUsIG1lYW5zIHdlIGFyZSBlbnRlcmluZyB0aGlzIGNsaWVudFxuICAgICAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgb25lbnRlcihldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5vdyBvdmVyIGVsZW1lbnQgKG5vIG1hdHRlciBpZiBpdCBhbGxvd3MgdGhlIGRyb3Agb3Igbm90KVxuICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdvdmVyJztcblxuICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRvIGFsbG93IHRyYW5zZmVyXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBvbmRyYWcoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBvdmVyIGFuIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJFbGVtZW50ICYmICFvdmVyRHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBzZXREcm9wRWZmZWN0KGRhdGFUcmFuc2ZlciwgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtaWdodCBoYXZlIGp1c3QgbGVmdCB0aGlzIGNsaWVudD9cbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50LnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuY29uc3QgZHJvcCA9IChyb290LCBjbGllbnRzKSA9PiBlID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcblxuICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhkYXRhVHJhbnNmZXIpLnRoZW4oaXRlbXMgPT4ge1xuICAgICAgICBjbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmlsdGVyRWxlbWVudCwgZWxlbWVudCwgb25kcm9wLCBvbmV4aXQsIGFsbG93ZHJvcCB9ID0gY2xpZW50O1xuXG4gICAgICAgICAgICBjbGllbnQuc3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBmaWx0ZXJpbmcgb24gZWxlbWVudCB3ZSBuZWVkIHRvIGJlIG92ZXIgdGhlIGVsZW1lbnQgdG8gZHJvcFxuICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIWlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gbm8gdHJhbnNmZXIgZm9yIHRoaXMgY2xpZW50XG4gICAgICAgICAgICBpZiAoIWFsbG93ZHJvcChpdGVtcykpIHJldHVybiBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG5cbiAgICAgICAgICAgIC8vIHdlIGNhbiBkcm9wIHRoZXNlIGl0ZW1zIG9uIHRoaXMgY2xpZW50XG4gICAgICAgICAgICBvbmRyb3AoZXZlbnRQb3NpdGlvbihlKSwgaXRlbXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGRyYWdsZWF2ZSA9IChyb290LCBjbGllbnRzKSA9PiBlID0+IHtcbiAgICBpZiAoaW5pdGlhbFRhcmdldCAhPT0gZS50YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsaWVudHMuZm9yRWFjaChjbGllbnQgPT4ge1xuICAgICAgICBjb25zdCB7IG9uZXhpdCB9ID0gY2xpZW50O1xuXG4gICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuICAgIH0pO1xufTtcblxuY29uc3QgY3JlYXRlSG9wcGVyID0gKHNjb3BlLCB2YWxpZGF0ZUl0ZW1zLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gaXMgbm93IGhvcHBlciBzY29wZVxuICAgIHNjb3BlLmNsYXNzTGlzdC5hZGQoJ2ZpbGVwb25kLS1ob3BwZXInKTtcblxuICAgIC8vIHNob3J0Y3V0c1xuICAgIGNvbnN0IHsgY2F0Y2hlc0Ryb3BzT25QYWdlLCByZXF1aXJlc0Ryb3BPbkVsZW1lbnQsIGZpbHRlckl0ZW1zID0gaXRlbXMgPT4gaXRlbXMgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBjcmVhdGUgYSBkbmQgY2xpZW50XG4gICAgY29uc3QgY2xpZW50ID0gY3JlYXRlRHJhZ05Ecm9wQ2xpZW50KFxuICAgICAgICBzY29wZSxcbiAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogc2NvcGUsXG4gICAgICAgIHJlcXVpcmVzRHJvcE9uRWxlbWVudFxuICAgICk7XG5cbiAgICAvLyBjdXJyZW50IGNsaWVudCBzdGF0ZVxuICAgIGxldCBsYXN0U3RhdGUgPSAnJztcbiAgICBsZXQgY3VycmVudFN0YXRlID0gJyc7XG5cbiAgICAvLyBkZXRlcm1pbmVzIGlmIGEgZmlsZSBtYXkgYmUgZHJvcHBlZFxuICAgIGNsaWVudC5hbGxvd2Ryb3AgPSBpdGVtcyA9PiB7XG4gICAgICAgIC8vIFRPRE86IGlmIHdlIGNhbiwgdGhyb3cgZXJyb3IgdG8gaW5kaWNhdGUgdGhlIGl0ZW1zIGNhbm5vdCBieSBkcm9wcGVkXG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlSXRlbXMoZmlsdGVySXRlbXMoaXRlbXMpKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZHJvcCA9IChwb3NpdGlvbiwgaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRJdGVtcyA9IGZpbHRlckl0ZW1zKGl0ZW1zKTtcblxuICAgICAgICBpZiAoIXZhbGlkYXRlSXRlbXMoZmlsdGVyZWRJdGVtcykpIHtcbiAgICAgICAgICAgIGFwaS5vbmRyYWdlbmQocG9zaXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZHJvcCc7XG5cbiAgICAgICAgYXBpLm9ubG9hZChmaWx0ZXJlZEl0ZW1zLCBwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIGNsaWVudC5vbmRyYWcgPSBwb3NpdGlvbiA9PiB7XG4gICAgICAgIGFwaS5vbmRyYWcocG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25lbnRlciA9IHBvc2l0aW9uID0+IHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctb3Zlcic7XG5cbiAgICAgICAgYXBpLm9uZHJhZ3N0YXJ0KHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZXhpdCA9IHBvc2l0aW9uID0+IHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gJ2RyYWctZXhpdCc7XG5cbiAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgdXBkYXRlSG9wcGVyU3RhdGU6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgIT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmRhdGFzZXQuaG9wcGVyU3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgICAgICAgbGFzdFN0YXRlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbmxvYWQ6ICgpID0+IHt9LFxuICAgICAgICBvbmRyYWdzdGFydDogKCkgPT4ge30sXG4gICAgICAgIG9uZHJhZzogKCkgPT4ge30sXG4gICAgICAgIG9uZHJhZ2VuZDogKCkgPT4ge30sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIGRlc3Ryb3kgY2xpZW50XG4gICAgICAgICAgICBjbGllbnQuZGVzdHJveSgpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxubGV0IGxpc3RlbmluZyA9IGZhbHNlO1xuY29uc3QgbGlzdGVuZXJzJDEgPSBbXTtcblxuY29uc3QgaGFuZGxlUGFzdGUgPSBlID0+IHtcbiAgICAvLyBpZiBpcyBwYXN0aW5nIGluIGlucHV0IG9yIHRleHRhcmVhIGFuZCB0aGUgdGFyZ2V0IGlzIG91dHNpZGUgb2YgYSBmaWxlcG9uZCBzY29wZSwgaWdub3JlXG4gICAgY29uc3QgYWN0aXZlRWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGNvbnN0IGlzQWN0aXZlRWxlbWVudEVkaXRhYmxlID1cbiAgICAgICAgYWN0aXZlRWwgJiZcbiAgICAgICAgKC90ZXh0YXJlYXxpbnB1dC9pLnRlc3QoYWN0aXZlRWwubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICBhY3RpdmVFbC5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAndHJ1ZScpO1xuXG4gICAgaWYgKGlzQWN0aXZlRWxlbWVudEVkaXRhYmxlKSB7XG4gICAgICAgIC8vIHRlc3QgdGV4dGFyZWEgb3IgaW5wdXQgaXMgY29udGFpbmVkIGluIGZpbGVwb25kIHJvb3RcbiAgICAgICAgbGV0IGluU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBhY3RpdmVFbDtcbiAgICAgICAgd2hpbGUgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZmlsZXBvbmQtLXJvb3QnKSkge1xuICAgICAgICAgICAgICAgIGluU2NvcGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5TY29wZSkgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyhlLmNsaXBib2FyZERhdGEpLnRoZW4oZmlsZXMgPT4ge1xuICAgICAgICAvLyBubyBmaWxlcyByZWNlaXZlZFxuICAgICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90aWZ5IGxpc3RlbmVycyBvZiByZWNlaXZlZCBmaWxlc1xuICAgICAgICBsaXN0ZW5lcnMkMS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGZpbGVzKSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBsaXN0ZW4gPSBjYiA9PiB7XG4gICAgLy8gY2FuJ3QgYWRkIHR3aWNlXG4gICAgaWYgKGxpc3RlbmVycyQxLmluY2x1ZGVzKGNiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYWRkIGluaXRpYWwgbGlzdGVuZXJcbiAgICBsaXN0ZW5lcnMkMS5wdXNoKGNiKTtcblxuICAgIC8vIHNldHVwIHBhc3RlIGxpc3RlbmVyIGZvciBlbnRpcmUgcGFnZVxuICAgIGlmIChsaXN0ZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpc3RlbmluZyA9IHRydWU7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG59O1xuXG5jb25zdCB1bmxpc3RlbiA9IGxpc3RlbmVyID0+IHtcbiAgICBhcnJheVJlbW92ZShsaXN0ZW5lcnMkMSwgbGlzdGVuZXJzJDEuaW5kZXhPZihsaXN0ZW5lcikpO1xuXG4gICAgLy8gY2xlYW4gdXBcbiAgICBpZiAobGlzdGVuZXJzJDEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgaGFuZGxlUGFzdGUpO1xuICAgICAgICBsaXN0ZW5pbmcgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGVQYXN0ZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgY2IgPSBmaWxlcyA9PiB7XG4gICAgICAgIGFwaS5vbmxvYWQoZmlsZXMpO1xuICAgIH07XG5cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIHVubGlzdGVuKGNiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25sb2FkOiAoKSA9PiB7fSxcbiAgICB9O1xuXG4gICAgbGlzdGVuKGNiKTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGZpbGUgdmlld1xuICovXG5jb25zdCBjcmVhdGUkZCA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICByb290LmVsZW1lbnQuaWQgPSBgZmlsZXBvbmQtLWFzc2lzdGFudC0ke3Byb3BzLmlkfWA7XG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2FsZXJ0Jyk7XG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLXJlbGV2YW50JywgJ2FkZGl0aW9ucycpO1xufTtcblxubGV0IGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7XG5sZXQgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gbnVsbDtcblxuY29uc3QgZmlsZW5hbWVzID0gW107XG5cbmNvbnN0IGFzc2lzdCA9IChyb290LCBtZXNzYWdlKSA9PiB7XG4gICAgcm9vdC5lbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbn07XG5cbmNvbnN0IGNsZWFyJDEgPSByb290ID0+IHtcbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbn07XG5cbmNvbnN0IGxpc3RNb2RpZmllZCA9IChyb290LCBmaWxlbmFtZSwgbGFiZWwpID0+IHtcbiAgICBjb25zdCB0b3RhbCA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgIGFzc2lzdChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYCR7bGFiZWx9ICR7ZmlsZW5hbWV9LCAke3RvdGFsfSAke1xuICAgICAgICAgICAgdG90YWwgPT09IDFcbiAgICAgICAgICAgICAgICA/IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1NJTkdVTEFSJylcbiAgICAgICAgICAgICAgICA6IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0NPVU5UX1BMVVJBTCcpXG4gICAgICAgIH1gXG4gICAgKTtcblxuICAgIC8vIGNsZWFyIGdyb3VwIGFmdGVyIHNldCBhbW91bnQgb2YgdGltZSBzbyB0aGUgc3RhdHVzIGlzIG5vdCByZWFkIHR3aWNlXG4gICAgY2xlYXJUaW1lb3V0KG5vdGlmaWNhdGlvbkNsZWFyVGltZW91dCk7XG4gICAgbm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFyJDEocm9vdCk7XG4gICAgfSwgMTUwMCk7XG59O1xuXG5jb25zdCBpc1VzaW5nRmlsZVBvbmQgPSByb290ID0+IHJvb3QuZWxlbWVudC5wYXJlbnROb2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuXG5jb25zdCBpdGVtQWRkZWQgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGlmICghaXNVc2luZ0ZpbGVQb25kKHJvb3QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICBjb25zdCBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIGZpbGVuYW1lcy5wdXNoKGl0ZW0uZmlsZW5hbWUpO1xuXG4gICAgY2xlYXJUaW1lb3V0KGFkZEZpbGVzTm90aWZpY2F0aW9uVGltZW91dCk7XG4gICAgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxpc3RNb2RpZmllZChyb290LCBmaWxlbmFtZXMuam9pbignLCAnKSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQURERUQnKSk7XG4gICAgICAgIGZpbGVuYW1lcy5sZW5ndGggPSAwO1xuICAgIH0sIDc1MCk7XG59O1xuXG5jb25zdCBpdGVtUmVtb3ZlZCA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW0gPSBhY3Rpb24uaXRlbTtcbiAgICBsaXN0TW9kaWZpZWQocm9vdCwgaXRlbS5maWxlbmFtZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUkVNT1ZFRCcpKTtcbn07XG5cbmNvbnN0IGl0ZW1Qcm9jZXNzZWQgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIC8vIHdpbGwgYWxzbyBub3RpZnkgdGhlIHVzZXIgd2hlbiBGaWxlUG9uZCBpcyBub3QgYmVpbmcgdXNlZCwgYXMgdGhlIHVzZXIgbWlnaHQgYmUgb2NjdXBpZWQgd2l0aCBvdGhlciBhY3Rpdml0aWVzIHdoaWxlIHVwbG9hZGluZyBhIGZpbGVcblxuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgIGNvbnN0IGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19DT01QTEVURScpO1xuXG4gICAgYXNzaXN0KHJvb3QsIGAke2ZpbGVuYW1lfSAke2xhYmVsfWApO1xufTtcblxuY29uc3QgaXRlbVByb2Nlc3NlZFVuZG8gPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuICAgIGNvbnN0IGxhYmVsID0gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lOR19BQk9SVEVEJyk7XG5cbiAgICBhc3Npc3Qocm9vdCwgYCR7ZmlsZW5hbWV9ICR7bGFiZWx9YCk7XG59O1xuXG5jb25zdCBpdGVtRXJyb3IgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBpdGVtLmZpbGVuYW1lO1xuXG4gICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgYXNzaXN0KHJvb3QsIGAke2FjdGlvbi5zdGF0dXMubWFpbn0gJHtmaWxlbmFtZX0gJHthY3Rpb24uc3RhdHVzLnN1Yn1gKTtcbn07XG5cbmNvbnN0IGFzc2lzdGFudCA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJGQsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0VXBkYXRlOiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9MT0FEX0lURU06IGl0ZW1BZGRlZCxcbiAgICAgICAgRElEX1JFTU9WRV9JVEVNOiBpdGVtUmVtb3ZlZCxcbiAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZCxcblxuICAgICAgICBESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HOiBpdGVtUHJvY2Vzc2VkVW5kbyxcbiAgICAgICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogaXRlbUVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiBpdGVtRXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGl0ZW1FcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogaXRlbUVycm9yLFxuICAgIH0pLFxuICAgIHRhZzogJ3NwYW4nLFxuICAgIG5hbWU6ICdhc3Npc3RhbnQnLFxufSk7XG5cbmNvbnN0IHRvQ2FtZWxzID0gKHN0cmluZywgc2VwYXJhdG9yID0gJy0nKSA9PlxuICAgIHN0cmluZy5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7c2VwYXJhdG9yfS5gLCAnZycpLCBzdWIgPT4gc3ViLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpKTtcblxuY29uc3QgZGVib3VuY2UgPSAoZnVuYywgaW50ZXJ2YWwgPSAxNiwgaW1taWRpYXRlT25seSA9IHRydWUpID0+IHtcbiAgICBsZXQgbGFzdCA9IERhdGUubm93KCk7XG4gICAgbGV0IHRpbWVvdXQgPSBudWxsO1xuXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblxuICAgICAgICBjb25zdCBkaXN0ID0gRGF0ZS5ub3coKSAtIGxhc3Q7XG5cbiAgICAgICAgY29uc3QgZm4gPSAoKSA9PiB7XG4gICAgICAgICAgICBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGRpc3QgPCBpbnRlcnZhbCkge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBieSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGludGVydmFsIGFuZCBkaXN0XG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZTogaWYgZGlzdGFuY2UgaXMgMTAgbXMgYW5kIGludGVydmFsIGlzIDE2IG1zLFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGFuIGFkZGl0aW9uYWwgNm1zIGJlZm9yZSBjYWxsaW5nIHRoZSBmdW5jdGlvbilcbiAgICAgICAgICAgIGlmICghaW1taWRpYXRlT25seSkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBpbnRlcnZhbCAtIGRpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ28hXG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNvbnN0IE1BWF9GSUxFU19MSU1JVCA9IDEwMDAwMDA7XG5cbmNvbnN0IHByZXZlbnQgPSBlID0+IGUucHJldmVudERlZmF1bHQoKTtcblxuY29uc3QgY3JlYXRlJGUgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gQWRkIGlkXG4gICAgY29uc3QgaWQgPSByb290LnF1ZXJ5KCdHRVRfSUQnKTtcbiAgICBpZiAoaWQpIHtcbiAgICAgICAgcm9vdC5lbGVtZW50LmlkID0gaWQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNsYXNzTmFtZVxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHJvb3QucXVlcnkoJ0dFVF9DTEFTU19OQU1FJyk7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBjbGFzc05hbWVcbiAgICAgICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZS5sZW5ndGgpXG4gICAgICAgICAgICAuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZpZWxkIGxhYmVsXG4gICAgcm9vdC5yZWYubGFiZWwgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoZHJvcExhYmVsLCB7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICBjYXB0aW9uOiByb290LnF1ZXJ5KCdHRVRfTEFCRUxfSURMRScpLFxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBMaXN0IG9mIGl0ZW1zXG4gICAgcm9vdC5yZWYubGlzdCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGxpc3RTY3JvbGxlciwgeyB0cmFuc2xhdGVZOiBudWxsIH0pKTtcblxuICAgIC8vIEJhY2tncm91bmQgcGFuZWxcbiAgICByb290LnJlZi5wYW5lbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHBhbmVsLCB7IG5hbWU6ICdwYW5lbC1yb290JyB9KSk7XG5cbiAgICAvLyBBc3Npc3RhbnQgbm90aWZpZXMgYXNzaXN0aXZlIHRlY2ggd2hlbiBjb250ZW50IGNoYW5nZXNcbiAgICByb290LnJlZi5hc3Npc3RhbnQgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhhc3Npc3RhbnQsIHsgLi4ucHJvcHMgfSkpO1xuXG4gICAgLy8gRGF0YVxuICAgIHJvb3QucmVmLmRhdGEgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhkYXRhLCB7IC4uLnByb3BzIH0pKTtcblxuICAgIC8vIE1lYXN1cmUgKHRlc3RzIGlmIGZpeGVkIGhlaWdodCB3YXMgc2V0KVxuICAgIC8vIERPQ1RZUEUgbmVlZHMgdG8gYmUgc2V0IGZvciB0aGlzIHRvIHdvcmtcbiAgICByb290LnJlZi5tZWFzdXJlID0gY3JlYXRlRWxlbWVudCQxKCdkaXYnKTtcbiAgICByb290LnJlZi5tZWFzdXJlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG5cbiAgICAvLyBpbmZvcm1hdGlvbiBvbiB0aGUgcm9vdCBoZWlnaHQgb3IgZml4ZWQgaGVpZ2h0IHN0YXR1c1xuICAgIHJvb3QucmVmLmJvdW5kcyA9IG51bGw7XG5cbiAgICAvLyBhcHBseSBpbml0aWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICByb290LnF1ZXJ5KCdHRVRfU1RZTEVTJylcbiAgICAgICAgLmZpbHRlcihzdHlsZSA9PiAhaXNFbXB0eShzdHlsZS52YWx1ZSkpXG4gICAgICAgIC5tYXAoKHsgbmFtZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgaWYgd2lkdGggY2hhbmdlZFxuICAgIHJvb3QucmVmLndpZHRoUHJldmlvdXMgPSBudWxsO1xuICAgIHJvb3QucmVmLndpZHRoVXBkYXRlZCA9IGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfUkVTSVpFX1JPT1QnKTtcbiAgICB9LCAyNTApO1xuXG4gICAgLy8gaGlzdG9yeSBvZiB1cGRhdGVzXG4gICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IG51bGw7XG4gICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuXG4gICAgLy8gcHJldmVudCBzY3JvbGxpbmcgYW5kIHpvb21pbmcgb24gaU9TIChvbmx5IGlmIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLCBmb3IgdGhlbiB3ZSBjYW4gZW5hYmxlIHJlb3JkZXIpXG4gICAgY29uc3QgY2FuSG92ZXIgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHBvaW50ZXI6IGZpbmUpIGFuZCAoaG92ZXI6IGhvdmVyKScpLm1hdGNoZXM7XG4gICAgY29uc3QgaGFzUG9pbnRlckV2ZW50cyA9ICdQb2ludGVyRXZlbnQnIGluIHdpbmRvdztcbiAgICBpZiAocm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFT1JERVInKSAmJiBoYXNQb2ludGVyRXZlbnRzICYmICFjYW5Ib3Zlcikge1xuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgIH1cblxuICAgIC8vIGFkZCBjcmVkaXRzXG4gICAgY29uc3QgY3JlZGl0cyA9IHJvb3QucXVlcnkoJ0dFVF9DUkVESVRTJyk7XG4gICAgY29uc3QgaGFzQ3JlZGl0cyA9IGNyZWRpdHMubGVuZ3RoID09PSAyO1xuICAgIGlmIChoYXNDcmVkaXRzKSB7XG4gICAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGZyYWcuY2xhc3NOYW1lID0gJ2ZpbGVwb25kLS1jcmVkaXRzJztcbiAgICAgICAgZnJhZy5ocmVmID0gY3JlZGl0c1swXTtcbiAgICAgICAgZnJhZy50YWJJbmRleCA9IC0xO1xuICAgICAgICBmcmFnLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICBmcmFnLnJlbCA9ICdub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93JztcbiAgICAgICAgZnJhZy50ZXh0Q29udGVudCA9IGNyZWRpdHNbMV07XG4gICAgICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgcm9vdC5yZWYuY3JlZGl0cyA9IGZyYWc7XG4gICAgfVxufTtcblxuY29uc3Qgd3JpdGUkOSA9ICh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pID0+IHtcbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkNSh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pO1xuXG4gICAgLy8gYXBwbHkgc3R5bGUgcHJvcGVydGllc1xuICAgIGFjdGlvbnNcbiAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gL15ESURfU0VUX1NUWUxFXy8udGVzdChhY3Rpb24udHlwZSkpXG4gICAgICAgIC5maWx0ZXIoYWN0aW9uID0+ICFpc0VtcHR5KGFjdGlvbi5kYXRhLnZhbHVlKSlcbiAgICAgICAgLm1hcCgoeyB0eXBlLCBkYXRhIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0b0NhbWVscyh0eXBlLnN1YnN0cmluZyg4KS50b0xvd2VyQ2FzZSgpLCAnXycpO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXRbbmFtZV0gPSBkYXRhLnZhbHVlO1xuICAgICAgICAgICAgcm9vdC5pbnZhbGlkYXRlTGF5b3V0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LmhpZGRlbikgcmV0dXJuO1xuXG4gICAgaWYgKHJvb3QucmVjdC5lbGVtZW50LndpZHRoICE9PSByb290LnJlZi53aWR0aFByZXZpb3VzKSB7XG4gICAgICAgIHJvb3QucmVmLndpZHRoUHJldmlvdXMgPSByb290LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICAgICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkKCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGJveCBib3VuZHMsIHdlIGRvIHRoaXMgb25seSBvbmNlXG4gICAgbGV0IGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcztcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICBib3VuZHMgPSByb290LnJlZi5ib3VuZHMgPSBjYWxjdWxhdGVSb290Qm91bmRpbmdCb3hIZWlnaHQocm9vdCk7XG5cbiAgICAgICAgLy8gZGVzdHJveSBtZWFzdXJlIGVsZW1lbnRcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUNoaWxkKHJvb3QucmVmLm1lYXN1cmUpO1xuICAgICAgICByb290LnJlZi5tZWFzdXJlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlcyB0byB2YXJpb3VzIGhpZ2ggbGV2ZWwgcGFydHMgb2YgdGhlIHVwbG9hZCB0b29sXG4gICAgY29uc3QgeyBob3BwZXIsIGxhYmVsLCBsaXN0LCBwYW5lbCB9ID0gcm9vdC5yZWY7XG5cbiAgICAvLyBzZXRzIGNvcnJlY3Qgc3RhdGUgdG8gaG9wcGVyIHNjb3BlXG4gICAgaWYgKGhvcHBlcikge1xuICAgICAgICBob3BwZXIudXBkYXRlSG9wcGVyU3RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBib29sIHRvIGluZGljYXRlIGlmIHdlJ3JlIGZ1bGwgb3Igbm90XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgY29uc3QgaXNNdWx0aUl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgY29uc3QgbWF4SXRlbXMgPSBpc011bHRpSXRlbSA/IHJvb3QucXVlcnkoJ0dFVF9NQVhfRklMRVMnKSB8fCBNQVhfRklMRVNfTElNSVQgOiAxO1xuICAgIGNvbnN0IGF0TWF4Q2FwYWNpdHkgPSB0b3RhbEl0ZW1zID09PSBtYXhJdGVtcztcblxuICAgIC8vIGFjdGlvbiB1c2VkIHRvIGFkZCBpdGVtXG4gICAgY29uc3QgYWRkQWN0aW9uID0gYWN0aW9ucy5maW5kKGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PT0gJ0RJRF9BRERfSVRFTScpO1xuXG4gICAgLy8gaWYgcmVhY2hlZCBtYXggY2FwYWNpdHkgYW5kIHdlJ3ZlIGp1c3QgcmVhY2hlZCBpdFxuICAgIGlmIChhdE1heENhcGFjaXR5ICYmIGFkZEFjdGlvbikge1xuICAgICAgICAvLyBnZXQgaW50ZXJhY3Rpb24gdHlwZVxuICAgICAgICBjb25zdCBpbnRlcmFjdGlvbk1ldGhvZCA9IGFkZEFjdGlvbi5kYXRhLmludGVyYWN0aW9uTWV0aG9kO1xuXG4gICAgICAgIC8vIGhpZGUgbGFiZWxcbiAgICAgICAgbGFiZWwub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgaWYgKGlzTXVsdGlJdGVtKSB7XG4gICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gLTQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5BUEkpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVYID0gNDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gNDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAzMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWF0TWF4Q2FwYWNpdHkpIHtcbiAgICAgICAgbGFiZWwub3BhY2l0eSA9IDE7XG4gICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSAwO1xuICAgICAgICBsYWJlbC50cmFuc2xhdGVZID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0SXRlbU1hcmdpbiA9IGNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luKHJvb3QpO1xuXG4gICAgY29uc3QgbGlzdEhlaWdodCA9IGNhbGN1bGF0ZUxpc3RIZWlnaHQocm9vdCk7XG5cbiAgICBjb25zdCBsYWJlbEhlaWdodCA9IGxhYmVsLnJlY3QuZWxlbWVudC5oZWlnaHQ7XG4gICAgY29uc3QgY3VycmVudExhYmVsSGVpZ2h0ID0gIWlzTXVsdGlJdGVtIHx8IGF0TWF4Q2FwYWNpdHkgPyAwIDogbGFiZWxIZWlnaHQ7XG5cbiAgICBjb25zdCBsaXN0TWFyZ2luVG9wID0gYXRNYXhDYXBhY2l0eSA/IGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCA6IDA7XG4gICAgY29uc3QgbGlzdE1hcmdpbkJvdHRvbSA9IHRvdGFsSXRlbXMgPT09IDAgPyAwIDogbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tO1xuXG4gICAgY29uc3QgdmlzdWFsSGVpZ2h0ID0gY3VycmVudExhYmVsSGVpZ2h0ICsgbGlzdE1hcmdpblRvcCArIGxpc3RIZWlnaHQudmlzdWFsICsgbGlzdE1hcmdpbkJvdHRvbTtcbiAgICBjb25zdCBib3VuZHNIZWlnaHQgPSBjdXJyZW50TGFiZWxIZWlnaHQgKyBsaXN0TWFyZ2luVG9wICsgbGlzdEhlaWdodC5ib3VuZHMgKyBsaXN0TWFyZ2luQm90dG9tO1xuXG4gICAgLy8gbGluayBsaXN0IHRvIGxhYmVsIGJvdHRvbSBwb3NpdGlvblxuICAgIGxpc3QudHJhbnNsYXRlWSA9XG4gICAgICAgIE1hdGgubWF4KDAsIGN1cnJlbnRMYWJlbEhlaWdodCAtIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCkgLSBsaXN0SXRlbU1hcmdpbi50b3A7XG5cbiAgICBpZiAoYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgLy8gZml4ZWQgYXNwZWN0IHJhdGlvXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGhlaWdodCBiYXNlZCBvbiB3aWR0aFxuICAgICAgICBjb25zdCB3aWR0aCA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB3aWR0aCAqIGFzcGVjdFJhdGlvO1xuXG4gICAgICAgIC8vIGNsZWFyIGhpc3RvcnkgaWYgYXNwZWN0IHJhdGlvIGhhcyBjaGFuZ2VkXG4gICAgICAgIGlmIChhc3BlY3RSYXRpbyAhPT0gcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgcm9vdC5yZWYucHJldmlvdXNBc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgcm9vdC5yZWYudXBkYXRlSGlzdG9yeSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtZW1iZXIgdGhpcyB3aWR0aFxuICAgICAgICBjb25zdCBoaXN0b3J5ID0gcm9vdC5yZWYudXBkYXRlSGlzdG9yeTtcbiAgICAgICAgaGlzdG9yeS5wdXNoKHdpZHRoKTtcblxuICAgICAgICBjb25zdCBNQVhfQk9VTkNFUyA9IDI7XG4gICAgICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA+IE1BWF9CT1VOQ0VTICogMikge1xuICAgICAgICAgICAgY29uc3QgbCA9IGhpc3RvcnkubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbCAtIDEwO1xuICAgICAgICAgICAgbGV0IGJvdW5jZXMgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGw7IGkgPj0gYm90dG9tOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeVtpXSA9PT0gaGlzdG9yeVtpIC0gMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmNlcysrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChib3VuY2VzID49IE1BWF9CT1VOQ0VTKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbnQgYWRqdXN0IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbCBzbyBpdCBhZGhlcmVzIHRvIGFzcGVjdCByYXRpb1xuICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuICAgICAgICBwYW5lbC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICBjb25zdCBsaXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgIGhlaWdodCAtXG4gICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICBpZiAobGlzdEhlaWdodC52aXN1YWwgPiBsaXN0QXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAoYm91bmRzLmZpeGVkSGVpZ2h0KSB7XG4gICAgICAgIC8vIGZpeGVkIGhlaWdodFxuXG4gICAgICAgIC8vIGZpeCBoZWlnaHQgb2YgcGFuZWxcbiAgICAgICAgcGFuZWwuc2NhbGFibGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgIGNvbnN0IGxpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgYm91bmRzLmZpeGVkSGVpZ2h0IC1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgIC8vIHNldCBsaXN0IGhlaWdodFxuICAgICAgICBpZiAobGlzdEhlaWdodC52aXN1YWwgPiBsaXN0QXZhaWxhYmxlSGVpZ2h0KSB7XG4gICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbGlzdEF2YWlsYWJsZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm8gbmVlZCB0byBzZXQgY29udGFpbmVyIGJvdW5kcyBhcyB0aGVzZSBhcmUgaGFuZGxlcyBieSBDU1MgZml4ZWQgaGVpZ2h0XG4gICAgfSBlbHNlIGlmIChib3VuZHMuY2FwcGVkSGVpZ2h0KSB7XG4gICAgICAgIC8vIG1heC1oZWlnaHRcblxuICAgICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgICAgY29uc3QgaXNDYXBwZWRIZWlnaHQgPSB2aXN1YWxIZWlnaHQgPj0gYm91bmRzLmNhcHBlZEhlaWdodDtcbiAgICAgICAgY29uc3QgcGFuZWxIZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuY2FwcGVkSGVpZ2h0LCB2aXN1YWxIZWlnaHQpO1xuICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICAgIHBhbmVsLmhlaWdodCA9IGlzQ2FwcGVkSGVpZ2h0XG4gICAgICAgICAgICA/IHBhbmVsSGVpZ2h0XG4gICAgICAgICAgICA6IHBhbmVsSGVpZ2h0IC0gbGlzdEl0ZW1NYXJnaW4udG9wIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tO1xuXG4gICAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgICAgY29uc3QgbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICBwYW5lbEhlaWdodCAtXG4gICAgICAgICAgICBjdXJyZW50TGFiZWxIZWlnaHQgLVxuICAgICAgICAgICAgLy8gdGhlIHJvb20gd2UgbGVhdmUgb3BlbiBiZXR3ZWVuIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHRoZSBwYW5lbCBib3R0b21cbiAgICAgICAgICAgIChsaXN0TWFyZ2luQm90dG9tIC0gbGlzdEl0ZW1NYXJnaW4uYm90dG9tKSAtXG4gICAgICAgICAgICAvLyBpZiB3ZSdyZSBmdWxsIHdlIG5lZWQgdG8gbGVhdmUgc29tZSByb29tIGJldHdlZW4gdGhlIHRvcCBvZiB0aGUgcGFuZWwgYW5kIHRoZSBsaXN0XG4gICAgICAgICAgICAoYXRNYXhDYXBhY2l0eSA/IGxpc3RNYXJnaW5Ub3AgOiAwKTtcblxuICAgICAgICAvLyBzZXQgbGlzdCBoZWlnaHQgKGlmIGlzIG92ZXJmbG93aW5nKVxuICAgICAgICBpZiAodmlzdWFsSGVpZ2h0ID4gYm91bmRzLmNhcHBlZEhlaWdodCAmJiBsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGJvdW5kcy5jYXBwZWRIZWlnaHQsXG4gICAgICAgICAgICBib3VuZHNIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b21cbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmbGV4aWJsZSBoZWlnaHRcblxuICAgICAgICAvLyBub3QgYSBmaXhlZCBoZWlnaHQgcGFuZWxcbiAgICAgICAgY29uc3QgaXRlbU1hcmdpbiA9IHRvdGFsSXRlbXMgPiAwID8gbGlzdEl0ZW1NYXJnaW4udG9wICsgbGlzdEl0ZW1NYXJnaW4uYm90dG9tIDogMDtcbiAgICAgICAgcGFuZWwuc2NhbGFibGUgPSB0cnVlO1xuICAgICAgICBwYW5lbC5oZWlnaHQgPSBNYXRoLm1heChsYWJlbEhlaWdodCwgdmlzdWFsSGVpZ2h0IC0gaXRlbU1hcmdpbik7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBib3VuZHMgKHNvIHB1c2hlcyBzaWJsaW5ncyBkb3dud2FyZHMpXG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gTWF0aC5tYXgobGFiZWxIZWlnaHQsIGJvdW5kc0hlaWdodCAtIGl0ZW1NYXJnaW4pO1xuICAgIH1cblxuICAgIC8vIG1vdmUgY3JlZGl0cyB0byBib3R0b21cbiAgICBpZiAocm9vdC5yZWYuY3JlZGl0cyAmJiBwYW5lbC5oZWlnaHRDdXJyZW50KVxuICAgICAgICByb290LnJlZi5jcmVkaXRzLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7cGFuZWwuaGVpZ2h0Q3VycmVudH1weClgO1xufTtcblxuY29uc3QgY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4gPSByb290ID0+IHtcbiAgICBjb25zdCBpdGVtID0gcm9vdC5yZWYubGlzdC5jaGlsZFZpZXdzWzBdLmNoaWxkVmlld3NbMF07XG4gICAgcmV0dXJuIGl0ZW1cbiAgICAgICAgPyB7XG4gICAgICAgICAgICAgIHRvcDogaXRlbS5yZWN0LmVsZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBib3R0b206IGl0ZW0ucmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICB9O1xufTtcblxuY29uc3QgY2FsY3VsYXRlTGlzdEhlaWdodCA9IHJvb3QgPT4ge1xuICAgIGxldCB2aXN1YWwgPSAwO1xuICAgIGxldCBib3VuZHMgPSAwO1xuXG4gICAgLy8gZ2V0IGZpbGUgbGlzdCByZWZlcmVuY2VcbiAgICBjb25zdCBzY3JvbGxMaXN0ID0gcm9vdC5yZWYubGlzdDtcbiAgICBjb25zdCBpdGVtTGlzdCA9IHNjcm9sbExpc3QuY2hpbGRWaWV3c1swXTtcbiAgICBjb25zdCB2aXNpYmxlQ2hpbGRyZW4gPSBpdGVtTGlzdC5jaGlsZFZpZXdzLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0KTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3RcbiAgICAgICAgLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJylcbiAgICAgICAgLm1hcChpdGVtID0+IHZpc2libGVDaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmlkID09PSBpdGVtLmlkKSlcbiAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0pO1xuXG4gICAgLy8gbm8gY2hpbGRyZW4sIGRvbmUhXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgdmlzdWFsLCBib3VuZHMgfTtcblxuICAgIGNvbnN0IGhvcml6b250YWxTcGFjZSA9IGl0ZW1MaXN0LnJlY3QuZWxlbWVudC53aWR0aDtcbiAgICBjb25zdCBkcmFnSW5kZXggPSBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKGl0ZW1MaXN0LCBjaGlsZHJlbiwgc2Nyb2xsTGlzdC5kcmFnQ29vcmRpbmF0ZXMpO1xuXG4gICAgY29uc3QgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuXG4gICAgY29uc3QgaXRlbVZlcnRpY2FsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpblRvcCArIGNoaWxkUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgY29uc3QgaXRlbUhvcml6b250YWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luTGVmdCArIGNoaWxkUmVjdC5tYXJnaW5SaWdodDtcblxuICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGNoaWxkUmVjdC53aWR0aCArIGl0ZW1Ib3Jpem9udGFsTWFyZ2luO1xuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBjaGlsZFJlY3QuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuXG4gICAgY29uc3QgbmV3SXRlbSA9IHR5cGVvZiBkcmFnSW5kZXggIT09ICd1bmRlZmluZWQnICYmIGRyYWdJbmRleCA+PSAwID8gMSA6IDA7XG4gICAgY29uc3QgcmVtb3ZlZEl0ZW0gPSBjaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNDUpXG4gICAgICAgID8gLTFcbiAgICAgICAgOiAwO1xuICAgIGNvbnN0IHZlcnRpY2FsSXRlbUNvdW50ID0gY2hpbGRyZW4ubGVuZ3RoICsgbmV3SXRlbSArIHJlbW92ZWRJdGVtO1xuICAgIGNvbnN0IGl0ZW1zUGVyUm93ID0gZ2V0SXRlbXNQZXJSb3coaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpO1xuXG4gICAgLy8gc3RhY2tcbiAgICBpZiAoaXRlbXNQZXJSb3cgPT09IDEpIHtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGl0ZW0ucmVjdC5lbGVtZW50LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICAgICAgICAgIGJvdW5kcyArPSBoZWlnaHQ7XG4gICAgICAgICAgICB2aXN1YWwgKz0gaGVpZ2h0ICogaXRlbS5vcGFjaXR5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ3JpZFxuICAgIGVsc2Uge1xuICAgICAgICBib3VuZHMgPSBNYXRoLmNlaWwodmVydGljYWxJdGVtQ291bnQgLyBpdGVtc1BlclJvdykgKiBpdGVtSGVpZ2h0O1xuICAgICAgICB2aXN1YWwgPSBib3VuZHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdmlzdWFsLCBib3VuZHMgfTtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodCA9IHJvb3QgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IHJvb3QucmVmLm1lYXN1cmVIZWlnaHQgfHwgbnVsbDtcbiAgICBjb25zdCBjYXBwZWRIZWlnaHQgPSBwYXJzZUludChyb290LnN0eWxlLm1heEhlaWdodCwgMTApIHx8IG51bGw7XG4gICAgY29uc3QgZml4ZWRIZWlnaHQgPSBoZWlnaHQgPT09IDAgPyBudWxsIDogaGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FwcGVkSGVpZ2h0LFxuICAgICAgICBmaXhlZEhlaWdodCxcbiAgICB9O1xufTtcblxuY29uc3QgZXhjZWVkc01heEZpbGVzID0gKHJvb3QsIGl0ZW1zKSA9PiB7XG4gICAgY29uc3QgYWxsb3dSZXBsYWNlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFUExBQ0UnKTtcbiAgICBjb25zdCBhbGxvd011bHRpcGxlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX01VTFRJUExFJyk7XG4gICAgY29uc3QgdG90YWxJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpO1xuICAgIGxldCBtYXhJdGVtcyA9IHJvb3QucXVlcnkoJ0dFVF9NQVhfRklMRVMnKTtcblxuICAgIC8vIHRvdGFsIGFtb3VudCBvZiBpdGVtcyBiZWluZyBkcmFnZ2VkXG4gICAgY29uc3QgdG90YWxCcm93c2VJdGVtcyA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIC8vIGlmIGRvZXMgbm90IGFsbG93IG11bHRpcGxlIGl0ZW1zIGFuZCBkcmFnZ2luZyBtb3JlIHRoYW4gb25lIGl0ZW1cbiAgICBpZiAoIWFsbG93TXVsdGlwbGUgJiYgdG90YWxCcm93c2VJdGVtcyA+IDEpIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgIHNvdXJjZTogaXRlbXMsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBsaW1pdCBtYXggaXRlbXMgdG8gb25lIGlmIG5vdCBhbGxvd2VkIHRvIGRyb3AgbXVsdGlwbGUgaXRlbXNcbiAgICBtYXhJdGVtcyA9IGFsbG93TXVsdGlwbGUgPyBtYXhJdGVtcyA6IDE7XG5cbiAgICBpZiAoIWFsbG93TXVsdGlwbGUgJiYgYWxsb3dSZXBsYWNlKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIGl0ZW0sIHNvIHRoZXJlIGlzIHJvb20gdG8gcmVwbGFjZSBvciBhZGQgYW4gaXRlbVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gbm8gbW9yZSByb29tP1xuICAgIGNvbnN0IGhhc01heEl0ZW1zID0gaXNJbnQobWF4SXRlbXMpO1xuICAgIGlmIChoYXNNYXhJdGVtcyAmJiB0b3RhbEl0ZW1zICsgdG90YWxCcm93c2VJdGVtcyA+IG1heEl0ZW1zKSB7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICBzb3VyY2U6IGl0ZW1zLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgZ2V0RHJhZ0luZGV4ID0gKGxpc3QsIGNoaWxkcmVuLCBwb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IGl0ZW1MaXN0ID0gbGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgIHJldHVybiBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKGl0ZW1MaXN0LCBjaGlsZHJlbiwge1xuICAgICAgICBsZWZ0OiBwb3NpdGlvbi5zY29wZUxlZnQgLSBpdGVtTGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgdG9wOlxuICAgICAgICAgICAgcG9zaXRpb24uc2NvcGVUb3AgLVxuICAgICAgICAgICAgKGxpc3QucmVjdC5vdXRlci50b3AgKyBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKyBsaXN0LnJlY3QuZWxlbWVudC5zY3JvbGxUb3ApLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBmaWxlIGRyb3AgZnVuY3Rpb25hbGl0eVxuICovXG5jb25zdCB0b2dnbGVEcm9wID0gcm9vdCA9PiB7XG4gICAgY29uc3QgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0RST1AnKTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgY29uc3QgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgIGNvbnN0IGhvcHBlciA9IGNyZWF0ZUhvcHBlcihcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudCxcbiAgICAgICAgICAgIGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBxdWljayB2YWxpZGF0aW9uIG9mIGRyb3BwZWQgaXRlbXNcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVEcm9wRmlsZSA9IHJvb3QucXVlcnkoJ0dFVF9CRUZPUkVfRFJPUF9GSUxFJykgfHwgKCgpID0+IHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gYWxsIGl0ZW1zIHNob3VsZCBiZSB2YWxpZGF0ZWQgYnkgYWxsIGZpbHRlcnMgYXMgdmFsaWRcbiAgICAgICAgICAgICAgICBjb25zdCBkcm9wVmFsaWRhdGlvbiA9IHJvb3QucXVlcnkoJ0dFVF9EUk9QX1ZBTElEQVRJT04nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHJvcFZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtcy5ldmVyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJzKCdBTExPV19IT1BQRVJfSVRFTScsIGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcm9vdC5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmV2ZXJ5KHJlc3VsdCA9PiByZXN1bHQgPT09IHRydWUpICYmIGJlZm9yZURyb3BGaWxlKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZpbHRlckl0ZW1zOiBpdGVtcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlnbm9yZWRGaWxlcyA9IHJvb3QucXVlcnkoJ0dFVF9JR05PUkVEX0ZJTEVTJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGaWxlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpZ25vcmVkRmlsZXMuaW5jbHVkZXMoaXRlbS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2F0Y2hlc0Ryb3BzT25QYWdlOiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9QQUdFJyksXG4gICAgICAgICAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50OiByb290LnF1ZXJ5KCdHRVRfRFJPUF9PTl9FTEVNRU5UJyksXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaG9wcGVyLm9ubG9hZCA9IChpdGVtcywgcG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgIC8vIGdldCBpdGVtIGNoaWxkcmVuIGVsZW1lbnRzIGFuZCBzb3J0IGJhc2VkIG9uIGxpc3Qgc29ydFxuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHJvb3QucmVmLmxpc3QuY2hpbGRWaWV3c1swXTtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IGxpc3QuY2hpbGRWaWV3cy5maWx0ZXIoY2hpbGQgPT4gY2hpbGQucmVjdC5lbGVtZW50LmhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3RcbiAgICAgICAgICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAgICAgICAgIC5tYXAoaXRlbSA9PiB2aXNpYmxlQ2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5pZCA9PT0gaXRlbS5pZCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0pO1xuXG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdBRERfSVRFTVMnLCBpdGVtcywgeyBkaXNwYXRjaDogcm9vdC5kaXNwYXRjaCB9KS50aGVuKHF1ZXVlID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGdvXG4gICAgICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBnZXREcmFnSW5kZXgocm9vdC5yZWYubGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2Q6IEludGVyYWN0aW9uTWV0aG9kLkRST1AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RST1AnLCB7IHBvc2l0aW9uIH0pO1xuXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhvcHBlci5vbmRyYWdzdGFydCA9IHBvc2l0aW9uID0+IHtcbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9TVEFSVF9EUkFHJywgeyBwb3NpdGlvbiB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBob3BwZXIub25kcmFnID0gZGVib3VuY2UocG9zaXRpb24gPT4ge1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0RSQUcnLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBob3BwZXIub25kcmFnZW5kID0gcG9zaXRpb24gPT4ge1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0VORF9EUkFHJywgeyBwb3NpdGlvbiB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByb290LnJlZi5ob3BwZXIgPSBob3BwZXI7XG5cbiAgICAgICAgcm9vdC5yZWYuZHJpcCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRyaXApKTtcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICByb290LnJlZi5ob3BwZXIgPSBudWxsO1xuICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5kcmlwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGJyb3dzZSBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IHRvZ2dsZUJyb3dzZSA9IChyb290LCBwcm9wcykgPT4ge1xuICAgIGNvbnN0IGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19CUk9XU0UnKTtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgY29uc3QgZW5hYmxlZCA9IGlzQWxsb3dlZCAmJiAhaXNEaXNhYmxlZDtcbiAgICBpZiAoZW5hYmxlZCAmJiAhcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgICByb290LnJlZi5icm93c2VyID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhicm93c2VyLCB7XG4gICAgICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICAgICAgb25sb2FkOiBpdGVtcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaDogcm9vdC5kaXNwYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihxdWV1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXRlbXMhXG4gICAgICAgICAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQlJPV1NFLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLmJyb3dzZXIpIHtcbiAgICAgICAgcm9vdC5yZW1vdmVDaGlsZFZpZXcocm9vdC5yZWYuYnJvd3Nlcik7XG4gICAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgcGFzdGUgZnVuY3Rpb25hbGl0eVxuICovXG5jb25zdCB0b2dnbGVQYXN0ZSA9IHJvb3QgPT4ge1xuICAgIGNvbnN0IGlzQWxsb3dlZCA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19QQVNURScpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICBjb25zdCBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgcm9vdC5yZWYucGFzdGVyID0gY3JlYXRlUGFzdGVyKCk7XG4gICAgICAgIHJvb3QucmVmLnBhc3Rlci5vbmxvYWQgPSBpdGVtcyA9PiB7XG4gICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdBRERfSVRFTVMnLCBpdGVtcywgeyBkaXNwYXRjaDogcm9vdC5kaXNwYXRjaCB9KS50aGVuKHF1ZXVlID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBmaWxlcyBkb24ndCBmaXQgc28gc3RvcCBoZXJlXG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VlZHNNYXhGaWxlcyhyb290LCBxdWV1ZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuUEFTVEUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFlbmFibGVkICYmIHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICByb290LnJlZi5wYXN0ZXIuZGVzdHJveSgpO1xuICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogUm91dGUgYWN0aW9uc1xuICovXG5jb25zdCByb3V0ZSQ1ID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICAgIHRvZ2dsZUJyb3dzZShyb290LCBwcm9wcyk7XG4gICAgfSxcbiAgICBESURfU0VUX0FMTE9XX0RST1A6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgIH0sXG4gICAgRElEX1NFVF9BTExPV19QQVNURTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgIH0sXG4gICAgRElEX1NFVF9ESVNBQkxFRDogKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgICAgICB0b2dnbGVEcm9wKHJvb3QpO1xuICAgICAgICB0b2dnbGVQYXN0ZShyb290KTtcbiAgICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZGlzYWJsZWQgPSAnZGlzYWJsZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVsZXRlIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRpc2FibGVkOyA8PSB0aGlzIGRvZXMgbm90IHdvcmsgb24gaU9TIDEwXG4gICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5cbmNvbnN0IHJvb3QgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAncm9vdCcsXG4gICAgcmVhZDogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIGlmIChyb290LnJlZi5tZWFzdXJlKSB7XG4gICAgICAgICAgICByb290LnJlZi5tZWFzdXJlSGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlJGUsXG4gICAgd3JpdGU6IHdyaXRlJDksXG4gICAgZGVzdHJveTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIGlmIChyb290LnJlZi5wYXN0ZXIpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLnBhc3Rlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QucmVmLmhvcHBlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYuaG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdnZXN0dXJlc3RhcnQnLCBwcmV2ZW50KTtcbiAgICB9LFxuICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsnaGVpZ2h0J10sXG4gICAgfSxcbn0pO1xuXG4vLyBjcmVhdGVzIHRoZSBhcHBcbmNvbnN0IGNyZWF0ZUFwcCA9IChpbml0aWFsT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgLy8gbGV0IGVsZW1lbnRcbiAgICBsZXQgb3JpZ2luYWxFbGVtZW50ID0gbnVsbDtcblxuICAgIC8vIGdldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IGdldE9wdGlvbnMoKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZGF0YSBzdG9yZSwgdGhpcyB3aWxsIGNvbnRhaW4gYWxsIG91ciBhcHAgaW5mb1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgICAgIC8vIGluaXRpYWwgc3RhdGUgKHNob3VsZCBiZSBzZXJpYWxpemFibGUpXG4gICAgICAgIGNyZWF0ZUluaXRpYWxTdGF0ZShkZWZhdWx0T3B0aW9ucyksXG5cbiAgICAgICAgLy8gcXVlcmllc1xuICAgICAgICBbcXVlcmllcywgY3JlYXRlT3B0aW9uUXVlcmllcyhkZWZhdWx0T3B0aW9ucyldLFxuXG4gICAgICAgIC8vIGFjdGlvbiBoYW5kbGVyc1xuICAgICAgICBbYWN0aW9ucywgY3JlYXRlT3B0aW9uQWN0aW9ucyhkZWZhdWx0T3B0aW9ucyldXG4gICAgKTtcblxuICAgIC8vIHNldCBpbml0aWFsIG9wdGlvbnNcbiAgICBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnM6IGluaXRpYWxPcHRpb25zIH0pO1xuXG4gICAgLy8ga2ljayB0aHJlYWQgaWYgdmlzaWJpbGl0eSBjaGFuZ2VzXG4gICAgY29uc3QgdmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHJldHVybjtcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0tJQ0snKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5SGFuZGxlcik7XG5cbiAgICAvLyByZS1yZW5kZXIgb24gd2luZG93IHJlc2l6ZSBzdGFydCBhbmQgZmluaXNoXG4gICAgbGV0IHJlc2l6ZURvbmVUaW1lciA9IG51bGw7XG4gICAgbGV0IGlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICBsZXQgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgIGxldCBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgIGxldCBjdXJyZW50V2luZG93V2lkdGggPSBudWxsO1xuICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghaXNSZXNpemluZykge1xuICAgICAgICAgICAgaXNSZXNpemluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZURvbmVUaW1lcik7XG4gICAgICAgIHJlc2l6ZURvbmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaW5pdGlhbFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNSZXNpemluZ0hvcml6b250YWxseSkge1xuICAgICAgICAgICAgICAgIGlzUmVzaXppbmdIb3Jpem9udGFsbHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUT1BfUkVTSVpFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAvLyByZW5kZXIgaW5pdGlhbCB2aWV3XG4gICAgY29uc3QgdmlldyA9IHJvb3Qoc3RvcmUsIHsgaWQ6IGdldFVuaXF1ZUlkKCkgfSk7XG5cbiAgICAvL1xuICAgIC8vIFBSSVZBVEUgQVBJIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIGxldCBpc1Jlc3RpbmcgPSBmYWxzZTtcbiAgICBsZXQgaXNIaWRkZW4gPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlYWRXcml0ZUFwaSA9IHtcbiAgICAgICAgLy8gbmVjZXNzYXJ5IGZvciB1cGRhdGUgbG9vcFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkcyBmcm9tIGRvbSAobmV2ZXIgY2FsbCBtYW51YWxseSlcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9yZWFkOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyB0ZXN0IGlmIHdlJ3JlIHJlc2l6aW5nIGhvcml6b250YWxseVxuICAgICAgICAgICAgLy8gVE9ETzogc2VlIGlmIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IG1lYXN1cmluZyByb290IHJlY3RcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKCFpbml0aWFsV2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFdpbmRvd1dpZHRoID0gY3VycmVudFdpbmRvd1dpZHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaXNSZXNpemluZ0hvcml6b250YWxseSAmJiBjdXJyZW50V2luZG93V2lkdGggIT09IGluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX1NUQVJUX1JFU0laRScpO1xuICAgICAgICAgICAgICAgICAgICBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbiAmJiBpc1Jlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIGlzIG5vIGxvbmdlciBoaWRkZW5cbiAgICAgICAgICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3LmVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiByZXN0aW5nLCBubyBuZWVkIHRvIHJlYWQgYXMgbnVtYmVycyB3aWxsIHN0aWxsIGFsbCBiZSBjb3JyZWN0XG4gICAgICAgICAgICBpZiAoaXNSZXN0aW5nKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHJlYWQgdmlldyBkYXRhXG4gICAgICAgICAgICB2aWV3Ll9yZWFkKCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGlzIGhpZGRlbiB3ZSBuZWVkIHRvIGtub3cgc28gd2UgZXhpdCByZXN0IG1vZGUgd2hlbiByZXZlYWxlZFxuICAgICAgICAgICAgaXNIaWRkZW4gPSB2aWV3LnJlY3QuZWxlbWVudC5oaWRkZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlcyB0byBkb20gKG5ldmVyIGNhbGwgbWFudWFsbHkpXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfd3JpdGU6IHRzID0+IHtcbiAgICAgICAgICAgIC8vIGdldCBhbGwgYWN0aW9ucyBmcm9tIHN0b3JlXG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gc3RvcmVcbiAgICAgICAgICAgICAgICAucHJvY2Vzc0FjdGlvblF1ZXVlKClcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgc2V0IGFjdGlvbnMgKHRoZXNlIHdpbGwgYXV0b21hdGljYWxseSB0cmlnZ2VyIERJRF9TRVQpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gIS9eU0VUXy8udGVzdChhY3Rpb24udHlwZSkpO1xuXG4gICAgICAgICAgICAvLyBpZiB3YXMgaWRsaW5nIGFuZCBubyBhY3Rpb25zIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKGlzUmVzdGluZyAmJiAhYWN0aW9ucy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gc29tZSBhY3Rpb25zIG1pZ2h0IHRyaWdnZXIgZXZlbnRzXG4gICAgICAgICAgICByb3V0ZUFjdGlvbnNUb0V2ZW50cyhhY3Rpb25zKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSB2aWV3XG4gICAgICAgICAgICBpc1Jlc3RpbmcgPSB2aWV3Ll93cml0ZSh0cywgYWN0aW9ucywgaXNSZXNpemluZ0hvcml6b250YWxseSk7XG5cbiAgICAgICAgICAgIC8vIHdpbGwgY2xlYW4gdXAgYWxsIGFyY2hpdmVkIGl0ZW1zXG4gICAgICAgICAgICByZW1vdmVSZWxlYXNlZEl0ZW1zKHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTVMnKSk7XG5cbiAgICAgICAgICAgIC8vIG5vdyBpZGxpbmdcbiAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5wcm9jZXNzRGlzcGF0Y2hRdWV1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIEVYUE9TRSBFVkVOVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgY29uc3QgY3JlYXRlRXZlbnQgPSBuYW1lID0+IGRhdGEgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgZGVmYXVsdCBldmVudFxuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbm8gZGF0YSB0byBhZGRcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IHJlbGV2YW50IHByb3BzXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdlcnJvcicpKSB7XG4gICAgICAgICAgICBldmVudC5lcnJvciA9IGRhdGEuZXJyb3IgPyB7IC4uLmRhdGEuZXJyb3IgfSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0YXR1cyA9IHsgLi4uZGF0YS5zdGF0dXMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgICAgICAgIGV2ZW50Lm91dHB1dCA9IGRhdGEuZmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgc291cmNlIGlzIGF2YWlsYWJsZSwgZWxzZSBhZGQgaXRlbSBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAoZGF0YS5zb3VyY2UpIHtcbiAgICAgICAgICAgIGV2ZW50LmZpbGUgPSBkYXRhLnNvdXJjZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLml0ZW0gfHwgZGF0YS5pZCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGEuaXRlbSA/IGRhdGEuaXRlbSA6IHN0b3JlLnF1ZXJ5KCdHRVRfSVRFTScsIGRhdGEuaWQpO1xuICAgICAgICAgICAgZXZlbnQuZmlsZSA9IGl0ZW0gPyBjcmVhdGVJdGVtQVBJKGl0ZW0pIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hcCBhbGwgaXRlbXMgaW4gYSBwb3NzaWJsZSBpdGVtcyBhcnJheVxuICAgICAgICBpZiAoZGF0YS5pdGVtcykge1xuICAgICAgICAgICAgZXZlbnQuaXRlbXMgPSBkYXRhLml0ZW1zLm1hcChjcmVhdGVJdGVtQVBJKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBwcm9ncmVzcyBldmVudCBhZGQgdGhlIHByb2dyZXNzIGFtb3VudFxuICAgICAgICBpZiAoL3Byb2dyZXNzLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBldmVudC5wcm9ncmVzcyA9IGRhdGEucHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb3B5IHJlbGV2YW50IHByb3BzXG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdvcmlnaW4nKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCd0YXJnZXQnKSkge1xuICAgICAgICAgICAgZXZlbnQub3JpZ2luID0gZGF0YS5vcmlnaW47XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSBkYXRhLnRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgY29uc3QgZXZlbnRSb3V0ZXMgPSB7XG4gICAgICAgIERJRF9ERVNUUk9ZOiBjcmVhdGVFdmVudCgnZGVzdHJveScpLFxuXG4gICAgICAgIERJRF9JTklUOiBjcmVhdGVFdmVudCgnaW5pdCcpLFxuXG4gICAgICAgIERJRF9USFJPV19NQVhfRklMRVM6IGNyZWF0ZUV2ZW50KCd3YXJuaW5nJyksXG5cbiAgICAgICAgRElEX0lOSVRfSVRFTTogY3JlYXRlRXZlbnQoJ2luaXRmaWxlJyksXG4gICAgICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlc3RhcnQnKSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6IGNyZWF0ZUV2ZW50KCdhZGRmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgRElEX0xPQURfSVRFTTogY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdhZGRmaWxlJyldLFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJyldLFxuXG4gICAgICAgIERJRF9QUkVQQVJFX09VVFBVVDogY3JlYXRlRXZlbnQoJ3ByZXBhcmVmaWxlJyksXG5cbiAgICAgICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlc3RhcnQnKSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZXByb2dyZXNzJyksXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZWFib3J0JyksXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpLFxuICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTDogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcycpLFxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcmV2ZXJ0JyksXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGUnKV0sXG5cbiAgICAgICAgRElEX1JFTU9WRV9JVEVNOiBjcmVhdGVFdmVudCgncmVtb3ZlZmlsZScpLFxuXG4gICAgICAgIERJRF9VUERBVEVfSVRFTVM6IGNyZWF0ZUV2ZW50KCd1cGRhdGVmaWxlcycpLFxuXG4gICAgICAgIERJRF9BQ1RJVkFURV9JVEVNOiBjcmVhdGVFdmVudCgnYWN0aXZhdGVmaWxlJyksXG5cbiAgICAgICAgRElEX1JFT1JERVJfSVRFTVM6IGNyZWF0ZUV2ZW50KCdyZW9yZGVyZmlsZXMnKSxcbiAgICB9O1xuXG4gICAgY29uc3QgZXhwb3NlRXZlbnQgPSBldmVudCA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBldmVudCBvYmplY3QgdG8gYmUgZGlzcGF0Y2hlZFxuICAgICAgICBjb25zdCBkZXRhaWwgPSB7IHBvbmQ6IGV4cG9ydHMsIC4uLmV2ZW50IH07XG4gICAgICAgIGRlbGV0ZSBkZXRhaWwudHlwZTtcbiAgICAgICAgdmlldy5lbGVtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoYEZpbGVQb25kOiR7ZXZlbnQudHlwZX1gLCB7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgaW5mb1xuICAgICAgICAgICAgICAgIGRldGFpbCxcblxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGJlaGF2aW91clxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSwgLy8gdHJpZ2dlcnMgbGlzdGVuZXJzIG91dHNpZGUgb2Ygc2hhZG93IHJvb3RcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZXZlbnQgb2JqZWN0IHRvIHBhcmFtcyB1c2VkIGZvciBgb24oKWAgZXZlbnQgaGFuZGxlcnMgYW5kIGNhbGxiYWNrcyBgb25pbml0KClgXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuXG4gICAgICAgIC8vIGlmIGlzIHBvc3NpYmxlIGVycm9yIGV2ZW50LCBtYWtlIGl0IHRoZSBmaXJzdCBwYXJhbVxuICAgICAgICBpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ2Vycm9yJykpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGUgaXMgYWx3YXlzIHNlY3Rpb25cbiAgICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCdmaWxlJykpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGV2ZW50LmZpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwZW5kIG90aGVyIHByb3BzXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWyd0eXBlJywgJ2Vycm9yJywgJ2ZpbGUnXTtcbiAgICAgICAgT2JqZWN0LmtleXMoZXZlbnQpXG4gICAgICAgICAgICAuZmlsdGVyKGtleSA9PiAhZmlsdGVyZWQuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiBwYXJhbXMucHVzaChldmVudFtrZXldKSk7XG5cbiAgICAgICAgLy8gb24odHlwZSwgKCkgPT4geyB9KVxuICAgICAgICBleHBvcnRzLmZpcmUoZXZlbnQudHlwZSwgLi4ucGFyYW1zKTtcblxuICAgICAgICAvLyBvbmluaXQgPSAoKSA9PiB7fVxuICAgICAgICBjb25zdCBoYW5kbGVyID0gc3RvcmUucXVlcnkoYEdFVF9PTiR7ZXZlbnQudHlwZS50b1VwcGVyQ2FzZSgpfWApO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgaGFuZGxlciguLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJvdXRlQWN0aW9uc1RvRXZlbnRzID0gYWN0aW9ucyA9PiB7XG4gICAgICAgIGlmICghYWN0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gZXZlbnRSb3V0ZXNbYWN0aW9uLnR5cGVdKVxuICAgICAgICAgICAgLmZvckVhY2goYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXMgPSBldmVudFJvdXRlc1thY3Rpb24udHlwZV07XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkocm91dGVzKSA/IHJvdXRlcyA6IFtyb3V0ZXNdKS5mb3JFYWNoKHJvdXRlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpc24ndCBmYW50YXN0aWMsIGJ1dCBiZWNhdXNlIG9mIHRoZSBzdGFja2luZyBvZiBzZXR0aW1lb3V0cyBwbHVnaW5zIGNhbiBoYW5kbGUgdGhlIGRpZF9sb2FkIGJlZm9yZSB0aGUgZGlkX2luaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbi50eXBlID09PSAnRElEX0lOSVRfSVRFTScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZUV2ZW50KHJvdXRlKGFjdGlvbi5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VFdmVudChyb3V0ZShhY3Rpb24uZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL1xuICAgIC8vIFBVQkxJQyBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgY29uc3Qgc2V0T3B0aW9ucyA9IG9wdGlvbnMgPT4gc3RvcmUuZGlzcGF0Y2goJ1NFVF9PUFRJT05TJywgeyBvcHRpb25zIH0pO1xuXG4gICAgY29uc3QgZ2V0RmlsZSA9IHF1ZXJ5ID0+IHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU0nLCBxdWVyeSk7XG5cbiAgICBjb25zdCBwcmVwYXJlRmlsZSA9IHF1ZXJ5ID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJFUEFSRScsIHtcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgYWRkRmlsZSA9IChzb3VyY2UsIG9wdGlvbnMgPSB7fSkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYWRkRmlsZXMoW3sgc291cmNlLCBvcHRpb25zIH1dLCB7IGluZGV4OiBvcHRpb25zLmluZGV4IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oaXRlbXMgPT4gcmVzb2x2ZShpdGVtcyAmJiBpdGVtc1swXSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgaXNGaWxlUG9uZEZpbGUgPSBvYmogPT4gb2JqLmZpbGUgJiYgb2JqLmlkO1xuXG4gICAgY29uc3QgcmVtb3ZlRmlsZSA9IChxdWVyeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBpZiBvbmx5IHBhc3NlZCBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnICYmICFpc0ZpbGVQb25kRmlsZShxdWVyeSkgJiYgIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyeTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVxdWVzdCBpdGVtIHJlbW92YWxcbiAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyAuLi5vcHRpb25zLCBxdWVyeSB9KTtcblxuICAgICAgICAvLyBzZWUgaWYgaXRlbSBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgIHJldHVybiBzdG9yZS5xdWVyeSgnR0VUX0FDVElWRV9JVEVNJywgcXVlcnkpID09PSBudWxsO1xuICAgIH07XG5cbiAgICBjb25zdCBhZGRGaWxlcyA9ICguLi5hcmdzKSA9PlxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG5cbiAgICAgICAgICAgIC8vIHVzZXIgcGFzc2VkIGEgc291cmNlcyBhcnJheVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzLnB1c2guYXBwbHkoc291cmNlcywgYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzWzFdIHx8IHt9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlciBwYXNzZWQgc291cmNlcyBhcyBhcmd1bWVudHMsIGxhc3Qgb25lIG1pZ2h0IGJlIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEFyZ3VtZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdEFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJiAhKGxhc3RBcmd1bWVudCBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgYXJncy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWRkIHJlc3QgdG8gc291cmNlc1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaCguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICBpdGVtczogc291cmNlcyxcbiAgICAgICAgICAgICAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuQVBJLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVqZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0RmlsZXMgPSAoKSA9PiBzdG9yZS5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpO1xuXG4gICAgY29uc3QgcHJvY2Vzc0ZpbGUgPSBxdWVyeSA9PlxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7XG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgc3VjY2VzczogaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaXRlbSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIGNvbnN0IHByZXBhcmVGaWxlcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gcXVlcmllcy5sZW5ndGggPyBxdWVyaWVzIDogZ2V0RmlsZXMoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChwcmVwYXJlRmlsZSkpO1xuICAgIH07XG5cbiAgICBjb25zdCBwcm9jZXNzRmlsZXMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuICAgICAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IGdldEZpbGVzKCkuZmlsdGVyKFxuICAgICAgICAgICAgICAgIGl0ZW0gPT5cbiAgICAgICAgICAgICAgICAgICAgIShpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5JRExFICYmIGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzICE9PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZXMubWFwKHByb2Nlc3NGaWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHF1ZXJpZXMubWFwKHByb2Nlc3NGaWxlKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbW92ZUZpbGVzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcblxuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzW3F1ZXJpZXMubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcXVlcmllcy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbGVzID0gZ2V0RmlsZXMoKTtcblxuICAgICAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoKSByZXR1cm4gUHJvbWlzZS5hbGwoZmlsZXMubWFwKGZpbGUgPT4gcmVtb3ZlRmlsZShmaWxlLCBvcHRpb25zKSkpO1xuXG4gICAgICAgIC8vIHdoZW4gcmVtb3ZpbmcgYnkgaW5kZXggdGhlIGluZGV4ZXMgc2hpZnQgYWZ0ZXIgZWFjaCBmaWxlIHJlbW92YWwgc28gd2UgbmVlZCB0byBjb252ZXJ0IGluZGV4ZXMgdG8gaWRzXG4gICAgICAgIGNvbnN0IG1hcHBlZFF1ZXJpZXMgPSBxdWVyaWVzXG4gICAgICAgICAgICAubWFwKHF1ZXJ5ID0+IChpc051bWJlcihxdWVyeSkgPyAoZmlsZXNbcXVlcnldID8gZmlsZXNbcXVlcnldLmlkIDogbnVsbCkgOiBxdWVyeSkpXG4gICAgICAgICAgICAuZmlsdGVyKHF1ZXJ5ID0+IHF1ZXJ5KTtcblxuICAgICAgICByZXR1cm4gbWFwcGVkUXVlcmllcy5tYXAocSA9PiByZW1vdmVGaWxlKHEsIG9wdGlvbnMpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXhwb3J0cyA9IHtcbiAgICAgICAgLy8gc3VwcG9ydHMgZXZlbnRzXG4gICAgICAgIC4uLm9uKCksXG5cbiAgICAgICAgLy8gaW5qZWN0IHByaXZhdGUgYXBpIG1ldGhvZHNcbiAgICAgICAgLi4ucmVhZFdyaXRlQXBpLFxuXG4gICAgICAgIC8vIGluamVjdCBhbGwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICAuLi5jcmVhdGVPcHRpb25BUEkoc3RvcmUsIGRlZmF1bHRPcHRpb25zKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGUgb3B0aW9ucyBkZWZpbmVkIGluIG9wdGlvbnMgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBzZXRPcHRpb25zLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIHRoZSBnaXZlbiBmaWxlXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2UgLSB0aGUgc291cmNlIG9mIHRoZSBmaWxlIChlaXRoZXIgYSBGaWxlLCBiYXNlNjQgZGF0YSB1cmkgb3IgdXJsKVxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIG9iamVjdCwgeyBpbmRleDogMCB9XG4gICAgICAgICAqL1xuICAgICAgICBhZGRGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIHRoZSBnaXZlbiBmaWxlc1xuICAgICAgICAgKiBAcGFyYW0gc291cmNlcyAtIHRoZSBzb3VyY2VzIG9mIHRoZSBmaWxlcyB0byBsb2FkXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBmaWxlIG9iamVjdHMgbWF0Y2hpbmcgdGhlIGdpdmVuIHF1ZXJ5XG4gICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsIH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwbG9hZCBmaWxlIHdpdGggZ2l2ZW4gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0ZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcXVlc3QgcHJlcGFyZSBvdXRwdXQgZm9yIGZpbGUgd2l0aCBnaXZlbiBuYW1lXG4gICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAqL1xuICAgICAgICBwcmVwYXJlRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGZpbGUgYnkgaXRzIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdmVzIGEgZmlsZSB0byBhIG5ldyBsb2NhdGlvbiBpbiB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgbW92ZUZpbGU6IChxdWVyeSwgaW5kZXgpID0+IHN0b3JlLmRpc3BhdGNoKCdNT1ZFX0lURU0nLCB7IHF1ZXJ5LCBpbmRleCB9KSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbGwgZmlsZXMgKHdyYXBwZWQgaW4gcHVibGljIGFwaSlcbiAgICAgICAgICovXG4gICAgICAgIGdldEZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgdXBsb2FkaW5nIGFsbCBmaWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0ZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhcnMgYWxsIGZpbGVzIGZyb20gdGhlIGZpbGVzIGxpc3RcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydHMgcHJlcGFyaW5nIG91dHB1dCBvZiBhbGwgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVGaWxlcyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29ydCBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqL1xuICAgICAgICBzb3J0OiBjb21wYXJlID0+IHN0b3JlLmRpc3BhdGNoKCdTT1JUJywgeyBjb21wYXJlIH0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm93c2UgdGhlIGZpbGUgc3lzdGVtIGZvciBhIGZpbGVcbiAgICAgICAgICovXG4gICAgICAgIGJyb3dzZTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gbmVlZHMgdG8gYmUgdHJpZ2dlciBkaXJlY3RseSBhcyB1c2VyIGFjdGlvbiBuZWVkcyB0byBiZSB0cmFjZWFibGUgKGlzIG5vdCB0cmFjZWFibGUgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgICAgICAgICAgdmFyIGlucHV0ID0gdmlldy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3lzIHRoZSBhcHBcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgZGVzdHJ1Y3Rpb25cbiAgICAgICAgICAgIGV4cG9ydHMuZmlyZSgnZGVzdHJveScsIHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgYWN0aXZlIHByb2Nlc3NlcyAoZmlsZSB1cGxvYWRzLCBmZXRjaGVzLCBzdHVmZiBsaWtlIHRoYXQpXG4gICAgICAgICAgICAvLyBsb29wIG92ZXIgaXRlbXMgYW5kIGRlcGVuZGluZyBvbiBzdGF0ZXMgY2FsbCBhYm9ydCBmb3Igb25nb2luZyBwcm9jZXNzZXNcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdBQk9SVF9BTEwnKTtcblxuICAgICAgICAgICAgLy8gZGVzdHJveSB2aWV3XG4gICAgICAgICAgICB2aWV3Ll9kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHJlc2l6ZVxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAvLyBzdG9wIGxpc3RlbmluZyB0byB0aGUgdmlzaWJsaXR5Y2hhbmdlIGV2ZW50XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdmlzaWJpbGl0eUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAvLyBkaXNwYXRjaCBkZXN0cm95XG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0RFU1RST1knKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGJlZm9yZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEJlZm9yZTogZWxlbWVudCA9PiBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0cyB0aGUgcGx1Z2luIGFmdGVyIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IGVsZW1lbnQgPT4gaW5zZXJ0QWZ0ZXIodmlldy5lbGVtZW50LCBlbGVtZW50KSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kcyB0aGUgcGx1Z2luIHRvIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kVG86IGVsZW1lbnQgPT4gZWxlbWVudC5hcHBlbmRDaGlsZCh2aWV3LmVsZW1lbnQpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlcyBhbiBlbGVtZW50IHdpdGggdGhlIGFwcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVwbGFjZUVsZW1lbnQ6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBhcHAgYmVmb3JlIHRoZSBlbGVtZW50XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUodmlldy5lbGVtZW50LCBlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmVzIHRoZSBvcmlnaW5hbCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICByZXN0b3JlRWxlbWVudDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFvcmlnaW5hbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG5vIGVsZW1lbnQgdG8gcmVzdG9yZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgIGluc2VydEFmdGVyKG9yaWdpbmFsRWxlbWVudCwgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIG91ciBlbGVtZW50XG4gICAgICAgICAgICB2aWV3LmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlXG4gICAgICAgICAgICBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGFwcCByb290IGlzIGF0dGFjaGVkIHRvIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGlzQXR0YWNoZWRUbzogZWxlbWVudCA9PiB2aWV3LmVsZW1lbnQgPT09IGVsZW1lbnQgfHwgb3JpZ2luYWxFbGVtZW50ID09PSBlbGVtZW50LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByb290IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gdmlldy5lbGVtZW50LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBvbmQgc3RhdHVzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gc3RvcmUucXVlcnkoJ0dFVF9TVEFUVVMnKSxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gRG9uZSFcbiAgICBzdG9yZS5kaXNwYXRjaCgnRElEX0lOSVQnKTtcblxuICAgIC8vIGNyZWF0ZSBhY3R1YWwgYXBpIG9iamVjdFxuICAgIHJldHVybiBjcmVhdGVPYmplY3QoZXhwb3J0cyk7XG59O1xuXG5jb25zdCBjcmVhdGVBcHBPYmplY3QgPSAoY3VzdG9tT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbiAgICBmb3JpbihnZXRPcHRpb25zKCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV0gPSB2YWx1ZVswXTtcbiAgICB9KTtcblxuICAgIC8vIHNldCBhcHAgb3B0aW9uc1xuICAgIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcCh7XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcblxuICAgICAgICAvLyBjdXN0b20gb3B0aW9uc1xuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgIH0pO1xuXG4gICAgLy8gcmV0dXJuIHRoZSBwbHVnaW4gaW5zdGFuY2VcbiAgICByZXR1cm4gYXBwO1xufTtcblxuY29uc3QgbG93ZXJDYXNlRmlyc3RMZXR0ZXIgPSBzdHJpbmcgPT4gc3RyaW5nLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuXG5jb25zdCBhdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUgPSBhdHRyaWJ1dGVOYW1lID0+IHRvQ2FtZWxzKGF0dHJpYnV0ZU5hbWUucmVwbGFjZSgvXmRhdGEtLywgJycpKTtcblxuY29uc3QgbWFwT2JqZWN0ID0gKG9iamVjdCwgcHJvcGVydHlNYXApID0+IHtcbiAgICAvLyByZW1vdmUgdW53YW50ZWRcbiAgICBmb3Jpbihwcm9wZXJ0eU1hcCwgKHNlbGVjdG9yLCBtYXBwaW5nKSA9PiB7XG4gICAgICAgIGZvcmluKG9iamVjdCwgKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHJlZ2V4cCBzaG9ydGN1dFxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3JSZWdFeHAgPSBuZXcgUmVnRXhwKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgLy8gdGVzdHMgaWZcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzZWxlY3RvclJlZ0V4cC50ZXN0KHByb3BlcnR5KTtcblxuICAgICAgICAgICAgLy8gbm8gbWF0Y2gsIHNraXBcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIG1hcHBpbmcsIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBpcyBhbHdheXMgcmVtb3ZlZFxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IHJlbW92ZSwgd2UgZG9uZSFcbiAgICAgICAgICAgIGlmIChtYXBwaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92ZSB2YWx1ZSB0byBuZXcgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdFttYXBwaW5nXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92ZSB0byBncm91cFxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBtYXBwaW5nLmdyb3VwO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1hcHBpbmcpICYmICFvYmplY3RbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2dyb3VwXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmplY3RbZ3JvdXBdW2xvd2VyQ2FzZUZpcnN0TGV0dGVyKHByb3BlcnR5LnJlcGxhY2Uoc2VsZWN0b3JSZWdFeHAsICcnKSldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGRvIHN1Ym1hcHBpbmdcbiAgICAgICAgaWYgKG1hcHBpbmcubWFwcGluZykge1xuICAgICAgICAgICAgbWFwT2JqZWN0KG9iamVjdFttYXBwaW5nLmdyb3VwXSwgbWFwcGluZy5tYXBwaW5nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgZ2V0QXR0cmlidXRlc0FzT2JqZWN0ID0gKG5vZGUsIGF0dHJpYnV0ZU1hcHBpbmcgPSB7fSkgPT4ge1xuICAgIC8vIHR1cm4gYXR0cmlidXRlcyBpbnRvIG9iamVjdFxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICBmb3Jpbihub2RlLmF0dHJpYnV0ZXMsIGluZGV4ID0+IHtcbiAgICAgICAgYXR0cmlidXRlcy5wdXNoKG5vZGUuYXR0cmlidXRlc1tpbmRleF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gYXR0cmlidXRlc1xuICAgICAgICAuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUubmFtZSlcbiAgICAgICAgLnJlZHVjZSgob2JqLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cihub2RlLCBhdHRyaWJ1dGUubmFtZSk7XG5cbiAgICAgICAgICAgIG9ialthdHRyaWJ1dGVOYW1lVG9Qcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpXSA9XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IGF0dHJpYnV0ZS5uYW1lID8gdHJ1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSwge30pO1xuXG4gICAgLy8gZG8gbWFwcGluZyBvZiBvYmplY3QgcHJvcGVydGllc1xuICAgIG1hcE9iamVjdChvdXRwdXQsIGF0dHJpYnV0ZU1hcHBpbmcpO1xuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmNvbnN0IGNyZWF0ZUFwcEF0RWxlbWVudCA9IChlbGVtZW50LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBob3cgYXR0cmlidXRlcyBvZiB0aGUgaW5wdXQgZWxlbWVudCBhcmUgbWFwcGVkIHRvIHRoZSBvcHRpb25zIGZvciB0aGUgcGx1Z2luXG4gICAgY29uc3QgYXR0cmlidXRlTWFwcGluZyA9IHtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRvIG90aGVyIG5hbWVcbiAgICAgICAgJ15jbGFzcyQnOiAnY2xhc3NOYW1lJyxcbiAgICAgICAgJ15tdWx0aXBsZSQnOiAnYWxsb3dNdWx0aXBsZScsXG4gICAgICAgICdeY2FwdHVyZSQnOiAnY2FwdHVyZU1ldGhvZCcsXG4gICAgICAgICded2Via2l0ZGlyZWN0b3J5JCc6ICdhbGxvd0RpcmVjdG9yaWVzT25seScsXG5cbiAgICAgICAgLy8gZ3JvdXAgdW5kZXIgc2luZ2xlIHByb3BlcnR5XG4gICAgICAgICdec2VydmVyJzoge1xuICAgICAgICAgICAgZ3JvdXA6ICdzZXJ2ZXInLFxuICAgICAgICAgICAgbWFwcGluZzoge1xuICAgICAgICAgICAgICAgICdecHJvY2Vzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdwcm9jZXNzJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdecmV2ZXJ0Jzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ3JldmVydCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnXmZldGNoJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ2ZldGNoJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdecmVzdG9yZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdyZXN0b3JlJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdebG9hZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBkb24ndCBpbmNsdWRlIGluIG9iamVjdFxuICAgICAgICAnXnR5cGUkJzogZmFsc2UsXG4gICAgICAgICdeZmlsZXMkJzogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIGFkZCBhZGRpdGlvbmFsIG9wdGlvbiB0cmFuc2xhdG9yc1xuICAgIGFwcGx5RmlsdGVycygnU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICAvLyBjcmVhdGUgZmluYWwgb3B0aW9ucyBvYmplY3QgYnkgc2V0dGluZyBvcHRpb25zIG9iamVjdCBhbmQgdGhlbiBvdmVycmlkaW5nIG9wdGlvbnMgc3VwcGxpZWQgb24gZWxlbWVudFxuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZU9wdGlvbnMgPSBnZXRBdHRyaWJ1dGVzQXNPYmplY3QoXG4gICAgICAgIGVsZW1lbnQubm9kZU5hbWUgPT09ICdGSUVMRFNFVCcgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9ZmlsZV0nKSA6IGVsZW1lbnQsXG4gICAgICAgIGF0dHJpYnV0ZU1hcHBpbmdcbiAgICApO1xuXG4gICAgLy8gbWVyZ2Ugd2l0aCBvcHRpb25zIG9iamVjdFxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZU9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KGF0dHJpYnV0ZU9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICAgIGlmICghaXNPYmplY3QobWVyZ2VkT3B0aW9uc1trZXldKSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtZXJnZWRPcHRpb25zW2tleV0sIGF0dHJpYnV0ZU9wdGlvbnNba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXJnZWRPcHRpb25zW2tleV0gPSBhdHRyaWJ1dGVPcHRpb25zW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHBhcmVudCBpcyBhIGZpZWxkc2V0LCBnZXQgZmlsZXMgZnJvbSBwYXJlbnQgYnkgc2VsZWN0aW5nIGFsbCBpbnB1dCBmaWVsZHMgdGhhdCBhcmUgbm90IGZpbGUgdXBsb2FkIGZpZWxkc1xuICAgIC8vIHRoZXNlIHdpbGwgdGhlbiBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUgaW5pdGlhbCBmaWxlc1xuICAgIG1lcmdlZE9wdGlvbnMuZmlsZXMgPSAob3B0aW9ucy5maWxlcyB8fCBbXSkuY29uY2F0KFxuICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6bm90KFt0eXBlPWZpbGVdKScpKS5tYXAoaW5wdXQgPT4gKHtcbiAgICAgICAgICAgIHNvdXJjZTogaW5wdXQudmFsdWUsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogaW5wdXQuZGF0YXNldC50eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpXG4gICAgKTtcblxuICAgIC8vIGJ1aWxkIHBsdWdpblxuICAgIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcE9iamVjdChtZXJnZWRPcHRpb25zKTtcblxuICAgIC8vIGFkZCBhbHJlYWR5IHNlbGVjdGVkIGZpbGVzXG4gICAgaWYgKGVsZW1lbnQuZmlsZXMpIHtcbiAgICAgICAgQXJyYXkuZnJvbShlbGVtZW50LmZpbGVzKS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgICAgYXBwLmFkZEZpbGUoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgYXBwLnJlcGxhY2VFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgLy8gZXhwb3NlXG4gICAgcmV0dXJuIGFwcDtcbn07XG5cbi8vIGlmIGFuIGVsZW1lbnQgaXMgcGFzc2VkLCB3ZSBjcmVhdGUgdGhlIGluc3RhbmNlIGF0IHRoYXQgZWxlbWVudCwgaWYgbm90LCB3ZSBqdXN0IGNyZWF0ZSBhbiB1cCBvYmplY3RcbmNvbnN0IGNyZWF0ZUFwcCQxID0gKC4uLmFyZ3MpID0+XG4gICAgaXNOb2RlKGFyZ3NbMF0pID8gY3JlYXRlQXBwQXRFbGVtZW50KC4uLmFyZ3MpIDogY3JlYXRlQXBwT2JqZWN0KC4uLmFyZ3MpO1xuXG5jb25zdCBQUklWQVRFX01FVEhPRFMgPSBbJ2ZpcmUnLCAnX3JlYWQnLCAnX3dyaXRlJ107XG5cbmNvbnN0IGNyZWF0ZUFwcEFQSSA9IGFwcCA9PiB7XG4gICAgY29uc3QgYXBpID0ge307XG5cbiAgICBjb3B5T2JqZWN0UHJvcGVydGllc1RvT2JqZWN0KGFwcCwgYXBpLCBQUklWQVRFX01FVEhPRFMpO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbi8qKlxuICogUmVwbGFjZXMgcGxhY2Vob2xkZXJzIGluIGdpdmVuIHN0cmluZyB3aXRoIHJlcGxhY2VtZW50c1xuICogQHBhcmFtIHN0cmluZyAtIFwiRm9vIHtiYXJ9XCJcIlxuICogQHBhcmFtIHJlcGxhY2VtZW50cyAtIHsgXCJiYXJcIjogMTAgfVxuICovXG5jb25zdCByZXBsYWNlSW5TdHJpbmcgPSAoc3RyaW5nLCByZXBsYWNlbWVudHMpID0+XG4gICAgc3RyaW5nLnJlcGxhY2UoLyg/OnsoW2EtekEtWl0rKX0pL2csIChtYXRjaCwgZ3JvdXApID0+IHJlcGxhY2VtZW50c1tncm91cF0pO1xuXG5jb25zdCBjcmVhdGVXb3JrZXIgPSBmbiA9PiB7XG4gICAgY29uc3Qgd29ya2VyQmxvYiA9IG5ldyBCbG9iKFsnKCcsIGZuLnRvU3RyaW5nKCksICcpKCknXSwge1xuICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgfSk7XG4gICAgY29uc3Qgd29ya2VyVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh3b3JrZXJCbG9iKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKHdvcmtlclVSTCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2ZlcjogKG1lc3NhZ2UsIGNiKSA9PiB7fSxcbiAgICAgICAgcG9zdDogKG1lc3NhZ2UsIGNiLCB0cmFuc2Zlckxpc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ2V0VW5pcXVlSWQoKTtcblxuICAgICAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZmVyTGlzdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGVybWluYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHdvcmtlclVSTCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IGxvYWRJbWFnZSA9IHVybCA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKGltZyk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5vbmVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfSk7XG5cbmNvbnN0IHJlbmFtZUZpbGUgPSAoZmlsZSwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHJlbmFtZWRGaWxlID0gZmlsZS5zbGljZSgwLCBmaWxlLnNpemUsIGZpbGUudHlwZSk7XG4gICAgcmVuYW1lZEZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IGZpbGUubGFzdE1vZGlmaWVkRGF0ZTtcbiAgICByZW5hbWVkRmlsZS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gcmVuYW1lZEZpbGU7XG59O1xuXG5jb25zdCBjb3B5RmlsZSA9IGZpbGUgPT4gcmVuYW1lRmlsZShmaWxlLCBmaWxlLm5hbWUpO1xuXG4vLyBhbHJlYWR5IHJlZ2lzdGVyZWQgcGx1Z2lucyAoY2FuJ3QgcmVnaXN0ZXIgdHdpY2UpXG5jb25zdCByZWdpc3RlcmVkUGx1Z2lucyA9IFtdO1xuXG4vLyBwYXNzIHV0aWxzIHRvIHBsdWdpblxuY29uc3QgY3JlYXRlQXBwUGx1Z2luID0gcGx1Z2luID0+IHtcbiAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICBpZiAocmVnaXN0ZXJlZFBsdWdpbnMuaW5jbHVkZXMocGx1Z2luKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVtZW1iZXIgdGhpcyBwbHVnaW5cbiAgICByZWdpc3RlcmVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cbiAgICAvLyBzZXR1cCFcbiAgICBjb25zdCBwbHVnaW5PdXRsaW5lID0gcGx1Z2luKHtcbiAgICAgICAgYWRkRmlsdGVyLFxuICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgVHlwZSxcbiAgICAgICAgICAgIGZvcmluLFxuICAgICAgICAgICAgaXNTdHJpbmcsXG4gICAgICAgICAgICBpc0ZpbGUsXG4gICAgICAgICAgICB0b05hdHVyYWxGaWxlU2l6ZSxcbiAgICAgICAgICAgIHJlcGxhY2VJblN0cmluZyxcbiAgICAgICAgICAgIGdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSxcbiAgICAgICAgICAgIGdldEZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbixcbiAgICAgICAgICAgIGd1ZXNzdGltYXRlTWltZVR5cGUsXG4gICAgICAgICAgICBnZXRGaWxlRnJvbUJsb2IsXG4gICAgICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkwsXG4gICAgICAgICAgICBjcmVhdGVSb3V0ZSxcbiAgICAgICAgICAgIGNyZWF0ZVdvcmtlcixcbiAgICAgICAgICAgIGNyZWF0ZVZpZXcsXG4gICAgICAgICAgICBjcmVhdGVJdGVtQVBJLFxuICAgICAgICAgICAgbG9hZEltYWdlLFxuICAgICAgICAgICAgY29weUZpbGUsXG4gICAgICAgICAgICByZW5hbWVGaWxlLFxuICAgICAgICAgICAgY3JlYXRlQmxvYixcbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4sXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyxcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3M6IHtcbiAgICAgICAgICAgIGZpbGVBY3Rpb25CdXR0b24sXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBhZGQgcGx1Z2luIG9wdGlvbnMgdG8gZGVmYXVsdCBvcHRpb25zXG4gICAgZXh0ZW5kRGVmYXVsdE9wdGlvbnMocGx1Z2luT3V0bGluZS5vcHRpb25zKTtcbn07XG5cbi8vIGZlYXR1cmUgZGV0ZWN0aW9uIHVzZWQgYnkgc3VwcG9ydGVkKCkgbWV0aG9kXG5jb25zdCBpc09wZXJhTWluaSA9ICgpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmFtaW5pKSA9PT0gJ1tvYmplY3QgT3BlcmFNaW5pXSc7XG5jb25zdCBoYXNQcm9taXNlcyA9ICgpID0+ICdQcm9taXNlJyBpbiB3aW5kb3c7XG5jb25zdCBoYXNCbG9iU2xpY2UgPSAoKSA9PiAnc2xpY2UnIGluIEJsb2IucHJvdG90eXBlO1xuY29uc3QgaGFzQ3JlYXRlT2JqZWN0VVJMID0gKCkgPT4gJ1VSTCcgaW4gd2luZG93ICYmICdjcmVhdGVPYmplY3RVUkwnIGluIHdpbmRvdy5VUkw7XG5jb25zdCBoYXNWaXNpYmlsaXR5ID0gKCkgPT4gJ3Zpc2liaWxpdHlTdGF0ZScgaW4gZG9jdW1lbnQ7XG5jb25zdCBoYXNUaW1pbmcgPSAoKSA9PiAncGVyZm9ybWFuY2UnIGluIHdpbmRvdzsgLy8gaU9TIDgueFxuY29uc3QgaGFzQ1NTU3VwcG9ydHMgPSAoKSA9PiAnc3VwcG9ydHMnIGluICh3aW5kb3cuQ1NTIHx8IHt9KTsgLy8gdXNlIHRvIGRldGVjdCBTYWZhcmkgOStcbmNvbnN0IGlzSUUxMSA9ICgpID0+IC9NU0lFfFRyaWRlbnQvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5jb25zdCBzdXBwb3J0ZWQgPSAoKCkgPT4ge1xuICAgIC8vIFJ1bnMgaW1tZWRpYXRlbHkgYW5kIHRoZW4gcmVtZW1iZXJzIHJlc3VsdCBmb3Igc3Vic2VxdWVudCBjYWxsc1xuICAgIGNvbnN0IGlzU3VwcG9ydGVkID1cbiAgICAgICAgLy8gSGFzIHRvIGJlIGEgYnJvd3NlclxuICAgICAgICBpc0Jyb3dzZXIoKSAmJlxuICAgICAgICAvLyBDYW4ndCBydW4gb24gT3BlcmEgTWluaSBkdWUgdG8gbGFjayBvZiBldmVyeXRoaW5nXG4gICAgICAgICFpc09wZXJhTWluaSgpICYmXG4gICAgICAgIC8vIFJlcXVpcmUgdGhlc2UgQVBJcyB0byBmZWF0dXJlIGRldGVjdCBhIG1vZGVybiBicm93c2VyXG4gICAgICAgIGhhc1Zpc2liaWxpdHkoKSAmJlxuICAgICAgICBoYXNQcm9taXNlcygpICYmXG4gICAgICAgIGhhc0Jsb2JTbGljZSgpICYmXG4gICAgICAgIGhhc0NyZWF0ZU9iamVjdFVSTCgpICYmXG4gICAgICAgIGhhc1RpbWluZygpICYmXG4gICAgICAgIC8vIGRvZXNuJ3QgbmVlZCBDU1NTdXBwb3J0cyBidXQgaXMgYSBnb29kIHdheSB0byBkZXRlY3QgU2FmYXJpIDkrICh3ZSBkbyB3YW50IHRvIHN1cHBvcnQgSUUxMSB0aG91Z2gpXG4gICAgICAgIChoYXNDU1NTdXBwb3J0cygpIHx8IGlzSUUxMSgpKTtcblxuICAgIHJldHVybiAoKSA9PiBpc1N1cHBvcnRlZDtcbn0pKCk7XG5cbi8qKlxuICogUGx1Z2luIGludGVybmFsIHN0YXRlIChvdmVyIGFsbCBpbnN0YW5jZXMpXG4gKi9cbmNvbnN0IHN0YXRlID0ge1xuICAgIC8vIGFjdGl2ZSBhcHAgaW5zdGFuY2VzLCB1c2VkIHRvIHJlZHJhdyB0aGUgYXBwcyBhbmQgdG8gZmluZCB0aGUgbGF0ZXJcbiAgICBhcHBzOiBbXSxcbn07XG5cbi8vIHBsdWdpbiBuYW1lXG5jb25zdCBuYW1lID0gJ2ZpbGVwb25kJztcblxuLyoqXG4gKiBQdWJsaWMgUGx1Z2luIG1ldGhvZHNcbiAqL1xuY29uc3QgZm4gPSAoKSA9PiB7fTtcbmxldCBTdGF0dXMkMSA9IHt9O1xubGV0IEZpbGVTdGF0dXMgPSB7fTtcbmxldCBGaWxlT3JpZ2luJDEgPSB7fTtcbmxldCBPcHRpb25UeXBlcyA9IHt9O1xubGV0IGNyZWF0ZSRmID0gZm47XG5sZXQgZGVzdHJveSA9IGZuO1xubGV0IHBhcnNlID0gZm47XG5sZXQgZmluZCA9IGZuO1xubGV0IHJlZ2lzdGVyUGx1Z2luID0gZm47XG5sZXQgZ2V0T3B0aW9ucyQxID0gZm47XG5sZXQgc2V0T3B0aW9ucyQxID0gZm47XG5cbi8vIGlmIG5vdCBzdXBwb3J0ZWQsIG5vIEFQSVxuaWYgKHN1cHBvcnRlZCgpKSB7XG4gICAgLy8gc3RhcnQgcGFpbnRlciBhbmQgZmlyZSBsb2FkIGV2ZW50XG4gICAgY3JlYXRlUGFpbnRlcihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGFwcCA9PiBhcHAuX3JlYWQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRzID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChhcHAgPT4gYXBwLl93cml0ZSh0cykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGZpcmUgbG9hZGVkIGV2ZW50IHNvIHdlIGtub3cgd2hlbiBGaWxlUG9uZCBpcyBhdmFpbGFibGVcbiAgICBjb25zdCBkaXNwYXRjaCA9ICgpID0+IHtcbiAgICAgICAgLy8gbGV0IG90aGVycyBrbm93IHdlIGhhdmUgYXJlYSByZWFkeVxuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCdGaWxlUG9uZDpsb2FkZWQnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlOiBjcmVhdGUkZixcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2UsXG4gICAgICAgICAgICAgICAgICAgIGZpbmQsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICBzZXRPcHRpb25zOiBzZXRPcHRpb25zJDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgZXZlbnRcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRpc3BhdGNoKTtcbiAgICB9O1xuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAvLyBtb3ZlIHRvIGJhY2sgb2YgZXhlY3V0aW9uIHF1ZXVlLCBGaWxlUG9uZCBzaG91bGQgaGF2ZSBiZWVuIGV4cG9ydGVkIGJ5IHRoZW5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkaXNwYXRjaCgpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZXMgdGhlIE9wdGlvblR5cGVzIG9iamVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgY29uc3QgdXBkYXRlT3B0aW9uVHlwZXMgPSAoKSA9PlxuICAgICAgICBmb3JpbihnZXRPcHRpb25zKCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBPcHRpb25UeXBlc1trZXldID0gdmFsdWVbMV07XG4gICAgICAgIH0pO1xuXG4gICAgU3RhdHVzJDEgPSB7IC4uLlN0YXR1cyB9O1xuICAgIEZpbGVPcmlnaW4kMSA9IHsgLi4uRmlsZU9yaWdpbiB9O1xuICAgIEZpbGVTdGF0dXMgPSB7IC4uLkl0ZW1TdGF0dXMgfTtcblxuICAgIE9wdGlvblR5cGVzID0ge307XG4gICAgdXBkYXRlT3B0aW9uVHlwZXMoKTtcblxuICAgIC8vIGNyZWF0ZSBtZXRob2QsIGNyZWF0ZXMgYXBwcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBhcHAgYXJyYXlcbiAgICBjcmVhdGUkZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcCA9IGNyZWF0ZUFwcCQxKC4uLmFyZ3MpO1xuICAgICAgICBhcHAub24oJ2Rlc3Ryb3knLCBkZXN0cm95KTtcbiAgICAgICAgc3RhdGUuYXBwcy5wdXNoKGFwcCk7XG4gICAgICAgIHJldHVybiBjcmVhdGVBcHBBUEkoYXBwKTtcbiAgICB9O1xuXG4gICAgLy8gZGVzdHJveXMgYXBwcyBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIGFwcCBhcnJheVxuICAgIGRlc3Ryb3kgPSBob29rID0+IHtcbiAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBhcHAgd2FzIGRlc3Ryb3llZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgY29uc3QgaW5kZXhUb1JlbW92ZSA9IHN0YXRlLmFwcHMuZmluZEluZGV4KGFwcCA9PiBhcHAuaXNBdHRhY2hlZFRvKGhvb2spKTtcbiAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gYXBwc1xuICAgICAgICAgICAgY29uc3QgYXBwID0gc3RhdGUuYXBwcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSlbMF07XG5cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgIGFwcC5yZXN0b3JlRWxlbWVudCgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gcGFyc2VzIHRoZSBnaXZlbiBjb250ZXh0IGZvciBwbHVnaW5zIChkb2VzIG5vdCBpbmNsdWRlIHRoZSBjb250ZXh0IGVsZW1lbnQgaXRzZWxmKVxuICAgIHBhcnNlID0gY29udGV4dCA9PiB7XG4gICAgICAgIC8vIGdldCBhbGwgcG9zc2libGUgaG9va3NcbiAgICAgICAgY29uc3QgbWF0Y2hlZEhvb2tzID0gQXJyYXkuZnJvbShjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke25hbWV9YCkpO1xuXG4gICAgICAgIC8vIGZpbHRlciBvdXQgYWxyZWFkeSBhY3RpdmUgaG9va3NcbiAgICAgICAgY29uc3QgbmV3SG9va3MgPSBtYXRjaGVkSG9va3MuZmlsdGVyKFxuICAgICAgICAgICAgbmV3SG9vayA9PiAhc3RhdGUuYXBwcy5maW5kKGFwcCA9PiBhcHAuaXNBdHRhY2hlZFRvKG5ld0hvb2spKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgaW5zdGFuY2UgZm9yIGVhY2ggaG9va1xuICAgICAgICByZXR1cm4gbmV3SG9va3MubWFwKGhvb2sgPT4gY3JlYXRlJGYoaG9vaykpO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm5zIGFuIGFwcCBiYXNlZCBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBob29rXG4gICAgZmluZCA9IGhvb2sgPT4ge1xuICAgICAgICBjb25zdCBhcHAgPSBzdGF0ZS5hcHBzLmZpbmQoYXBwID0+IGFwcC5pc0F0dGFjaGVkVG8oaG9vaykpO1xuICAgICAgICBpZiAoIWFwcCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgIH07XG5cbiAgICAvLyBhZGRzIGEgcGx1Z2luIGV4dGVuc2lvblxuICAgIHJlZ2lzdGVyUGx1Z2luID0gKC4uLnBsdWdpbnMpID0+IHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgcGx1Z2luc1xuICAgICAgICBwbHVnaW5zLmZvckVhY2goY3JlYXRlQXBwUGx1Z2luKTtcblxuICAgICAgICAvLyB1cGRhdGUgT3B0aW9uVHlwZXMsIGVhY2ggcGx1Z2luIG1pZ2h0IGhhdmUgZXh0ZW5kZWQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuICAgIH07XG5cbiAgICBnZXRPcHRpb25zJDEgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgZm9yaW4oZ2V0T3B0aW9ucygpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgb3B0c1trZXldID0gdmFsdWVbMF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9O1xuXG4gICAgc2V0T3B0aW9ucyQxID0gb3B0cyA9PiB7XG4gICAgICAgIGlmIChpc09iamVjdChvcHRzKSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHBsdWdpbnNcbiAgICAgICAgICAgIHN0YXRlLmFwcHMuZm9yRWFjaChhcHAgPT4ge1xuICAgICAgICAgICAgICAgIGFwcC5zZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIGRlZmF1bHRzXG4gICAgICAgICAgICBzZXRPcHRpb25zKG9wdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIG5ldyBvcHRpb25zXG4gICAgICAgIHJldHVybiBnZXRPcHRpb25zJDEoKTtcbiAgICB9O1xufVxuXG5leHBvcnQge1xuICAgIEZpbGVPcmlnaW4kMSBhcyBGaWxlT3JpZ2luLFxuICAgIEZpbGVTdGF0dXMsXG4gICAgT3B0aW9uVHlwZXMsXG4gICAgU3RhdHVzJDEgYXMgU3RhdHVzLFxuICAgIGNyZWF0ZSRmIGFzIGNyZWF0ZSxcbiAgICBkZXN0cm95LFxuICAgIGZpbmQsXG4gICAgZ2V0T3B0aW9ucyQxIGFzIGdldE9wdGlvbnMsXG4gICAgcGFyc2UsXG4gICAgcmVnaXN0ZXJQbHVnaW4sXG4gICAgc2V0T3B0aW9ucyQxIGFzIHNldE9wdGlvbnMsXG4gICAgc3VwcG9ydGVkLFxufTtcbiJdLCJuYW1lcyI6WyJpc05vZGUiLCJ2YWx1ZSIsIkhUTUxFbGVtZW50IiwiY3JlYXRlU3RvcmUiLCJpbml0aWFsU3RhdGUiLCJxdWVyaWVzIiwiYWN0aW9ucyIsInN0YXRlIiwiYWN0aW9uUXVldWUiLCJkaXNwYXRjaFF1ZXVlIiwiZ2V0U3RhdGUiLCJwcm9jZXNzQWN0aW9uUXVldWUiLCJxdWV1ZSIsImxlbmd0aCIsInByb2Nlc3NEaXNwYXRjaFF1ZXVlIiwiZm9yRWFjaCIsInR5cGUiLCJkYXRhIiwiZGlzcGF0Y2giLCJpc0Jsb2NraW5nIiwiZG9jdW1lbnQiLCJoaWRkZW4iLCJwdXNoIiwiYWN0aW9uSGFuZGxlcnMiLCJxdWVyeSIsInN0ciIsImFyZ3MiLCJxdWVyeUhhbmRsZXMiLCJhcGkiLCJhY3Rpb24iLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsInByb3BlcnR5IiwiZGVmaW5pdGlvbiIsIk9iamVjdCIsImZvcmluIiwiY2IiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsImNyZWF0ZU9iamVjdCIsImF0dHIiLCJub2RlIiwibmFtZSIsImdldEF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIm5zIiwic3ZnRWxlbWVudHMiLCJpc1NWR0VsZW1lbnQiLCJ0YWciLCJpbmNsdWRlcyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJhdHRyaWJ1dGVzIiwiZWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImFwcGVuZENoaWxkIiwicGFyZW50IiwiY2hpbGQiLCJpbmRleCIsImNoaWxkcmVuIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGRWaWV3IiwiY2hpbGRWaWV3cyIsInZpZXciLCJzcGxpY2UiLCJyZW1vdmVDaGlsZFZpZXciLCJpbmRleE9mIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiSVNfQlJPV1NFUiIsIndpbmRvdyIsImlzQnJvd3NlciIsInRlc3RFbGVtZW50IiwiZ2V0Q2hpbGRDb3VudCIsImVsIiwiY2hpbGROb2RlcyIsImdldFZpZXdSZWN0IiwiZWxlbWVudFJlY3QiLCJvZmZzZXQiLCJzY2FsZSIsImxlZnQiLCJ0b3AiLCJyaWdodCIsIndpZHRoIiwiYm90dG9tIiwiaGVpZ2h0IiwicmVjdCIsImlubmVyIiwib3V0ZXIiLCJmaWx0ZXIiLCJjaGlsZFZpZXciLCJpc1JlY3RJZ25vcmVkIiwibWFwIiwiY2hpbGRWaWV3UmVjdCIsImV4cGFuZFJlY3QiLCJjYWxjdWxhdGVSZWN0U2l6ZSIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpblJpZ2h0IiwiaXNOdW1iZXIiLCJ0aGVyZVlldCIsInBvc2l0aW9uIiwiZGVzdGluYXRpb24iLCJ2ZWxvY2l0eSIsImVycm9yTWFyZ2luIiwiTWF0aCIsImFicyIsInNwcmluZyIsInN0aWZmbmVzcyIsImRhbXBpbmciLCJtYXNzIiwidGFyZ2V0IiwicmVzdGluZyIsImludGVycG9sYXRlIiwidHMiLCJza2lwVG9FbmRTdGF0ZSIsImYiLCJvbnVwZGF0ZSIsIm9uY29tcGxldGUiLCJzZXRUYXJnZXQiLCJzZXQiLCJnZXQiLCJlYXNlTGluZWFyIiwidCIsImVhc2VJbk91dFF1YWQiLCJ0d2VlbiIsImR1cmF0aW9uIiwiZWFzaW5nIiwiZGVsYXkiLCJzdGFydCIsInAiLCJyZXZlcnNlIiwiYW5pbWF0b3IiLCJjcmVhdGVBbmltYXRvciIsImNhdGVnb3J5IiwiZGVmIiwicHJvcHMiLCJhZGRHZXRTZXQiLCJrZXlzIiwib3ZlcndyaXRlIiwiQXJyYXkiLCJpc0FycmF5IiwibyIsImdldHRlciIsInNldHRlciIsImFuaW1hdGlvbnMiLCJtaXhpbkNvbmZpZyIsInZpZXdQcm9wcyIsInZpZXdJbnRlcm5hbEFQSSIsInZpZXdFeHRlcm5hbEFQSSIsImluaXRpYWxQcm9wcyIsImFuaW1hdGlvbiIsInByb3AiLCJ3cml0ZSIsImRlc3Ryb3kiLCJhZGRFdmVudCIsImZuIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVycyIsInZpZXdTdGF0ZSIsImV2ZW50cyIsImFkZCIsInJlbW92ZSIsIm9uIiwib2ZmIiwiZmluZEluZGV4IiwiZXZlbnQiLCJhcGlzIiwiaXNEZWZpbmVkIiwiZGVmYXVsdHMiLCJvcGFjaXR5Iiwic2NhbGVYIiwic2NhbGVZIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJvcmlnaW5YIiwib3JpZ2luWSIsInN0eWxlcyIsImN1cnJlbnRQcm9wcyIsImdldE9mZnNldCIsImdldFNjYWxlIiwiZ2V0UmVjdCIsInByb3BzSGF2ZUNoYW5nZWQiLCJhcHBseVN0eWxlcyIsImFzc2lnbiIsIm5ld1Byb3BzIiwicGVyc3BlY3RpdmUiLCJ0cmFuc2Zvcm1zIiwiZWxlbWVudEN1cnJlbnRTdHlsZSIsInN0eWxlIiwiY3NzVGV4dCIsIk1peGlucyIsInVwZGF0ZVJlY3QiLCJsYXlvdXRDYWxjdWxhdGVkIiwicGFkZGluZ1RvcCIsInBhcnNlSW50IiwibWFyZ2luVG9wIiwibWFyZ2luTGVmdCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInNjcm9sbFRvcCIsIm9mZnNldFBhcmVudCIsImNyZWF0ZVZpZXciLCJyZWFkIiwiY3JlYXRlIiwiZmlsdGVyRnJhbWVBY3Rpb25zRm9yQ2hpbGQiLCJkaWRDcmVhdGVWaWV3IiwiZGlkV3JpdGVWaWV3IiwiaWdub3JlUmVjdCIsImlnbm9yZVJlY3RVcGRhdGUiLCJtaXhpbnMiLCJzdG9yZSIsImdldENvbXB1dGVkU3R5bGUiLCJmcmFtZVJlY3QiLCJpc1Jlc3RpbmciLCJhY3RpdmVNaXhpbnMiLCJyZWYiLCJ3cml0ZXJzIiwicmVhZGVycyIsImRlc3Ryb3llcnMiLCJnZXRFbGVtZW50IiwiZ2V0Q2hpbGRWaWV3cyIsImNvbmNhdCIsImdldFJlZmVyZW5jZSIsImNyZWF0ZUNoaWxkVmlldyIsImdldFN0eWxlIiwiX3JlYWQiLCJzaG91bGRVcGRhdGUiLCJyb290IiwiaW50ZXJuYWxBUEkiLCJyZWFkZXIiLCJfd3JpdGUiLCJmcmFtZUFjdGlvbnMiLCJzaG91bGRPcHRpbWl6ZSIsIndyaXRlciIsIndyaXRlclJlc3RpbmciLCJ0aW1lc3RhbXAiLCJtaXhpbiIsIm1peGluUmVzdGluZyIsImNoaWxkUmVzdGluZyIsIl9kZXN0cm95IiwiZGVzdHJveWVyIiwic2hhcmVkQVBJRGVmaW5pdGlvbiIsImludGVybmFsQVBJRGVmaW5pdGlvbiIsImlzIiwibmVlZGxlIiwibGlua1ZpZXciLCJ1bmxpbmtWaWV3IiwicmVnaXN0ZXJXcml0ZXIiLCJyZWdpc3RlclJlYWRlciIsInJlZ2lzdGVyRGVzdHJveWVyIiwiaW52YWxpZGF0ZUxheW91dCIsImV4dGVybmFsQVBJRGVmaW5pdGlvbiIsIm1peGluQVBJRGVmaW5pdGlvbiIsInNvcnQiLCJhIiwiYiIsIm1peGluQVBJIiwiY2hpbGRDb3VudCIsImNyZWF0ZVBhaW50ZXIiLCJmcHMiLCJwYWludGVyIiwiaW50ZXJ2YWwiLCJsYXN0IiwiaWQiLCJyZXF1ZXN0VGljayIsImNhbmNlbFRpY2siLCJzZXRUaW1lclR5cGUiLCJzZXRUaW1lb3V0IiwidGljayIsInBlcmZvcm1hbmNlIiwibm93IiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkZWx0YSIsInBhdXNlIiwiY3JlYXRlUm91dGUiLCJyb3V0ZXMiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsImluc2VydEFmdGVyIiwibmV4dFNpYmxpbmciLCJpc0VtcHR5IiwidHJpbSIsInRvU3RyaW5nIiwidG9BcnJheSIsInNwbGl0dGVyIiwic3BsaXQiLCJpc0Jvb2xlYW4iLCJ0b0Jvb2xlYW4iLCJpc1N0cmluZyIsInRvTnVtYmVyIiwicmVwbGFjZSIsInRvSW50IiwidG9GbG9hdCIsInBhcnNlRmxvYXQiLCJpc0ludCIsImlzRmluaXRlIiwiZmxvb3IiLCJ0b0J5dGVzIiwiYmFzZSIsIm5hdHVyYWxGaWxlU2l6ZSIsInRlc3QiLCJpc0Z1bmN0aW9uIiwidG9GdW5jdGlvblJlZmVyZW5jZSIsInN0cmluZyIsInNlbGYiLCJsZXZlbHMiLCJsZXZlbCIsInNoaWZ0IiwibWV0aG9kcyIsInByb2Nlc3MiLCJwYXRjaCIsInJldmVydCIsImZldGNoIiwicmVzdG9yZSIsImxvYWQiLCJjcmVhdGVTZXJ2ZXJBUEkiLCJvdXRsaW5lIiwidXJsIiwidGltZW91dCIsImhlYWRlcnMiLCJjcmVhdGVBY3Rpb24iLCJtZXRob2QiLCJ3aXRoQ3JlZGVudGlhbHMiLCJvbmxvYWQiLCJvbmRhdGEiLCJvbmVycm9yIiwicGFydHMiLCJoZWFkZXIiLCJ0b1NlcnZlckFQSSIsImlzTnVsbCIsImlzT2JqZWN0IiwiaXNBUEkiLCJnZXRUeXBlIiwicmVwbGFjZVNpbmdsZVF1b3RlcyIsImNvbnZlcnNpb25UYWJsZSIsImFycmF5IiwiYm9vbGVhbiIsImludCIsIm51bWJlciIsImZsb2F0IiwiYnl0ZXMiLCJmdW5jdGlvbiIsInNlcnZlcmFwaSIsIm9iamVjdCIsIkpTT04iLCJwYXJzZSIsImUiLCJjb252ZXJ0VG8iLCJnZXRWYWx1ZUJ5VHlwZSIsIm5ld1ZhbHVlIiwiZGVmYXVsdFZhbHVlIiwidmFsdWVUeXBlIiwibmV3VmFsdWVUeXBlIiwiY29udmVydGVkVmFsdWUiLCJvcHRpb24iLCJjcmVhdGVPcHRpb24iLCJjdXJyZW50VmFsdWUiLCJlbnVtZXJhYmxlIiwiY3JlYXRlT3B0aW9ucyIsIm9wdGlvbnMiLCJvcHRpb25EZWZpbml0aW9uIiwiY3JlYXRlSW5pdGlhbFN0YXRlIiwiaXRlbXMiLCJsaXN0VXBkYXRlVGltZW91dCIsIml0ZW1VcGRhdGVUaW1lb3V0IiwicHJvY2Vzc2luZ1F1ZXVlIiwiZnJvbUNhbWVscyIsInNlcGFyYXRvciIsInBhcnQiLCJ0b0xvd2VyQ2FzZSIsImpvaW4iLCJjcmVhdGVPcHRpb25BUEkiLCJ0b1VwcGVyQ2FzZSIsImNyZWF0ZU9wdGlvbkFjdGlvbnMiLCJjcmVhdGVPcHRpb25RdWVyaWVzIiwiSW50ZXJhY3Rpb25NZXRob2QiLCJBUEkiLCJEUk9QIiwiQlJPV1NFIiwiUEFTVEUiLCJOT05FIiwiZ2V0VW5pcXVlSWQiLCJyYW5kb20iLCJzdWJzdHJpbmciLCJhcnJheVJlbW92ZSIsImFyciIsInJ1biIsInN5bmMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJsaXN0ZW5lciIsImZpcmUiLCJmaXJlU3luYyIsIm9uT25jZSIsImNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QiLCJzcmMiLCJleGNsdWRlZCIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJQUklWQVRFIiwiY3JlYXRlSXRlbUFQSSIsIml0ZW0iLCJyZW1vdmVSZWxlYXNlZEl0ZW1zIiwicmVsZWFzZWQiLCJJdGVtU3RhdHVzIiwiSU5JVCIsIklETEUiLCJQUk9DRVNTSU5HX1FVRVVFRCIsIlBST0NFU1NJTkciLCJQUk9DRVNTSU5HX0NPTVBMRVRFIiwiUFJPQ0VTU0lOR19FUlJPUiIsIlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SIiwiTE9BRElORyIsIkxPQURfRVJST1IiLCJGaWxlT3JpZ2luIiwiSU5QVVQiLCJMSU1CTyIsIkxPQ0FMIiwiZ2V0Tm9uTnVtZXJpYyIsImV4ZWMiLCJnZXREZWNpbWFsU2VwYXJhdG9yIiwidG9Mb2NhbGVTdHJpbmciLCJnZXRUaG91c2FuZHNTZXBhcmF0b3IiLCJkZWNpbWFsU2VwYXJhdG9yIiwidGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciIsInRob3VzYW5kc1N0cmluZ1dpdGhvdXRTZXBhcmF0b3IiLCJUeXBlIiwiQk9PTEVBTiIsIklOVCIsIk5VTUJFUiIsIlNUUklORyIsIkFSUkFZIiwiT0JKRUNUIiwiRlVOQ1RJT04iLCJBQ1RJT04iLCJTRVJWRVJfQVBJIiwiUkVHRVgiLCJmaWx0ZXJzIiwiYXBwbHlGaWx0ZXJDaGFpbiIsInV0aWxzIiwicmVqZWN0IiwibWF0Y2hpbmdGaWx0ZXJzIiwiaW5pdGlhbEZpbHRlciIsInJlZHVjZSIsImN1cnJlbnQiLCJuZXh0IiwiY2F0Y2giLCJlcnJvciIsImFwcGx5RmlsdGVycyIsImFkZEZpbHRlciIsImV4dGVuZERlZmF1bHRPcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJkZWZhdWx0T3B0aW9ucyIsImdldE9wdGlvbnMiLCJzZXRPcHRpb25zIiwib3B0cyIsImRpc2FibGVkIiwicmVxdWlyZWQiLCJjYXB0dXJlTWV0aG9kIiwiYWxsb3dTeW5jQWNjZXB0QXR0cmlidXRlIiwiYWxsb3dEcm9wIiwiYWxsb3dCcm93c2UiLCJhbGxvd1Bhc3RlIiwiYWxsb3dNdWx0aXBsZSIsImFsbG93UmVwbGFjZSIsImFsbG93UmV2ZXJ0IiwiYWxsb3dSZW1vdmUiLCJhbGxvd1Byb2Nlc3MiLCJhbGxvd1Jlb3JkZXIiLCJhbGxvd0RpcmVjdG9yaWVzT25seSIsInN0b3JlQXNGaWxlIiwiZm9yY2VSZXZlcnQiLCJtYXhGaWxlcyIsImNoZWNrVmFsaWRpdHkiLCJpdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tIiwiaXRlbUluc2VydExvY2F0aW9uIiwiaXRlbUluc2VydEludGVydmFsIiwiZHJvcE9uUGFnZSIsImRyb3BPbkVsZW1lbnQiLCJkcm9wVmFsaWRhdGlvbiIsImlnbm9yZWRGaWxlcyIsImluc3RhbnRVcGxvYWQiLCJtYXhQYXJhbGxlbFVwbG9hZHMiLCJhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiIsImNodW5rVXBsb2FkcyIsImNodW5rRm9yY2UiLCJjaHVua1NpemUiLCJjaHVua1JldHJ5RGVsYXlzIiwic2VydmVyIiwiZmlsZVNpemVCYXNlIiwibGFiZWxGaWxlU2l6ZUJ5dGVzIiwibGFiZWxGaWxlU2l6ZUtpbG9ieXRlcyIsImxhYmVsRmlsZVNpemVNZWdhYnl0ZXMiLCJsYWJlbEZpbGVTaXplR2lnYWJ5dGVzIiwibGFiZWxEZWNpbWFsU2VwYXJhdG9yIiwibGFiZWxUaG91c2FuZHNTZXBhcmF0b3IiLCJsYWJlbElkbGUiLCJsYWJlbEludmFsaWRGaWVsZCIsImxhYmVsRmlsZVdhaXRpbmdGb3JTaXplIiwibGFiZWxGaWxlU2l6ZU5vdEF2YWlsYWJsZSIsImxhYmVsRmlsZUNvdW50U2luZ3VsYXIiLCJsYWJlbEZpbGVDb3VudFBsdXJhbCIsImxhYmVsRmlsZUxvYWRpbmciLCJsYWJlbEZpbGVBZGRlZCIsImxhYmVsRmlsZUxvYWRFcnJvciIsImxhYmVsRmlsZVJlbW92ZWQiLCJsYWJlbEZpbGVSZW1vdmVFcnJvciIsImxhYmVsRmlsZVByb2Nlc3NpbmciLCJsYWJlbEZpbGVQcm9jZXNzaW5nQ29tcGxldGUiLCJsYWJlbEZpbGVQcm9jZXNzaW5nQWJvcnRlZCIsImxhYmVsRmlsZVByb2Nlc3NpbmdFcnJvciIsImxhYmVsRmlsZVByb2Nlc3NpbmdSZXZlcnRFcnJvciIsImxhYmVsVGFwVG9DYW5jZWwiLCJsYWJlbFRhcFRvUmV0cnkiLCJsYWJlbFRhcFRvVW5kbyIsImxhYmVsQnV0dG9uUmVtb3ZlSXRlbSIsImxhYmVsQnV0dG9uQWJvcnRJdGVtTG9hZCIsImxhYmVsQnV0dG9uUmV0cnlJdGVtTG9hZCIsImxhYmVsQnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZyIsImxhYmVsQnV0dG9uVW5kb0l0ZW1Qcm9jZXNzaW5nIiwibGFiZWxCdXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nIiwibGFiZWxCdXR0b25Qcm9jZXNzSXRlbSIsImljb25SZW1vdmUiLCJpY29uUHJvY2VzcyIsImljb25SZXRyeSIsImljb25VbmRvIiwiaWNvbkRvbmUiLCJvbmluaXQiLCJvbndhcm5pbmciLCJvbmFjdGl2YXRlZmlsZSIsIm9uaW5pdGZpbGUiLCJvbmFkZGZpbGVzdGFydCIsIm9uYWRkZmlsZXByb2dyZXNzIiwib25hZGRmaWxlIiwib25wcm9jZXNzZmlsZXN0YXJ0Iiwib25wcm9jZXNzZmlsZXByb2dyZXNzIiwib25wcm9jZXNzZmlsZWFib3J0Iiwib25wcm9jZXNzZmlsZXJldmVydCIsIm9ucHJvY2Vzc2ZpbGUiLCJvbnByb2Nlc3NmaWxlcyIsIm9ucmVtb3ZlZmlsZSIsIm9ucHJlcGFyZWZpbGUiLCJvbnVwZGF0ZWZpbGVzIiwib25yZW9yZGVyZmlsZXMiLCJiZWZvcmVEcm9wRmlsZSIsImJlZm9yZUFkZEZpbGUiLCJiZWZvcmVSZW1vdmVGaWxlIiwiYmVmb3JlUHJlcGFyZUZpbGUiLCJzdHlsZVBhbmVsTGF5b3V0Iiwic3R5bGVQYW5lbEFzcGVjdFJhdGlvIiwic3R5bGVJdGVtUGFuZWxBc3BlY3RSYXRpbyIsInN0eWxlQnV0dG9uUmVtb3ZlSXRlbVBvc2l0aW9uIiwic3R5bGVCdXR0b25Qcm9jZXNzSXRlbVBvc2l0aW9uIiwic3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb24iLCJzdHlsZVByb2dyZXNzSW5kaWNhdG9yUG9zaXRpb24iLCJzdHlsZUJ1dHRvblJlbW92ZUl0ZW1BbGlnbiIsImZpbGVzIiwiY3JlZGl0cyIsImdldEl0ZW1CeVF1ZXJ5IiwiZmluZCIsImdldE51bWVyaWNBc3BlY3RSYXRpb0Zyb21TdHJpbmciLCJhc3BlY3RSYXRpbyIsImdldEFjdGl2ZUl0ZW1zIiwiYXJjaGl2ZWQiLCJTdGF0dXMiLCJFTVBUWSIsIkVSUk9SIiwiQlVTWSIsIlJFQURZIiwicmVzIiwiY2FuVXBkYXRlRmlsZUlucHV0IiwiZGF0YVRyYW5zZmVyIiwiRGF0YVRyYW5zZmVyIiwiRmlsZSIsImVyciIsIklURU1fRVJST1IiLCJJVEVNX0JVU1kiLCJJVEVNX1JFQURZIiwiaXNJdGVtSW5FcnJvclN0YXRlIiwic3RhdHVzIiwiaXNJdGVtSW5CdXN5U3RhdGUiLCJpc0l0ZW1JblJlYWR5U3RhdGUiLCJpc0FzeW5jIiwiR0VUX1NUQVRVUyIsInNvbWUiLCJHRVRfSVRFTSIsIkdFVF9BQ1RJVkVfSVRFTSIsIkdFVF9BQ1RJVkVfSVRFTVMiLCJHRVRfSVRFTVMiLCJHRVRfSVRFTV9OQU1FIiwiZmlsZW5hbWUiLCJHRVRfSVRFTV9TSVpFIiwiZmlsZVNpemUiLCJHRVRfU1RZTEVTIiwiR0VUX1BBTkVMX0FTUEVDVF9SQVRJTyIsImlzU2hhcGVDaXJjbGUiLCJHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8iLCJHRVRfSVRFTVNfQllfU1RBVFVTIiwiR0VUX1RPVEFMX0lURU1TIiwiU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUIiwiSVNfQVNZTkMiLCJHRVRfRklMRV9TSVpFX0xBQkVMUyIsImxhYmVsQnl0ZXMiLCJ1bmRlZmluZWQiLCJsYWJlbEtpbG9ieXRlcyIsImxhYmVsTWVnYWJ5dGVzIiwibGFiZWxHaWdhYnl0ZXMiLCJoYXNSb29tRm9ySXRlbSIsImNvdW50IiwibWF4RmlsZUNvdW50IiwibGltaXQiLCJtaW4iLCJtYXgiLCJhcnJheUluc2VydCIsImluc2VydEl0ZW0iLCJpc0Jhc2U2NERhdGFVUkkiLCJnZXRGaWxlbmFtZUZyb21VUkwiLCJwb3AiLCJnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUiLCJndWVzc3RpbWF0ZUV4dGVuc2lvbiIsInN1YnR5cGUiLCJsZWZ0UGFkIiwicGFkZGluZyIsInNsaWNlIiwiZ2V0RGF0ZVN0cmluZyIsImRhdGUiLCJEYXRlIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RmlsZUZyb21CbG9iIiwiYmxvYiIsImV4dGVuc2lvbiIsImZpbGUiLCJzaXplIiwibGFzdE1vZGlmaWVkRGF0ZSIsIl9yZWxhdGl2ZVBhdGgiLCJnZXRCbG9iQnVpbGRlciIsIkJsb2JCdWlsZGVyIiwiV2ViS2l0QmxvYkJ1aWxkZXIiLCJNb3pCbG9iQnVpbGRlciIsIk1TQmxvYkJ1aWxkZXIiLCJjcmVhdGVCbG9iIiwiYXJyYXlCdWZmZXIiLCJtaW1lVHlwZSIsIkJCIiwiYmIiLCJhcHBlbmQiLCJnZXRCbG9iIiwiQmxvYiIsImdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZSIsImJ5dGVTdHJpbmciLCJhYiIsIkFycmF5QnVmZmVyIiwiaWEiLCJVaW50OEFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJnZXRNaW1lVHlwZUZyb21CYXNlNjREYXRhVVJJIiwiZGF0YVVSSSIsImdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSSIsImdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSIsImF0b2IiLCJnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkiLCJnZXRGaWxlRnJvbUJhc2U2NERhdGFVUkkiLCJnZXRGaWxlTmFtZUZyb21IZWFkZXIiLCJtYXRjaGVzIiwiZGVjb2RlVVJJIiwiZ2V0RmlsZVNpemVGcm9tSGVhZGVyIiwibWF0Y2giLCJnZXRUcmFuZnNlcklkRnJvbUhlYWRlciIsImdldEZpbGVJbmZvRnJvbUhlYWRlcnMiLCJpbmZvIiwic291cmNlIiwicm93cyIsImNyZWF0ZUZpbGVMb2FkZXIiLCJmZXRjaEZuIiwiY29tcGxldGUiLCJwcm9ncmVzcyIsInJlcXVlc3QiLCJnZXRQcm9ncmVzcyIsImFib3J0IiwibG9hZFVSTCIsImJvZHkiLCJjb2RlIiwicmVzcG9uc2UiLCJjb21wdXRhYmxlIiwidG90YWwiLCJmaWxlaW5mbyIsInNldFNvdXJjZSIsImlzR2V0Iiwic2VuZFJlcXVlc3QiLCJvbmhlYWRlcnMiLCJvbnByb2dyZXNzIiwib250aW1lb3V0Iiwib25hYm9ydCIsImFib3J0ZWQiLCJ4aHIiLCJoZWFkZXJzUmVjZWl2ZWQiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdHJpbmdpZnkiLCJYTUxIdHRwUmVxdWVzdCIsInVwbG9hZCIsImxlbmd0aENvbXB1dGFibGUiLCJsb2FkZWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwib3BlbiIsInVuZXNjYXBlIiwic2V0UmVxdWVzdEhlYWRlciIsInJlc3BvbnNlVHlwZSIsInNlbmQiLCJjcmVhdGVSZXNwb25zZSIsImNyZWF0ZVRpbWVvdXRSZXNwb25zZSIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImhhc1FTIiwiYnVpbGRVUkwiLCJjcmVhdGVGZXRjaEZ1bmN0aW9uIiwiYXBpVXJsIiwic3RhdHVzVGV4dCIsIkNodW5rU3RhdHVzIiwiUVVFVUVEIiwiQ09NUExFVEUiLCJXQUlUSU5HIiwicHJvY2Vzc0ZpbGVDaHVua2VkIiwibWV0YWRhdGEiLCJ0cmFuc2ZlciIsImNodW5rcyIsImNodW5rVHJhbnNmZXJJZCIsImNodW5rU2VydmVyIiwic2VydmVySWQiLCJmZCIsImdldFJlc3BvbnNlSGVhZGVyIiwicmVxdWVzdFRyYW5zZmVySWQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwicmVxdWVzdFBhcmFtcyIsInJlcXVlc3RUcmFuc2Zlck9mZnNldCIsInJlcXVlc3RVcmwiLCJsYXN0Q2h1bmtJbmRleCIsInJldHJpZXMiLCJjb21wbGV0ZVByb2Nlc3NpbmdDaHVua3MiLCJjYW5Qcm9jZXNzQ2h1bmsiLCJjaHVuayIsInByb2Nlc3NDaHVuayIsImV2ZXJ5IiwicHJvY2Vzc0NodW5rcyIsInVwZGF0ZVRvdGFsUHJvZ3Jlc3MiLCJyZXRyeVByb2Nlc3NDaHVuayIsInRvdGFsQnl0ZXNUcmFuc2ZlcmVkIiwidG90YWxTaXplIiwidG90YWxQcm9jZXNzaW5nIiwiYWJvcnRDaHVua3MiLCJjcmVhdGVGaWxlUHJvY2Vzc29yRnVuY3Rpb24iLCJjYW5DaHVua1VwbG9hZCIsInNob3VsZENodW5rVXBsb2FkIiwid2lsbENodW5rVXBsb2FkIiwiY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24iLCJwYXJhbXMiLCJjcmVhdGVSZXZlcnRGdW5jdGlvbiIsInVuaXF1ZUZpbGVJZCIsImdldFJhbmRvbU51bWJlciIsImNyZWF0ZVBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlciIsInRpY2tNaW4iLCJ0aWNrTWF4IiwicnVudGltZSIsImNsZWFyIiwiY3JlYXRlRmlsZVByb2Nlc3NvciIsInByb2Nlc3NGbiIsInBlcmNlaXZlZFByb2dyZXNzIiwicGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyIiwicGVyY2VpdmVkRHVyYXRpb24iLCJwcm9ncmVzc0ZuIiwiY29tcGxldGVGbiIsInRyYW5zZmVySWQiLCJyZXNldCIsImdldER1cmF0aW9uIiwiZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uIiwibGFzdEluZGV4T2YiLCJjcmVhdGVGaWxlU3R1YiIsImlzRmlsZSIsImRlZXBDbG9uZU9iamVjdCIsInYiLCJjcmVhdGVJdGVtIiwib3JpZ2luIiwic2VydmVyRmlsZVJlZmVyZW5jZSIsImZyb3plbiIsInByb2Nlc3NpbmdBYm9ydGVkIiwiYWN0aXZlTG9hZGVyIiwiYWN0aXZlUHJvY2Vzc29yIiwiYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlIiwic2V0U3RhdHVzIiwiZ2V0RmlsZUV4dGVuc2lvbiIsImdldEZpbGVUeXBlIiwiZ2V0RmlsZVNpemUiLCJnZXRGaWxlIiwibG9hZGVyIiwibWV0YSIsInN1Y2Nlc3MiLCJyZXN1bHQiLCJyZXRyeUxvYWQiLCJhYm9ydExvYWQiLCJwcm9jZXNzb3IiLCJvbnByb2Nlc3MiLCJjb25zb2xlIiwicmVxdWVzdFByb2Nlc3NpbmciLCJhYm9ydFByb2Nlc3NpbmciLCJyZXZlcnRGaWxlVXBsb2FkIiwic2VydmVyVHJhbnNmZXJJZCIsInNldE1ldGFkYXRhIiwic2lsZW50IiwiZ2V0TWV0YWRhdGEiLCJmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24iLCJmaWxlRXh0ZW5zaW9uIiwiZmlsZVR5cGUiLCJyZWxhdGl2ZVBhdGgiLCJleHRlbmQiLCJoYW5kbGVyIiwiaXRlbUFQSSIsImZyZWV6ZSIsInJlbGVhc2UiLCJhcmNoaXZlIiwic2V0RmlsZSIsImdldEl0ZW1JbmRleEJ5UXVlcnkiLCJnZXRJdGVtQnlJZCIsIml0ZW1JZCIsImZldGNoQmxvYiIsImdldERvbWFpbkZyb21VUkwiLCJsb2NhdGlvbiIsInByb3RvY29sIiwiaXNFeHRlcm5hbFVSTCIsImhyZWYiLCJkeW5hbWljTGFiZWwiLCJsYWJlbCIsImlzTW9ja0l0ZW0iLCJsaXN0VXBkYXRlZCIsIm9wdGlvbmFsUHJvbWlzZSIsInNvcnRJdGVtcyIsImNvbXBhcmUiLCJnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZSIsIml0ZW1IYW5kbGVyIiwiZmFpbHVyZSIsIkFCT1JUX0FMTCIsIkRJRF9TRVRfRklMRVMiLCJhY3RpdmVJdGVtcyIsImludGVyYWN0aW9uTWV0aG9kIiwiRElEX1VQREFURV9JVEVNX01FVEFEQVRBIiwiY2hhbmdlIiwic2hvdWxkUHJlcGFyZU91dHB1dCIsImRvVXBsb2FkIiwiTU9WRV9JVEVNIiwiY3VycmVudEluZGV4IiwiU09SVCIsIkFERF9JVEVNUyIsImluc2VydExvY2F0aW9uIiwidG90YWxJdGVtcyIsImlzVmFsaWRGaWxlIiwidmFsaWRJdGVtcyIsInByb21pc2VzIiwiYWxsIiwiQUREX0lURU0iLCJtYWluU3RhdHVzIiwibWFpbiIsInN1YiIsImhhbmRsZUFkZCIsInNob3VsZEFkZCIsImxvYWRDb21wbGV0ZSIsIlJFUVVFU1RfUFJFUEFSRV9PVVRQVVQiLCJDT01QTEVURV9MT0FEX0lURU0iLCJSRVRSWV9JVEVNX0xPQUQiLCJSRVFVRVNUX0lURU1fUFJFUEFSRSIsIm91dHB1dCIsIlJFUVVFU1RfSVRFTV9QUk9DRVNTSU5HIiwiaXRlbUNhbkJlUXVldWVkRm9yUHJvY2Vzc2luZyIsInByb2Nlc3NOb3ciLCJQUk9DRVNTX0lURU0iLCJ0b3RhbEN1cnJlbnRVcGxvYWRzIiwicHJvY2Vzc05leHQiLCJxdWV1ZUVudHJ5IiwiaXRlbVJlZmVyZW5jZSIsIm5vb3AiLCJhbGxJdGVtc1Byb2Nlc3NlZCIsIlJFVFJZX0lURU1fUFJPQ0VTU0lORyIsIlJFUVVFU1RfUkVNT1ZFX0lURU0iLCJzaG91bGRSZW1vdmUiLCJSRUxFQVNFX0lURU0iLCJSRU1PVkVfSVRFTSIsInJlbW92ZUZyb21WaWV3IiwiQUJPUlRfSVRFTV9MT0FEIiwiQUJPUlRfSVRFTV9QUk9DRVNTSU5HIiwiUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HIiwiaGFuZGxlUmV2ZXJ0Iiwic2hvdWxkUmV2ZXJ0IiwicmVxdWVzdFJlbW92ZVJlc3VsdCIsIlJFVkVSVF9JVEVNX1BST0NFU1NJTkciLCJTRVRfT1BUSU9OUyIsIm9wdGlvbktleXMiLCJwcmlvcml0aXplZE9wdGlvbktleXMiLCJQcmlvcml0aXplZE9wdGlvbnMiLCJvcmRlcmVkT3B0aW9uS2V5cyIsImZvcm1hdEZpbGVuYW1lIiwiY3JlYXRlRWxlbWVudCQxIiwidGFnTmFtZSIsInRleHQiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwibm9kZVZhbHVlIiwicG9sYXJUb0NhcnRlc2lhbiIsImNlbnRlclgiLCJjZW50ZXJZIiwicmFkaXVzIiwiYW5nbGVJbkRlZ3JlZXMiLCJhbmdsZUluUmFkaWFucyIsIlBJIiwieCIsImNvcyIsInkiLCJzaW4iLCJkZXNjcmliZUFyYyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImFyY1N3ZWVwIiwiZW5kIiwicGVyY2VudGFnZUFyYyIsImZyb20iLCJ0byIsInNwaW4iLCJzdmciLCJwYXRoIiwiYWxpZ24iLCJkYXRhc2V0IiwicmluZ1N0cm9rZVdpZHRoIiwicmluZ0Zyb20iLCJyaW5nVG8iLCJjb29yZGluYXRlcyIsInByb2dyZXNzSW5kaWNhdG9yIiwiY3JlYXRlJDEiLCJpbm5lckhUTUwiLCJpY29uIiwiaXNEaXNhYmxlZCIsIndyaXRlJDEiLCJzaG91bGREaXNhYmxlIiwicmVtb3ZlQXR0cmlidXRlIiwiZmlsZUFjdGlvbkJ1dHRvbiIsInRvTmF0dXJhbEZpbGVTaXplIiwicm91bmQiLCJLQiIsIk1CIiwiR0IiLCJyZW1vdmVEZWNpbWFsc1doZW5aZXJvIiwiZGVjaW1hbENvdW50IiwidG9GaXhlZCIsImNyZWF0ZSQyIiwiZmlsZU5hbWUiLCJ1cGRhdGVGaWxlIiwidXBkYXRlRmlsZVNpemVPbkVycm9yIiwiZmlsZUluZm8iLCJESURfTE9BRF9JVEVNIiwiRElEX1VQREFURV9JVEVNX01FVEEiLCJESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SIiwiRElEX1RIUk9XX0lURU1fSU5WQUxJRCIsInRvUGVyY2VudGFnZSIsImNyZWF0ZSQzIiwiZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyIsInRpdGxlIiwiZGlkU2V0SXRlbVByb2Nlc3NQcm9ncmVzcyIsImRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyIsImRpZEFib3J0SXRlbVByb2Nlc3NpbmciLCJkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nIiwiZmlsZVN0YXR1cyIsIkRJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HIiwiRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HIiwiRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORyIsIkRJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkciLCJESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUyIsIkRJRF9VUERBVEVfSVRFTV9MT0FEX1BST0dSRVNTIiwiRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19FUlJPUiIsIkRJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SIiwiRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SIiwiQnV0dG9ucyIsIkFib3J0SXRlbUxvYWQiLCJSZXRyeUl0ZW1Mb2FkIiwiUmVtb3ZlSXRlbSIsIlByb2Nlc3NJdGVtIiwiQWJvcnRJdGVtUHJvY2Vzc2luZyIsIlJldHJ5SXRlbVByb2Nlc3NpbmciLCJSZXZlcnRJdGVtUHJvY2Vzc2luZyIsIkJ1dHRvbktleXMiLCJjYWxjdWxhdGVGaWxlSW5mb09mZnNldCIsImdldFJlbW92ZUluZGljYXRvckFsaWdtZW50IiwiYnV0dG9uUmVjdCIsImJ1dHRvblJlbW92ZUl0ZW0iLCJjYWxjdWxhdGVCdXR0b25XaWR0aCIsImJ1dHRvbkFib3J0SXRlbUxvYWQiLCJjYWxjdWxhdGVGaWxlVmVydGljYWxDZW50ZXJPZmZzZXQiLCJjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldCIsImdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQiLCJnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50IiwiRGVmYXVsdFN0eWxlIiwiYnV0dG9uUmV0cnlJdGVtTG9hZCIsImJ1dHRvblByb2Nlc3NJdGVtIiwiYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZyIsImJ1dHRvblJldHJ5SXRlbVByb2Nlc3NpbmciLCJidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZyIsImxvYWRQcm9ncmVzc0luZGljYXRvciIsInByb2Nlc3NQcm9ncmVzc0luZGljYXRvciIsInByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciIsIklkbGVTdHlsZSIsIlByb2Nlc3NpbmdTdHlsZSIsIlN0eWxlTWFwIiwiRElEX1NUQVJUX0lURU1fTE9BRCIsIkRJRF9TVEFSVF9JVEVNX1JFTU9WRSIsIkRJRF9MT0FEX0xPQ0FMX0lURU0iLCJESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HIiwicHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yVmlldyIsImNyZWF0ZSQ0IiwiTG9jYWxCdXR0b25zIiwicHJldiIsImN1cnIiLCJhbGlnblJlbW92ZUl0ZW1CdXR0b24iLCJidXR0b25GaWx0ZXIiLCJlbmFibGVkQnV0dG9ucyIsImJ1dHRvblZpZXciLCJjbGFzc0xpc3QiLCJzdG9wUHJvcGFnYXRpb24iLCJsb2FkSW5kaWNhdG9yVmlldyIsInByb2dyZXNzSW5kaWNhdG9yVmlldyIsImFjdGl2ZVN0eWxlcyIsIndyaXRlJDIiLCJyb3V0ZSIsInN0eWxlc1RvQXBwbHkiLCJkZWZhdWx0U3R5bGVzIiwiY29udHJvbCIsIkRJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORyIsIkRJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRCIsIkRJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUkVNT1ZBTCIsImJ1dHRvbkFib3J0SXRlbVJlbW92YWwiLCJjcmVhdGUkNSIsImRpZExvYWRJdGVtIiwiZmlsZVdyYXBwZXIiLCJQQU5FTF9TUFJJTkdfUFJPUFMiLCJjcmVhdGUkNiIsInNlY3Rpb24iLCJjcmVhdGVTZWN0aW9uIiwic2NhbGFibGUiLCJ2aWV3Q29uc3RydWN0b3IiLCJ3cml0ZSQzIiwidG9wUmVjdCIsImJvdHRvbVJlY3QiLCJjZW50ZXIiLCJwYW5lbCIsImhlaWdodEN1cnJlbnQiLCJjcmVhdGVEcmFnSGVscGVyIiwiaXRlbUlkcyIsInByZXZJbmRleCIsInNldEluZGV4IiwiZ2V0SW5kZXgiLCJnZXRJdGVtSW5kZXgiLCJJVEVNX1RSQU5TTEFURV9TUFJJTkciLCJJVEVNX1NDQUxFX1NQUklORyIsIlN0YXRlTWFwIiwiY3JlYXRlJDciLCJoYW5kbGVDbGljayIsImNvbnRhaW5lciIsIm1hcmtlZEZvclJlbW92YWwiLCJkcmFnU3RhdGUiLCJncmFiIiwiaXNQcmltYXJ5IiwicmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIiLCJwYWdlWCIsInBhZ2VZIiwiZHJhZ09yaWdpbiIsImRyYWdDZW50ZXIiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImRyYWciLCJwcmV2ZW50RGVmYXVsdCIsImRyYWdPZmZzZXQiLCJkaXN0IiwiZHJvcCIsImNhbmNlbCIsInJvdXRlJDEiLCJESURfVVBEQVRFX1BBTkVMX0hFSUdIVCIsIndyaXRlJDQiLCJESURfR1JBQl9JVEVNIiwiRElEX0RSQUdfSVRFTSIsIkRJRF9EUk9QX0lURU0iLCJjdXJyZW50U3RhdGUiLCJmaWxlcG9uZEl0ZW1TdGF0ZSIsImdldEl0ZW1zUGVyUm93IiwiaG9yaXpvbnRhbFNwYWNlIiwiaXRlbVdpZHRoIiwiZ2V0SXRlbUluZGV4QnlQb3NpdGlvbiIsInBvc2l0aW9uSW5WaWV3IiwibCIsIml0ZW1SZWN0IiwiaXRlbUhvcml6b250YWxNYXJnaW4iLCJpdGVtc1BlclJvdyIsImNoaWxkTWlkIiwiaXRlbVZlcnRpY2FsTWFyZ2luIiwiaXRlbUhlaWdodCIsImluZGV4WCIsImluZGV4WSIsIml0ZW1Ub3AiLCJpdGVtUmlnaHQiLCJpdGVtQm90dG9tIiwiZHJvcEFyZWFEaW1lbnNpb25zIiwiZ2V0SGVpZ2h0Iiwic2V0SGVpZ2h0IiwidmFsIiwiZ2V0V2lkdGgiLCJzZXRXaWR0aCIsInNldERpbWVuc2lvbnMiLCJjcmVhdGUkOCIsImxhc3RJdGVtU3BhbndEYXRlIiwiYWRkSXRlbVZpZXciLCJhZGRJbmRleCIsInNwYXduRGF0ZSIsImNvb2xkb3duIiwibW92ZUl0ZW0iLCJ2eCIsInZ5IiwiaW50cm9JdGVtVmlldyIsInJlbW92ZUl0ZW1WaWV3IiwiZ2V0SXRlbUhlaWdodCIsImdldEl0ZW1XaWR0aCIsImRyYWdJdGVtIiwibnVtSXRlbXMiLCJvbGRJbmRleCIsImRyYWdQb3NpdGlvbiIsImRyYWdIZWlnaHQiLCJkcmFnV2lkdGgiLCJjb2xzIiwiZ2V0R3JpZEluZGV4IiwiZ2V0Q29sSW5kZXgiLCJ2aXNpYmxlQ2hpbGRyZW4iLCJpZHgiLCJjaGlsZEhlaWdodCIsImNoaWxkQm90dG9tIiwiY2hpbGRUb3AiLCJyb3V0ZSQyIiwiRElEX0FERF9JVEVNIiwiRElEX1JFTU9WRV9JVEVNIiwid3JpdGUkNSIsImRyYWdDb29yZGluYXRlcyIsImRyYWdJbmRleCIsImRyYWdJbmRleE9mZnNldCIsInJlbW92ZUluZGV4T2Zmc2V0IiwiYWRkSW5kZXhPZmZzZXQiLCJjaGlsZFJlY3QiLCJ2aXN1YWxIZWlnaHQiLCJwcmV2WCIsInByZXZZIiwidmlzdWFsSW5kZXgiLCJ2ZWN0b3JYIiwic2lnbiIsInZlY3RvclkiLCJmaWx0ZXJTZXRJdGVtQWN0aW9ucyIsImxpc3QiLCJjcmVhdGUkOSIsIm92ZXJmbG93aW5nIiwic3RvcmVEcmFnQ29vcmRpbmF0ZXMiLCJzY29wZUxlZnQiLCJzY29wZVRvcCIsImNsZWFyRHJhZ0Nvb3JkaW5hdGVzIiwicm91dGUkMyIsIkRJRF9EUkFHIiwiRElEX0VORF9EUkFHIiwid3JpdGUkNiIsIm92ZXJmbG93IiwibmV3SGVpZ2h0IiwibGlzdFNjcm9sbGVyIiwiYXR0clRvZ2dsZSIsImVuYWJsZWRWYWx1ZSIsInJlc2V0RmlsZUlucHV0IiwiaW5wdXQiLCJmb3JtIiwiY3JlYXRlJGEiLCJzZXRBY2NlcHRlZEZpbGVUeXBlcyIsInRvZ2dsZUFsbG93TXVsdGlwbGUiLCJ0b2dnbGVEaXJlY3RvcnlGaWx0ZXIiLCJ0b2dnbGVEaXNhYmxlZCIsInRvZ2dsZVJlcXVpcmVkIiwic2V0Q2FwdHVyZU1ldGhvZCIsImhhbmRsZUNoYW5nZSIsIndlYmtpdFJlbGF0aXZlUGF0aCIsImRvZXNBbGxvd0Jyb3dzZSIsImRpc2FibGVGaWVsZCIsInVwZGF0ZVJlcXVpcmVkU3RhdHVzIiwiaGFzSW52YWxpZEZpZWxkIiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJzaG91bGRDaGVja1ZhbGlkaXR5IiwidXBkYXRlRmllbGRWYWxpZGl0eVN0YXR1cyIsImJyb3dzZXIiLCJESURfU0VUX0RJU0FCTEVEIiwiRElEX1NFVF9BTExPV19CUk9XU0UiLCJESURfU0VUX0FMTE9XX0RJUkVDVE9SSUVTX09OTFkiLCJESURfU0VUX0FMTE9XX01VTFRJUExFIiwiRElEX1NFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTIiwiRElEX1NFVF9DQVBUVVJFX01FVEhPRCIsIkRJRF9TRVRfUkVRVUlSRUQiLCJLZXkiLCJFTlRFUiIsIlNQQUNFIiwiY3JlYXRlJGIiLCJoYW5kbGVLZXlEb3duIiwiaXNBY3RpdmF0aW9uS2V5Iiwia2V5Q29kZSIsImNsaWNrIiwiaXNMYWJlbENsaWNrIiwiY29udGFpbnMiLCJ1cGRhdGVMYWJlbFZhbHVlIiwiY2FwdGlvbiIsImNsaWNrYWJsZSIsInF1ZXJ5U2VsZWN0b3IiLCJkcm9wTGFiZWwiLCJESURfU0VUX0xBQkVMX0lETEUiLCJhZGRCbG9iIiwibW92ZUJsb2IiLCJoaWRlQmxvYiIsImV4cGxvZGVCbG9iIiwid3JpdGUkNyIsInJvdXRlJDQiLCJESURfRFJPUCIsImRyaXAiLCJzZXRJbnB1dEZpbGVzIiwiY3JlYXRlJGMiLCJmaWVsZHMiLCJsZWdlbmQiLCJ0ZXh0Q29udGVudCIsImdldEZpZWxkIiwic3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zIiwiZGlkUmVvcmRlckl0ZW1zIiwiZGlkQWRkSXRlbSIsImZpbGVJdGVtIiwiaXNMb2NhbEZpbGUiLCJzaG91bGRVc2VGaWxlSW5wdXQiLCJkYXRhQ29udGFpbmVyIiwiZGlkTG9hZEl0ZW0kMSIsImZpZWxkIiwiZGlkUHJlcGFyZU91dHB1dCIsImRpZFNldERpc2FibGVkIiwiZGlkUmVtb3ZlSXRlbSIsImRpZERlZmluZVZhbHVlIiwid3JpdGUkOCIsIkRJRF9ERUZJTkVfVkFMVUUiLCJESURfUFJFUEFSRV9PVVRQVVQiLCJESURfUkVPUkRFUl9JVEVNUyIsIkRJRF9TT1JUX0lURU1TIiwiZ2V0Um9vdE5vZGUiLCJpbWFnZXMiLCJ0ZXh0JDEiLCJ6aXAiLCJlcHViIiwiZ3Vlc3N0aW1hdGVNaW1lVHlwZSIsInJlcXVlc3REYXRhVHJhbnNmZXJJdGVtcyIsImxpbmtzIiwiZ2V0TGlua3MiLCJoYXNGaWxlcyIsImdldEZpbGVzIiwicHJvbWlzZWRGaWxlcyIsImlzRmlsZVN5c3RlbUl0ZW0iLCJnZXRGaWxlc0Zyb21JdGVtIiwicmV0dXJuZWRGaWxlR3JvdXBzIiwiZ3JvdXAiLCJhcHBseSIsImlzRW50cnkiLCJlbnRyeSIsImdldEFzRW50cnkiLCJpc0RpcmVjdG9yeSIsImtpbmQiLCJpc0RpcmVjdG9yeUVudHJ5IiwiZ2V0RmlsZXNJbkRpcmVjdG9yeSIsImdldEFzRmlsZSIsImRpckNvdW50ZXIiLCJmaWxlQ291bnRlciIsInJlc29sdmVJZkRvbmUiLCJyZWFkRW50cmllcyIsImRpckVudHJ5IiwiZGlyZWN0b3J5UmVhZGVyIiwiY3JlYXRlUmVhZGVyIiwicmVhZEJhdGNoIiwiZW50cmllcyIsImNvcnJlY3RlZEZpbGUiLCJjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlIiwiZnVsbFBhdGgiLCJ3ZWJraXRHZXRBc0VudHJ5IiwiZ2V0TGlua3NGcm9tVHJhbnNmZXJNZXRhRGF0YSIsImdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YSIsImdldERhdGEiLCJkcmFnTkRyb3BPYnNlcnZlcnMiLCJldmVudFBvc2l0aW9uIiwicGFnZUxlZnQiLCJwYWdlVG9wIiwibGF5ZXJYIiwibGF5ZXJZIiwiY3JlYXRlRHJhZ05Ecm9wQ2xpZW50Iiwic2NvcGVUb09ic2VydmUiLCJmaWx0ZXJFbGVtZW50Iiwib2JzZXJ2ZXIiLCJnZXREcmFnTkRyb3BPYnNlcnZlciIsImNsaWVudCIsIm9uZHJvcCIsIm9uZW50ZXIiLCJvbmRyYWciLCJvbmV4aXQiLCJhbGxvd2Ryb3AiLCJhZGRMaXN0ZW5lciIsIm5ld09ic2VydmVyIiwiY3JlYXRlRHJhZ05Ecm9wT2JzZXJ2ZXIiLCJjbGllbnRzIiwiZHJhZ2VudGVyIiwiZHJhZ292ZXIiLCJkcmFnbGVhdmUiLCJoYW5kbGVycyIsImNyZWF0ZUhhbmRsZXIiLCJlbGVtZW50RnJvbVBvaW50IiwicG9pbnQiLCJpc0V2ZW50VGFyZ2V0IiwiZWxlbWVudEF0UG9zaXRpb24iLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiaW5pdGlhbFRhcmdldCIsInNldERyb3BFZmZlY3QiLCJlZmZlY3QiLCJkcm9wRWZmZWN0Iiwib3ZlckRyb3BUYXJnZXQiLCJhbGxvd3NUcmFuc2ZlciIsImNyZWF0ZUhvcHBlciIsInNjb3BlIiwidmFsaWRhdGVJdGVtcyIsImNhdGNoZXNEcm9wc09uUGFnZSIsInJlcXVpcmVzRHJvcE9uRWxlbWVudCIsImZpbHRlckl0ZW1zIiwiZG9jdW1lbnRFbGVtZW50IiwibGFzdFN0YXRlIiwiZmlsdGVyZWRJdGVtcyIsIm9uZHJhZ2VuZCIsIm9uZHJhZ3N0YXJ0IiwidXBkYXRlSG9wcGVyU3RhdGUiLCJob3BwZXJTdGF0ZSIsImxpc3RlbmluZyIsImxpc3RlbmVycyQxIiwiaGFuZGxlUGFzdGUiLCJhY3RpdmVFbCIsImFjdGl2ZUVsZW1lbnQiLCJpc0FjdGl2ZUVsZW1lbnRFZGl0YWJsZSIsIm5vZGVOYW1lIiwiaW5TY29wZSIsImNsaXBib2FyZERhdGEiLCJsaXN0ZW4iLCJ1bmxpc3RlbiIsImNyZWF0ZVBhc3RlciIsImNyZWF0ZSRkIiwiYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0Iiwibm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0IiwiZmlsZW5hbWVzIiwiYXNzaXN0IiwibWVzc2FnZSIsImNsZWFyJDEiLCJsaXN0TW9kaWZpZWQiLCJpc1VzaW5nRmlsZVBvbmQiLCJpdGVtQWRkZWQiLCJpdGVtUmVtb3ZlZCIsIml0ZW1Qcm9jZXNzZWQiLCJpdGVtUHJvY2Vzc2VkVW5kbyIsIml0ZW1FcnJvciIsImFzc2lzdGFudCIsInRvQ2FtZWxzIiwiUmVnRXhwIiwiY2hhckF0IiwiZGVib3VuY2UiLCJmdW5jIiwiaW1taWRpYXRlT25seSIsIk1BWF9GSUxFU19MSU1JVCIsInByZXZlbnQiLCJjcmVhdGUkZSIsIm1lYXN1cmUiLCJib3VuZHMiLCJ3aWR0aFByZXZpb3VzIiwid2lkdGhVcGRhdGVkIiwidXBkYXRlSGlzdG9yeSIsInByZXZpb3VzQXNwZWN0UmF0aW8iLCJjYW5Ib3ZlciIsIm1hdGNoTWVkaWEiLCJoYXNQb2ludGVyRXZlbnRzIiwicGFzc2l2ZSIsImhhc0NyZWRpdHMiLCJmcmFnIiwidGFiSW5kZXgiLCJyZWwiLCJ3cml0ZSQ5Iiwicm91dGUkNSIsImNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodCIsImhvcHBlciIsImlzTXVsdGlJdGVtIiwibWF4SXRlbXMiLCJhdE1heENhcGFjaXR5IiwiYWRkQWN0aW9uIiwibGlzdEl0ZW1NYXJnaW4iLCJjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbiIsImxpc3RIZWlnaHQiLCJjYWxjdWxhdGVMaXN0SGVpZ2h0IiwibGFiZWxIZWlnaHQiLCJjdXJyZW50TGFiZWxIZWlnaHQiLCJsaXN0TWFyZ2luVG9wIiwibGlzdE1hcmdpbkJvdHRvbSIsInZpc3VhbCIsImJvdW5kc0hlaWdodCIsImhpc3RvcnkiLCJNQVhfQk9VTkNFUyIsImJvdW5jZXMiLCJsaXN0QXZhaWxhYmxlSGVpZ2h0IiwiZml4ZWRIZWlnaHQiLCJjYXBwZWRIZWlnaHQiLCJpc0NhcHBlZEhlaWdodCIsInBhbmVsSGVpZ2h0IiwiaXRlbU1hcmdpbiIsInRyYW5zZm9ybSIsInNjcm9sbExpc3QiLCJpdGVtTGlzdCIsIm5ld0l0ZW0iLCJyZW1vdmVkSXRlbSIsInZlcnRpY2FsSXRlbUNvdW50IiwiY2VpbCIsIm1lYXN1cmVIZWlnaHQiLCJtYXhIZWlnaHQiLCJleGNlZWRzTWF4RmlsZXMiLCJ0b3RhbEJyb3dzZUl0ZW1zIiwiaGFzTWF4SXRlbXMiLCJnZXREcmFnSW5kZXgiLCJ0b2dnbGVEcm9wIiwiaXNBbGxvd2VkIiwiZW5hYmxlZCIsInRvZ2dsZUJyb3dzZSIsInRvZ2dsZVBhc3RlIiwicGFzdGVyIiwiRElEX1NFVF9BTExPV19EUk9QIiwiRElEX1NFVF9BTExPV19QQVNURSIsImNyZWF0ZUFwcCIsImluaXRpYWxPcHRpb25zIiwib3JpZ2luYWxFbGVtZW50IiwidmlzaWJpbGl0eUhhbmRsZXIiLCJyZXNpemVEb25lVGltZXIiLCJpc1Jlc2l6aW5nIiwiaXNSZXNpemluZ0hvcml6b250YWxseSIsImluaXRpYWxXaW5kb3dXaWR0aCIsImN1cnJlbnRXaW5kb3dXaWR0aCIsInJlc2l6ZUhhbmRsZXIiLCJpc0hpZGRlbiIsInJlYWRXcml0ZUFwaSIsImlubmVyV2lkdGgiLCJyb3V0ZUFjdGlvbnNUb0V2ZW50cyIsImNyZWF0ZUV2ZW50IiwiZXZlbnRSb3V0ZXMiLCJESURfREVTVFJPWSIsIkRJRF9JTklUIiwiRElEX1RIUk9XX01BWF9GSUxFUyIsIkRJRF9JTklUX0lURU0iLCJESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HX0FMTCIsIkRJRF9VUERBVEVfSVRFTVMiLCJESURfQUNUSVZBVEVfSVRFTSIsImV4cG9zZUV2ZW50IiwiZGV0YWlsIiwicG9uZCIsImV4cG9ydHMiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNvbXBvc2VkIiwiZmlsdGVyZWQiLCJwcmVwYXJlRmlsZSIsImFkZEZpbGUiLCJhZGRGaWxlcyIsImlzRmlsZVBvbmRGaWxlIiwicmVtb3ZlRmlsZSIsInNvdXJjZXMiLCJsYXN0QXJndW1lbnQiLCJwcm9jZXNzRmlsZSIsInByZXBhcmVGaWxlcyIsInByb2Nlc3NGaWxlcyIsInJlbW92ZUZpbGVzIiwibWFwcGVkUXVlcmllcyIsInEiLCJtb3ZlRmlsZSIsImJyb3dzZSIsImFwcGVuZFRvIiwicmVwbGFjZUVsZW1lbnQiLCJyZXN0b3JlRWxlbWVudCIsImlzQXR0YWNoZWRUbyIsImNyZWF0ZUFwcE9iamVjdCIsImN1c3RvbU9wdGlvbnMiLCJhcHAiLCJsb3dlckNhc2VGaXJzdExldHRlciIsImF0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZSIsImF0dHJpYnV0ZU5hbWUiLCJtYXBPYmplY3QiLCJwcm9wZXJ0eU1hcCIsInNlbGVjdG9yIiwibWFwcGluZyIsInNlbGVjdG9yUmVnRXhwIiwiZ2V0QXR0cmlidXRlc0FzT2JqZWN0IiwiYXR0cmlidXRlTWFwcGluZyIsImF0dHJpYnV0ZSIsImNyZWF0ZUFwcEF0RWxlbWVudCIsIm1lcmdlZE9wdGlvbnMiLCJhdHRyaWJ1dGVPcHRpb25zIiwicXVlcnlTZWxlY3RvckFsbCIsImNyZWF0ZUFwcCQxIiwiUFJJVkFURV9NRVRIT0RTIiwiY3JlYXRlQXBwQVBJIiwicmVwbGFjZUluU3RyaW5nIiwicmVwbGFjZW1lbnRzIiwiY3JlYXRlV29ya2VyIiwid29ya2VyQmxvYiIsIndvcmtlclVSTCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIndvcmtlciIsIldvcmtlciIsInBvc3QiLCJ0cmFuc2Zlckxpc3QiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsInRlcm1pbmF0ZSIsInJldm9rZU9iamVjdFVSTCIsImxvYWRJbWFnZSIsImltZyIsIkltYWdlIiwicmVuYW1lRmlsZSIsInJlbmFtZWRGaWxlIiwiY29weUZpbGUiLCJyZWdpc3RlcmVkUGx1Z2lucyIsImNyZWF0ZUFwcFBsdWdpbiIsInBsdWdpbiIsInBsdWdpbk91dGxpbmUiLCJ2aWV3cyIsImlzT3BlcmFNaW5pIiwicHJvdG90eXBlIiwiY2FsbCIsIm9wZXJhbWluaSIsImhhc1Byb21pc2VzIiwiaGFzQmxvYlNsaWNlIiwiaGFzQ3JlYXRlT2JqZWN0VVJMIiwiaGFzVmlzaWJpbGl0eSIsImhhc1RpbWluZyIsImhhc0NTU1N1cHBvcnRzIiwiQ1NTIiwiaXNJRTExIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwic3VwcG9ydGVkIiwiaXNTdXBwb3J0ZWQiLCJhcHBzIiwiU3RhdHVzJDEiLCJGaWxlU3RhdHVzIiwiRmlsZU9yaWdpbiQxIiwiT3B0aW9uVHlwZXMiLCJjcmVhdGUkZiIsInJlZ2lzdGVyUGx1Z2luIiwiZ2V0T3B0aW9ucyQxIiwic2V0T3B0aW9ucyQxIiwidXBkYXRlT3B0aW9uVHlwZXMiLCJob29rIiwiaW5kZXhUb1JlbW92ZSIsImNvbnRleHQiLCJtYXRjaGVkSG9va3MiLCJuZXdIb29rcyIsIm5ld0hvb2siLCJwbHVnaW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond/dist/filepond.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"02888899690d\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmluLWV4dHJhY3Rvci8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC9kaXN0L2ZpbGVwb25kLm1pbi5jc3M/Y2U1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjAyODg4ODk5NjkwZFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond/dist/filepond.min.css\n");

/***/ })

};
;