"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/filepond";
exports.ids = ["vendor-chunks/filepond"];
exports.modules = {

/***/ "(ssr)/./node_modules/filepond/dist/filepond.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileOrigin: () => (/* binding */ FileOrigin$1),\n/* harmony export */   FileStatus: () => (/* binding */ FileStatus),\n/* harmony export */   OptionTypes: () => (/* binding */ OptionTypes),\n/* harmony export */   Status: () => (/* binding */ Status$1),\n/* harmony export */   create: () => (/* binding */ create$f),\n/* harmony export */   destroy: () => (/* binding */ destroy),\n/* harmony export */   find: () => (/* binding */ find),\n/* harmony export */   getOptions: () => (/* binding */ getOptions$1),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   registerPlugin: () => (/* binding */ registerPlugin),\n/* harmony export */   setOptions: () => (/* binding */ setOptions$1),\n/* harmony export */   supported: () => (/* binding */ supported)\n/* harmony export */ });\n/*!\n * FilePond 4.32.6\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */ /* eslint-disable */ const isNode = (value)=>value instanceof HTMLElement;\nconst createStore = (initialState, queries = [], actions = [])=>{\n    // internal state\n    const state = {\n        ...initialState\n    };\n    // contains all actions for next frame, is clear when actions are requested\n    const actionQueue = [];\n    const dispatchQueue = [];\n    // returns a duplicate of the current state\n    const getState = ()=>({\n            ...state\n        });\n    // returns a duplicate of the actions array and clears the actions array\n    const processActionQueue = ()=>{\n        // create copy of actions queue\n        const queue = [\n            ...actionQueue\n        ];\n        // clear actions queue (we don't want no double actions)\n        actionQueue.length = 0;\n        return queue;\n    };\n    // processes actions that might block the main UI thread\n    const processDispatchQueue = ()=>{\n        // create copy of actions queue\n        const queue = [\n            ...dispatchQueue\n        ];\n        // clear actions queue (we don't want no double actions)\n        dispatchQueue.length = 0;\n        // now dispatch these actions\n        queue.forEach(({ type, data })=>{\n            dispatch(type, data);\n        });\n    };\n    // adds a new action, calls its handler and\n    const dispatch = (type, data, isBlocking)=>{\n        // is blocking action (should never block if document is hidden)\n        if (isBlocking && !document.hidden) {\n            dispatchQueue.push({\n                type,\n                data\n            });\n            return;\n        }\n        // if this action has a handler, handle the action\n        if (actionHandlers[type]) {\n            actionHandlers[type](data);\n        }\n        // now add action\n        actionQueue.push({\n            type,\n            data\n        });\n    };\n    const query = (str, ...args)=>queryHandles[str] ? queryHandles[str](...args) : null;\n    const api = {\n        getState,\n        processActionQueue,\n        processDispatchQueue,\n        dispatch,\n        query\n    };\n    let queryHandles = {};\n    queries.forEach((query)=>{\n        queryHandles = {\n            ...query(state),\n            ...queryHandles\n        };\n    });\n    let actionHandlers = {};\n    actions.forEach((action)=>{\n        actionHandlers = {\n            ...action(dispatch, query, state),\n            ...actionHandlers\n        };\n    });\n    return api;\n};\nconst defineProperty = (obj, property, definition)=>{\n    if (typeof definition === \"function\") {\n        obj[property] = definition;\n        return;\n    }\n    Object.defineProperty(obj, property, {\n        ...definition\n    });\n};\nconst forin = (obj, cb)=>{\n    for(const key in obj){\n        if (!obj.hasOwnProperty(key)) {\n            continue;\n        }\n        cb(key, obj[key]);\n    }\n};\nconst createObject = (definition)=>{\n    const obj = {};\n    forin(definition, (property)=>{\n        defineProperty(obj, property, definition[property]);\n    });\n    return obj;\n};\nconst attr = (node, name, value = null)=>{\n    if (value === null) {\n        return node.getAttribute(name) || node.hasAttribute(name);\n    }\n    node.setAttribute(name, value);\n};\nconst ns = \"http://www.w3.org/2000/svg\";\nconst svgElements = [\n    \"svg\",\n    \"path\"\n]; // only svg elements used\nconst isSVGElement = (tag)=>svgElements.includes(tag);\nconst createElement = (tag, className, attributes = {})=>{\n    if (typeof className === \"object\") {\n        attributes = className;\n        className = null;\n    }\n    const element = isSVGElement(tag) ? document.createElementNS(ns, tag) : document.createElement(tag);\n    if (className) {\n        if (isSVGElement(tag)) {\n            attr(element, \"class\", className);\n        } else {\n            element.className = className;\n        }\n    }\n    forin(attributes, (name, value)=>{\n        attr(element, name, value);\n    });\n    return element;\n};\nconst appendChild = (parent)=>(child, index)=>{\n        if (typeof index !== \"undefined\" && parent.children[index]) {\n            parent.insertBefore(child, parent.children[index]);\n        } else {\n            parent.appendChild(child);\n        }\n    };\nconst appendChildView = (parent, childViews)=>(view, index)=>{\n        if (typeof index !== \"undefined\") {\n            childViews.splice(index, 0, view);\n        } else {\n            childViews.push(view);\n        }\n        return view;\n    };\nconst removeChildView = (parent, childViews)=>(view)=>{\n        // remove from child views\n        childViews.splice(childViews.indexOf(view), 1);\n        // remove the element\n        if (view.element.parentNode) {\n            parent.removeChild(view.element);\n        }\n        return view;\n    };\nconst IS_BROWSER = (()=> false && 0)();\nconst isBrowser = ()=>IS_BROWSER;\nconst testElement = isBrowser() ? createElement(\"svg\") : {};\nconst getChildCount = \"children\" in testElement ? (el)=>el.children.length : (el)=>el.childNodes.length;\nconst getViewRect = (elementRect, childViews, offset, scale)=>{\n    const left = offset[0] || elementRect.left;\n    const top = offset[1] || elementRect.top;\n    const right = left + elementRect.width;\n    const bottom = top + elementRect.height * (scale[1] || 1);\n    const rect = {\n        // the rectangle of the element itself\n        element: {\n            ...elementRect\n        },\n        // the rectangle of the element expanded to contain its children, does not include any margins\n        inner: {\n            left: elementRect.left,\n            top: elementRect.top,\n            right: elementRect.right,\n            bottom: elementRect.bottom\n        },\n        // the rectangle of the element expanded to contain its children including own margin and child margins\n        // margins will be added after we've recalculated the size\n        outer: {\n            left,\n            top,\n            right,\n            bottom\n        }\n    };\n    // expand rect to fit all child rectangles\n    childViews.filter((childView)=>!childView.isRectIgnored()).map((childView)=>childView.rect).forEach((childViewRect)=>{\n        expandRect(rect.inner, {\n            ...childViewRect.inner\n        });\n        expandRect(rect.outer, {\n            ...childViewRect.outer\n        });\n    });\n    // calculate inner width and height\n    calculateRectSize(rect.inner);\n    // append additional margin (top and left margins are included in top and left automatically)\n    rect.outer.bottom += rect.element.marginBottom;\n    rect.outer.right += rect.element.marginRight;\n    // calculate outer width and height\n    calculateRectSize(rect.outer);\n    return rect;\n};\nconst expandRect = (parent, child)=>{\n    // adjust for parent offset\n    child.top += parent.top;\n    child.right += parent.left;\n    child.bottom += parent.top;\n    child.left += parent.left;\n    if (child.bottom > parent.bottom) {\n        parent.bottom = child.bottom;\n    }\n    if (child.right > parent.right) {\n        parent.right = child.right;\n    }\n};\nconst calculateRectSize = (rect)=>{\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n};\nconst isNumber = (value)=>typeof value === \"number\";\n/**\n * Determines if position is at destination\n * @param position\n * @param destination\n * @param velocity\n * @param errorMargin\n * @returns {boolean}\n */ const thereYet = (position, destination, velocity, errorMargin = 0.001)=>{\n    return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;\n};\n/**\n * Spring animation\n */ const spring = // default options\n({ stiffness = 0.5, damping = 0.75, mass = 10 } = {})=>// method definition\n{\n    let target = null;\n    let position = null;\n    let velocity = 0;\n    let resting = false;\n    // updates spring state\n    const interpolate = (ts, skipToEndState)=>{\n        // in rest, don't animate\n        if (resting) return;\n        // need at least a target or position to do springy things\n        if (!(isNumber(target) && isNumber(position))) {\n            resting = true;\n            velocity = 0;\n            return;\n        }\n        // calculate spring force\n        const f = -(position - target) * stiffness;\n        // update velocity by adding force based on mass\n        velocity += f / mass;\n        // update position by adding velocity\n        position += velocity;\n        // slow down based on amount of damping\n        velocity *= damping;\n        // we've arrived if we're near target and our velocity is near zero\n        if (thereYet(position, target, velocity) || skipToEndState) {\n            position = target;\n            velocity = 0;\n            resting = true;\n            // we done\n            api.onupdate(position);\n            api.oncomplete(position);\n        } else {\n            // progress update\n            api.onupdate(position);\n        }\n    };\n    /**\n             * Set new target value\n             * @param value\n             */ const setTarget = (value)=>{\n        // if currently has no position, set target and position to this value\n        if (isNumber(value) && !isNumber(position)) {\n            position = value;\n        }\n        // next target value will not be animated to\n        if (target === null) {\n            target = value;\n            position = value;\n        }\n        // let start moving to target\n        target = value;\n        // already at target\n        if (position === target || typeof target === \"undefined\") {\n            // now resting as target is current position, stop moving\n            resting = true;\n            velocity = 0;\n            // done!\n            api.onupdate(position);\n            api.oncomplete(position);\n            return;\n        }\n        resting = false;\n    };\n    // need 'api' to call onupdate callback\n    const api = createObject({\n        interpolate,\n        target: {\n            set: setTarget,\n            get: ()=>target\n        },\n        resting: {\n            get: ()=>resting\n        },\n        onupdate: (value)=>{},\n        oncomplete: (value)=>{}\n    });\n    return api;\n};\nconst easeLinear = (t)=>t;\nconst easeInOutQuad = (t)=>t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\nconst tween = // default values\n({ duration = 500, easing = easeInOutQuad, delay = 0 } = {})=>// method definition\n{\n    let start = null;\n    let t;\n    let p;\n    let resting = true;\n    let reverse = false;\n    let target = null;\n    const interpolate = (ts, skipToEndState)=>{\n        if (resting || target === null) return;\n        if (start === null) {\n            start = ts;\n        }\n        if (ts - start < delay) return;\n        t = ts - start - delay;\n        if (t >= duration || skipToEndState) {\n            t = 1;\n            p = reverse ? 0 : 1;\n            api.onupdate(p * target);\n            api.oncomplete(p * target);\n            resting = true;\n        } else {\n            p = t / duration;\n            api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);\n        }\n    };\n    // need 'api' to call onupdate callback\n    const api = createObject({\n        interpolate,\n        target: {\n            get: ()=>reverse ? 0 : target,\n            set: (value)=>{\n                // is initial value\n                if (target === null) {\n                    target = value;\n                    api.onupdate(value);\n                    api.oncomplete(value);\n                    return;\n                }\n                // want to tween to a smaller value and have a current value\n                if (value < target) {\n                    target = 1;\n                    reverse = true;\n                } else {\n                    // not tweening to a smaller value\n                    reverse = false;\n                    target = value;\n                }\n                // let's go!\n                resting = false;\n                start = null;\n            }\n        },\n        resting: {\n            get: ()=>resting\n        },\n        onupdate: (value)=>{},\n        oncomplete: (value)=>{}\n    });\n    return api;\n};\nconst animator = {\n    spring,\n    tween\n};\n/*\n { type: 'spring', stiffness: .5, damping: .75, mass: 10 };\n { translation: { type: 'spring', ... }, ... }\n { translation: { x: { type: 'spring', ... } } }\n*/ const createAnimator = (definition, category, property)=>{\n    // default is single definition\n    // we check if transform is set, if so, we check if property is set\n    const def = definition[category] && typeof definition[category][property] === \"object\" ? definition[category][property] : definition[category] || definition;\n    const type = typeof def === \"string\" ? def : def.type;\n    const props = typeof def === \"object\" ? {\n        ...def\n    } : {};\n    return animator[type] ? animator[type](props) : null;\n};\nconst addGetSet = (keys, obj, props, overwrite = false)=>{\n    obj = Array.isArray(obj) ? obj : [\n        obj\n    ];\n    obj.forEach((o)=>{\n        keys.forEach((key)=>{\n            let name = key;\n            let getter = ()=>props[key];\n            let setter = (value)=>props[key] = value;\n            if (typeof key === \"object\") {\n                name = key.key;\n                getter = key.getter || getter;\n                setter = key.setter || setter;\n            }\n            if (o[name] && !overwrite) {\n                return;\n            }\n            o[name] = {\n                get: getter,\n                set: setter\n            };\n        });\n    });\n};\n// add to state,\n// add getters and setters to internal and external api (if not set)\n// setup animators\nconst animations = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI })=>{\n    // initial properties\n    const initialProps = {\n        ...viewProps\n    };\n    // list of all active animations\n    const animations = [];\n    // setup animators\n    forin(mixinConfig, (property, animation)=>{\n        const animator = createAnimator(animation);\n        if (!animator) {\n            return;\n        }\n        // when the animator updates, update the view state value\n        animator.onupdate = (value)=>{\n            viewProps[property] = value;\n        };\n        // set animator target\n        animator.target = initialProps[property];\n        // when value is set, set the animator target value\n        const prop = {\n            key: property,\n            setter: (value)=>{\n                // if already at target, we done!\n                if (animator.target === value) {\n                    return;\n                }\n                animator.target = value;\n            },\n            getter: ()=>viewProps[property]\n        };\n        // add getters and setters\n        addGetSet([\n            prop\n        ], [\n            viewInternalAPI,\n            viewExternalAPI\n        ], viewProps, true);\n        // add it to the list for easy updating from the _write method\n        animations.push(animator);\n    });\n    // expose internal write api\n    return {\n        write: (ts)=>{\n            let skipToEndState = document.hidden;\n            let resting = true;\n            animations.forEach((animation)=>{\n                if (!animation.resting) resting = false;\n                animation.interpolate(ts, skipToEndState);\n            });\n            return resting;\n        },\n        destroy: ()=>{}\n    };\n};\nconst addEvent = (element)=>(type, fn)=>{\n        element.addEventListener(type, fn);\n    };\nconst removeEvent = (element)=>(type, fn)=>{\n        element.removeEventListener(type, fn);\n    };\n// mixin\nconst listeners = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, viewState, view })=>{\n    const events = [];\n    const add = addEvent(view.element);\n    const remove = removeEvent(view.element);\n    viewExternalAPI.on = (type, fn)=>{\n        events.push({\n            type,\n            fn\n        });\n        add(type, fn);\n    };\n    viewExternalAPI.off = (type, fn)=>{\n        events.splice(events.findIndex((event)=>event.type === type && event.fn === fn), 1);\n        remove(type, fn);\n    };\n    return {\n        write: ()=>{\n            // not busy\n            return true;\n        },\n        destroy: ()=>{\n            events.forEach((event)=>{\n                remove(event.type, event.fn);\n            });\n        }\n    };\n};\n// add to external api and link to props\nconst apis = ({ mixinConfig, viewProps, viewExternalAPI })=>{\n    addGetSet(mixinConfig, viewExternalAPI, viewProps);\n};\nconst isDefined = (value)=>value != null;\n// add to state,\n// add getters and setters to internal and external api (if not set)\n// set initial state based on props in viewProps\n// apply as transforms each frame\nconst defaults = {\n    opacity: 1,\n    scaleX: 1,\n    scaleY: 1,\n    translateX: 0,\n    translateY: 0,\n    rotateX: 0,\n    rotateY: 0,\n    rotateZ: 0,\n    originX: 0,\n    originY: 0\n};\nconst styles = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, view })=>{\n    // initial props\n    const initialProps = {\n        ...viewProps\n    };\n    // current props\n    const currentProps = {};\n    // we will add those properties to the external API and link them to the viewState\n    addGetSet(mixinConfig, [\n        viewInternalAPI,\n        viewExternalAPI\n    ], viewProps);\n    // override rect on internal and external rect getter so it takes in account transforms\n    const getOffset = ()=>[\n            viewProps[\"translateX\"] || 0,\n            viewProps[\"translateY\"] || 0\n        ];\n    const getScale = ()=>[\n            viewProps[\"scaleX\"] || 0,\n            viewProps[\"scaleY\"] || 0\n        ];\n    const getRect = ()=>view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;\n    viewInternalAPI.rect = {\n        get: getRect\n    };\n    viewExternalAPI.rect = {\n        get: getRect\n    };\n    // apply view props\n    mixinConfig.forEach((key)=>{\n        viewProps[key] = typeof initialProps[key] === \"undefined\" ? defaults[key] : initialProps[key];\n    });\n    // expose api\n    return {\n        write: ()=>{\n            // see if props have changed\n            if (!propsHaveChanged(currentProps, viewProps)) {\n                return;\n            }\n            // moves element to correct position on screen\n            applyStyles(view.element, viewProps);\n            // store new transforms\n            Object.assign(currentProps, {\n                ...viewProps\n            });\n            // no longer busy\n            return true;\n        },\n        destroy: ()=>{}\n    };\n};\nconst propsHaveChanged = (currentProps, newProps)=>{\n    // different amount of keys\n    if (Object.keys(currentProps).length !== Object.keys(newProps).length) {\n        return true;\n    }\n    // lets analyze the individual props\n    for(const prop in newProps){\n        if (newProps[prop] !== currentProps[prop]) {\n            return true;\n        }\n    }\n    return false;\n};\nconst applyStyles = (element, { opacity, perspective, translateX, translateY, scaleX, scaleY, rotateX, rotateY, rotateZ, originX, originY, width, height })=>{\n    let transforms = \"\";\n    let styles = \"\";\n    // handle transform origin\n    if (isDefined(originX) || isDefined(originY)) {\n        styles += `transform-origin: ${originX || 0}px ${originY || 0}px;`;\n    }\n    // transform order is relevant\n    // 0. perspective\n    if (isDefined(perspective)) {\n        transforms += `perspective(${perspective}px) `;\n    }\n    // 1. translate\n    if (isDefined(translateX) || isDefined(translateY)) {\n        transforms += `translate3d(${translateX || 0}px, ${translateY || 0}px, 0) `;\n    }\n    // 2. scale\n    if (isDefined(scaleX) || isDefined(scaleY)) {\n        transforms += `scale3d(${isDefined(scaleX) ? scaleX : 1}, ${isDefined(scaleY) ? scaleY : 1}, 1) `;\n    }\n    // 3. rotate\n    if (isDefined(rotateZ)) {\n        transforms += `rotateZ(${rotateZ}rad) `;\n    }\n    if (isDefined(rotateX)) {\n        transforms += `rotateX(${rotateX}rad) `;\n    }\n    if (isDefined(rotateY)) {\n        transforms += `rotateY(${rotateY}rad) `;\n    }\n    // add transforms\n    if (transforms.length) {\n        styles += `transform:${transforms};`;\n    }\n    // add opacity\n    if (isDefined(opacity)) {\n        styles += `opacity:${opacity};`;\n        // if we reach zero, we make the element inaccessible\n        if (opacity === 0) {\n            styles += `visibility:hidden;`;\n        }\n        // if we're below 100% opacity this element can't be clicked\n        if (opacity < 1) {\n            styles += `pointer-events:none;`;\n        }\n    }\n    // add height\n    if (isDefined(height)) {\n        styles += `height:${height}px;`;\n    }\n    // add width\n    if (isDefined(width)) {\n        styles += `width:${width}px;`;\n    }\n    // apply styles\n    const elementCurrentStyle = element.elementCurrentStyle || \"\";\n    // if new styles does not match current styles, lets update!\n    if (styles.length !== elementCurrentStyle.length || styles !== elementCurrentStyle) {\n        element.style.cssText = styles;\n        // store current styles so we can compare them to new styles later on\n        // _not_ getting the style value is faster\n        element.elementCurrentStyle = styles;\n    }\n};\nconst Mixins = {\n    styles,\n    listeners,\n    animations,\n    apis\n};\nconst updateRect = (rect = {}, element = {}, style = {})=>{\n    if (!element.layoutCalculated) {\n        rect.paddingTop = parseInt(style.paddingTop, 10) || 0;\n        rect.marginTop = parseInt(style.marginTop, 10) || 0;\n        rect.marginRight = parseInt(style.marginRight, 10) || 0;\n        rect.marginBottom = parseInt(style.marginBottom, 10) || 0;\n        rect.marginLeft = parseInt(style.marginLeft, 10) || 0;\n        element.layoutCalculated = true;\n    }\n    rect.left = element.offsetLeft || 0;\n    rect.top = element.offsetTop || 0;\n    rect.width = element.offsetWidth || 0;\n    rect.height = element.offsetHeight || 0;\n    rect.right = rect.left + rect.width;\n    rect.bottom = rect.top + rect.height;\n    rect.scrollTop = element.scrollTop;\n    rect.hidden = element.offsetParent === null;\n    return rect;\n};\nconst createView = // default view definition\n({ // element definition\ntag = \"div\", name = null, attributes = {}, // view interaction\nread = ()=>{}, write = ()=>{}, create = ()=>{}, destroy = ()=>{}, // hooks\nfilterFrameActionsForChild = (child, actions)=>actions, didCreateView = ()=>{}, didWriteView = ()=>{}, // rect related\nignoreRect = false, ignoreRectUpdate = false, // mixins\nmixins = [] } = {})=>(// each view requires reference to store\n    store, // specific properties for this view\n    props = {})=>{\n        // root element should not be changed\n        const element = createElement(tag, `filepond--${name}`, attributes);\n        // style reference should also not be changed\n        const style = window.getComputedStyle(element, null);\n        // element rectangle\n        const rect = updateRect();\n        let frameRect = null;\n        // rest state\n        let isResting = false;\n        // pretty self explanatory\n        const childViews = [];\n        // loaded mixins\n        const activeMixins = [];\n        // references to created children\n        const ref = {};\n        // state used for each instance\n        const state = {};\n        // list of writers that will be called to update this view\n        const writers = [\n            write\n        ];\n        const readers = [\n            read\n        ];\n        const destroyers = [\n            destroy\n        ];\n        // core view methods\n        const getElement = ()=>element;\n        const getChildViews = ()=>childViews.concat();\n        const getReference = ()=>ref;\n        const createChildView = (store)=>(view, props)=>view(store, props);\n        const getRect = ()=>{\n            if (frameRect) {\n                return frameRect;\n            }\n            frameRect = getViewRect(rect, childViews, [\n                0,\n                0\n            ], [\n                1,\n                1\n            ]);\n            return frameRect;\n        };\n        const getStyle = ()=>style;\n        /**\n         * Read data from DOM\n         * @private\n         */ const _read = ()=>{\n            frameRect = null;\n            // read child views\n            childViews.forEach((child)=>child._read());\n            const shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);\n            if (shouldUpdate) {\n                updateRect(rect, element, style);\n            }\n            // readers\n            const api = {\n                root: internalAPI,\n                props,\n                rect\n            };\n            readers.forEach((reader)=>reader(api));\n        };\n        /**\n         * Write data to DOM\n         * @private\n         */ const _write = (ts, frameActions, shouldOptimize)=>{\n            // if no actions, we assume that the view is resting\n            let resting = frameActions.length === 0;\n            // writers\n            writers.forEach((writer)=>{\n                const writerResting = writer({\n                    props,\n                    root: internalAPI,\n                    actions: frameActions,\n                    timestamp: ts,\n                    shouldOptimize\n                });\n                if (writerResting === false) {\n                    resting = false;\n                }\n            });\n            // run mixins\n            activeMixins.forEach((mixin)=>{\n                // if one of the mixins is still busy after write operation, we are not resting\n                const mixinResting = mixin.write(ts);\n                if (mixinResting === false) {\n                    resting = false;\n                }\n            });\n            // updates child views that are currently attached to the DOM\n            childViews.filter((child)=>!!child.element.parentNode).forEach((child)=>{\n                // if a child view is not resting, we are not resting\n                const childResting = child._write(ts, filterFrameActionsForChild(child, frameActions), shouldOptimize);\n                if (!childResting) {\n                    resting = false;\n                }\n            });\n            // append new elements to DOM and update those\n            childViews//.filter(child => !child.element.parentNode)\n            .forEach((child, index)=>{\n                // skip\n                if (child.element.parentNode) {\n                    return;\n                }\n                // append to DOM\n                internalAPI.appendChild(child.element, index);\n                // call read (need to know the size of these elements)\n                child._read();\n                // re-call write\n                child._write(ts, filterFrameActionsForChild(child, frameActions), shouldOptimize);\n                // we just added somthing to the dom, no rest\n                resting = false;\n            });\n            // update resting state\n            isResting = resting;\n            didWriteView({\n                props,\n                root: internalAPI,\n                actions: frameActions,\n                timestamp: ts\n            });\n            // let parent know if we are resting\n            return resting;\n        };\n        const _destroy = ()=>{\n            activeMixins.forEach((mixin)=>mixin.destroy());\n            destroyers.forEach((destroyer)=>{\n                destroyer({\n                    root: internalAPI,\n                    props\n                });\n            });\n            childViews.forEach((child)=>child._destroy());\n        };\n        // sharedAPI\n        const sharedAPIDefinition = {\n            element: {\n                get: getElement\n            },\n            style: {\n                get: getStyle\n            },\n            childViews: {\n                get: getChildViews\n            }\n        };\n        // private API definition\n        const internalAPIDefinition = {\n            ...sharedAPIDefinition,\n            rect: {\n                get: getRect\n            },\n            // access to custom children references\n            ref: {\n                get: getReference\n            },\n            // dom modifiers\n            is: (needle)=>name === needle,\n            appendChild: appendChild(element),\n            createChildView: createChildView(store),\n            linkView: (view)=>{\n                childViews.push(view);\n                return view;\n            },\n            unlinkView: (view)=>{\n                childViews.splice(childViews.indexOf(view), 1);\n            },\n            appendChildView: appendChildView(element, childViews),\n            removeChildView: removeChildView(element, childViews),\n            registerWriter: (writer)=>writers.push(writer),\n            registerReader: (reader)=>readers.push(reader),\n            registerDestroyer: (destroyer)=>destroyers.push(destroyer),\n            invalidateLayout: ()=>element.layoutCalculated = false,\n            // access to data store\n            dispatch: store.dispatch,\n            query: store.query\n        };\n        // public view API methods\n        const externalAPIDefinition = {\n            element: {\n                get: getElement\n            },\n            childViews: {\n                get: getChildViews\n            },\n            rect: {\n                get: getRect\n            },\n            resting: {\n                get: ()=>isResting\n            },\n            isRectIgnored: ()=>ignoreRect,\n            _read,\n            _write,\n            _destroy\n        };\n        // mixin API methods\n        const mixinAPIDefinition = {\n            ...sharedAPIDefinition,\n            rect: {\n                get: ()=>rect\n            }\n        };\n        // add mixin functionality\n        Object.keys(mixins).sort((a, b)=>{\n            // move styles to the back of the mixin list (so adjustments of other mixins are applied to the props correctly)\n            if (a === \"styles\") {\n                return 1;\n            } else if (b === \"styles\") {\n                return -1;\n            }\n            return 0;\n        }).forEach((key)=>{\n            const mixinAPI = Mixins[key]({\n                mixinConfig: mixins[key],\n                viewProps: props,\n                viewState: state,\n                viewInternalAPI: internalAPIDefinition,\n                viewExternalAPI: externalAPIDefinition,\n                view: createObject(mixinAPIDefinition)\n            });\n            if (mixinAPI) {\n                activeMixins.push(mixinAPI);\n            }\n        });\n        // construct private api\n        const internalAPI = createObject(internalAPIDefinition);\n        // create the view\n        create({\n            root: internalAPI,\n            props\n        });\n        // append created child views to root node\n        const childCount = getChildCount(element); // need to know the current child count so appending happens in correct order\n        childViews.forEach((child, index)=>{\n            internalAPI.appendChild(child.element, childCount + index);\n        });\n        // call did create\n        didCreateView(internalAPI);\n        // expose public api\n        return createObject(externalAPIDefinition);\n    };\nconst createPainter = (read, write, fps = 60)=>{\n    const name = \"__framePainter\";\n    // set global painter\n    if (window[name]) {\n        window[name].readers.push(read);\n        window[name].writers.push(write);\n        return;\n    }\n    window[name] = {\n        readers: [\n            read\n        ],\n        writers: [\n            write\n        ]\n    };\n    const painter = window[name];\n    const interval = 1000 / fps;\n    let last = null;\n    let id = null;\n    let requestTick = null;\n    let cancelTick = null;\n    const setTimerType = ()=>{\n        if (document.hidden) {\n            requestTick = ()=>window.setTimeout(()=>tick(performance.now()), interval);\n            cancelTick = ()=>window.clearTimeout(id);\n        } else {\n            requestTick = ()=>window.requestAnimationFrame(tick);\n            cancelTick = ()=>window.cancelAnimationFrame(id);\n        }\n    };\n    document.addEventListener(\"visibilitychange\", ()=>{\n        if (cancelTick) cancelTick();\n        setTimerType();\n        tick(performance.now());\n    });\n    const tick = (ts)=>{\n        // queue next tick\n        id = requestTick(tick);\n        // limit fps\n        if (!last) {\n            last = ts;\n        }\n        const delta = ts - last;\n        if (delta <= interval) {\n            // skip frame\n            return;\n        }\n        // align next frame\n        last = ts - delta % interval;\n        // update view\n        painter.readers.forEach((read)=>read());\n        painter.writers.forEach((write)=>write(ts));\n    };\n    setTimerType();\n    tick(performance.now());\n    return {\n        pause: ()=>{\n            cancelTick(id);\n        }\n    };\n};\nconst createRoute = (routes, fn)=>({ root, props, actions = [], timestamp, shouldOptimize })=>{\n        actions.filter((action)=>routes[action.type]).forEach((action)=>routes[action.type]({\n                root,\n                props,\n                action: action.data,\n                timestamp,\n                shouldOptimize\n            }));\n        if (fn) {\n            fn({\n                root,\n                props,\n                actions,\n                timestamp,\n                shouldOptimize\n            });\n        }\n    };\nconst insertBefore = (newNode, referenceNode)=>referenceNode.parentNode.insertBefore(newNode, referenceNode);\nconst insertAfter = (newNode, referenceNode)=>{\n    return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n};\nconst isArray = (value)=>Array.isArray(value);\nconst isEmpty = (value)=>value == null;\nconst trim = (str)=>str.trim();\nconst toString = (value)=>\"\" + value;\nconst toArray = (value, splitter = \",\")=>{\n    if (isEmpty(value)) {\n        return [];\n    }\n    if (isArray(value)) {\n        return value;\n    }\n    return toString(value).split(splitter).map(trim).filter((str)=>str.length);\n};\nconst isBoolean = (value)=>typeof value === \"boolean\";\nconst toBoolean = (value)=>isBoolean(value) ? value : value === \"true\";\nconst isString = (value)=>typeof value === \"string\";\nconst toNumber = (value)=>isNumber(value) ? value : isString(value) ? toString(value).replace(/[a-z]+/gi, \"\") : 0;\nconst toInt = (value)=>parseInt(toNumber(value), 10);\nconst toFloat = (value)=>parseFloat(toNumber(value));\nconst isInt = (value)=>isNumber(value) && isFinite(value) && Math.floor(value) === value;\nconst toBytes = (value, base = 1000)=>{\n    // is in bytes\n    if (isInt(value)) {\n        return value;\n    }\n    // is natural file size\n    let naturalFileSize = toString(value).trim();\n    // if is value in megabytes\n    if (/MB$/i.test(naturalFileSize)) {\n        naturalFileSize = naturalFileSize.replace(/MB$i/, \"\").trim();\n        return toInt(naturalFileSize) * base * base;\n    }\n    // if is value in kilobytes\n    if (/KB/i.test(naturalFileSize)) {\n        naturalFileSize = naturalFileSize.replace(/KB$i/, \"\").trim();\n        return toInt(naturalFileSize) * base;\n    }\n    return toInt(naturalFileSize);\n};\nconst isFunction = (value)=>typeof value === \"function\";\nconst toFunctionReference = (string)=>{\n    let ref = self;\n    let levels = string.split(\".\");\n    let level = null;\n    while(level = levels.shift()){\n        ref = ref[level];\n        if (!ref) {\n            return null;\n        }\n    }\n    return ref;\n};\nconst methods = {\n    process: \"POST\",\n    patch: \"PATCH\",\n    revert: \"DELETE\",\n    fetch: \"GET\",\n    restore: \"GET\",\n    load: \"GET\"\n};\nconst createServerAPI = (outline)=>{\n    const api = {};\n    api.url = isString(outline) ? outline : outline.url || \"\";\n    api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;\n    api.headers = outline.headers ? outline.headers : {};\n    forin(methods, (key)=>{\n        api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);\n    });\n    // remove process if no url or process on outline\n    api.process = outline.process || isString(outline) || outline.url ? api.process : null;\n    // special treatment for remove\n    api.remove = outline.remove || null;\n    // remove generic headers from api object\n    delete api.headers;\n    return api;\n};\nconst createAction = (name, outline, method, timeout, headers)=>{\n    // is explicitely set to null so disable\n    if (outline === null) {\n        return null;\n    }\n    // if is custom function, done! Dev handles everything.\n    if (typeof outline === \"function\") {\n        return outline;\n    }\n    // build action object\n    const action = {\n        url: method === \"GET\" || method === \"PATCH\" ? `?${name}=` : \"\",\n        method,\n        headers,\n        withCredentials: false,\n        timeout,\n        onload: null,\n        ondata: null,\n        onerror: null\n    };\n    // is a single url\n    if (isString(outline)) {\n        action.url = outline;\n        return action;\n    }\n    // overwrite\n    Object.assign(action, outline);\n    // see if should reformat headers;\n    if (isString(action.headers)) {\n        const parts = action.headers.split(/:(.+)/);\n        action.headers = {\n            header: parts[0],\n            value: parts[1]\n        };\n    }\n    // if is bool withCredentials\n    action.withCredentials = toBoolean(action.withCredentials);\n    return action;\n};\nconst toServerAPI = (value)=>createServerAPI(value);\nconst isNull = (value)=>value === null;\nconst isObject = (value)=>typeof value === \"object\" && value !== null;\nconst isAPI = (value)=>{\n    return isObject(value) && isString(value.url) && isObject(value.process) && isObject(value.revert) && isObject(value.restore) && isObject(value.fetch);\n};\nconst getType = (value)=>{\n    if (isArray(value)) {\n        return \"array\";\n    }\n    if (isNull(value)) {\n        return \"null\";\n    }\n    if (isInt(value)) {\n        return \"int\";\n    }\n    if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {\n        return \"bytes\";\n    }\n    if (isAPI(value)) {\n        return \"api\";\n    }\n    return typeof value;\n};\nconst replaceSingleQuotes = (str)=>str.replace(/{\\s*'/g, '{\"').replace(/'\\s*}/g, '\"}').replace(/'\\s*:/g, '\":').replace(/:\\s*'/g, ':\"').replace(/,\\s*'/g, ',\"').replace(/'\\s*,/g, '\",');\nconst conversionTable = {\n    array: toArray,\n    boolean: toBoolean,\n    int: (value)=>getType(value) === \"bytes\" ? toBytes(value) : toInt(value),\n    number: toFloat,\n    float: toFloat,\n    bytes: toBytes,\n    string: (value)=>isFunction(value) ? value : toString(value),\n    function: (value)=>toFunctionReference(value),\n    serverapi: toServerAPI,\n    object: (value)=>{\n        try {\n            return JSON.parse(replaceSingleQuotes(value));\n        } catch (e) {\n            return null;\n        }\n    }\n};\nconst convertTo = (value, type)=>conversionTable[type](value);\nconst getValueByType = (newValue, defaultValue, valueType)=>{\n    // can always assign default value\n    if (newValue === defaultValue) {\n        return newValue;\n    }\n    // get the type of the new value\n    let newValueType = getType(newValue);\n    // is valid type?\n    if (newValueType !== valueType) {\n        // is string input, let's attempt to convert\n        const convertedValue = convertTo(newValue, valueType);\n        // what is the type now\n        newValueType = getType(convertedValue);\n        // no valid conversions found\n        if (convertedValue === null) {\n            throw `Trying to assign value with incorrect type to \"${option}\", allowed type: \"${valueType}\"`;\n        } else {\n            newValue = convertedValue;\n        }\n    }\n    // assign new value\n    return newValue;\n};\nconst createOption = (defaultValue, valueType)=>{\n    let currentValue = defaultValue;\n    return {\n        enumerable: true,\n        get: ()=>currentValue,\n        set: (newValue)=>{\n            currentValue = getValueByType(newValue, defaultValue, valueType);\n        }\n    };\n};\nconst createOptions = (options)=>{\n    const obj = {};\n    forin(options, (prop)=>{\n        const optionDefinition = options[prop];\n        obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);\n    });\n    return createObject(obj);\n};\nconst createInitialState = (options)=>({\n        // model\n        items: [],\n        // timeout used for calling update items\n        listUpdateTimeout: null,\n        // timeout used for stacking metadata updates\n        itemUpdateTimeout: null,\n        // queue of items waiting to be processed\n        processingQueue: [],\n        // options\n        options: createOptions(options)\n    });\nconst fromCamels = (string, separator = \"-\")=>string.split(/(?=[A-Z])/).map((part)=>part.toLowerCase()).join(separator);\nconst createOptionAPI = (store, options)=>{\n    const obj = {};\n    forin(options, (key)=>{\n        obj[key] = {\n            get: ()=>store.getState().options[key],\n            set: (value)=>{\n                store.dispatch(`SET_${fromCamels(key, \"_\").toUpperCase()}`, {\n                    value\n                });\n            }\n        };\n    });\n    return obj;\n};\nconst createOptionActions = (options)=>(dispatch, query, state)=>{\n        const obj = {};\n        forin(options, (key)=>{\n            const name = fromCamels(key, \"_\").toUpperCase();\n            obj[`SET_${name}`] = (action)=>{\n                try {\n                    state.options[key] = action.value;\n                } catch (e) {\n                // nope, failed\n                }\n                // we successfully set the value of this option\n                dispatch(`DID_SET_${name}`, {\n                    value: state.options[key]\n                });\n            };\n        });\n        return obj;\n    };\nconst createOptionQueries = (options)=>(state)=>{\n        const obj = {};\n        forin(options, (key)=>{\n            obj[`GET_${fromCamels(key, \"_\").toUpperCase()}`] = (action)=>state.options[key];\n        });\n        return obj;\n    };\nconst InteractionMethod = {\n    API: 1,\n    DROP: 2,\n    BROWSE: 3,\n    PASTE: 4,\n    NONE: 5\n};\nconst getUniqueId = ()=>Math.random().toString(36).substring(2, 11);\nconst arrayRemove = (arr, index)=>arr.splice(index, 1);\nconst run = (cb, sync)=>{\n    if (sync) {\n        cb();\n    } else if (document.hidden) {\n        Promise.resolve(1).then(cb);\n    } else {\n        setTimeout(cb, 0);\n    }\n};\nconst on = ()=>{\n    const listeners = [];\n    const off = (event, cb)=>{\n        arrayRemove(listeners, listeners.findIndex((listener)=>listener.event === event && (listener.cb === cb || !cb)));\n    };\n    const fire = (event, args, sync)=>{\n        listeners.filter((listener)=>listener.event === event).map((listener)=>listener.cb).forEach((cb)=>run(()=>cb(...args), sync));\n    };\n    return {\n        fireSync: (event, ...args)=>{\n            fire(event, args, true);\n        },\n        fire: (event, ...args)=>{\n            fire(event, args, false);\n        },\n        on: (event, cb)=>{\n            listeners.push({\n                event,\n                cb\n            });\n        },\n        onOnce: (event, cb)=>{\n            listeners.push({\n                event,\n                cb: (...args)=>{\n                    off(event, cb);\n                    cb(...args);\n                }\n            });\n        },\n        off\n    };\n};\nconst copyObjectPropertiesToObject = (src, target, excluded)=>{\n    Object.getOwnPropertyNames(src).filter((property)=>!excluded.includes(property)).forEach((key)=>Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(src, key)));\n};\nconst PRIVATE = [\n    \"fire\",\n    \"process\",\n    \"revert\",\n    \"load\",\n    \"on\",\n    \"off\",\n    \"onOnce\",\n    \"retryLoad\",\n    \"extend\",\n    \"archive\",\n    \"archived\",\n    \"release\",\n    \"released\",\n    \"requestProcessing\",\n    \"freeze\"\n];\nconst createItemAPI = (item)=>{\n    const api = {};\n    copyObjectPropertiesToObject(item, api, PRIVATE);\n    return api;\n};\nconst removeReleasedItems = (items)=>{\n    items.forEach((item, index)=>{\n        if (item.released) {\n            arrayRemove(items, index);\n        }\n    });\n};\nconst ItemStatus = {\n    INIT: 1,\n    IDLE: 2,\n    PROCESSING_QUEUED: 9,\n    PROCESSING: 3,\n    PROCESSING_COMPLETE: 5,\n    PROCESSING_ERROR: 6,\n    PROCESSING_REVERT_ERROR: 10,\n    LOADING: 7,\n    LOAD_ERROR: 8\n};\nconst FileOrigin = {\n    INPUT: 1,\n    LIMBO: 2,\n    LOCAL: 3\n};\nconst getNonNumeric = (str)=>/[^0-9]+/.exec(str);\nconst getDecimalSeparator = ()=>getNonNumeric(1.1.toLocaleString())[0];\nconst getThousandsSeparator = ()=>{\n    // Added for browsers that do not return the thousands separator (happend on native browser Android 4.4.4)\n    // We check against the normal toString output and if they're the same return a comma when decimal separator is a dot\n    const decimalSeparator = getDecimalSeparator();\n    const thousandsStringWithSeparator = 1000.0.toLocaleString();\n    const thousandsStringWithoutSeparator = 1000.0.toString();\n    if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {\n        return getNonNumeric(thousandsStringWithSeparator)[0];\n    }\n    return decimalSeparator === \".\" ? \",\" : \".\";\n};\nconst Type = {\n    BOOLEAN: \"boolean\",\n    INT: \"int\",\n    NUMBER: \"number\",\n    STRING: \"string\",\n    ARRAY: \"array\",\n    OBJECT: \"object\",\n    FUNCTION: \"function\",\n    ACTION: \"action\",\n    SERVER_API: \"serverapi\",\n    REGEX: \"regex\"\n};\n// all registered filters\nconst filters = [];\n// loops over matching filters and passes options to each filter, returning the mapped results\nconst applyFilterChain = (key, value, utils)=>new Promise((resolve, reject)=>{\n        // find matching filters for this key\n        const matchingFilters = filters.filter((f)=>f.key === key).map((f)=>f.cb);\n        // resolve now\n        if (matchingFilters.length === 0) {\n            resolve(value);\n            return;\n        }\n        // first filter to kick things of\n        const initialFilter = matchingFilters.shift();\n        // chain filters\n        matchingFilters.reduce(// loop over promises passing value to next promise\n        (current, next)=>current.then((value)=>next(value, utils)), // call initial filter, will return a promise\n        initialFilter(value, utils)).then((value)=>resolve(value)).catch((error)=>reject(error));\n    });\nconst applyFilters = (key, value, utils)=>filters.filter((f)=>f.key === key).map((f)=>f.cb(value, utils));\n// adds a new filter to the list\nconst addFilter = (key, cb)=>filters.push({\n        key,\n        cb\n    });\nconst extendDefaultOptions = (additionalOptions)=>Object.assign(defaultOptions, additionalOptions);\nconst getOptions = ()=>({\n        ...defaultOptions\n    });\nconst setOptions = (opts)=>{\n    forin(opts, (key, value)=>{\n        // key does not exist, so this option cannot be set\n        if (!defaultOptions[key]) {\n            return;\n        }\n        defaultOptions[key][0] = getValueByType(value, defaultOptions[key][0], defaultOptions[key][1]);\n    });\n};\n// default options on app\nconst defaultOptions = {\n    // the id to add to the root element\n    id: [\n        null,\n        Type.STRING\n    ],\n    // input field name to use\n    name: [\n        \"filepond\",\n        Type.STRING\n    ],\n    // disable the field\n    disabled: [\n        false,\n        Type.BOOLEAN\n    ],\n    // classname to put on wrapper\n    className: [\n        null,\n        Type.STRING\n    ],\n    // is the field required\n    required: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Allow media capture when value is set\n    captureMethod: [\n        null,\n        Type.STRING\n    ],\n    // - \"camera\", \"microphone\" or \"camcorder\",\n    // - Does not work with multiple on apple devices\n    // - If set, acceptedFileTypes must be made to match with media wildcard \"image/*\", \"audio/*\" or \"video/*\"\n    // sync `acceptedFileTypes` property with `accept` attribute\n    allowSyncAcceptAttribute: [\n        true,\n        Type.BOOLEAN\n    ],\n    // Feature toggles\n    allowDrop: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowBrowse: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowPaste: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowMultiple: [\n        false,\n        Type.BOOLEAN\n    ],\n    allowReplace: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowRevert: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowRemove: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowProcess: [\n        true,\n        Type.BOOLEAN\n    ],\n    allowReorder: [\n        false,\n        Type.BOOLEAN\n    ],\n    allowDirectoriesOnly: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Try store file if `server` not set\n    storeAsFile: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Revert mode\n    forceRevert: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Input requirements\n    maxFiles: [\n        null,\n        Type.INT\n    ],\n    checkValidity: [\n        false,\n        Type.BOOLEAN\n    ],\n    // Where to put file\n    itemInsertLocationFreedom: [\n        true,\n        Type.BOOLEAN\n    ],\n    itemInsertLocation: [\n        \"before\",\n        Type.STRING\n    ],\n    itemInsertInterval: [\n        75,\n        Type.INT\n    ],\n    // Drag 'n Drop related\n    dropOnPage: [\n        false,\n        Type.BOOLEAN\n    ],\n    dropOnElement: [\n        true,\n        Type.BOOLEAN\n    ],\n    dropValidation: [\n        false,\n        Type.BOOLEAN\n    ],\n    ignoredFiles: [\n        [\n            \".ds_store\",\n            \"thumbs.db\",\n            \"desktop.ini\"\n        ],\n        Type.ARRAY\n    ],\n    // Upload related\n    instantUpload: [\n        true,\n        Type.BOOLEAN\n    ],\n    maxParallelUploads: [\n        2,\n        Type.INT\n    ],\n    allowMinimumUploadDuration: [\n        true,\n        Type.BOOLEAN\n    ],\n    // Chunks\n    chunkUploads: [\n        false,\n        Type.BOOLEAN\n    ],\n    chunkForce: [\n        false,\n        Type.BOOLEAN\n    ],\n    chunkSize: [\n        5000000,\n        Type.INT\n    ],\n    chunkRetryDelays: [\n        [\n            500,\n            1000,\n            3000\n        ],\n        Type.ARRAY\n    ],\n    // The server api end points to use for uploading (see docs)\n    server: [\n        null,\n        Type.SERVER_API\n    ],\n    // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000\n    fileSizeBase: [\n        1000,\n        Type.INT\n    ],\n    // Labels and status messages\n    labelFileSizeBytes: [\n        \"bytes\",\n        Type.STRING\n    ],\n    labelFileSizeKilobytes: [\n        \"KB\",\n        Type.STRING\n    ],\n    labelFileSizeMegabytes: [\n        \"MB\",\n        Type.STRING\n    ],\n    labelFileSizeGigabytes: [\n        \"GB\",\n        Type.STRING\n    ],\n    labelDecimalSeparator: [\n        getDecimalSeparator(),\n        Type.STRING\n    ],\n    labelThousandsSeparator: [\n        getThousandsSeparator(),\n        Type.STRING\n    ],\n    labelIdle: [\n        'Drag & Drop your files or <span class=\"filepond--label-action\">Browse</span>',\n        Type.STRING\n    ],\n    labelInvalidField: [\n        \"Field contains invalid files\",\n        Type.STRING\n    ],\n    labelFileWaitingForSize: [\n        \"Waiting for size\",\n        Type.STRING\n    ],\n    labelFileSizeNotAvailable: [\n        \"Size not available\",\n        Type.STRING\n    ],\n    labelFileCountSingular: [\n        \"file in list\",\n        Type.STRING\n    ],\n    labelFileCountPlural: [\n        \"files in list\",\n        Type.STRING\n    ],\n    labelFileLoading: [\n        \"Loading\",\n        Type.STRING\n    ],\n    labelFileAdded: [\n        \"Added\",\n        Type.STRING\n    ],\n    labelFileLoadError: [\n        \"Error during load\",\n        Type.STRING\n    ],\n    labelFileRemoved: [\n        \"Removed\",\n        Type.STRING\n    ],\n    labelFileRemoveError: [\n        \"Error during remove\",\n        Type.STRING\n    ],\n    labelFileProcessing: [\n        \"Uploading\",\n        Type.STRING\n    ],\n    labelFileProcessingComplete: [\n        \"Upload complete\",\n        Type.STRING\n    ],\n    labelFileProcessingAborted: [\n        \"Upload cancelled\",\n        Type.STRING\n    ],\n    labelFileProcessingError: [\n        \"Error during upload\",\n        Type.STRING\n    ],\n    labelFileProcessingRevertError: [\n        \"Error during revert\",\n        Type.STRING\n    ],\n    labelTapToCancel: [\n        \"tap to cancel\",\n        Type.STRING\n    ],\n    labelTapToRetry: [\n        \"tap to retry\",\n        Type.STRING\n    ],\n    labelTapToUndo: [\n        \"tap to undo\",\n        Type.STRING\n    ],\n    labelButtonRemoveItem: [\n        \"Remove\",\n        Type.STRING\n    ],\n    labelButtonAbortItemLoad: [\n        \"Abort\",\n        Type.STRING\n    ],\n    labelButtonRetryItemLoad: [\n        \"Retry\",\n        Type.STRING\n    ],\n    labelButtonAbortItemProcessing: [\n        \"Cancel\",\n        Type.STRING\n    ],\n    labelButtonUndoItemProcessing: [\n        \"Undo\",\n        Type.STRING\n    ],\n    labelButtonRetryItemProcessing: [\n        \"Retry\",\n        Type.STRING\n    ],\n    labelButtonProcessItem: [\n        \"Upload\",\n        Type.STRING\n    ],\n    // make sure width and height plus viewpox are even numbers so icons are nicely centered\n    iconRemove: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    iconProcess: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z\" fill=\"currentColor\" fill-rule=\"evenodd\"/></svg>',\n        Type.STRING\n    ],\n    iconRetry: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    iconUndo: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    iconDone: [\n        '<svg width=\"26\" height=\"26\" viewBox=\"0 0 26 26\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z\" fill=\"currentColor\" fill-rule=\"nonzero\"/></svg>',\n        Type.STRING\n    ],\n    // event handlers\n    oninit: [\n        null,\n        Type.FUNCTION\n    ],\n    onwarning: [\n        null,\n        Type.FUNCTION\n    ],\n    onerror: [\n        null,\n        Type.FUNCTION\n    ],\n    onactivatefile: [\n        null,\n        Type.FUNCTION\n    ],\n    oninitfile: [\n        null,\n        Type.FUNCTION\n    ],\n    onaddfilestart: [\n        null,\n        Type.FUNCTION\n    ],\n    onaddfileprogress: [\n        null,\n        Type.FUNCTION\n    ],\n    onaddfile: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfilestart: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfileprogress: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfileabort: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfilerevert: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfile: [\n        null,\n        Type.FUNCTION\n    ],\n    onprocessfiles: [\n        null,\n        Type.FUNCTION\n    ],\n    onremovefile: [\n        null,\n        Type.FUNCTION\n    ],\n    onpreparefile: [\n        null,\n        Type.FUNCTION\n    ],\n    onupdatefiles: [\n        null,\n        Type.FUNCTION\n    ],\n    onreorderfiles: [\n        null,\n        Type.FUNCTION\n    ],\n    // hooks\n    beforeDropFile: [\n        null,\n        Type.FUNCTION\n    ],\n    beforeAddFile: [\n        null,\n        Type.FUNCTION\n    ],\n    beforeRemoveFile: [\n        null,\n        Type.FUNCTION\n    ],\n    beforePrepareFile: [\n        null,\n        Type.FUNCTION\n    ],\n    // styles\n    stylePanelLayout: [\n        null,\n        Type.STRING\n    ],\n    stylePanelAspectRatio: [\n        null,\n        Type.STRING\n    ],\n    styleItemPanelAspectRatio: [\n        null,\n        Type.STRING\n    ],\n    styleButtonRemoveItemPosition: [\n        \"left\",\n        Type.STRING\n    ],\n    styleButtonProcessItemPosition: [\n        \"right\",\n        Type.STRING\n    ],\n    styleLoadIndicatorPosition: [\n        \"right\",\n        Type.STRING\n    ],\n    styleProgressIndicatorPosition: [\n        \"right\",\n        Type.STRING\n    ],\n    styleButtonRemoveItemAlign: [\n        false,\n        Type.BOOLEAN\n    ],\n    // custom initial files array\n    files: [\n        [],\n        Type.ARRAY\n    ],\n    // show support by displaying credits\n    credits: [\n        [\n            \"https://pqina.nl/\",\n            \"Powered by PQINA\"\n        ],\n        Type.ARRAY\n    ]\n};\nconst getItemByQuery = (items, query)=>{\n    // just return first index\n    if (isEmpty(query)) {\n        return items[0] || null;\n    }\n    // query is index\n    if (isInt(query)) {\n        return items[query] || null;\n    }\n    // if query is item, get the id\n    if (typeof query === \"object\") {\n        query = query.id;\n    }\n    // assume query is a string and return item by id\n    return items.find((item)=>item.id === query) || null;\n};\nconst getNumericAspectRatioFromString = (aspectRatio)=>{\n    if (isEmpty(aspectRatio)) {\n        return aspectRatio;\n    }\n    if (/:/.test(aspectRatio)) {\n        const parts = aspectRatio.split(\":\");\n        return parts[1] / parts[0];\n    }\n    return parseFloat(aspectRatio);\n};\nconst getActiveItems = (items)=>items.filter((item)=>!item.archived);\nconst Status = {\n    EMPTY: 0,\n    IDLE: 1,\n    ERROR: 2,\n    BUSY: 3,\n    READY: 4\n};\nlet res = null;\nconst canUpdateFileInput = ()=>{\n    if (res === null) {\n        try {\n            const dataTransfer = new DataTransfer();\n            dataTransfer.items.add(new File([\n                \"hello world\"\n            ], \"This_Works.txt\"));\n            const el = document.createElement(\"input\");\n            el.setAttribute(\"type\", \"file\");\n            el.files = dataTransfer.files;\n            res = el.files.length === 1;\n        } catch (err) {\n            res = false;\n        }\n    }\n    return res;\n};\nconst ITEM_ERROR = [\n    ItemStatus.LOAD_ERROR,\n    ItemStatus.PROCESSING_ERROR,\n    ItemStatus.PROCESSING_REVERT_ERROR\n];\nconst ITEM_BUSY = [\n    ItemStatus.LOADING,\n    ItemStatus.PROCESSING,\n    ItemStatus.PROCESSING_QUEUED,\n    ItemStatus.INIT\n];\nconst ITEM_READY = [\n    ItemStatus.PROCESSING_COMPLETE\n];\nconst isItemInErrorState = (item)=>ITEM_ERROR.includes(item.status);\nconst isItemInBusyState = (item)=>ITEM_BUSY.includes(item.status);\nconst isItemInReadyState = (item)=>ITEM_READY.includes(item.status);\nconst isAsync = (state)=>isObject(state.options.server) && (isObject(state.options.server.process) || isFunction(state.options.server.process));\nconst queries = (state)=>({\n        GET_STATUS: ()=>{\n            const items = getActiveItems(state.items);\n            const { EMPTY, ERROR, BUSY, IDLE, READY } = Status;\n            if (items.length === 0) return EMPTY;\n            if (items.some(isItemInErrorState)) return ERROR;\n            if (items.some(isItemInBusyState)) return BUSY;\n            if (items.some(isItemInReadyState)) return READY;\n            return IDLE;\n        },\n        GET_ITEM: (query)=>getItemByQuery(state.items, query),\n        GET_ACTIVE_ITEM: (query)=>getItemByQuery(getActiveItems(state.items), query),\n        GET_ACTIVE_ITEMS: ()=>getActiveItems(state.items),\n        GET_ITEMS: ()=>state.items,\n        GET_ITEM_NAME: (query)=>{\n            const item = getItemByQuery(state.items, query);\n            return item ? item.filename : null;\n        },\n        GET_ITEM_SIZE: (query)=>{\n            const item = getItemByQuery(state.items, query);\n            return item ? item.fileSize : null;\n        },\n        GET_STYLES: ()=>Object.keys(state.options).filter((key)=>/^style/.test(key)).map((option1)=>({\n                    name: option1,\n                    value: state.options[option1]\n                })),\n        GET_PANEL_ASPECT_RATIO: ()=>{\n            const isShapeCircle = /circle/.test(state.options.stylePanelLayout);\n            const aspectRatio = isShapeCircle ? 1 : getNumericAspectRatioFromString(state.options.stylePanelAspectRatio);\n            return aspectRatio;\n        },\n        GET_ITEM_PANEL_ASPECT_RATIO: ()=>state.options.styleItemPanelAspectRatio,\n        GET_ITEMS_BY_STATUS: (status)=>getActiveItems(state.items).filter((item)=>item.status === status),\n        GET_TOTAL_ITEMS: ()=>getActiveItems(state.items).length,\n        SHOULD_UPDATE_FILE_INPUT: ()=>state.options.storeAsFile && canUpdateFileInput() && !isAsync(state),\n        IS_ASYNC: ()=>isAsync(state),\n        GET_FILE_SIZE_LABELS: (query)=>({\n                labelBytes: query(\"GET_LABEL_FILE_SIZE_BYTES\") || undefined,\n                labelKilobytes: query(\"GET_LABEL_FILE_SIZE_KILOBYTES\") || undefined,\n                labelMegabytes: query(\"GET_LABEL_FILE_SIZE_MEGABYTES\") || undefined,\n                labelGigabytes: query(\"GET_LABEL_FILE_SIZE_GIGABYTES\") || undefined\n            })\n    });\nconst hasRoomForItem = (state)=>{\n    const count = getActiveItems(state.items).length;\n    // if cannot have multiple items, to add one item it should currently not contain items\n    if (!state.options.allowMultiple) {\n        return count === 0;\n    }\n    // if allows multiple items, we check if a max item count has been set, if not, there's no limit\n    const maxFileCount = state.options.maxFiles;\n    if (maxFileCount === null) {\n        return true;\n    }\n    // we check if the current count is smaller than the max count, if so, another file can still be added\n    if (count < maxFileCount) {\n        return true;\n    }\n    // no more room for another file\n    return false;\n};\nconst limit = (value, min, max)=>Math.max(Math.min(max, value), min);\nconst arrayInsert = (arr, index, item)=>arr.splice(index, 0, item);\nconst insertItem = (items, item, index)=>{\n    if (isEmpty(item)) {\n        return null;\n    }\n    // if index is undefined, append\n    if (typeof index === \"undefined\") {\n        items.push(item);\n        return item;\n    }\n    // limit the index to the size of the items array\n    index = limit(index, 0, items.length);\n    // add item to array\n    arrayInsert(items, index, item);\n    // expose\n    return item;\n};\nconst isBase64DataURI = (str)=>/^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\\-._~:@\\/?%\\s]*)\\s*$/i.test(str);\nconst getFilenameFromURL = (url)=>`${url}`.split(\"/\").pop().split(\"?\").shift();\nconst getExtensionFromFilename = (name)=>name.split(\".\").pop();\nconst guesstimateExtension = (type)=>{\n    // if no extension supplied, exit here\n    if (typeof type !== \"string\") {\n        return \"\";\n    }\n    // get subtype\n    const subtype = type.split(\"/\").pop();\n    // is svg subtype\n    if (/svg/.test(subtype)) {\n        return \"svg\";\n    }\n    if (/zip|compressed/.test(subtype)) {\n        return \"zip\";\n    }\n    if (/plain/.test(subtype)) {\n        return \"txt\";\n    }\n    if (/msword/.test(subtype)) {\n        return \"doc\";\n    }\n    // if is valid subtype\n    if (/[a-z]+/.test(subtype)) {\n        // always use jpg extension\n        if (subtype === \"jpeg\") {\n            return \"jpg\";\n        }\n        // return subtype\n        return subtype;\n    }\n    return \"\";\n};\nconst leftPad = (value, padding = \"\")=>(padding + value).slice(-padding.length);\nconst getDateString = (date = new Date())=>`${date.getFullYear()}-${leftPad(date.getMonth() + 1, \"00\")}-${leftPad(date.getDate(), \"00\")}_${leftPad(date.getHours(), \"00\")}-${leftPad(date.getMinutes(), \"00\")}-${leftPad(date.getSeconds(), \"00\")}`;\nconst getFileFromBlob = (blob, filename, type = null, extension = null)=>{\n    const file = typeof type === \"string\" ? blob.slice(0, blob.size, type) : blob.slice(0, blob.size, blob.type);\n    file.lastModifiedDate = new Date();\n    // copy relative path\n    if (blob._relativePath) file._relativePath = blob._relativePath;\n    // if blob has name property, use as filename if no filename supplied\n    if (!isString(filename)) {\n        filename = getDateString();\n    }\n    // if filename supplied but no extension and filename has extension\n    if (filename && extension === null && getExtensionFromFilename(filename)) {\n        file.name = filename;\n    } else {\n        extension = extension || guesstimateExtension(file.type);\n        file.name = filename + (extension ? \".\" + extension : \"\");\n    }\n    return file;\n};\nconst getBlobBuilder = ()=>{\n    return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n};\nconst createBlob = (arrayBuffer, mimeType)=>{\n    const BB = getBlobBuilder();\n    if (BB) {\n        const bb = new BB();\n        bb.append(arrayBuffer);\n        return bb.getBlob(mimeType);\n    }\n    return new Blob([\n        arrayBuffer\n    ], {\n        type: mimeType\n    });\n};\nconst getBlobFromByteStringWithMimeType = (byteString, mimeType)=>{\n    const ab = new ArrayBuffer(byteString.length);\n    const ia = new Uint8Array(ab);\n    for(let i = 0; i < byteString.length; i++){\n        ia[i] = byteString.charCodeAt(i);\n    }\n    return createBlob(ab, mimeType);\n};\nconst getMimeTypeFromBase64DataURI = (dataURI)=>{\n    return (/^data:(.+);/.exec(dataURI) || [])[1] || null;\n};\nconst getBase64DataFromBase64DataURI = (dataURI)=>{\n    // get data part of string (remove data:image/jpeg...,)\n    const data = dataURI.split(\",\")[1];\n    // remove any whitespace as that causes InvalidCharacterError in IE\n    return data.replace(/\\s/g, \"\");\n};\nconst getByteStringFromBase64DataURI = (dataURI)=>{\n    return atob(getBase64DataFromBase64DataURI(dataURI));\n};\nconst getBlobFromBase64DataURI = (dataURI)=>{\n    const mimeType = getMimeTypeFromBase64DataURI(dataURI);\n    const byteString = getByteStringFromBase64DataURI(dataURI);\n    return getBlobFromByteStringWithMimeType(byteString, mimeType);\n};\nconst getFileFromBase64DataURI = (dataURI, filename, extension)=>{\n    return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);\n};\nconst getFileNameFromHeader = (header)=>{\n    // test if is content disposition header, if not exit\n    if (!/^content-disposition:/i.test(header)) return null;\n    // get filename parts\n    const matches = header.split(/filename=|filename\\*=.+''/).splice(1).map((name)=>name.trim().replace(/^[\"']|[;\"']{0,2}$/g, \"\")).filter((name)=>name.length);\n    return matches.length ? decodeURI(matches[matches.length - 1]) : null;\n};\nconst getFileSizeFromHeader = (header)=>{\n    if (/content-length:/i.test(header)) {\n        const size = header.match(/[0-9]+/)[0];\n        return size ? parseInt(size, 10) : null;\n    }\n    return null;\n};\nconst getTranfserIdFromHeader = (header)=>{\n    if (/x-content-transfer-id:/i.test(header)) {\n        const id = (header.split(\":\")[1] || \"\").trim();\n        return id || null;\n    }\n    return null;\n};\nconst getFileInfoFromHeaders = (headers)=>{\n    const info = {\n        source: null,\n        name: null,\n        size: null\n    };\n    const rows = headers.split(\"\\n\");\n    for (let header of rows){\n        const name = getFileNameFromHeader(header);\n        if (name) {\n            info.name = name;\n            continue;\n        }\n        const size = getFileSizeFromHeader(header);\n        if (size) {\n            info.size = size;\n            continue;\n        }\n        const source = getTranfserIdFromHeader(header);\n        if (source) {\n            info.source = source;\n            continue;\n        }\n    }\n    return info;\n};\nconst createFileLoader = (fetchFn)=>{\n    const state = {\n        source: null,\n        complete: false,\n        progress: 0,\n        size: null,\n        timestamp: null,\n        duration: 0,\n        request: null\n    };\n    const getProgress = ()=>state.progress;\n    const abort = ()=>{\n        if (state.request && state.request.abort) {\n            state.request.abort();\n        }\n    };\n    // load source\n    const load = ()=>{\n        // get quick reference\n        const source = state.source;\n        api.fire(\"init\", source);\n        // Load Files\n        if (source instanceof File) {\n            api.fire(\"load\", source);\n        } else if (source instanceof Blob) {\n            // Load blobs, set default name to current date\n            api.fire(\"load\", getFileFromBlob(source, source.name));\n        } else if (isBase64DataURI(source)) {\n            // Load base 64, set default name to current date\n            api.fire(\"load\", getFileFromBase64DataURI(source));\n        } else {\n            // Deal as if is external URL, let's load it!\n            loadURL(source);\n        }\n    };\n    // loads a url\n    const loadURL = (url)=>{\n        // is remote url and no fetch method supplied\n        if (!fetchFn) {\n            api.fire(\"error\", {\n                type: \"error\",\n                body: \"Can't load URL\",\n                code: 400\n            });\n            return;\n        }\n        // set request start\n        state.timestamp = Date.now();\n        // load file\n        state.request = fetchFn(url, (response)=>{\n            // update duration\n            state.duration = Date.now() - state.timestamp;\n            // done!\n            state.complete = true;\n            // turn blob response into a file\n            if (response instanceof Blob) {\n                response = getFileFromBlob(response, response.name || getFilenameFromURL(url));\n            }\n            api.fire(\"load\", // if has received blob, we go with blob, if no response, we return null\n            response instanceof Blob ? response : response ? response.body : null);\n        }, (error)=>{\n            api.fire(\"error\", typeof error === \"string\" ? {\n                type: \"error\",\n                code: 0,\n                body: error\n            } : error);\n        }, (computable, current, total)=>{\n            // collected some meta data already\n            if (total) {\n                state.size = total;\n            }\n            // update duration\n            state.duration = Date.now() - state.timestamp;\n            // if we can't compute progress, we're not going to fire progress events\n            if (!computable) {\n                state.progress = null;\n                return;\n            }\n            // update progress percentage\n            state.progress = current / total;\n            // expose\n            api.fire(\"progress\", state.progress);\n        }, ()=>{\n            api.fire(\"abort\");\n        }, (response)=>{\n            const fileinfo = getFileInfoFromHeaders(typeof response === \"string\" ? response : response.headers);\n            api.fire(\"meta\", {\n                size: state.size || fileinfo.size,\n                filename: fileinfo.name,\n                source: fileinfo.source\n            });\n        });\n    };\n    const api = {\n        ...on(),\n        setSource: (source)=>state.source = source,\n        getProgress,\n        abort,\n        load\n    };\n    return api;\n};\nconst isGet = (method)=>/GET|HEAD/.test(method);\nconst sendRequest = (data, url, options)=>{\n    const api = {\n        onheaders: ()=>{},\n        onprogress: ()=>{},\n        onload: ()=>{},\n        ontimeout: ()=>{},\n        onerror: ()=>{},\n        onabort: ()=>{},\n        abort: ()=>{\n            aborted = true;\n            xhr.abort();\n        }\n    };\n    // timeout identifier, only used when timeout is defined\n    let aborted = false;\n    let headersReceived = false;\n    // set default options\n    options = {\n        method: \"POST\",\n        headers: {},\n        withCredentials: false,\n        ...options\n    };\n    // encode url\n    url = encodeURI(url);\n    // if method is GET, add any received data to url\n    if (isGet(options.method) && data) {\n        url = `${url}${encodeURIComponent(typeof data === \"string\" ? data : JSON.stringify(data))}`;\n    }\n    // create request\n    const xhr = new XMLHttpRequest();\n    // progress of load\n    const process = isGet(options.method) ? xhr : xhr.upload;\n    process.onprogress = (e)=>{\n        // no progress event when aborted ( onprogress is called once after abort() )\n        if (aborted) {\n            return;\n        }\n        api.onprogress(e.lengthComputable, e.loaded, e.total);\n    };\n    // tries to get header info to the app as fast as possible\n    xhr.onreadystatechange = ()=>{\n        // not interesting in these states ('unsent' and 'openend' as they don't give us any additional info)\n        if (xhr.readyState < 2) {\n            return;\n        }\n        // no server response\n        if (xhr.readyState === 4 && xhr.status === 0) {\n            return;\n        }\n        if (headersReceived) {\n            return;\n        }\n        headersReceived = true;\n        // we've probably received some useful data in response headers\n        api.onheaders(xhr);\n    };\n    // load successful\n    xhr.onload = ()=>{\n        // is classified as valid response\n        if (xhr.status >= 200 && xhr.status < 300) {\n            api.onload(xhr);\n        } else {\n            api.onerror(xhr);\n        }\n    };\n    // error during load\n    xhr.onerror = ()=>api.onerror(xhr);\n    // request aborted\n    xhr.onabort = ()=>{\n        aborted = true;\n        api.onabort();\n    };\n    // request timeout\n    xhr.ontimeout = ()=>api.ontimeout(xhr);\n    // open up open up!\n    xhr.open(options.method, url, true);\n    // set timeout if defined (do it after open so IE11 plays ball)\n    if (isInt(options.timeout)) {\n        xhr.timeout = options.timeout;\n    }\n    // add headers\n    Object.keys(options.headers).forEach((key)=>{\n        const value = unescape(encodeURIComponent(options.headers[key]));\n        xhr.setRequestHeader(key, value);\n    });\n    // set type of response\n    if (options.responseType) {\n        xhr.responseType = options.responseType;\n    }\n    // set credentials\n    if (options.withCredentials) {\n        xhr.withCredentials = true;\n    }\n    // let's send our data\n    xhr.send(data);\n    return api;\n};\nconst createResponse = (type, code, body, headers)=>({\n        type,\n        code,\n        body,\n        headers\n    });\nconst createTimeoutResponse = (cb)=>(xhr)=>{\n        cb(createResponse(\"error\", 0, \"Timeout\", xhr.getAllResponseHeaders()));\n    };\nconst hasQS = (str)=>/\\?/.test(str);\nconst buildURL = (...parts)=>{\n    let url = \"\";\n    parts.forEach((part)=>{\n        url += hasQS(url) && hasQS(part) ? part.replace(/\\?/, \"&\") : part;\n    });\n    return url;\n};\nconst createFetchFunction = (apiUrl = \"\", action)=>{\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === \"function\") {\n        return action;\n    }\n    // no action supplied\n    if (!action || !isString(action.url)) {\n        return null;\n    }\n    // set onload hanlder\n    const onload = action.onload || ((res)=>res);\n    const onerror = action.onerror || ((res)=>null);\n    // internal handler\n    return (url, load, error, progress, abort, headers)=>{\n        // do local or remote request based on if the url is external\n        const request = sendRequest(url, buildURL(apiUrl, action.url), {\n            ...action,\n            responseType: \"blob\"\n        });\n        request.onload = (xhr)=>{\n            // get headers\n            const headers = xhr.getAllResponseHeaders();\n            // get filename\n            const filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n            // create response\n            load(createResponse(\"load\", xhr.status, action.method === \"HEAD\" ? null : getFileFromBlob(onload(xhr.response), filename), headers));\n        };\n        request.onerror = (xhr)=>{\n            error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n        request.onheaders = (xhr)=>{\n            headers(createResponse(\"headers\", xhr.status, null, xhr.getAllResponseHeaders()));\n        };\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n        // should return request\n        return request;\n    };\n};\nconst ChunkStatus = {\n    QUEUED: 0,\n    COMPLETE: 1,\n    PROCESSING: 2,\n    ERROR: 3,\n    WAITING: 4\n};\n/*\nfunction signature:\n  (file, metadata, load, error, progress, abort, transfer, options) => {\n    return {\n    abort:() => {}\n  }\n}\n*/ // apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options\nconst processFileChunked = (apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options)=>{\n    // all chunks\n    const chunks = [];\n    const { chunkTransferId, chunkServer, chunkSize, chunkRetryDelays } = options;\n    // default state\n    const state = {\n        serverId: chunkTransferId,\n        aborted: false\n    };\n    // set onload handlers\n    const ondata = action.ondata || ((fd)=>fd);\n    const onload = action.onload || ((xhr, method)=>method === \"HEAD\" ? xhr.getResponseHeader(\"Upload-Offset\") : xhr.response);\n    const onerror = action.onerror || ((res)=>null);\n    // create server hook\n    const requestTransferId = (cb)=>{\n        const formData = new FormData();\n        // add metadata under same name\n        if (isObject(metadata)) formData.append(name, JSON.stringify(metadata));\n        const headers = typeof action.headers === \"function\" ? action.headers(file, metadata) : {\n            ...action.headers,\n            \"Upload-Length\": file.size\n        };\n        const requestParams = {\n            ...action,\n            headers\n        };\n        // send request object\n        const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);\n        request.onload = (xhr)=>cb(onload(xhr, requestParams.method));\n        request.onerror = (xhr)=>error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        request.ontimeout = createTimeoutResponse(error);\n    };\n    const requestTransferOffset = (cb)=>{\n        const requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n        const headers = typeof action.headers === \"function\" ? action.headers(state.serverId) : {\n            ...action.headers\n        };\n        const requestParams = {\n            headers,\n            method: \"HEAD\"\n        };\n        const request = sendRequest(null, requestUrl, requestParams);\n        request.onload = (xhr)=>cb(onload(xhr, requestParams.method));\n        request.onerror = (xhr)=>error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        request.ontimeout = createTimeoutResponse(error);\n    };\n    // create chunks\n    const lastChunkIndex = Math.floor(file.size / chunkSize);\n    for(let i = 0; i <= lastChunkIndex; i++){\n        const offset = i * chunkSize;\n        const data = file.slice(offset, offset + chunkSize, \"application/offset+octet-stream\");\n        chunks[i] = {\n            index: i,\n            size: data.size,\n            offset,\n            data,\n            file,\n            progress: 0,\n            retries: [\n                ...chunkRetryDelays\n            ],\n            status: ChunkStatus.QUEUED,\n            error: null,\n            request: null,\n            timeout: null\n        };\n    }\n    const completeProcessingChunks = ()=>load(state.serverId);\n    const canProcessChunk = (chunk)=>chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;\n    const processChunk = (chunk)=>{\n        // processing is paused, wait here\n        if (state.aborted) return;\n        // get next chunk to process\n        chunk = chunk || chunks.find(canProcessChunk);\n        // no more chunks to process\n        if (!chunk) {\n            // all done?\n            if (chunks.every((chunk)=>chunk.status === ChunkStatus.COMPLETE)) {\n                completeProcessingChunks();\n            }\n            // no chunk to handle\n            return;\n        }\n        // now processing this chunk\n        chunk.status = ChunkStatus.PROCESSING;\n        chunk.progress = null;\n        // allow parsing of formdata\n        const ondata = chunkServer.ondata || ((fd)=>fd);\n        const onerror = chunkServer.onerror || ((res)=>null);\n        const onload = chunkServer.onload || (()=>{});\n        // send request object\n        const requestUrl = buildURL(apiUrl, chunkServer.url, state.serverId);\n        const headers = typeof chunkServer.headers === \"function\" ? chunkServer.headers(chunk) : {\n            ...chunkServer.headers,\n            \"Content-Type\": \"application/offset+octet-stream\",\n            \"Upload-Offset\": chunk.offset,\n            \"Upload-Length\": file.size,\n            \"Upload-Name\": file.name\n        };\n        const request = chunk.request = sendRequest(ondata(chunk.data), requestUrl, {\n            ...chunkServer,\n            headers\n        });\n        request.onload = (xhr)=>{\n            // allow hooking into request result\n            onload(xhr, chunk.index, chunks.length);\n            // done!\n            chunk.status = ChunkStatus.COMPLETE;\n            // remove request reference\n            chunk.request = null;\n            // start processing more chunks\n            processChunks();\n        };\n        request.onprogress = (lengthComputable, loaded, total)=>{\n            chunk.progress = lengthComputable ? loaded : null;\n            updateTotalProgress();\n        };\n        request.onerror = (xhr)=>{\n            chunk.status = ChunkStatus.ERROR;\n            chunk.request = null;\n            chunk.error = onerror(xhr.response) || xhr.statusText;\n            if (!retryProcessChunk(chunk)) {\n                error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n            }\n        };\n        request.ontimeout = (xhr)=>{\n            chunk.status = ChunkStatus.ERROR;\n            chunk.request = null;\n            if (!retryProcessChunk(chunk)) {\n                createTimeoutResponse(error)(xhr);\n            }\n        };\n        request.onabort = ()=>{\n            chunk.status = ChunkStatus.QUEUED;\n            chunk.request = null;\n            abort();\n        };\n    };\n    const retryProcessChunk = (chunk)=>{\n        // no more retries left\n        if (chunk.retries.length === 0) return false;\n        // new retry\n        chunk.status = ChunkStatus.WAITING;\n        clearTimeout(chunk.timeout);\n        chunk.timeout = setTimeout(()=>{\n            processChunk(chunk);\n        }, chunk.retries.shift());\n        // we're going to retry\n        return true;\n    };\n    const updateTotalProgress = ()=>{\n        // calculate total progress fraction\n        const totalBytesTransfered = chunks.reduce((p, chunk)=>{\n            if (p === null || chunk.progress === null) return null;\n            return p + chunk.progress;\n        }, 0);\n        // can't compute progress\n        if (totalBytesTransfered === null) return progress(false, 0, 0);\n        // calculate progress values\n        const totalSize = chunks.reduce((total, chunk)=>total + chunk.size, 0);\n        // can update progress indicator\n        progress(true, totalBytesTransfered, totalSize);\n    };\n    // process new chunks\n    const processChunks = ()=>{\n        const totalProcessing = chunks.filter((chunk)=>chunk.status === ChunkStatus.PROCESSING).length;\n        if (totalProcessing >= 1) return;\n        processChunk();\n    };\n    const abortChunks = ()=>{\n        chunks.forEach((chunk)=>{\n            clearTimeout(chunk.timeout);\n            if (chunk.request) {\n                chunk.request.abort();\n            }\n        });\n    };\n    // let's go!\n    if (!state.serverId) {\n        requestTransferId((serverId)=>{\n            // stop here if aborted, might have happened in between request and callback\n            if (state.aborted) return;\n            // pass back to item so we can use it if something goes wrong\n            transfer(serverId);\n            // store internally\n            state.serverId = serverId;\n            processChunks();\n        });\n    } else {\n        requestTransferOffset((offset)=>{\n            // stop here if aborted, might have happened in between request and callback\n            if (state.aborted) return;\n            // mark chunks with lower offset as complete\n            chunks.filter((chunk)=>chunk.offset < offset).forEach((chunk)=>{\n                chunk.status = ChunkStatus.COMPLETE;\n                chunk.progress = chunk.size;\n            });\n            // continue processing\n            processChunks();\n        });\n    }\n    return {\n        abort: ()=>{\n            state.aborted = true;\n            abortChunks();\n        }\n    };\n};\n/*\nfunction signature:\n  (file, metadata, load, error, progress, abort) => {\n    return {\n    abort:() => {}\n  }\n}\n*/ const createFileProcessorFunction = (apiUrl, action, name, options)=>(file, metadata, load, error, progress, abort, transfer)=>{\n        // no file received\n        if (!file) return;\n        // if was passed a file, and we can chunk it, exit here\n        const canChunkUpload = options.chunkUploads;\n        const shouldChunkUpload = canChunkUpload && file.size > options.chunkSize;\n        const willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);\n        if (file instanceof Blob && willChunkUpload) return processFileChunked(apiUrl, action, name, file, metadata, load, error, progress, abort, transfer, options);\n        // set handlers\n        const ondata = action.ondata || ((fd)=>fd);\n        const onload = action.onload || ((res)=>res);\n        const onerror = action.onerror || ((res)=>null);\n        const headers = typeof action.headers === \"function\" ? action.headers(file, metadata) || {} : {\n            ...action.headers\n        };\n        const requestParams = {\n            ...action,\n            headers\n        };\n        // create formdata object\n        var formData = new FormData();\n        // add metadata under same name\n        if (isObject(metadata)) {\n            formData.append(name, JSON.stringify(metadata));\n        }\n        // Turn into an array of objects so no matter what the input, we can handle it the same way\n        (file instanceof Blob ? [\n            {\n                name: null,\n                file\n            }\n        ] : file).forEach((item)=>{\n            formData.append(name, item.file, item.name === null ? item.file.name : `${item.name}${item.file.name}`);\n        });\n        // send request object\n        const request = sendRequest(ondata(formData), buildURL(apiUrl, action.url), requestParams);\n        request.onload = (xhr)=>{\n            load(createResponse(\"load\", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));\n        };\n        request.onerror = (xhr)=>{\n            error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n        request.ontimeout = createTimeoutResponse(error);\n        request.onprogress = progress;\n        request.onabort = abort;\n        // should return request\n        return request;\n    };\nconst createProcessorFunction = (apiUrl = \"\", action, name, options)=>{\n    // custom handler (should also handle file, load, error, progress and abort)\n    if (typeof action === \"function\") return (...params)=>action(name, ...params, options);\n    // no action supplied\n    if (!action || !isString(action.url)) return null;\n    // internal handler\n    return createFileProcessorFunction(apiUrl, action, name, options);\n};\n/*\n function signature:\n (uniqueFileId, load, error) => { }\n */ const createRevertFunction = (apiUrl = \"\", action)=>{\n    // is custom implementation\n    if (typeof action === \"function\") {\n        return action;\n    }\n    // no action supplied, return stub function, interface will work, but file won't be removed\n    if (!action || !isString(action.url)) {\n        return (uniqueFileId, load)=>load();\n    }\n    // set onload hanlder\n    const onload = action.onload || ((res)=>res);\n    const onerror = action.onerror || ((res)=>null);\n    // internal implementation\n    return (uniqueFileId, load, error)=>{\n        const request = sendRequest(uniqueFileId, apiUrl + action.url, action // contains method, headers and withCredentials properties\n        );\n        request.onload = (xhr)=>{\n            load(createResponse(\"load\", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));\n        };\n        request.onerror = (xhr)=>{\n            error(createResponse(\"error\", xhr.status, onerror(xhr.response) || xhr.statusText, xhr.getAllResponseHeaders()));\n        };\n        request.ontimeout = createTimeoutResponse(error);\n        return request;\n    };\n};\nconst getRandomNumber = (min = 0, max = 1)=>min + Math.random() * (max - min);\nconst createPerceivedPerformanceUpdater = (cb, duration = 1000, offset = 0, tickMin = 25, tickMax = 250)=>{\n    let timeout = null;\n    const start = Date.now();\n    const tick = ()=>{\n        let runtime = Date.now() - start;\n        let delay = getRandomNumber(tickMin, tickMax);\n        if (runtime + delay > duration) {\n            delay = runtime + delay - duration;\n        }\n        let progress = runtime / duration;\n        if (progress >= 1 || document.hidden) {\n            cb(1);\n            return;\n        }\n        cb(progress);\n        timeout = setTimeout(tick, delay);\n    };\n    if (duration > 0) tick();\n    return {\n        clear: ()=>{\n            clearTimeout(timeout);\n        }\n    };\n};\nconst createFileProcessor = (processFn, options)=>{\n    const state = {\n        complete: false,\n        perceivedProgress: 0,\n        perceivedPerformanceUpdater: null,\n        progress: null,\n        timestamp: null,\n        perceivedDuration: 0,\n        duration: 0,\n        request: null,\n        response: null\n    };\n    const { allowMinimumUploadDuration } = options;\n    const process = (file, metadata)=>{\n        const progressFn = ()=>{\n            // we've not yet started the real download, stop here\n            // the request might not go through, for instance, there might be some server trouble\n            // if state.progress is null, the server does not allow computing progress and we show the spinner instead\n            if (state.duration === 0 || state.progress === null) return;\n            // as we're now processing, fire the progress event\n            api.fire(\"progress\", api.getProgress());\n        };\n        const completeFn = ()=>{\n            state.complete = true;\n            api.fire(\"load-perceived\", state.response.body);\n        };\n        // let's start processing\n        api.fire(\"start\");\n        // set request start\n        state.timestamp = Date.now();\n        // create perceived performance progress indicator\n        state.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater((progress)=>{\n            state.perceivedProgress = progress;\n            state.perceivedDuration = Date.now() - state.timestamp;\n            progressFn();\n            // if fake progress is done, and a response has been received,\n            // and we've not yet called the complete method\n            if (state.response && state.perceivedProgress === 1 && !state.complete) {\n                // we done!\n                completeFn();\n            }\n        }, // random delay as in a list of files you start noticing\n        // files uploading at the exact same speed\n        allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0);\n        // remember request so we can abort it later\n        state.request = processFn(// the file to process\n        file, // the metadata to send along\n        metadata, // callbacks (load, error, progress, abort, transfer)\n        // load expects the body to be a server id if\n        // you want to make use of revert\n        (response)=>{\n            // we put the response in state so we can access\n            // it outside of this method\n            state.response = isObject(response) ? response : {\n                type: \"load\",\n                code: 200,\n                body: `${response}`,\n                headers: {}\n            };\n            // update duration\n            state.duration = Date.now() - state.timestamp;\n            // force progress to 1 as we're now done\n            state.progress = 1;\n            // actual load is done let's share results\n            api.fire(\"load\", state.response.body);\n            // we are really done\n            // if perceived progress is 1 ( wait for perceived progress to complete )\n            // or if server does not support progress ( null )\n            if (!allowMinimumUploadDuration || allowMinimumUploadDuration && state.perceivedProgress === 1) {\n                completeFn();\n            }\n        }, // error is expected to be an object with type, code, body\n        (error)=>{\n            // cancel updater\n            state.perceivedPerformanceUpdater.clear();\n            // update others about this error\n            api.fire(\"error\", isObject(error) ? error : {\n                type: \"error\",\n                code: 0,\n                body: `${error}`\n            });\n        }, // actual processing progress\n        (computable, current, total)=>{\n            // update actual duration\n            state.duration = Date.now() - state.timestamp;\n            // update actual progress\n            state.progress = computable ? current / total : null;\n            progressFn();\n        }, // abort does not expect a value\n        ()=>{\n            // stop updater\n            state.perceivedPerformanceUpdater.clear();\n            // fire the abort event so we can switch visuals\n            api.fire(\"abort\", state.response ? state.response.body : null);\n        }, // register the id for this transfer\n        (transferId)=>{\n            api.fire(\"transfer\", transferId);\n        });\n    };\n    const abort = ()=>{\n        // no request running, can't abort\n        if (!state.request) return;\n        // stop updater\n        state.perceivedPerformanceUpdater.clear();\n        // abort actual request\n        if (state.request.abort) state.request.abort();\n        // if has response object, we've completed the request\n        state.complete = true;\n    };\n    const reset = ()=>{\n        abort();\n        state.complete = false;\n        state.perceivedProgress = 0;\n        state.progress = 0;\n        state.timestamp = null;\n        state.perceivedDuration = 0;\n        state.duration = 0;\n        state.request = null;\n        state.response = null;\n    };\n    const getProgress = allowMinimumUploadDuration ? ()=>state.progress ? Math.min(state.progress, state.perceivedProgress) : null : ()=>state.progress || null;\n    const getDuration = allowMinimumUploadDuration ? ()=>Math.min(state.duration, state.perceivedDuration) : ()=>state.duration;\n    const api = {\n        ...on(),\n        process,\n        abort,\n        getProgress,\n        getDuration,\n        reset\n    };\n    return api;\n};\nconst getFilenameWithoutExtension = (name)=>name.substring(0, name.lastIndexOf(\".\")) || name;\nconst createFileStub = (source)=>{\n    let data = [\n        source.name,\n        source.size,\n        source.type\n    ];\n    // is blob or base64, then we need to set the name\n    if (source instanceof Blob || isBase64DataURI(source)) {\n        data[0] = source.name || getDateString();\n    } else if (isBase64DataURI(source)) {\n        // if is base64 data uri we need to determine the average size and type\n        data[1] = source.length;\n        data[2] = getMimeTypeFromBase64DataURI(source);\n    } else if (isString(source)) {\n        // url\n        data[0] = getFilenameFromURL(source);\n        data[1] = 0;\n        data[2] = \"application/octet-stream\";\n    }\n    return {\n        name: data[0],\n        size: data[1],\n        type: data[2]\n    };\n};\nconst isFile = (value)=>!!(value instanceof File || value instanceof Blob && value.name);\nconst deepCloneObject = (src)=>{\n    if (!isObject(src)) return src;\n    const target = isArray(src) ? [] : {};\n    for(const key in src){\n        if (!src.hasOwnProperty(key)) continue;\n        const v = src[key];\n        target[key] = v && isObject(v) ? deepCloneObject(v) : v;\n    }\n    return target;\n};\nconst createItem = (origin = null, serverFileReference = null, file = null)=>{\n    // unique id for this item, is used to identify the item across views\n    const id = getUniqueId();\n    /**\n     * Internal item state\n     */ const state = {\n        // is archived\n        archived: false,\n        // if is frozen, no longer fires events\n        frozen: false,\n        // removed from view\n        released: false,\n        // original source\n        source: null,\n        // file model reference\n        file,\n        // id of file on server\n        serverFileReference,\n        // id of file transfer on server\n        transferId: null,\n        // is aborted\n        processingAborted: false,\n        // current item status\n        status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,\n        // active processes\n        activeLoader: null,\n        activeProcessor: null\n    };\n    // callback used when abort processing is called to link back to the resolve method\n    let abortProcessingRequestComplete = null;\n    /**\n     * Externally added item metadata\n     */ const metadata = {};\n    // item data\n    const setStatus = (status)=>state.status = status;\n    // fire event unless the item has been archived\n    const fire = (event, ...params)=>{\n        if (state.released || state.frozen) return;\n        api.fire(event, ...params);\n    };\n    // file data\n    const getFileExtension = ()=>getExtensionFromFilename(state.file.name);\n    const getFileType = ()=>state.file.type;\n    const getFileSize = ()=>state.file.size;\n    const getFile = ()=>state.file;\n    //\n    // logic to load a file\n    //\n    const load = (source, loader, onload)=>{\n        // remember the original item source\n        state.source = source;\n        // source is known\n        api.fireSync(\"init\");\n        // file stub is already there\n        if (state.file) {\n            api.fireSync(\"load-skip\");\n            return;\n        }\n        // set a stub file object while loading the actual data\n        state.file = createFileStub(source);\n        // starts loading\n        loader.on(\"init\", ()=>{\n            fire(\"load-init\");\n        });\n        // we'eve received a size indication, let's update the stub\n        loader.on(\"meta\", (meta)=>{\n            // set size of file stub\n            state.file.size = meta.size;\n            // set name of file stub\n            state.file.filename = meta.filename;\n            // if has received source, we done\n            if (meta.source) {\n                origin = FileOrigin.LIMBO;\n                state.serverFileReference = meta.source;\n                state.status = ItemStatus.PROCESSING_COMPLETE;\n            }\n            // size has been updated\n            fire(\"load-meta\");\n        });\n        // the file is now loading we need to update the progress indicators\n        loader.on(\"progress\", (progress)=>{\n            setStatus(ItemStatus.LOADING);\n            fire(\"load-progress\", progress);\n        });\n        // an error was thrown while loading the file, we need to switch to error state\n        loader.on(\"error\", (error)=>{\n            setStatus(ItemStatus.LOAD_ERROR);\n            fire(\"load-request-error\", error);\n        });\n        // user or another process aborted the file load (cannot retry)\n        loader.on(\"abort\", ()=>{\n            setStatus(ItemStatus.INIT);\n            fire(\"load-abort\");\n        });\n        // done loading\n        loader.on(\"load\", (file)=>{\n            // as we've now loaded the file the loader is no longer required\n            state.activeLoader = null;\n            // called when file has loaded succesfully\n            const success = (result)=>{\n                // set (possibly) transformed file\n                state.file = isFile(result) ? result : state.file;\n                // file received\n                if (origin === FileOrigin.LIMBO && state.serverFileReference) {\n                    setStatus(ItemStatus.PROCESSING_COMPLETE);\n                } else {\n                    setStatus(ItemStatus.IDLE);\n                }\n                fire(\"load\");\n            };\n            const error = (result)=>{\n                // set original file\n                state.file = file;\n                fire(\"load-meta\");\n                setStatus(ItemStatus.LOAD_ERROR);\n                fire(\"load-file-error\", result);\n            };\n            // if we already have a server file reference, we don't need to call the onload method\n            if (state.serverFileReference) {\n                success(file);\n                return;\n            }\n            // no server id, let's give this file the full treatment\n            onload(file, success, error);\n        });\n        // set loader source data\n        loader.setSource(source);\n        // set as active loader\n        state.activeLoader = loader;\n        // load the source data\n        loader.load();\n    };\n    const retryLoad = ()=>{\n        if (!state.activeLoader) {\n            return;\n        }\n        state.activeLoader.load();\n    };\n    const abortLoad = ()=>{\n        if (state.activeLoader) {\n            state.activeLoader.abort();\n            return;\n        }\n        setStatus(ItemStatus.INIT);\n        fire(\"load-abort\");\n    };\n    //\n    // logic to process a file\n    //\n    const process = (processor, onprocess)=>{\n        // processing was aborted\n        if (state.processingAborted) {\n            state.processingAborted = false;\n            return;\n        }\n        // now processing\n        setStatus(ItemStatus.PROCESSING);\n        // reset abort callback\n        abortProcessingRequestComplete = null;\n        // if no file loaded we'll wait for the load event\n        if (!(state.file instanceof Blob)) {\n            api.on(\"load\", ()=>{\n                process(processor, onprocess);\n            });\n            return;\n        }\n        // setup processor\n        processor.on(\"load\", (serverFileReference)=>{\n            // need this id to be able to revert the upload\n            state.transferId = null;\n            state.serverFileReference = serverFileReference;\n        });\n        // register transfer id\n        processor.on(\"transfer\", (transferId)=>{\n            // need this id to be able to revert the upload\n            state.transferId = transferId;\n        });\n        processor.on(\"load-perceived\", (serverFileReference)=>{\n            // no longer required\n            state.activeProcessor = null;\n            // need this id to be able to rever the upload\n            state.transferId = null;\n            state.serverFileReference = serverFileReference;\n            setStatus(ItemStatus.PROCESSING_COMPLETE);\n            fire(\"process-complete\", serverFileReference);\n        });\n        processor.on(\"start\", ()=>{\n            fire(\"process-start\");\n        });\n        processor.on(\"error\", (error)=>{\n            state.activeProcessor = null;\n            setStatus(ItemStatus.PROCESSING_ERROR);\n            fire(\"process-error\", error);\n        });\n        processor.on(\"abort\", (serverFileReference)=>{\n            state.activeProcessor = null;\n            // if file was uploaded but processing was cancelled during perceived processor time store file reference\n            state.serverFileReference = serverFileReference;\n            setStatus(ItemStatus.IDLE);\n            fire(\"process-abort\");\n            // has timeout so doesn't interfere with remove action\n            if (abortProcessingRequestComplete) {\n                abortProcessingRequestComplete();\n            }\n        });\n        processor.on(\"progress\", (progress)=>{\n            fire(\"process-progress\", progress);\n        });\n        // when successfully transformed\n        const success = (file)=>{\n            // if was archived in the mean time, don't process\n            if (state.archived) return;\n            // process file!\n            processor.process(file, {\n                ...metadata\n            });\n        };\n        // something went wrong during transform phase\n        const error = console.error;\n        // start processing the file\n        onprocess(state.file, success, error);\n        // set as active processor\n        state.activeProcessor = processor;\n    };\n    const requestProcessing = ()=>{\n        state.processingAborted = false;\n        setStatus(ItemStatus.PROCESSING_QUEUED);\n    };\n    const abortProcessing = ()=>new Promise((resolve)=>{\n            if (!state.activeProcessor) {\n                state.processingAborted = true;\n                setStatus(ItemStatus.IDLE);\n                fire(\"process-abort\");\n                resolve();\n                return;\n            }\n            abortProcessingRequestComplete = ()=>{\n                resolve();\n            };\n            state.activeProcessor.abort();\n        });\n    //\n    // logic to revert a processed file\n    //\n    const revert = (revertFileUpload, forceRevert)=>new Promise((resolve, reject)=>{\n            // a completed upload will have a serverFileReference, a failed chunked upload where\n            // getting a serverId succeeded but >=0 chunks have been uploaded will have transferId set\n            const serverTransferId = state.serverFileReference !== null ? state.serverFileReference : state.transferId;\n            // cannot revert without a server id for this process\n            if (serverTransferId === null) {\n                resolve();\n                return;\n            }\n            // revert the upload (fire and forget)\n            revertFileUpload(serverTransferId, ()=>{\n                // reset file server id and transfer id as now it's not available on the server\n                state.serverFileReference = null;\n                state.transferId = null;\n                resolve();\n            }, (error)=>{\n                // don't set error state when reverting is optional, it will always resolve\n                if (!forceRevert) {\n                    resolve();\n                    return;\n                }\n                // oh no errors\n                setStatus(ItemStatus.PROCESSING_REVERT_ERROR);\n                fire(\"process-revert-error\");\n                reject(error);\n            });\n            // fire event\n            setStatus(ItemStatus.IDLE);\n            fire(\"process-revert\");\n        });\n    // exposed methods\n    const setMetadata = (key, value, silent)=>{\n        const keys = key.split(\".\");\n        const root = keys[0];\n        const last = keys.pop();\n        let data = metadata;\n        keys.forEach((key)=>data = data[key]);\n        // compare old value against new value, if they're the same, we're not updating\n        if (JSON.stringify(data[last]) === JSON.stringify(value)) return;\n        // update value\n        data[last] = value;\n        // fire update\n        fire(\"metadata-update\", {\n            key: root,\n            value: metadata[root],\n            silent\n        });\n    };\n    const getMetadata = (key)=>deepCloneObject(key ? metadata[key] : metadata);\n    const api = {\n        id: {\n            get: ()=>id\n        },\n        origin: {\n            get: ()=>origin,\n            set: (value)=>origin = value\n        },\n        serverId: {\n            get: ()=>state.serverFileReference\n        },\n        transferId: {\n            get: ()=>state.transferId\n        },\n        status: {\n            get: ()=>state.status\n        },\n        filename: {\n            get: ()=>state.file.name\n        },\n        filenameWithoutExtension: {\n            get: ()=>getFilenameWithoutExtension(state.file.name)\n        },\n        fileExtension: {\n            get: getFileExtension\n        },\n        fileType: {\n            get: getFileType\n        },\n        fileSize: {\n            get: getFileSize\n        },\n        file: {\n            get: getFile\n        },\n        relativePath: {\n            get: ()=>state.file._relativePath\n        },\n        source: {\n            get: ()=>state.source\n        },\n        getMetadata,\n        setMetadata: (key, value, silent)=>{\n            if (isObject(key)) {\n                const data = key;\n                Object.keys(data).forEach((key)=>{\n                    setMetadata(key, data[key], value);\n                });\n                return key;\n            }\n            setMetadata(key, value, silent);\n            return value;\n        },\n        extend: (name, handler)=>itemAPI[name] = handler,\n        abortLoad,\n        retryLoad,\n        requestProcessing,\n        abortProcessing,\n        load,\n        process,\n        revert,\n        ...on(),\n        freeze: ()=>state.frozen = true,\n        release: ()=>state.released = true,\n        released: {\n            get: ()=>state.released\n        },\n        archive: ()=>state.archived = true,\n        archived: {\n            get: ()=>state.archived\n        },\n        // replace source and file object\n        setFile: (file)=>state.file = file\n    };\n    // create it here instead of returning it instantly so we can extend it later\n    const itemAPI = createObject(api);\n    return itemAPI;\n};\nconst getItemIndexByQuery = (items, query)=>{\n    // just return first index\n    if (isEmpty(query)) {\n        return 0;\n    }\n    // invalid queries\n    if (!isString(query)) {\n        return -1;\n    }\n    // return item by id (or -1 if not found)\n    return items.findIndex((item)=>item.id === query);\n};\nconst getItemById = (items, itemId)=>{\n    const index = getItemIndexByQuery(items, itemId);\n    if (index < 0) {\n        return;\n    }\n    return items[index] || null;\n};\nconst fetchBlob = (url, load, error, progress, abort, headers)=>{\n    const request = sendRequest(null, url, {\n        method: \"GET\",\n        responseType: \"blob\"\n    });\n    request.onload = (xhr)=>{\n        // get headers\n        const headers = xhr.getAllResponseHeaders();\n        // get filename\n        const filename = getFileInfoFromHeaders(headers).name || getFilenameFromURL(url);\n        // create response\n        load(createResponse(\"load\", xhr.status, getFileFromBlob(xhr.response, filename), headers));\n    };\n    request.onerror = (xhr)=>{\n        error(createResponse(\"error\", xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));\n    };\n    request.onheaders = (xhr)=>{\n        headers(createResponse(\"headers\", xhr.status, null, xhr.getAllResponseHeaders()));\n    };\n    request.ontimeout = createTimeoutResponse(error);\n    request.onprogress = progress;\n    request.onabort = abort;\n    // should return request\n    return request;\n};\nconst getDomainFromURL = (url)=>{\n    if (url.indexOf(\"//\") === 0) {\n        url = location.protocol + url;\n    }\n    return url.toLowerCase().replace(\"blob:\", \"\").replace(/([a-z])?:\\/\\//, \"$1\").split(\"/\")[0];\n};\nconst isExternalURL = (url)=>(url.indexOf(\":\") > -1 || url.indexOf(\"//\") > -1) && getDomainFromURL(location.href) !== getDomainFromURL(url);\nconst dynamicLabel = (label)=>(...params)=>isFunction(label) ? label(...params) : label;\nconst isMockItem = (item)=>!isFile(item.file);\nconst listUpdated = (dispatch, state)=>{\n    clearTimeout(state.listUpdateTimeout);\n    state.listUpdateTimeout = setTimeout(()=>{\n        dispatch(\"DID_UPDATE_ITEMS\", {\n            items: getActiveItems(state.items)\n        });\n    }, 0);\n};\nconst optionalPromise = (fn, ...params)=>new Promise((resolve)=>{\n        if (!fn) {\n            return resolve(true);\n        }\n        const result = fn(...params);\n        if (result == null) {\n            return resolve(true);\n        }\n        if (typeof result === \"boolean\") {\n            return resolve(result);\n        }\n        if (typeof result.then === \"function\") {\n            result.then(resolve);\n        }\n    });\nconst sortItems = (state, compare)=>{\n    state.items.sort((a, b)=>compare(createItemAPI(a), createItemAPI(b)));\n};\n// returns item based on state\nconst getItemByQueryFromState = (state, itemHandler)=>({ query, success = ()=>{}, failure = ()=>{}, ...options } = {})=>{\n        const item = getItemByQuery(state.items, query);\n        if (!item) {\n            failure({\n                error: createResponse(\"error\", 0, \"Item not found\"),\n                file: null\n            });\n            return;\n        }\n        itemHandler(item, success, failure, options || {});\n    };\nconst actions = (dispatch, query, state)=>({\n        /**\n     * Aborts all ongoing processes\n     */ ABORT_ALL: ()=>{\n            getActiveItems(state.items).forEach((item)=>{\n                item.freeze();\n                item.abortLoad();\n                item.abortProcessing();\n            });\n        },\n        /**\n     * Sets initial files\n     */ DID_SET_FILES: ({ value = [] })=>{\n            // map values to file objects\n            const files = value.map((file)=>({\n                    source: file.source ? file.source : file,\n                    options: file.options\n                }));\n            // loop over files, if file is in list, leave it be, if not, remove\n            // test if items should be moved\n            let activeItems = getActiveItems(state.items);\n            activeItems.forEach((item)=>{\n                // if item not is in new value, remove\n                if (!files.find((file)=>file.source === item.source || file.source === item.file)) {\n                    dispatch(\"REMOVE_ITEM\", {\n                        query: item,\n                        remove: false\n                    });\n                }\n            });\n            // add new files\n            activeItems = getActiveItems(state.items);\n            files.forEach((file, index)=>{\n                // if file is already in list\n                if (activeItems.find((item)=>item.source === file.source || item.file === file.source)) return;\n                // not in list, add\n                dispatch(\"ADD_ITEM\", {\n                    ...file,\n                    interactionMethod: InteractionMethod.NONE,\n                    index\n                });\n            });\n        },\n        DID_UPDATE_ITEM_METADATA: ({ id, action, change })=>{\n            // don't do anything\n            if (change.silent) return;\n            // if is called multiple times in close succession we combined all calls together to save resources\n            clearTimeout(state.itemUpdateTimeout);\n            state.itemUpdateTimeout = setTimeout(()=>{\n                const item = getItemById(state.items, id);\n                // only revert and attempt to upload when we're uploading to a server\n                if (!query(\"IS_ASYNC\")) {\n                    // should we update the output data\n                    applyFilterChain(\"SHOULD_PREPARE_OUTPUT\", false, {\n                        item,\n                        query,\n                        action,\n                        change\n                    }).then((shouldPrepareOutput)=>{\n                        // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                        const beforePrepareFile = query(\"GET_BEFORE_PREPARE_FILE\");\n                        if (beforePrepareFile) shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n                        if (!shouldPrepareOutput) return;\n                        dispatch(\"REQUEST_PREPARE_OUTPUT\", {\n                            query: id,\n                            item,\n                            success: (file)=>{\n                                dispatch(\"DID_PREPARE_OUTPUT\", {\n                                    id,\n                                    file\n                                });\n                            }\n                        }, true);\n                    });\n                    return;\n                }\n                // if is local item we need to enable upload button so change can be propagated to server\n                if (item.origin === FileOrigin.LOCAL) {\n                    dispatch(\"DID_LOAD_ITEM\", {\n                        id: item.id,\n                        error: null,\n                        serverFileReference: item.source\n                    });\n                }\n                // for async scenarios\n                const upload = ()=>{\n                    // we push this forward a bit so the interface is updated correctly\n                    setTimeout(()=>{\n                        dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                            query: id\n                        });\n                    }, 32);\n                };\n                const revert = (doUpload)=>{\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\")).then(doUpload ? upload : ()=>{}).catch(()=>{});\n                };\n                const abort = (doUpload)=>{\n                    item.abortProcessing().then(doUpload ? upload : ()=>{});\n                };\n                // if we should re-upload the file immediately\n                if (item.status === ItemStatus.PROCESSING_COMPLETE) {\n                    return revert(state.options.instantUpload);\n                }\n                // if currently uploading, cancel upload\n                if (item.status === ItemStatus.PROCESSING) {\n                    return abort(state.options.instantUpload);\n                }\n                if (state.options.instantUpload) {\n                    upload();\n                }\n            }, 0);\n        },\n        MOVE_ITEM: ({ query, index })=>{\n            const item = getItemByQuery(state.items, query);\n            if (!item) return;\n            const currentIndex = state.items.indexOf(item);\n            index = limit(index, 0, state.items.length - 1);\n            if (currentIndex === index) return;\n            state.items.splice(index, 0, state.items.splice(currentIndex, 1)[0]);\n        },\n        SORT: ({ compare })=>{\n            sortItems(state, compare);\n            dispatch(\"DID_SORT_ITEMS\", {\n                items: query(\"GET_ACTIVE_ITEMS\")\n            });\n        },\n        ADD_ITEMS: ({ items, index, interactionMethod, success = ()=>{}, failure = ()=>{} })=>{\n            let currentIndex = index;\n            if (index === -1 || typeof index === \"undefined\") {\n                const insertLocation = query(\"GET_ITEM_INSERT_LOCATION\");\n                const totalItems = query(\"GET_TOTAL_ITEMS\");\n                currentIndex = insertLocation === \"before\" ? 0 : totalItems;\n            }\n            const ignoredFiles = query(\"GET_IGNORED_FILES\");\n            const isValidFile = (source)=>isFile(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);\n            const validItems = items.filter(isValidFile);\n            const promises = validItems.map((source)=>new Promise((resolve, reject)=>{\n                    dispatch(\"ADD_ITEM\", {\n                        interactionMethod,\n                        source: source.source || source,\n                        success: resolve,\n                        failure: reject,\n                        index: currentIndex++,\n                        options: source.options || {}\n                    });\n                }));\n            Promise.all(promises).then(success).catch(failure);\n        },\n        /**\n     * @param source\n     * @param index\n     * @param interactionMethod\n     */ ADD_ITEM: ({ source, index = -1, interactionMethod, success = ()=>{}, failure = ()=>{}, options = {} })=>{\n            // if no source supplied\n            if (isEmpty(source)) {\n                failure({\n                    error: createResponse(\"error\", 0, \"No source\"),\n                    file: null\n                });\n                return;\n            }\n            // filter out invalid file items, used to filter dropped directory contents\n            if (isFile(source) && state.options.ignoredFiles.includes(source.name.toLowerCase())) {\n                // fail silently\n                return;\n            }\n            // test if there's still room in the list of files\n            if (!hasRoomForItem(state)) {\n                // if multiple allowed, we can't replace\n                // or if only a single item is allowed but we're not allowed to replace it we exit\n                if (state.options.allowMultiple || !state.options.allowMultiple && !state.options.allowReplace) {\n                    const error = createResponse(\"warning\", 0, \"Max files\");\n                    dispatch(\"DID_THROW_MAX_FILES\", {\n                        source,\n                        error\n                    });\n                    failure({\n                        error,\n                        file: null\n                    });\n                    return;\n                }\n                // let's replace the item\n                // id of first item we're about to remove\n                const item = getActiveItems(state.items)[0];\n                // if has been processed remove it from the server as well\n                if (item.status === ItemStatus.PROCESSING_COMPLETE || item.status === ItemStatus.PROCESSING_REVERT_ERROR) {\n                    const forceRevert = query(\"GET_FORCE_REVERT\");\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), forceRevert).then(()=>{\n                        if (!forceRevert) return;\n                        // try to add now\n                        dispatch(\"ADD_ITEM\", {\n                            source,\n                            index,\n                            interactionMethod,\n                            success,\n                            failure,\n                            options\n                        });\n                    }).catch(()=>{}); // no need to handle this catch state for now\n                    if (forceRevert) return;\n                }\n                // remove first item as it will be replaced by this item\n                dispatch(\"REMOVE_ITEM\", {\n                    query: item.id\n                });\n            }\n            // where did the file originate\n            const origin = options.type === \"local\" ? FileOrigin.LOCAL : options.type === \"limbo\" ? FileOrigin.LIMBO : FileOrigin.INPUT;\n            // create a new blank item\n            const item = createItem(// where did this file come from\n            origin, // an input file never has a server file reference\n            origin === FileOrigin.INPUT ? null : source, // file mock data, if defined\n            options.file);\n            // set initial meta data\n            Object.keys(options.metadata || {}).forEach((key)=>{\n                item.setMetadata(key, options.metadata[key]);\n            });\n            // created the item, let plugins add methods\n            applyFilters(\"DID_CREATE_ITEM\", item, {\n                query,\n                dispatch\n            });\n            // where to insert new items\n            const itemInsertLocation = query(\"GET_ITEM_INSERT_LOCATION\");\n            // adjust index if is not allowed to pick location\n            if (!state.options.itemInsertLocationFreedom) {\n                index = itemInsertLocation === \"before\" ? -1 : state.items.length;\n            }\n            // add item to list\n            insertItem(state.items, item, index);\n            // sort items in list\n            if (isFunction(itemInsertLocation) && source) {\n                sortItems(state, itemInsertLocation);\n            }\n            // get a quick reference to the item id\n            const id = item.id;\n            // observe item events\n            item.on(\"init\", ()=>{\n                dispatch(\"DID_INIT_ITEM\", {\n                    id\n                });\n            });\n            item.on(\"load-init\", ()=>{\n                dispatch(\"DID_START_ITEM_LOAD\", {\n                    id\n                });\n            });\n            item.on(\"load-meta\", ()=>{\n                dispatch(\"DID_UPDATE_ITEM_META\", {\n                    id\n                });\n            });\n            item.on(\"load-progress\", (progress)=>{\n                dispatch(\"DID_UPDATE_ITEM_LOAD_PROGRESS\", {\n                    id,\n                    progress\n                });\n            });\n            item.on(\"load-request-error\", (error)=>{\n                const mainStatus = dynamicLabel(state.options.labelFileLoadError)(error);\n                // is client error, no way to recover\n                if (error.code >= 400 && error.code < 500) {\n                    dispatch(\"DID_THROW_ITEM_INVALID\", {\n                        id,\n                        error,\n                        status: {\n                            main: mainStatus,\n                            sub: `${error.code} (${error.body})`\n                        }\n                    });\n                    // reject the file so can be dealt with through API\n                    failure({\n                        error,\n                        file: createItemAPI(item)\n                    });\n                    return;\n                }\n                // is possible server error, so might be possible to retry\n                dispatch(\"DID_THROW_ITEM_LOAD_ERROR\", {\n                    id,\n                    error,\n                    status: {\n                        main: mainStatus,\n                        sub: state.options.labelTapToRetry\n                    }\n                });\n            });\n            item.on(\"load-file-error\", (error)=>{\n                dispatch(\"DID_THROW_ITEM_INVALID\", {\n                    id,\n                    error: error.status,\n                    status: error.status\n                });\n                failure({\n                    error: error.status,\n                    file: createItemAPI(item)\n                });\n            });\n            item.on(\"load-abort\", ()=>{\n                dispatch(\"REMOVE_ITEM\", {\n                    query: id\n                });\n            });\n            item.on(\"load-skip\", ()=>{\n                item.on(\"metadata-update\", (change)=>{\n                    if (!isFile(item.file)) return;\n                    dispatch(\"DID_UPDATE_ITEM_METADATA\", {\n                        id,\n                        change\n                    });\n                });\n                dispatch(\"COMPLETE_LOAD_ITEM\", {\n                    query: id,\n                    item,\n                    data: {\n                        source,\n                        success\n                    }\n                });\n            });\n            item.on(\"load\", ()=>{\n                const handleAdd = (shouldAdd)=>{\n                    // no should not add this file\n                    if (!shouldAdd) {\n                        dispatch(\"REMOVE_ITEM\", {\n                            query: id\n                        });\n                        return;\n                    }\n                    // now interested in metadata updates\n                    item.on(\"metadata-update\", (change)=>{\n                        dispatch(\"DID_UPDATE_ITEM_METADATA\", {\n                            id,\n                            change\n                        });\n                    });\n                    // let plugins decide if the output data should be prepared at this point\n                    // means we'll do this and wait for idle state\n                    applyFilterChain(\"SHOULD_PREPARE_OUTPUT\", false, {\n                        item,\n                        query\n                    }).then((shouldPrepareOutput)=>{\n                        // plugins determined the output data should be prepared (or not), can be adjusted with beforePrepareOutput hook\n                        const beforePrepareFile = query(\"GET_BEFORE_PREPARE_FILE\");\n                        if (beforePrepareFile) shouldPrepareOutput = beforePrepareFile(item, shouldPrepareOutput);\n                        const loadComplete = ()=>{\n                            dispatch(\"COMPLETE_LOAD_ITEM\", {\n                                query: id,\n                                item,\n                                data: {\n                                    source,\n                                    success\n                                }\n                            });\n                            listUpdated(dispatch, state);\n                        };\n                        // exit\n                        if (shouldPrepareOutput) {\n                            // wait for idle state and then run PREPARE_OUTPUT\n                            dispatch(\"REQUEST_PREPARE_OUTPUT\", {\n                                query: id,\n                                item,\n                                success: (file)=>{\n                                    dispatch(\"DID_PREPARE_OUTPUT\", {\n                                        id,\n                                        file\n                                    });\n                                    loadComplete();\n                                }\n                            }, true);\n                            return;\n                        }\n                        loadComplete();\n                    });\n                };\n                // item loaded, allow plugins to\n                // - read data (quickly)\n                // - add metadata\n                applyFilterChain(\"DID_LOAD_ITEM\", item, {\n                    query,\n                    dispatch\n                }).then(()=>{\n                    optionalPromise(query(\"GET_BEFORE_ADD_FILE\"), createItemAPI(item)).then(handleAdd);\n                }).catch((e)=>{\n                    if (!e || !e.error || !e.status) return handleAdd(false);\n                    dispatch(\"DID_THROW_ITEM_INVALID\", {\n                        id,\n                        error: e.error,\n                        status: e.status\n                    });\n                });\n            });\n            item.on(\"process-start\", ()=>{\n                dispatch(\"DID_START_ITEM_PROCESSING\", {\n                    id\n                });\n            });\n            item.on(\"process-progress\", (progress)=>{\n                dispatch(\"DID_UPDATE_ITEM_PROCESS_PROGRESS\", {\n                    id,\n                    progress\n                });\n            });\n            item.on(\"process-error\", (error)=>{\n                dispatch(\"DID_THROW_ITEM_PROCESSING_ERROR\", {\n                    id,\n                    error,\n                    status: {\n                        main: dynamicLabel(state.options.labelFileProcessingError)(error),\n                        sub: state.options.labelTapToRetry\n                    }\n                });\n            });\n            item.on(\"process-revert-error\", (error)=>{\n                dispatch(\"DID_THROW_ITEM_PROCESSING_REVERT_ERROR\", {\n                    id,\n                    error,\n                    status: {\n                        main: dynamicLabel(state.options.labelFileProcessingRevertError)(error),\n                        sub: state.options.labelTapToRetry\n                    }\n                });\n            });\n            item.on(\"process-complete\", (serverFileReference)=>{\n                dispatch(\"DID_COMPLETE_ITEM_PROCESSING\", {\n                    id,\n                    error: null,\n                    serverFileReference\n                });\n                dispatch(\"DID_DEFINE_VALUE\", {\n                    id,\n                    value: serverFileReference\n                });\n            });\n            item.on(\"process-abort\", ()=>{\n                dispatch(\"DID_ABORT_ITEM_PROCESSING\", {\n                    id\n                });\n            });\n            item.on(\"process-revert\", ()=>{\n                dispatch(\"DID_REVERT_ITEM_PROCESSING\", {\n                    id\n                });\n                dispatch(\"DID_DEFINE_VALUE\", {\n                    id,\n                    value: null\n                });\n            });\n            // let view know the item has been inserted\n            dispatch(\"DID_ADD_ITEM\", {\n                id,\n                index,\n                interactionMethod\n            });\n            listUpdated(dispatch, state);\n            // start loading the source\n            const { url, load, restore, fetch } = state.options.server || {};\n            item.load(source, // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)\n            createFileLoader(origin === FileOrigin.INPUT ? isString(source) && isExternalURL(source) ? fetch ? createFetchFunction(url, fetch) : fetchBlob // remote url\n             : fetchBlob // try to fetch url\n             : origin === FileOrigin.LIMBO ? createFetchFunction(url, restore) // limbo\n             : createFetchFunction(url, load) // local\n            ), // called when the file is loaded so it can be piped through the filters\n            (file, success, error)=>{\n                // let's process the file\n                applyFilterChain(\"LOAD_FILE\", file, {\n                    query\n                }).then(success).catch(error);\n            });\n        },\n        REQUEST_PREPARE_OUTPUT: ({ item, success, failure = ()=>{} })=>{\n            // error response if item archived\n            const err = {\n                error: createResponse(\"error\", 0, \"Item not found\"),\n                file: null\n            };\n            // don't handle archived items, an item could have been archived (load aborted) while waiting to be prepared\n            if (item.archived) return failure(err);\n            // allow plugins to alter the file data\n            applyFilterChain(\"PREPARE_OUTPUT\", item.file, {\n                query,\n                item\n            }).then((result)=>{\n                applyFilterChain(\"COMPLETE_PREPARE_OUTPUT\", result, {\n                    query,\n                    item\n                }).then((result)=>{\n                    // don't handle archived items, an item could have been archived (load aborted) while being prepared\n                    if (item.archived) return failure(err);\n                    // we done!\n                    success(result);\n                });\n            });\n        },\n        COMPLETE_LOAD_ITEM: ({ item, data })=>{\n            const { success, source } = data;\n            // sort items in list\n            const itemInsertLocation = query(\"GET_ITEM_INSERT_LOCATION\");\n            if (isFunction(itemInsertLocation) && source) {\n                sortItems(state, itemInsertLocation);\n            }\n            // let interface know the item has loaded\n            dispatch(\"DID_LOAD_ITEM\", {\n                id: item.id,\n                error: null,\n                serverFileReference: item.origin === FileOrigin.INPUT ? null : source\n            });\n            // item has been successfully loaded and added to the\n            // list of items so can now be safely returned for use\n            success(createItemAPI(item));\n            // if this is a local server file we need to show a different state\n            if (item.origin === FileOrigin.LOCAL) {\n                dispatch(\"DID_LOAD_LOCAL_ITEM\", {\n                    id: item.id\n                });\n                return;\n            }\n            // if is a temp server file we prevent async upload call here (as the file is already on the server)\n            if (item.origin === FileOrigin.LIMBO) {\n                dispatch(\"DID_COMPLETE_ITEM_PROCESSING\", {\n                    id: item.id,\n                    error: null,\n                    serverFileReference: source\n                });\n                dispatch(\"DID_DEFINE_VALUE\", {\n                    id: item.id,\n                    value: item.serverId || source\n                });\n                return;\n            }\n            // id we are allowed to upload the file immediately, lets do it\n            if (query(\"IS_ASYNC\") && state.options.instantUpload) {\n                dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                    query: item.id\n                });\n            }\n        },\n        RETRY_ITEM_LOAD: getItemByQueryFromState(state, (item)=>{\n            // try loading the source one more time\n            item.retryLoad();\n        }),\n        REQUEST_ITEM_PREPARE: getItemByQueryFromState(state, (item, success, failure)=>{\n            dispatch(\"REQUEST_PREPARE_OUTPUT\", {\n                query: item.id,\n                item,\n                success: (file)=>{\n                    dispatch(\"DID_PREPARE_OUTPUT\", {\n                        id: item.id,\n                        file\n                    });\n                    success({\n                        file: item,\n                        output: file\n                    });\n                },\n                failure\n            }, true);\n        }),\n        REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state, (item, success, failure)=>{\n            // cannot be queued (or is already queued)\n            const itemCanBeQueuedForProcessing = // waiting for something\n            item.status === ItemStatus.IDLE || // processing went wrong earlier\n            item.status === ItemStatus.PROCESSING_ERROR;\n            // not ready to be processed\n            if (!itemCanBeQueuedForProcessing) {\n                const processNow = ()=>dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                        query: item,\n                        success,\n                        failure\n                    });\n                const process = ()=>document.hidden ? processNow() : setTimeout(processNow, 32);\n                // if already done processing or tried to revert but didn't work, try again\n                if (item.status === ItemStatus.PROCESSING_COMPLETE || item.status === ItemStatus.PROCESSING_REVERT_ERROR) {\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\")).then(process).catch(()=>{}); // don't continue with processing if something went wrong\n                } else if (item.status === ItemStatus.PROCESSING) {\n                    item.abortProcessing().then(process);\n                }\n                return;\n            }\n            // already queued for processing\n            if (item.status === ItemStatus.PROCESSING_QUEUED) return;\n            item.requestProcessing();\n            dispatch(\"DID_REQUEST_ITEM_PROCESSING\", {\n                id: item.id\n            });\n            dispatch(\"PROCESS_ITEM\", {\n                query: item,\n                success,\n                failure\n            }, true);\n        }),\n        PROCESS_ITEM: getItemByQueryFromState(state, (item, success, failure)=>{\n            const maxParallelUploads = query(\"GET_MAX_PARALLEL_UPLOADS\");\n            const totalCurrentUploads = query(\"GET_ITEMS_BY_STATUS\", ItemStatus.PROCESSING).length;\n            // queue and wait till queue is freed up\n            if (totalCurrentUploads === maxParallelUploads) {\n                // queue for later processing\n                state.processingQueue.push({\n                    id: item.id,\n                    success,\n                    failure\n                });\n                // stop it!\n                return;\n            }\n            // if was not queued or is already processing exit here\n            if (item.status === ItemStatus.PROCESSING) return;\n            const processNext = ()=>{\n                // process queueud items\n                const queueEntry = state.processingQueue.shift();\n                // no items left\n                if (!queueEntry) return;\n                // get item reference\n                const { id, success, failure } = queueEntry;\n                const itemReference = getItemByQuery(state.items, id);\n                // if item was archived while in queue, jump to next\n                if (!itemReference || itemReference.archived) {\n                    processNext();\n                    return;\n                }\n                // process queued item\n                dispatch(\"PROCESS_ITEM\", {\n                    query: id,\n                    success,\n                    failure\n                }, true);\n            };\n            // we done function\n            item.onOnce(\"process-complete\", ()=>{\n                success(createItemAPI(item));\n                processNext();\n                // if origin is local, and we're instant uploading, trigger remove of original\n                // as revert will remove file from list\n                const server = state.options.server;\n                const instantUpload = state.options.instantUpload;\n                if (instantUpload && item.origin === FileOrigin.LOCAL && isFunction(server.remove)) {\n                    const noop = ()=>{};\n                    item.origin = FileOrigin.LIMBO;\n                    state.options.server.remove(item.source, noop, noop);\n                }\n                // All items processed? No errors?\n                const allItemsProcessed = query(\"GET_ITEMS_BY_STATUS\", ItemStatus.PROCESSING_COMPLETE).length === state.items.length;\n                if (allItemsProcessed) {\n                    dispatch(\"DID_COMPLETE_ITEM_PROCESSING_ALL\");\n                }\n            });\n            // we error function\n            item.onOnce(\"process-error\", (error)=>{\n                failure({\n                    error,\n                    file: createItemAPI(item)\n                });\n                processNext();\n            });\n            // start file processing\n            const options = state.options;\n            item.process(createFileProcessor(createProcessorFunction(options.server.url, options.server.process, options.name, {\n                chunkTransferId: item.transferId,\n                chunkServer: options.server.patch,\n                chunkUploads: options.chunkUploads,\n                chunkForce: options.chunkForce,\n                chunkSize: options.chunkSize,\n                chunkRetryDelays: options.chunkRetryDelays\n            }), {\n                allowMinimumUploadDuration: query(\"GET_ALLOW_MINIMUM_UPLOAD_DURATION\")\n            }), // called when the file is about to be processed so it can be piped through the transform filters\n            (file, success, error)=>{\n                // allow plugins to alter the file data\n                applyFilterChain(\"PREPARE_OUTPUT\", file, {\n                    query,\n                    item\n                }).then((file)=>{\n                    dispatch(\"DID_PREPARE_OUTPUT\", {\n                        id: item.id,\n                        file\n                    });\n                    success(file);\n                }).catch(error);\n            });\n        }),\n        RETRY_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                query: item\n            });\n        }),\n        REQUEST_REMOVE_ITEM: getItemByQueryFromState(state, (item)=>{\n            optionalPromise(query(\"GET_BEFORE_REMOVE_FILE\"), createItemAPI(item)).then((shouldRemove)=>{\n                if (!shouldRemove) {\n                    return;\n                }\n                dispatch(\"REMOVE_ITEM\", {\n                    query: item\n                });\n            });\n        }),\n        RELEASE_ITEM: getItemByQueryFromState(state, (item)=>{\n            item.release();\n        }),\n        REMOVE_ITEM: getItemByQueryFromState(state, (item, success, failure, options)=>{\n            const removeFromView = ()=>{\n                // get id reference\n                const id = item.id;\n                // archive the item, this does not remove it from the list\n                getItemById(state.items, id).archive();\n                // tell the view the item has been removed\n                dispatch(\"DID_REMOVE_ITEM\", {\n                    error: null,\n                    id,\n                    item\n                });\n                // now the list has been modified\n                listUpdated(dispatch, state);\n                // correctly removed\n                success(createItemAPI(item));\n            };\n            // if this is a local file and the `server.remove` function has been configured,\n            // send source there so dev can remove file from server\n            const server = state.options.server;\n            if (item.origin === FileOrigin.LOCAL && server && isFunction(server.remove) && options.remove !== false) {\n                dispatch(\"DID_START_ITEM_REMOVE\", {\n                    id: item.id\n                });\n                server.remove(item.source, ()=>removeFromView(), (status)=>{\n                    dispatch(\"DID_THROW_ITEM_REMOVE_ERROR\", {\n                        id: item.id,\n                        error: createResponse(\"error\", 0, status, null),\n                        status: {\n                            main: dynamicLabel(state.options.labelFileRemoveError)(status),\n                            sub: state.options.labelTapToRetry\n                        }\n                    });\n                });\n            } else {\n                // if is requesting revert and can revert need to call revert handler (not calling request_ because that would also trigger beforeRemoveHook)\n                if (options.revert && item.origin !== FileOrigin.LOCAL && item.serverId !== null || // if chunked uploads are enabled and we're uploading in chunks for this specific file\n                // or if the file isn't big enough for chunked uploads but chunkForce is set then call\n                // revert before removing from the view...\n                state.options.chunkUploads && item.file.size > state.options.chunkSize || state.options.chunkUploads && state.options.chunkForce) {\n                    item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\"));\n                }\n                // can now safely remove from view\n                removeFromView();\n            }\n        }),\n        ABORT_ITEM_LOAD: getItemByQueryFromState(state, (item)=>{\n            item.abortLoad();\n        }),\n        ABORT_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            // test if is already processed\n            if (item.serverId) {\n                dispatch(\"REVERT_ITEM_PROCESSING\", {\n                    id: item.id\n                });\n                return;\n            }\n            // abort\n            item.abortProcessing().then(()=>{\n                const shouldRemove = state.options.instantUpload;\n                if (shouldRemove) {\n                    dispatch(\"REMOVE_ITEM\", {\n                        query: item.id\n                    });\n                }\n            });\n        }),\n        REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            // not instant uploading, revert immediately\n            if (!state.options.instantUpload) {\n                dispatch(\"REVERT_ITEM_PROCESSING\", {\n                    query: item\n                });\n                return;\n            }\n            // if we're instant uploading the file will also be removed if we revert,\n            // so if a before remove file hook is defined we need to run it now\n            const handleRevert = (shouldRevert)=>{\n                if (!shouldRevert) return;\n                dispatch(\"REVERT_ITEM_PROCESSING\", {\n                    query: item\n                });\n            };\n            const fn = query(\"GET_BEFORE_REMOVE_FILE\");\n            if (!fn) {\n                return handleRevert(true);\n            }\n            const requestRemoveResult = fn(createItemAPI(item));\n            if (requestRemoveResult == null) {\n                // undefined or null\n                return handleRevert(true);\n            }\n            if (typeof requestRemoveResult === \"boolean\") {\n                return handleRevert(requestRemoveResult);\n            }\n            if (typeof requestRemoveResult.then === \"function\") {\n                requestRemoveResult.then(handleRevert);\n            }\n        }),\n        REVERT_ITEM_PROCESSING: getItemByQueryFromState(state, (item)=>{\n            item.revert(createRevertFunction(state.options.server.url, state.options.server.revert), query(\"GET_FORCE_REVERT\")).then(()=>{\n                const shouldRemove = state.options.instantUpload || isMockItem(item);\n                if (shouldRemove) {\n                    dispatch(\"REMOVE_ITEM\", {\n                        query: item.id\n                    });\n                }\n            }).catch(()=>{});\n        }),\n        SET_OPTIONS: ({ options })=>{\n            // get all keys passed\n            const optionKeys = Object.keys(options);\n            // get prioritized keyed to include (remove once not in options object)\n            const prioritizedOptionKeys = PrioritizedOptions.filter((key)=>optionKeys.includes(key));\n            // order the keys, prioritized first, then rest\n            const orderedOptionKeys = [\n                // add prioritized first if passed to options, else remove\n                ...prioritizedOptionKeys,\n                // prevent duplicate keys\n                ...Object.keys(options).filter((key)=>!prioritizedOptionKeys.includes(key))\n            ];\n            // dispatch set event for each option\n            orderedOptionKeys.forEach((key)=>{\n                dispatch(`SET_${fromCamels(key, \"_\").toUpperCase()}`, {\n                    value: options[key]\n                });\n            });\n        }\n    });\nconst PrioritizedOptions = [\n    \"server\"\n];\nconst formatFilename = (name)=>name;\nconst createElement$1 = (tagName)=>{\n    return document.createElement(tagName);\n};\nconst text = (node, value)=>{\n    let textNode = node.childNodes[0];\n    if (!textNode) {\n        textNode = document.createTextNode(value);\n        node.appendChild(textNode);\n    } else if (value !== textNode.nodeValue) {\n        textNode.nodeValue = value;\n    }\n};\nconst polarToCartesian = (centerX, centerY, radius, angleInDegrees)=>{\n    const angleInRadians = (angleInDegrees % 360 - 90) * Math.PI / 180.0;\n    return {\n        x: centerX + radius * Math.cos(angleInRadians),\n        y: centerY + radius * Math.sin(angleInRadians)\n    };\n};\nconst describeArc = (x, y, radius, startAngle, endAngle, arcSweep)=>{\n    const start = polarToCartesian(x, y, radius, endAngle);\n    const end = polarToCartesian(x, y, radius, startAngle);\n    return [\n        \"M\",\n        start.x,\n        start.y,\n        \"A\",\n        radius,\n        radius,\n        0,\n        arcSweep,\n        0,\n        end.x,\n        end.y\n    ].join(\" \");\n};\nconst percentageArc = (x, y, radius, from, to)=>{\n    let arcSweep = 1;\n    if (to > from && to - from <= 0.5) {\n        arcSweep = 0;\n    }\n    if (from > to && from - to >= 0.5) {\n        arcSweep = 0;\n    }\n    return describeArc(x, y, radius, Math.min(0.9999, from) * 360, Math.min(0.9999, to) * 360, arcSweep);\n};\nconst create = ({ root, props })=>{\n    // start at 0\n    props.spin = false;\n    props.progress = 0;\n    props.opacity = 0;\n    // svg\n    const svg = createElement(\"svg\");\n    root.ref.path = createElement(\"path\", {\n        \"stroke-width\": 2,\n        \"stroke-linecap\": \"round\"\n    });\n    svg.appendChild(root.ref.path);\n    root.ref.svg = svg;\n    root.appendChild(svg);\n};\nconst write = ({ root, props })=>{\n    if (props.opacity === 0) {\n        return;\n    }\n    if (props.align) {\n        root.element.dataset.align = props.align;\n    }\n    // get width of stroke\n    const ringStrokeWidth = parseInt(attr(root.ref.path, \"stroke-width\"), 10);\n    // calculate size of ring\n    const size = root.rect.element.width * 0.5;\n    // ring state\n    let ringFrom = 0;\n    let ringTo = 0;\n    // now in busy mode\n    if (props.spin) {\n        ringFrom = 0;\n        ringTo = 0.5;\n    } else {\n        ringFrom = 0;\n        ringTo = props.progress;\n    }\n    // get arc path\n    const coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);\n    // update progress bar\n    attr(root.ref.path, \"d\", coordinates);\n    // hide while contains 0 value\n    attr(root.ref.path, \"stroke-opacity\", props.spin || props.progress > 0 ? 1 : 0);\n};\nconst progressIndicator = createView({\n    tag: \"div\",\n    name: \"progress-indicator\",\n    ignoreRectUpdate: true,\n    ignoreRect: true,\n    create,\n    write,\n    mixins: {\n        apis: [\n            \"progress\",\n            \"spin\",\n            \"align\"\n        ],\n        styles: [\n            \"opacity\"\n        ],\n        animations: {\n            opacity: {\n                type: \"tween\",\n                duration: 500\n            },\n            progress: {\n                type: \"spring\",\n                stiffness: 0.95,\n                damping: 0.65,\n                mass: 10\n            }\n        }\n    }\n});\nconst create$1 = ({ root, props })=>{\n    root.element.innerHTML = (props.icon || \"\") + `<span>${props.label}</span>`;\n    props.isDisabled = false;\n};\nconst write$1 = ({ root, props })=>{\n    const { isDisabled } = props;\n    const shouldDisable = root.query(\"GET_DISABLED\") || props.opacity === 0;\n    if (shouldDisable && !isDisabled) {\n        props.isDisabled = true;\n        attr(root.element, \"disabled\", \"disabled\");\n    } else if (!shouldDisable && isDisabled) {\n        props.isDisabled = false;\n        root.element.removeAttribute(\"disabled\");\n    }\n};\nconst fileActionButton = createView({\n    tag: \"button\",\n    attributes: {\n        type: \"button\"\n    },\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: \"file-action-button\",\n    mixins: {\n        apis: [\n            \"label\"\n        ],\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\"\n        ],\n        animations: {\n            scaleX: \"spring\",\n            scaleY: \"spring\",\n            translateX: \"spring\",\n            translateY: \"spring\",\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            }\n        },\n        listeners: true\n    },\n    create: create$1,\n    write: write$1\n});\nconst toNaturalFileSize = (bytes, decimalSeparator = \".\", base = 1000, options = {})=>{\n    const { labelBytes = \"bytes\", labelKilobytes = \"KB\", labelMegabytes = \"MB\", labelGigabytes = \"GB\" } = options;\n    // no negative byte sizes\n    bytes = Math.round(Math.abs(bytes));\n    const KB = base;\n    const MB = base * base;\n    const GB = base * base * base;\n    // just bytes\n    if (bytes < KB) {\n        return `${bytes} ${labelBytes}`;\n    }\n    // kilobytes\n    if (bytes < MB) {\n        return `${Math.floor(bytes / KB)} ${labelKilobytes}`;\n    }\n    // megabytes\n    if (bytes < GB) {\n        return `${removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator)} ${labelMegabytes}`;\n    }\n    // gigabytes\n    return `${removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator)} ${labelGigabytes}`;\n};\nconst removeDecimalsWhenZero = (value, decimalCount, separator)=>{\n    return value.toFixed(decimalCount).split(\".\").filter((part)=>part !== \"0\").join(separator);\n};\nconst create$2 = ({ root, props })=>{\n    // filename\n    const fileName = createElement$1(\"span\");\n    fileName.className = \"filepond--file-info-main\";\n    // hide for screenreaders\n    // the file is contained in a fieldset with legend that contains the filename\n    // no need to read it twice\n    attr(fileName, \"aria-hidden\", \"true\");\n    root.appendChild(fileName);\n    root.ref.fileName = fileName;\n    // filesize\n    const fileSize = createElement$1(\"span\");\n    fileSize.className = \"filepond--file-info-sub\";\n    root.appendChild(fileSize);\n    root.ref.fileSize = fileSize;\n    // set initial values\n    text(fileSize, root.query(\"GET_LABEL_FILE_WAITING_FOR_SIZE\"));\n    text(fileName, formatFilename(root.query(\"GET_ITEM_NAME\", props.id)));\n};\nconst updateFile = ({ root, props })=>{\n    text(root.ref.fileSize, toNaturalFileSize(root.query(\"GET_ITEM_SIZE\", props.id), \".\", root.query(\"GET_FILE_SIZE_BASE\"), root.query(\"GET_FILE_SIZE_LABELS\", root.query)));\n    text(root.ref.fileName, formatFilename(root.query(\"GET_ITEM_NAME\", props.id)));\n};\nconst updateFileSizeOnError = ({ root, props })=>{\n    // if size is available don't fallback to unknown size message\n    if (isInt(root.query(\"GET_ITEM_SIZE\", props.id))) {\n        updateFile({\n            root,\n            props\n        });\n        return;\n    }\n    text(root.ref.fileSize, root.query(\"GET_LABEL_FILE_SIZE_NOT_AVAILABLE\"));\n};\nconst fileInfo = createView({\n    name: \"file-info\",\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: updateFile,\n        DID_UPDATE_ITEM_META: updateFile,\n        DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,\n        DID_THROW_ITEM_INVALID: updateFileSizeOnError\n    }),\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    create: create$2,\n    mixins: {\n        styles: [\n            \"translateX\",\n            \"translateY\"\n        ],\n        animations: {\n            translateX: \"spring\",\n            translateY: \"spring\"\n        }\n    }\n});\nconst toPercentage = (value)=>Math.round(value * 100);\nconst create$3 = ({ root })=>{\n    // main status\n    const main = createElement$1(\"span\");\n    main.className = \"filepond--file-status-main\";\n    root.appendChild(main);\n    root.ref.main = main;\n    // sub status\n    const sub = createElement$1(\"span\");\n    sub.className = \"filepond--file-status-sub\";\n    root.appendChild(sub);\n    root.ref.sub = sub;\n    didSetItemLoadProgress({\n        root,\n        action: {\n            progress: null\n        }\n    });\n};\nconst didSetItemLoadProgress = ({ root, action })=>{\n    const title = action.progress === null ? root.query(\"GET_LABEL_FILE_LOADING\") : `${root.query(\"GET_LABEL_FILE_LOADING\")} ${toPercentage(action.progress)}%`;\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_CANCEL\"));\n};\nconst didSetItemProcessProgress = ({ root, action })=>{\n    const title = action.progress === null ? root.query(\"GET_LABEL_FILE_PROCESSING\") : `${root.query(\"GET_LABEL_FILE_PROCESSING\")} ${toPercentage(action.progress)}%`;\n    text(root.ref.main, title);\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_CANCEL\"));\n};\nconst didRequestItemProcessing = ({ root })=>{\n    text(root.ref.main, root.query(\"GET_LABEL_FILE_PROCESSING\"));\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_CANCEL\"));\n};\nconst didAbortItemProcessing = ({ root })=>{\n    text(root.ref.main, root.query(\"GET_LABEL_FILE_PROCESSING_ABORTED\"));\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_RETRY\"));\n};\nconst didCompleteItemProcessing = ({ root })=>{\n    text(root.ref.main, root.query(\"GET_LABEL_FILE_PROCESSING_COMPLETE\"));\n    text(root.ref.sub, root.query(\"GET_LABEL_TAP_TO_UNDO\"));\n};\nconst clear = ({ root })=>{\n    text(root.ref.main, \"\");\n    text(root.ref.sub, \"\");\n};\nconst error = ({ root, action })=>{\n    text(root.ref.main, action.status.main);\n    text(root.ref.sub, action.status.sub);\n};\nconst fileStatus = createView({\n    name: \"file-status\",\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: clear,\n        DID_REVERT_ITEM_PROCESSING: clear,\n        DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,\n        DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,\n        DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,\n        DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,\n        DID_THROW_ITEM_LOAD_ERROR: error,\n        DID_THROW_ITEM_INVALID: error,\n        DID_THROW_ITEM_PROCESSING_ERROR: error,\n        DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,\n        DID_THROW_ITEM_REMOVE_ERROR: error\n    }),\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    create: create$3,\n    mixins: {\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"opacity\"\n        ],\n        animations: {\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            },\n            translateX: \"spring\",\n            translateY: \"spring\"\n        }\n    }\n});\n/**\n * Button definitions for the file view\n */ const Buttons = {\n    AbortItemLoad: {\n        label: \"GET_LABEL_BUTTON_ABORT_ITEM_LOAD\",\n        action: \"ABORT_ITEM_LOAD\",\n        className: \"filepond--action-abort-item-load\",\n        align: \"LOAD_INDICATOR_POSITION\"\n    },\n    RetryItemLoad: {\n        label: \"GET_LABEL_BUTTON_RETRY_ITEM_LOAD\",\n        action: \"RETRY_ITEM_LOAD\",\n        icon: \"GET_ICON_RETRY\",\n        className: \"filepond--action-retry-item-load\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    RemoveItem: {\n        label: \"GET_LABEL_BUTTON_REMOVE_ITEM\",\n        action: \"REQUEST_REMOVE_ITEM\",\n        icon: \"GET_ICON_REMOVE\",\n        className: \"filepond--action-remove-item\",\n        align: \"BUTTON_REMOVE_ITEM_POSITION\"\n    },\n    ProcessItem: {\n        label: \"GET_LABEL_BUTTON_PROCESS_ITEM\",\n        action: \"REQUEST_ITEM_PROCESSING\",\n        icon: \"GET_ICON_PROCESS\",\n        className: \"filepond--action-process-item\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    AbortItemProcessing: {\n        label: \"GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING\",\n        action: \"ABORT_ITEM_PROCESSING\",\n        className: \"filepond--action-abort-item-processing\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    RetryItemProcessing: {\n        label: \"GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING\",\n        action: \"RETRY_ITEM_PROCESSING\",\n        icon: \"GET_ICON_RETRY\",\n        className: \"filepond--action-retry-item-processing\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    },\n    RevertItemProcessing: {\n        label: \"GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING\",\n        action: \"REQUEST_REVERT_ITEM_PROCESSING\",\n        icon: \"GET_ICON_UNDO\",\n        className: \"filepond--action-revert-item-processing\",\n        align: \"BUTTON_PROCESS_ITEM_POSITION\"\n    }\n};\n// make a list of buttons, we can then remove buttons from this list if they're disabled\nconst ButtonKeys = [];\nforin(Buttons, (key)=>{\n    ButtonKeys.push(key);\n});\nconst calculateFileInfoOffset = (root)=>{\n    if (getRemoveIndicatorAligment(root) === \"right\") return 0;\n    const buttonRect = root.ref.buttonRemoveItem.rect.element;\n    return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;\n};\nconst calculateButtonWidth = (root)=>{\n    const buttonRect = root.ref.buttonAbortItemLoad.rect.element;\n    return buttonRect.width;\n};\n// Force on full pixels so text stays crips\nconst calculateFileVerticalCenterOffset = (root)=>Math.floor(root.ref.buttonRemoveItem.rect.element.height / 4);\nconst calculateFileHorizontalCenterOffset = (root)=>Math.floor(root.ref.buttonRemoveItem.rect.element.left / 2);\nconst getLoadIndicatorAlignment = (root)=>root.query(\"GET_STYLE_LOAD_INDICATOR_POSITION\");\nconst getProcessIndicatorAlignment = (root)=>root.query(\"GET_STYLE_PROGRESS_INDICATOR_POSITION\");\nconst getRemoveIndicatorAligment = (root)=>root.query(\"GET_STYLE_BUTTON_REMOVE_ITEM_POSITION\");\nconst DefaultStyle = {\n    buttonAbortItemLoad: {\n        opacity: 0\n    },\n    buttonRetryItemLoad: {\n        opacity: 0\n    },\n    buttonRemoveItem: {\n        opacity: 0\n    },\n    buttonProcessItem: {\n        opacity: 0\n    },\n    buttonAbortItemProcessing: {\n        opacity: 0\n    },\n    buttonRetryItemProcessing: {\n        opacity: 0\n    },\n    buttonRevertItemProcessing: {\n        opacity: 0\n    },\n    loadProgressIndicator: {\n        opacity: 0,\n        align: getLoadIndicatorAlignment\n    },\n    processProgressIndicator: {\n        opacity: 0,\n        align: getProcessIndicatorAlignment\n    },\n    processingCompleteIndicator: {\n        opacity: 0,\n        scaleX: 0.75,\n        scaleY: 0.75\n    },\n    info: {\n        translateX: 0,\n        translateY: 0,\n        opacity: 0\n    },\n    status: {\n        translateX: 0,\n        translateY: 0,\n        opacity: 0\n    }\n};\nconst IdleStyle = {\n    buttonRemoveItem: {\n        opacity: 1\n    },\n    buttonProcessItem: {\n        opacity: 1\n    },\n    info: {\n        translateX: calculateFileInfoOffset\n    },\n    status: {\n        translateX: calculateFileInfoOffset\n    }\n};\nconst ProcessingStyle = {\n    buttonAbortItemProcessing: {\n        opacity: 1\n    },\n    processProgressIndicator: {\n        opacity: 1\n    },\n    status: {\n        opacity: 1\n    }\n};\nconst StyleMap = {\n    DID_THROW_ITEM_INVALID: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            translateX: calculateFileInfoOffset,\n            opacity: 1\n        }\n    },\n    DID_START_ITEM_LOAD: {\n        buttonAbortItemLoad: {\n            opacity: 1\n        },\n        loadProgressIndicator: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_THROW_ITEM_LOAD_ERROR: {\n        buttonRetryItemLoad: {\n            opacity: 1\n        },\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_START_ITEM_REMOVE: {\n        processProgressIndicator: {\n            opacity: 1,\n            align: getRemoveIndicatorAligment\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 0\n        }\n    },\n    DID_THROW_ITEM_REMOVE_ERROR: {\n        processProgressIndicator: {\n            opacity: 0,\n            align: getRemoveIndicatorAligment\n        },\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 1,\n            translateX: calculateFileInfoOffset\n        }\n    },\n    DID_LOAD_ITEM: IdleStyle,\n    DID_LOAD_LOCAL_ITEM: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            translateX: calculateFileInfoOffset\n        }\n    },\n    DID_START_ITEM_PROCESSING: ProcessingStyle,\n    DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,\n    DID_COMPLETE_ITEM_PROCESSING: {\n        buttonRevertItemProcessing: {\n            opacity: 1\n        },\n        info: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_THROW_ITEM_PROCESSING_ERROR: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        buttonRetryItemProcessing: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        }\n    },\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {\n        buttonRevertItemProcessing: {\n            opacity: 1\n        },\n        status: {\n            opacity: 1\n        },\n        info: {\n            opacity: 1\n        }\n    },\n    DID_ABORT_ITEM_PROCESSING: {\n        buttonRemoveItem: {\n            opacity: 1\n        },\n        buttonProcessItem: {\n            opacity: 1\n        },\n        info: {\n            translateX: calculateFileInfoOffset\n        },\n        status: {\n            opacity: 1\n        }\n    },\n    DID_REVERT_ITEM_PROCESSING: IdleStyle\n};\n// complete indicator view\nconst processingCompleteIndicatorView = createView({\n    create: ({ root })=>{\n        root.element.innerHTML = root.query(\"GET_ICON_DONE\");\n    },\n    name: \"processing-complete-indicator\",\n    ignoreRect: true,\n    mixins: {\n        styles: [\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\"\n        ],\n        animations: {\n            scaleX: \"spring\",\n            scaleY: \"spring\",\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            }\n        }\n    }\n});\n/**\n * Creates the file view\n */ const create$4 = ({ root, props })=>{\n    // copy Buttons object\n    const LocalButtons = Object.keys(Buttons).reduce((prev, curr)=>{\n        prev[curr] = {\n            ...Buttons[curr]\n        };\n        return prev;\n    }, {});\n    const { id } = props;\n    // allow reverting upload\n    const allowRevert = root.query(\"GET_ALLOW_REVERT\");\n    // allow remove file\n    const allowRemove = root.query(\"GET_ALLOW_REMOVE\");\n    // allow processing upload\n    const allowProcess = root.query(\"GET_ALLOW_PROCESS\");\n    // is instant uploading, need this to determine the icon of the undo button\n    const instantUpload = root.query(\"GET_INSTANT_UPLOAD\");\n    // is async set up\n    const isAsync = root.query(\"IS_ASYNC\");\n    // should align remove item buttons\n    const alignRemoveItemButton = root.query(\"GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN\");\n    // enabled buttons array\n    let buttonFilter;\n    if (isAsync) {\n        if (allowProcess && !allowRevert) {\n            // only remove revert button\n            buttonFilter = (key)=>!/RevertItemProcessing/.test(key);\n        } else if (!allowProcess && allowRevert) {\n            // only remove process button\n            buttonFilter = (key)=>!/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);\n        } else if (!allowProcess && !allowRevert) {\n            // remove all process buttons\n            buttonFilter = (key)=>!/Process/.test(key);\n        }\n    } else {\n        // no process controls available\n        buttonFilter = (key)=>!/Process/.test(key);\n    }\n    const enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();\n    // update icon and label for revert button when instant uploading\n    if (instantUpload && allowRevert) {\n        LocalButtons[\"RevertItemProcessing\"].label = \"GET_LABEL_BUTTON_REMOVE_ITEM\";\n        LocalButtons[\"RevertItemProcessing\"].icon = \"GET_ICON_REMOVE\";\n    }\n    // remove last button (revert) if not allowed\n    if (isAsync && !allowRevert) {\n        const map = StyleMap[\"DID_COMPLETE_ITEM_PROCESSING\"];\n        map.info.translateX = calculateFileHorizontalCenterOffset;\n        map.info.translateY = calculateFileVerticalCenterOffset;\n        map.status.translateY = calculateFileVerticalCenterOffset;\n        map.processingCompleteIndicator = {\n            opacity: 1,\n            scaleX: 1,\n            scaleY: 1\n        };\n    }\n    // should align center\n    if (isAsync && !allowProcess) {\n        [\n            \"DID_START_ITEM_PROCESSING\",\n            \"DID_REQUEST_ITEM_PROCESSING\",\n            \"DID_UPDATE_ITEM_PROCESS_PROGRESS\",\n            \"DID_THROW_ITEM_PROCESSING_ERROR\"\n        ].forEach((key)=>{\n            StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;\n        });\n        StyleMap[\"DID_THROW_ITEM_PROCESSING_ERROR\"].status.translateX = calculateButtonWidth;\n    }\n    // move remove button to right\n    if (alignRemoveItemButton && allowRevert) {\n        LocalButtons[\"RevertItemProcessing\"].align = \"BUTTON_REMOVE_ITEM_POSITION\";\n        const map = StyleMap[\"DID_COMPLETE_ITEM_PROCESSING\"];\n        map.info.translateX = calculateFileInfoOffset;\n        map.status.translateY = calculateFileVerticalCenterOffset;\n        map.processingCompleteIndicator = {\n            opacity: 1,\n            scaleX: 1,\n            scaleY: 1\n        };\n    }\n    // show/hide RemoveItem button\n    if (!allowRemove) {\n        LocalButtons[\"RemoveItem\"].disabled = true;\n    }\n    // create the button views\n    forin(LocalButtons, (key, definition)=>{\n        // create button\n        const buttonView = root.createChildView(fileActionButton, {\n            label: root.query(definition.label),\n            icon: root.query(definition.icon),\n            opacity: 0\n        });\n        // should be appended?\n        if (enabledButtons.includes(key)) {\n            root.appendChildView(buttonView);\n        }\n        // toggle\n        if (definition.disabled) {\n            buttonView.element.setAttribute(\"disabled\", \"disabled\");\n            buttonView.element.setAttribute(\"hidden\", \"hidden\");\n        }\n        // add position attribute\n        buttonView.element.dataset.align = root.query(`GET_STYLE_${definition.align}`);\n        // add class\n        buttonView.element.classList.add(definition.className);\n        // handle interactions\n        buttonView.on(\"click\", (e)=>{\n            e.stopPropagation();\n            if (definition.disabled) return;\n            root.dispatch(definition.action, {\n                query: id\n            });\n        });\n        // set reference\n        root.ref[`button${key}`] = buttonView;\n    });\n    // checkmark\n    root.ref.processingCompleteIndicator = root.appendChildView(root.createChildView(processingCompleteIndicatorView));\n    root.ref.processingCompleteIndicator.element.dataset.align = root.query(`GET_STYLE_BUTTON_PROCESS_ITEM_POSITION`);\n    // create file info view\n    root.ref.info = root.appendChildView(root.createChildView(fileInfo, {\n        id\n    }));\n    // create file status view\n    root.ref.status = root.appendChildView(root.createChildView(fileStatus, {\n        id\n    }));\n    // add progress indicators\n    const loadIndicatorView = root.appendChildView(root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query(`GET_STYLE_LOAD_INDICATOR_POSITION`)\n    }));\n    loadIndicatorView.element.classList.add(\"filepond--load-indicator\");\n    root.ref.loadProgressIndicator = loadIndicatorView;\n    const progressIndicatorView = root.appendChildView(root.createChildView(progressIndicator, {\n        opacity: 0,\n        align: root.query(`GET_STYLE_PROGRESS_INDICATOR_POSITION`)\n    }));\n    progressIndicatorView.element.classList.add(\"filepond--process-indicator\");\n    root.ref.processProgressIndicator = progressIndicatorView;\n    // current active styles\n    root.ref.activeStyles = [];\n};\nconst write$2 = ({ root, actions, props })=>{\n    // route actions\n    route({\n        root,\n        actions,\n        props\n    });\n    // select last state change action\n    let action = actions.concat().filter((action)=>/^DID_/.test(action.type)).reverse().find((action)=>StyleMap[action.type]);\n    // a new action happened, let's get the matching styles\n    if (action) {\n        // define new active styles\n        root.ref.activeStyles = [];\n        const stylesToApply = StyleMap[action.type];\n        forin(DefaultStyle, (name, defaultStyles)=>{\n            // get reference to control\n            const control = root.ref[name];\n            // loop over all styles for this control\n            forin(defaultStyles, (key, defaultValue)=>{\n                const value = stylesToApply[name] && typeof stylesToApply[name][key] !== \"undefined\" ? stylesToApply[name][key] : defaultValue;\n                root.ref.activeStyles.push({\n                    control,\n                    key,\n                    value\n                });\n            });\n        });\n    }\n    // apply active styles to element\n    root.ref.activeStyles.forEach(({ control, key, value })=>{\n        control[key] = typeof value === \"function\" ? value(root) : value;\n    });\n};\nconst route = createRoute({\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: ({ root, action })=>{\n        root.ref.buttonAbortItemProcessing.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: ({ root, action })=>{\n        root.ref.buttonAbortItemLoad.label = action.value;\n    },\n    DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: ({ root, action })=>{\n        root.ref.buttonAbortItemRemoval.label = action.value;\n    },\n    DID_REQUEST_ITEM_PROCESSING: ({ root })=>{\n        root.ref.processProgressIndicator.spin = true;\n        root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_LOAD: ({ root })=>{\n        root.ref.loadProgressIndicator.spin = true;\n        root.ref.loadProgressIndicator.progress = 0;\n    },\n    DID_START_ITEM_REMOVE: ({ root })=>{\n        root.ref.processProgressIndicator.spin = true;\n        root.ref.processProgressIndicator.progress = 0;\n    },\n    DID_UPDATE_ITEM_LOAD_PROGRESS: ({ root, action })=>{\n        root.ref.loadProgressIndicator.spin = false;\n        root.ref.loadProgressIndicator.progress = action.progress;\n    },\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: ({ root, action })=>{\n        root.ref.processProgressIndicator.spin = false;\n        root.ref.processProgressIndicator.progress = action.progress;\n    }\n});\nconst file = createView({\n    create: create$4,\n    write: write$2,\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    name: \"file\"\n});\n/**\n * Creates the file view\n */ const create$5 = ({ root, props })=>{\n    // filename\n    root.ref.fileName = createElement$1(\"legend\");\n    root.appendChild(root.ref.fileName);\n    // file appended\n    root.ref.file = root.appendChildView(root.createChildView(file, {\n        id: props.id\n    }));\n    // data has moved to data.js\n    root.ref.data = false;\n};\n/**\n * Data storage\n */ const didLoadItem = ({ root, props })=>{\n    // updates the legend of the fieldset so screenreaders can better group buttons\n    text(root.ref.fileName, formatFilename(root.query(\"GET_ITEM_NAME\", props.id)));\n};\nconst fileWrapper = createView({\n    create: create$5,\n    ignoreRect: true,\n    write: createRoute({\n        DID_LOAD_ITEM: didLoadItem\n    }),\n    didCreateView: (root)=>{\n        applyFilters(\"CREATE_VIEW\", {\n            ...root,\n            view: root\n        });\n    },\n    tag: \"fieldset\",\n    name: \"file-wrapper\"\n});\nconst PANEL_SPRING_PROPS = {\n    type: \"spring\",\n    damping: 0.6,\n    mass: 7\n};\nconst create$6 = ({ root, props })=>{\n    [\n        {\n            name: \"top\"\n        },\n        {\n            name: \"center\",\n            props: {\n                translateY: null,\n                scaleY: null\n            },\n            mixins: {\n                animations: {\n                    scaleY: PANEL_SPRING_PROPS\n                },\n                styles: [\n                    \"translateY\",\n                    \"scaleY\"\n                ]\n            }\n        },\n        {\n            name: \"bottom\",\n            props: {\n                translateY: null\n            },\n            mixins: {\n                animations: {\n                    translateY: PANEL_SPRING_PROPS\n                },\n                styles: [\n                    \"translateY\"\n                ]\n            }\n        }\n    ].forEach((section)=>{\n        createSection(root, section, props.name);\n    });\n    root.element.classList.add(`filepond--${props.name}`);\n    root.ref.scalable = null;\n};\nconst createSection = (root, section, className)=>{\n    const viewConstructor = createView({\n        name: `panel-${section.name} filepond--${className}`,\n        mixins: section.mixins,\n        ignoreRectUpdate: true\n    });\n    const view = root.createChildView(viewConstructor, section.props);\n    root.ref[section.name] = root.appendChildView(view);\n};\nconst write$3 = ({ root, props })=>{\n    // update scalable state\n    if (root.ref.scalable === null || props.scalable !== root.ref.scalable) {\n        root.ref.scalable = isBoolean(props.scalable) ? props.scalable : true;\n        root.element.dataset.scalable = root.ref.scalable;\n    }\n    // no height, can't set\n    if (!props.height) return;\n    // get child rects\n    const topRect = root.ref.top.rect.element;\n    const bottomRect = root.ref.bottom.rect.element;\n    // make sure height never is smaller than bottom and top seciton heights combined (will probably never happen, but who knows)\n    const height = Math.max(topRect.height + bottomRect.height, props.height);\n    // offset center part\n    root.ref.center.translateY = topRect.height;\n    // scale center part\n    // use math ceil to prevent transparent lines because of rounding errors\n    root.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;\n    // offset bottom part\n    root.ref.bottom.translateY = height - bottomRect.height;\n};\nconst panel = createView({\n    name: \"panel\",\n    read: ({ root, props })=>props.heightCurrent = root.ref.bottom.translateY,\n    write: write$3,\n    create: create$6,\n    ignoreRect: true,\n    mixins: {\n        apis: [\n            \"height\",\n            \"heightCurrent\",\n            \"scalable\"\n        ]\n    }\n});\nconst createDragHelper = (items)=>{\n    const itemIds = items.map((item)=>item.id);\n    let prevIndex = undefined;\n    return {\n        setIndex: (index)=>{\n            prevIndex = index;\n        },\n        getIndex: ()=>prevIndex,\n        getItemIndex: (item)=>itemIds.indexOf(item.id)\n    };\n};\nconst ITEM_TRANSLATE_SPRING = {\n    type: \"spring\",\n    stiffness: 0.75,\n    damping: 0.45,\n    mass: 10\n};\nconst ITEM_SCALE_SPRING = \"spring\";\nconst StateMap = {\n    DID_START_ITEM_LOAD: \"busy\",\n    DID_UPDATE_ITEM_LOAD_PROGRESS: \"loading\",\n    DID_THROW_ITEM_INVALID: \"load-invalid\",\n    DID_THROW_ITEM_LOAD_ERROR: \"load-error\",\n    DID_LOAD_ITEM: \"idle\",\n    DID_THROW_ITEM_REMOVE_ERROR: \"remove-error\",\n    DID_START_ITEM_REMOVE: \"busy\",\n    DID_START_ITEM_PROCESSING: \"busy processing\",\n    DID_REQUEST_ITEM_PROCESSING: \"busy processing\",\n    DID_UPDATE_ITEM_PROCESS_PROGRESS: \"processing\",\n    DID_COMPLETE_ITEM_PROCESSING: \"processing-complete\",\n    DID_THROW_ITEM_PROCESSING_ERROR: \"processing-error\",\n    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: \"processing-revert-error\",\n    DID_ABORT_ITEM_PROCESSING: \"cancelled\",\n    DID_REVERT_ITEM_PROCESSING: \"idle\"\n};\n/**\n * Creates the file view\n */ const create$7 = ({ root, props })=>{\n    // select\n    root.ref.handleClick = (e)=>root.dispatch(\"DID_ACTIVATE_ITEM\", {\n            id: props.id\n        });\n    // set id\n    root.element.id = `filepond--item-${props.id}`;\n    root.element.addEventListener(\"click\", root.ref.handleClick);\n    // file view\n    root.ref.container = root.appendChildView(root.createChildView(fileWrapper, {\n        id: props.id\n    }));\n    // file panel\n    root.ref.panel = root.appendChildView(root.createChildView(panel, {\n        name: \"item-panel\"\n    }));\n    // default start height\n    root.ref.panel.height = null;\n    // by default not marked for removal\n    props.markedForRemoval = false;\n    // if not allowed to reorder file items, exit here\n    if (!root.query(\"GET_ALLOW_REORDER\")) return;\n    // set to idle so shows grab cursor\n    root.element.dataset.dragState = \"idle\";\n    const grab = (e)=>{\n        if (!e.isPrimary) return;\n        let removedActivateListener = false;\n        const origin = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        props.dragOrigin = {\n            x: root.translateX,\n            y: root.translateY\n        };\n        props.dragCenter = {\n            x: e.offsetX,\n            y: e.offsetY\n        };\n        const dragState = createDragHelper(root.query(\"GET_ACTIVE_ITEMS\"));\n        root.dispatch(\"DID_GRAB_ITEM\", {\n            id: props.id,\n            dragState\n        });\n        const drag = (e)=>{\n            if (!e.isPrimary) return;\n            e.stopPropagation();\n            e.preventDefault();\n            props.dragOffset = {\n                x: e.pageX - origin.x,\n                y: e.pageY - origin.y\n            };\n            // if dragged stop listening to clicks, will re-add when done dragging\n            const dist = props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;\n            if (dist > 16 && !removedActivateListener) {\n                removedActivateListener = true;\n                root.element.removeEventListener(\"click\", root.ref.handleClick);\n            }\n            root.dispatch(\"DID_DRAG_ITEM\", {\n                id: props.id,\n                dragState\n            });\n        };\n        const drop = (e)=>{\n            if (!e.isPrimary) return;\n            props.dragOffset = {\n                x: e.pageX - origin.x,\n                y: e.pageY - origin.y\n            };\n            reset();\n        };\n        const cancel = ()=>{\n            reset();\n        };\n        const reset = ()=>{\n            document.removeEventListener(\"pointercancel\", cancel);\n            document.removeEventListener(\"pointermove\", drag);\n            document.removeEventListener(\"pointerup\", drop);\n            root.dispatch(\"DID_DROP_ITEM\", {\n                id: props.id,\n                dragState\n            });\n            // start listening to clicks again\n            if (removedActivateListener) {\n                setTimeout(()=>root.element.addEventListener(\"click\", root.ref.handleClick), 0);\n            }\n        };\n        document.addEventListener(\"pointercancel\", cancel);\n        document.addEventListener(\"pointermove\", drag);\n        document.addEventListener(\"pointerup\", drop);\n    };\n    root.element.addEventListener(\"pointerdown\", grab);\n};\nconst route$1 = createRoute({\n    DID_UPDATE_PANEL_HEIGHT: ({ root, action })=>{\n        root.height = action.height;\n    }\n});\nconst write$4 = createRoute({\n    DID_GRAB_ITEM: ({ root, props })=>{\n        props.dragOrigin = {\n            x: root.translateX,\n            y: root.translateY\n        };\n    },\n    DID_DRAG_ITEM: ({ root })=>{\n        root.element.dataset.dragState = \"drag\";\n    },\n    DID_DROP_ITEM: ({ root, props })=>{\n        props.dragOffset = null;\n        props.dragOrigin = null;\n        root.element.dataset.dragState = \"drop\";\n    }\n}, ({ root, actions, props, shouldOptimize })=>{\n    if (root.element.dataset.dragState === \"drop\") {\n        if (root.scaleX <= 1) {\n            root.element.dataset.dragState = \"idle\";\n        }\n    }\n    // select last state change action\n    let action = actions.concat().filter((action)=>/^DID_/.test(action.type)).reverse().find((action)=>StateMap[action.type]);\n    // no need to set same state twice\n    if (action && action.type !== props.currentState) {\n        // set current state\n        props.currentState = action.type;\n        // set state\n        root.element.dataset.filepondItemState = StateMap[props.currentState] || \"\";\n    }\n    // route actions\n    const aspectRatio = root.query(\"GET_ITEM_PANEL_ASPECT_RATIO\") || root.query(\"GET_PANEL_ASPECT_RATIO\");\n    if (!aspectRatio) {\n        route$1({\n            root,\n            actions,\n            props\n        });\n        if (!root.height && root.ref.container.rect.element.height > 0) {\n            root.height = root.ref.container.rect.element.height;\n        }\n    } else if (!shouldOptimize) {\n        root.height = root.rect.element.width * aspectRatio;\n    }\n    // sync panel height with item height\n    if (shouldOptimize) {\n        root.ref.panel.height = null;\n    }\n    root.ref.panel.height = root.height;\n});\nconst item = createView({\n    create: create$7,\n    write: write$4,\n    destroy: ({ root, props })=>{\n        root.element.removeEventListener(\"click\", root.ref.handleClick);\n        root.dispatch(\"RELEASE_ITEM\", {\n            query: props.id\n        });\n    },\n    tag: \"li\",\n    name: \"item\",\n    mixins: {\n        apis: [\n            \"id\",\n            \"interactionMethod\",\n            \"markedForRemoval\",\n            \"spawnDate\",\n            \"dragCenter\",\n            \"dragOrigin\",\n            \"dragOffset\"\n        ],\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\",\n            \"height\"\n        ],\n        animations: {\n            scaleX: ITEM_SCALE_SPRING,\n            scaleY: ITEM_SCALE_SPRING,\n            translateX: ITEM_TRANSLATE_SPRING,\n            translateY: ITEM_TRANSLATE_SPRING,\n            opacity: {\n                type: \"tween\",\n                duration: 150\n            }\n        }\n    }\n});\nvar getItemsPerRow = (horizontalSpace, itemWidth)=>{\n    // add one pixel leeway, when using percentages for item width total items can be 1.99 per row\n    return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));\n};\nconst getItemIndexByPosition = (view, children, positionInView)=>{\n    if (!positionInView) return;\n    const horizontalSpace = view.rect.element.width;\n    // const children = view.childViews;\n    const l = children.length;\n    let last = null;\n    // -1, don't move items to accomodate (either add to top or bottom)\n    if (l === 0 || positionInView.top < children[0].rect.element.top) return -1;\n    // let's get the item width\n    const item = children[0];\n    const itemRect = item.rect.element;\n    const itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;\n    const itemWidth = itemRect.width + itemHorizontalMargin;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n    // stack\n    if (itemsPerRow === 1) {\n        for(let index = 0; index < l; index++){\n            const child = children[index];\n            const childMid = child.rect.outer.top + child.rect.element.height * 0.5;\n            if (positionInView.top < childMid) {\n                return index;\n            }\n        }\n        return l;\n    }\n    // grid\n    const itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;\n    const itemHeight = itemRect.height + itemVerticalMargin;\n    for(let index = 0; index < l; index++){\n        const indexX = index % itemsPerRow;\n        const indexY = Math.floor(index / itemsPerRow);\n        const offsetX = indexX * itemWidth;\n        const offsetY = indexY * itemHeight;\n        const itemTop = offsetY - itemRect.marginTop;\n        const itemRight = offsetX + itemWidth;\n        const itemBottom = offsetY + itemHeight + itemRect.marginBottom;\n        if (positionInView.top < itemBottom && positionInView.top > itemTop) {\n            if (positionInView.left < itemRight) {\n                return index;\n            } else if (index !== l - 1) {\n                last = index;\n            } else {\n                last = null;\n            }\n        }\n    }\n    if (last !== null) {\n        return last;\n    }\n    return l;\n};\nconst dropAreaDimensions = {\n    height: 0,\n    width: 0,\n    get getHeight () {\n        return this.height;\n    },\n    set setHeight (val){\n        if (this.height === 0 || val === 0) this.height = val;\n    },\n    get getWidth () {\n        return this.width;\n    },\n    set setWidth (val){\n        if (this.width === 0 || val === 0) this.width = val;\n    },\n    setDimensions: function(height, width) {\n        if (this.height === 0 || height === 0) this.height = height;\n        if (this.width === 0 || width === 0) this.width = width;\n    }\n};\nconst create$8 = ({ root })=>{\n    // need to set role to list as otherwise it won't be read as a list by VoiceOver\n    attr(root.element, \"role\", \"list\");\n    root.ref.lastItemSpanwDate = Date.now();\n};\n/**\n * Inserts a new item\n * @param root\n * @param action\n */ const addItemView = ({ root, action })=>{\n    const { id, index, interactionMethod } = action;\n    root.ref.addIndex = index;\n    const now = Date.now();\n    let spawnDate = now;\n    let opacity = 1;\n    if (interactionMethod !== InteractionMethod.NONE) {\n        opacity = 0;\n        const cooldown = root.query(\"GET_ITEM_INSERT_INTERVAL\");\n        const dist = now - root.ref.lastItemSpanwDate;\n        spawnDate = dist < cooldown ? now + (cooldown - dist) : now;\n    }\n    root.ref.lastItemSpanwDate = spawnDate;\n    root.appendChildView(root.createChildView(// view type\n    item, // props\n    {\n        spawnDate,\n        id,\n        opacity,\n        interactionMethod\n    }), index);\n};\nconst moveItem = (item, x, y, vx = 0, vy = 1)=>{\n    // set to null to remove animation while dragging\n    if (item.dragOffset) {\n        item.translateX = null;\n        item.translateY = null;\n        item.translateX = item.dragOrigin.x + item.dragOffset.x;\n        item.translateY = item.dragOrigin.y + item.dragOffset.y;\n        item.scaleX = 1.025;\n        item.scaleY = 1.025;\n    } else {\n        item.translateX = x;\n        item.translateY = y;\n        if (Date.now() > item.spawnDate) {\n            // reveal element\n            if (item.opacity === 0) {\n                introItemView(item, x, y, vx, vy);\n            }\n            // make sure is default scale every frame\n            item.scaleX = 1;\n            item.scaleY = 1;\n            item.opacity = 1;\n        }\n    }\n};\nconst introItemView = (item, x, y, vx, vy)=>{\n    if (item.interactionMethod === InteractionMethod.NONE) {\n        item.translateX = null;\n        item.translateX = x;\n        item.translateY = null;\n        item.translateY = y;\n    } else if (item.interactionMethod === InteractionMethod.DROP) {\n        item.translateX = null;\n        item.translateX = x - vx * 20;\n        item.translateY = null;\n        item.translateY = y - vy * 10;\n        item.scaleX = 0.8;\n        item.scaleY = 0.8;\n    } else if (item.interactionMethod === InteractionMethod.BROWSE) {\n        item.translateY = null;\n        item.translateY = y - 30;\n    } else if (item.interactionMethod === InteractionMethod.API) {\n        item.translateX = null;\n        item.translateX = x - 30;\n        item.translateY = null;\n    }\n};\n/**\n * Removes an existing item\n * @param root\n * @param action\n */ const removeItemView = ({ root, action })=>{\n    const { id } = action;\n    // get the view matching the given id\n    const view = root.childViews.find((child)=>child.id === id);\n    // if no view found, exit\n    if (!view) {\n        return;\n    }\n    // animate view out of view\n    view.scaleX = 0.9;\n    view.scaleY = 0.9;\n    view.opacity = 0;\n    // mark for removal\n    view.markedForRemoval = true;\n};\nconst getItemHeight = (child)=>child.rect.element.height + child.rect.element.marginBottom * 0.5 + child.rect.element.marginTop * 0.5;\nconst getItemWidth = (child)=>child.rect.element.width + child.rect.element.marginLeft * 0.5 + child.rect.element.marginRight * 0.5;\nconst dragItem = ({ root, action })=>{\n    const { id, dragState } = action;\n    // reference to item\n    const item = root.query(\"GET_ITEM\", {\n        id\n    });\n    // get the view matching the given id\n    const view = root.childViews.find((child)=>child.id === id);\n    const numItems = root.childViews.length;\n    const oldIndex = dragState.getItemIndex(item);\n    // if no view found, exit\n    if (!view) return;\n    const dragPosition = {\n        x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,\n        y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y\n    };\n    // get drag area dimensions\n    const dragHeight = getItemHeight(view);\n    const dragWidth = getItemWidth(view);\n    // get rows and columns (There will always be at least one row and one column if a file is present)\n    let cols = Math.floor(root.rect.outer.width / dragWidth);\n    if (cols > numItems) cols = numItems;\n    // rows are used to find when we have left the preview area bounding box\n    const rows = Math.floor(numItems / cols + 1);\n    dropAreaDimensions.setHeight = dragHeight * rows;\n    dropAreaDimensions.setWidth = dragWidth * cols;\n    // get new index of dragged item\n    var location1 = {\n        y: Math.floor(dragPosition.y / dragHeight),\n        x: Math.floor(dragPosition.x / dragWidth),\n        getGridIndex: function getGridIndex() {\n            if (dragPosition.y > dropAreaDimensions.getHeight || dragPosition.y < 0 || dragPosition.x > dropAreaDimensions.getWidth || dragPosition.x < 0) return oldIndex;\n            return this.y * cols + this.x;\n        },\n        getColIndex: function getColIndex() {\n            const items = root.query(\"GET_ACTIVE_ITEMS\");\n            const visibleChildren = root.childViews.filter((child)=>child.rect.element.height);\n            const children = items.map((item)=>visibleChildren.find((childView)=>childView.id === item.id));\n            const currentIndex = children.findIndex((child)=>child === view);\n            const dragHeight = getItemHeight(view);\n            const l = children.length;\n            let idx = l;\n            let childHeight = 0;\n            let childBottom = 0;\n            let childTop = 0;\n            for(let i = 0; i < l; i++){\n                childHeight = getItemHeight(children[i]);\n                childTop = childBottom;\n                childBottom = childTop + childHeight;\n                if (dragPosition.y < childBottom) {\n                    if (currentIndex > i) {\n                        if (dragPosition.y < childTop + dragHeight) {\n                            idx = i;\n                            break;\n                        }\n                        continue;\n                    }\n                    idx = i;\n                    break;\n                }\n            }\n            return idx;\n        }\n    };\n    // get new index\n    const index = cols > 1 ? location1.getGridIndex() : location1.getColIndex();\n    root.dispatch(\"MOVE_ITEM\", {\n        query: view,\n        index\n    });\n    // if the index of the item changed, dispatch reorder action\n    const currentIndex = dragState.getIndex();\n    if (currentIndex === undefined || currentIndex !== index) {\n        dragState.setIndex(index);\n        if (currentIndex === undefined) return;\n        root.dispatch(\"DID_REORDER_ITEMS\", {\n            items: root.query(\"GET_ACTIVE_ITEMS\"),\n            origin: oldIndex,\n            target: index\n        });\n    }\n};\n/**\n * Setup action routes\n */ const route$2 = createRoute({\n    DID_ADD_ITEM: addItemView,\n    DID_REMOVE_ITEM: removeItemView,\n    DID_DRAG_ITEM: dragItem\n});\n/**\n * Write to view\n * @param root\n * @param actions\n * @param props\n */ const write$5 = ({ root, props, actions, shouldOptimize })=>{\n    // route actions\n    route$2({\n        root,\n        props,\n        actions\n    });\n    const { dragCoordinates } = props;\n    // available space on horizontal axis\n    const horizontalSpace = root.rect.element.width;\n    // only draw children that have dimensions\n    const visibleChildren = root.childViews.filter((child)=>child.rect.element.height);\n    // sort based on current active items\n    const children = root.query(\"GET_ACTIVE_ITEMS\").map((item)=>visibleChildren.find((child)=>child.id === item.id)).filter((item)=>item);\n    // get index\n    const dragIndex = dragCoordinates ? getItemIndexByPosition(root, children, dragCoordinates) : null;\n    // add index is used to reserve the dropped/added item index till the actual item is rendered\n    const addIndex = root.ref.addIndex || null;\n    // add index no longer needed till possibly next draw\n    root.ref.addIndex = null;\n    let dragIndexOffset = 0;\n    let removeIndexOffset = 0;\n    let addIndexOffset = 0;\n    if (children.length === 0) return;\n    const childRect = children[0].rect.element;\n    const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    const itemWidth = childRect.width + itemHorizontalMargin;\n    const itemHeight = childRect.height + itemVerticalMargin;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n    // stack\n    if (itemsPerRow === 1) {\n        let offsetY = 0;\n        let dragOffset = 0;\n        children.forEach((child, index)=>{\n            if (dragIndex) {\n                let dist = index - dragIndex;\n                if (dist === -2) {\n                    dragOffset = -itemVerticalMargin * 0.25;\n                } else if (dist === -1) {\n                    dragOffset = -itemVerticalMargin * 0.75;\n                } else if (dist === 0) {\n                    dragOffset = itemVerticalMargin * 0.75;\n                } else if (dist === 1) {\n                    dragOffset = itemVerticalMargin * 0.25;\n                } else {\n                    dragOffset = 0;\n                }\n            }\n            if (shouldOptimize) {\n                child.translateX = null;\n                child.translateY = null;\n            }\n            if (!child.markedForRemoval) {\n                moveItem(child, 0, offsetY + dragOffset);\n            }\n            let itemHeight = child.rect.element.height + itemVerticalMargin;\n            let visualHeight = itemHeight * (child.markedForRemoval ? child.opacity : 1);\n            offsetY += visualHeight;\n        });\n    } else {\n        let prevX = 0;\n        let prevY = 0;\n        children.forEach((child, index)=>{\n            if (index === dragIndex) {\n                dragIndexOffset = 1;\n            }\n            if (index === addIndex) {\n                addIndexOffset += 1;\n            }\n            if (child.markedForRemoval && child.opacity < 0.5) {\n                removeIndexOffset -= 1;\n            }\n            const visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;\n            const indexX = visualIndex % itemsPerRow;\n            const indexY = Math.floor(visualIndex / itemsPerRow);\n            const offsetX = indexX * itemWidth;\n            const offsetY = indexY * itemHeight;\n            const vectorX = Math.sign(offsetX - prevX);\n            const vectorY = Math.sign(offsetY - prevY);\n            prevX = offsetX;\n            prevY = offsetY;\n            if (child.markedForRemoval) return;\n            if (shouldOptimize) {\n                child.translateX = null;\n                child.translateY = null;\n            }\n            moveItem(child, offsetX, offsetY, vectorX, vectorY);\n        });\n    }\n};\n/**\n * Filters actions that are meant specifically for a certain child of the list\n * @param child\n * @param actions\n */ const filterSetItemActions = (child, actions)=>actions.filter((action)=>{\n        // if action has an id, filter out actions that don't have this child id\n        if (action.data && action.data.id) {\n            return child.id === action.data.id;\n        }\n        // allow all other actions\n        return true;\n    });\nconst list = createView({\n    create: create$8,\n    write: write$5,\n    tag: \"ul\",\n    name: \"list\",\n    didWriteView: ({ root })=>{\n        root.childViews.filter((view)=>view.markedForRemoval && view.opacity === 0 && view.resting).forEach((view)=>{\n            view._destroy();\n            root.removeChildView(view);\n        });\n    },\n    filterFrameActionsForChild: filterSetItemActions,\n    mixins: {\n        apis: [\n            \"dragCoordinates\"\n        ]\n    }\n});\nconst create$9 = ({ root, props })=>{\n    root.ref.list = root.appendChildView(root.createChildView(list));\n    props.dragCoordinates = null;\n    props.overflowing = false;\n};\nconst storeDragCoordinates = ({ root, props, action })=>{\n    if (!root.query(\"GET_ITEM_INSERT_LOCATION_FREEDOM\")) return;\n    props.dragCoordinates = {\n        left: action.position.scopeLeft - root.ref.list.rect.element.left,\n        top: action.position.scopeTop - (root.rect.outer.top + root.rect.element.marginTop + root.rect.element.scrollTop)\n    };\n};\nconst clearDragCoordinates = ({ props })=>{\n    props.dragCoordinates = null;\n};\nconst route$3 = createRoute({\n    DID_DRAG: storeDragCoordinates,\n    DID_END_DRAG: clearDragCoordinates\n});\nconst write$6 = ({ root, props, actions })=>{\n    // route actions\n    route$3({\n        root,\n        props,\n        actions\n    });\n    // current drag position\n    root.ref.list.dragCoordinates = props.dragCoordinates;\n    // if currently overflowing but no longer received overflow\n    if (props.overflowing && !props.overflow) {\n        props.overflowing = false;\n        // reset overflow state\n        root.element.dataset.state = \"\";\n        root.height = null;\n    }\n    // if is not overflowing currently but does receive overflow value\n    if (props.overflow) {\n        const newHeight = Math.round(props.overflow);\n        if (newHeight !== root.height) {\n            props.overflowing = true;\n            root.element.dataset.state = \"overflow\";\n            root.height = newHeight;\n        }\n    }\n};\nconst listScroller = createView({\n    create: create$9,\n    write: write$6,\n    name: \"list-scroller\",\n    mixins: {\n        apis: [\n            \"overflow\",\n            \"dragCoordinates\"\n        ],\n        styles: [\n            \"height\",\n            \"translateY\"\n        ],\n        animations: {\n            translateY: \"spring\"\n        }\n    }\n});\nconst attrToggle = (element, name, state, enabledValue = \"\")=>{\n    if (state) {\n        attr(element, name, enabledValue);\n    } else {\n        element.removeAttribute(name);\n    }\n};\nconst resetFileInput = (input)=>{\n    // no value, no need to reset\n    if (!input || input.value === \"\") {\n        return;\n    }\n    try {\n        // for modern browsers\n        input.value = \"\";\n    } catch (err) {}\n    // for IE10\n    if (input.value) {\n        // quickly append input to temp form and reset form\n        const form = createElement$1(\"form\");\n        const parentNode = input.parentNode;\n        const ref = input.nextSibling;\n        form.appendChild(input);\n        form.reset();\n        // re-inject input where it originally was\n        if (ref) {\n            parentNode.insertBefore(input, ref);\n        } else {\n            parentNode.appendChild(input);\n        }\n    }\n};\nconst create$a = ({ root, props })=>{\n    // set id so can be referenced from outside labels\n    root.element.id = `filepond--browser-${props.id}`;\n    // set name of element (is removed when a value is set)\n    attr(root.element, \"name\", root.query(\"GET_NAME\"));\n    // we have to link this element to the status element\n    attr(root.element, \"aria-controls\", `filepond--assistant-${props.id}`);\n    // set label, we use labelled by as otherwise the screenreader does not read the \"browse\" text in the label (as it has tabindex: 0)\n    attr(root.element, \"aria-labelledby\", `filepond--drop-label-${props.id}`);\n    // set configurable props\n    setAcceptedFileTypes({\n        root,\n        action: {\n            value: root.query(\"GET_ACCEPTED_FILE_TYPES\")\n        }\n    });\n    toggleAllowMultiple({\n        root,\n        action: {\n            value: root.query(\"GET_ALLOW_MULTIPLE\")\n        }\n    });\n    toggleDirectoryFilter({\n        root,\n        action: {\n            value: root.query(\"GET_ALLOW_DIRECTORIES_ONLY\")\n        }\n    });\n    toggleDisabled({\n        root\n    });\n    toggleRequired({\n        root,\n        action: {\n            value: root.query(\"GET_REQUIRED\")\n        }\n    });\n    setCaptureMethod({\n        root,\n        action: {\n            value: root.query(\"GET_CAPTURE_METHOD\")\n        }\n    });\n    // handle changes to the input field\n    root.ref.handleChange = (e)=>{\n        if (!root.element.value) {\n            return;\n        }\n        // extract files and move value of webkitRelativePath path to _relativePath\n        const files = Array.from(root.element.files).map((file)=>{\n            file._relativePath = file.webkitRelativePath;\n            return file;\n        });\n        // we add a little delay so the OS file select window can move out of the way before we add our file\n        setTimeout(()=>{\n            // load files\n            props.onload(files);\n            // reset input, it's just for exposing a method to drop files, should not retain any state\n            resetFileInput(root.element);\n        }, 250);\n    };\n    root.element.addEventListener(\"change\", root.ref.handleChange);\n};\nconst setAcceptedFileTypes = ({ root, action })=>{\n    if (!root.query(\"GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE\")) return;\n    attrToggle(root.element, \"accept\", !!action.value, action.value ? action.value.join(\",\") : \"\");\n};\nconst toggleAllowMultiple = ({ root, action })=>{\n    attrToggle(root.element, \"multiple\", action.value);\n};\nconst toggleDirectoryFilter = ({ root, action })=>{\n    attrToggle(root.element, \"webkitdirectory\", action.value);\n};\nconst toggleDisabled = ({ root })=>{\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const doesAllowBrowse = root.query(\"GET_ALLOW_BROWSE\");\n    const disableField = isDisabled || !doesAllowBrowse;\n    attrToggle(root.element, \"disabled\", disableField);\n};\nconst toggleRequired = ({ root, action })=>{\n    // want to remove required, always possible\n    if (!action.value) {\n        attrToggle(root.element, \"required\", false);\n    } else if (root.query(\"GET_TOTAL_ITEMS\") === 0) {\n        attrToggle(root.element, \"required\", true);\n    }\n};\nconst setCaptureMethod = ({ root, action })=>{\n    attrToggle(root.element, \"capture\", !!action.value, action.value === true ? \"\" : action.value);\n};\nconst updateRequiredStatus = ({ root })=>{\n    const { element } = root;\n    // always remove the required attribute when more than zero items\n    if (root.query(\"GET_TOTAL_ITEMS\") > 0) {\n        attrToggle(element, \"required\", false);\n        attrToggle(element, \"name\", false);\n    } else {\n        // add name attribute\n        attrToggle(element, \"name\", true, root.query(\"GET_NAME\"));\n        // remove any validation messages\n        const shouldCheckValidity = root.query(\"GET_CHECK_VALIDITY\");\n        if (shouldCheckValidity) {\n            element.setCustomValidity(\"\");\n        }\n        // we only add required if the field has been deemed required\n        if (root.query(\"GET_REQUIRED\")) {\n            attrToggle(element, \"required\", true);\n        }\n    }\n};\nconst updateFieldValidityStatus = ({ root })=>{\n    const shouldCheckValidity = root.query(\"GET_CHECK_VALIDITY\");\n    if (!shouldCheckValidity) return;\n    root.element.setCustomValidity(root.query(\"GET_LABEL_INVALID_FIELD\"));\n};\nconst browser = createView({\n    tag: \"input\",\n    name: \"browser\",\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    attributes: {\n        type: \"file\"\n    },\n    create: create$a,\n    destroy: ({ root })=>{\n        root.element.removeEventListener(\"change\", root.ref.handleChange);\n    },\n    write: createRoute({\n        DID_LOAD_ITEM: updateRequiredStatus,\n        DID_REMOVE_ITEM: updateRequiredStatus,\n        DID_THROW_ITEM_INVALID: updateFieldValidityStatus,\n        DID_SET_DISABLED: toggleDisabled,\n        DID_SET_ALLOW_BROWSE: toggleDisabled,\n        DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,\n        DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,\n        DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,\n        DID_SET_CAPTURE_METHOD: setCaptureMethod,\n        DID_SET_REQUIRED: toggleRequired\n    })\n});\nconst Key = {\n    ENTER: 13,\n    SPACE: 32\n};\nconst create$b = ({ root, props })=>{\n    // create the label and link it to the file browser\n    const label = createElement$1(\"label\");\n    attr(label, \"for\", `filepond--browser-${props.id}`);\n    // use for labeling file input (aria-labelledby on file input)\n    attr(label, \"id\", `filepond--drop-label-${props.id}`);\n    // handle keys\n    root.ref.handleKeyDown = (e)=>{\n        const isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;\n        if (!isActivationKey) return;\n        // stops from triggering the element a second time\n        e.preventDefault();\n        // click link (will then in turn activate file input)\n        root.ref.label.click();\n    };\n    root.ref.handleClick = (e)=>{\n        const isLabelClick = e.target === label || label.contains(e.target);\n        // don't want to click twice\n        if (isLabelClick) return;\n        // click link (will then in turn activate file input)\n        root.ref.label.click();\n    };\n    // attach events\n    label.addEventListener(\"keydown\", root.ref.handleKeyDown);\n    root.element.addEventListener(\"click\", root.ref.handleClick);\n    // update\n    updateLabelValue(label, props.caption);\n    // add!\n    root.appendChild(label);\n    root.ref.label = label;\n};\nconst updateLabelValue = (label, value)=>{\n    label.innerHTML = value;\n    const clickable = label.querySelector(\".filepond--label-action\");\n    if (clickable) {\n        attr(clickable, \"tabindex\", \"0\");\n    }\n    return value;\n};\nconst dropLabel = createView({\n    name: \"drop-label\",\n    ignoreRect: true,\n    create: create$b,\n    destroy: ({ root })=>{\n        root.ref.label.addEventListener(\"keydown\", root.ref.handleKeyDown);\n        root.element.removeEventListener(\"click\", root.ref.handleClick);\n    },\n    write: createRoute({\n        DID_SET_LABEL_IDLE: ({ root, action })=>{\n            updateLabelValue(root.ref.label, action.value);\n        }\n    }),\n    mixins: {\n        styles: [\n            \"opacity\",\n            \"translateX\",\n            \"translateY\"\n        ],\n        animations: {\n            opacity: {\n                type: \"tween\",\n                duration: 150\n            },\n            translateX: \"spring\",\n            translateY: \"spring\"\n        }\n    }\n});\nconst blob = createView({\n    name: \"drip-blob\",\n    ignoreRect: true,\n    mixins: {\n        styles: [\n            \"translateX\",\n            \"translateY\",\n            \"scaleX\",\n            \"scaleY\",\n            \"opacity\"\n        ],\n        animations: {\n            scaleX: \"spring\",\n            scaleY: \"spring\",\n            translateX: \"spring\",\n            translateY: \"spring\",\n            opacity: {\n                type: \"tween\",\n                duration: 250\n            }\n        }\n    }\n});\nconst addBlob = ({ root })=>{\n    const centerX = root.rect.element.width * 0.5;\n    const centerY = root.rect.element.height * 0.5;\n    root.ref.blob = root.appendChildView(root.createChildView(blob, {\n        opacity: 0,\n        scaleX: 2.5,\n        scaleY: 2.5,\n        translateX: centerX,\n        translateY: centerY\n    }));\n};\nconst moveBlob = ({ root, action })=>{\n    if (!root.ref.blob) {\n        addBlob({\n            root\n        });\n        return;\n    }\n    root.ref.blob.translateX = action.position.scopeLeft;\n    root.ref.blob.translateY = action.position.scopeTop;\n    root.ref.blob.scaleX = 1;\n    root.ref.blob.scaleY = 1;\n    root.ref.blob.opacity = 1;\n};\nconst hideBlob = ({ root })=>{\n    if (!root.ref.blob) {\n        return;\n    }\n    root.ref.blob.opacity = 0;\n};\nconst explodeBlob = ({ root })=>{\n    if (!root.ref.blob) {\n        return;\n    }\n    root.ref.blob.scaleX = 2.5;\n    root.ref.blob.scaleY = 2.5;\n    root.ref.blob.opacity = 0;\n};\nconst write$7 = ({ root, props, actions })=>{\n    route$4({\n        root,\n        props,\n        actions\n    });\n    const { blob } = root.ref;\n    if (actions.length === 0 && blob && blob.opacity === 0) {\n        root.removeChildView(blob);\n        root.ref.blob = null;\n    }\n};\nconst route$4 = createRoute({\n    DID_DRAG: moveBlob,\n    DID_DROP: explodeBlob,\n    DID_END_DRAG: hideBlob\n});\nconst drip = createView({\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    name: \"drip\",\n    write: write$7\n});\nconst setInputFiles = (element, files)=>{\n    try {\n        // Create a DataTransfer instance and add a newly created file\n        const dataTransfer = new DataTransfer();\n        files.forEach((file)=>{\n            if (file instanceof File) {\n                dataTransfer.items.add(file);\n            } else {\n                dataTransfer.items.add(new File([\n                    file\n                ], file.name, {\n                    type: file.type\n                }));\n            }\n        });\n        // Assign the DataTransfer files list to the file input\n        element.files = dataTransfer.files;\n    } catch (err) {\n        return false;\n    }\n    return true;\n};\nconst create$c = ({ root })=>{\n    root.ref.fields = {};\n    const legend = document.createElement(\"legend\");\n    legend.textContent = \"Files\";\n    root.element.appendChild(legend);\n};\nconst getField = (root, id)=>root.ref.fields[id];\nconst syncFieldPositionsWithItems = (root)=>{\n    root.query(\"GET_ACTIVE_ITEMS\").forEach((item)=>{\n        if (!root.ref.fields[item.id]) return;\n        root.element.appendChild(root.ref.fields[item.id]);\n    });\n};\nconst didReorderItems = ({ root })=>syncFieldPositionsWithItems(root);\nconst didAddItem = ({ root, action })=>{\n    const fileItem = root.query(\"GET_ITEM\", action.id);\n    const isLocalFile = fileItem.origin === FileOrigin.LOCAL;\n    const shouldUseFileInput = !isLocalFile && root.query(\"SHOULD_UPDATE_FILE_INPUT\");\n    const dataContainer = createElement$1(\"input\");\n    dataContainer.type = shouldUseFileInput ? \"file\" : \"hidden\";\n    dataContainer.name = root.query(\"GET_NAME\");\n    root.ref.fields[action.id] = dataContainer;\n    syncFieldPositionsWithItems(root);\n};\nconst didLoadItem$1 = ({ root, action })=>{\n    const field = getField(root, action.id);\n    if (!field) return;\n    // store server ref in hidden input\n    if (action.serverFileReference !== null) field.value = action.serverFileReference;\n    // store file item in file input\n    if (!root.query(\"SHOULD_UPDATE_FILE_INPUT\")) return;\n    const fileItem = root.query(\"GET_ITEM\", action.id);\n    setInputFiles(field, [\n        fileItem.file\n    ]);\n};\nconst didPrepareOutput = ({ root, action })=>{\n    // this timeout pushes the handler after 'load'\n    if (!root.query(\"SHOULD_UPDATE_FILE_INPUT\")) return;\n    setTimeout(()=>{\n        const field = getField(root, action.id);\n        if (!field) return;\n        setInputFiles(field, [\n            action.file\n        ]);\n    }, 0);\n};\nconst didSetDisabled = ({ root })=>{\n    root.element.disabled = root.query(\"GET_DISABLED\");\n};\nconst didRemoveItem = ({ root, action })=>{\n    const field = getField(root, action.id);\n    if (!field) return;\n    if (field.parentNode) field.parentNode.removeChild(field);\n    delete root.ref.fields[action.id];\n};\n// only runs for server files. will refuse to update the value if the field\n// is a file field\nconst didDefineValue = ({ root, action })=>{\n    const field = getField(root, action.id);\n    if (!field) return;\n    if (action.value === null) {\n        // clear field value\n        field.removeAttribute(\"value\");\n    } else {\n        // set field value\n        if (field.type != \"file\") {\n            field.value = action.value;\n        }\n    }\n    syncFieldPositionsWithItems(root);\n};\nconst write$8 = createRoute({\n    DID_SET_DISABLED: didSetDisabled,\n    DID_ADD_ITEM: didAddItem,\n    DID_LOAD_ITEM: didLoadItem$1,\n    DID_REMOVE_ITEM: didRemoveItem,\n    DID_DEFINE_VALUE: didDefineValue,\n    DID_PREPARE_OUTPUT: didPrepareOutput,\n    DID_REORDER_ITEMS: didReorderItems,\n    DID_SORT_ITEMS: didReorderItems\n});\nconst data = createView({\n    tag: \"fieldset\",\n    name: \"data\",\n    create: create$c,\n    write: write$8,\n    ignoreRect: true\n});\nconst getRootNode = (element)=>\"getRootNode\" in element ? element.getRootNode() : document;\nconst images = [\n    \"jpg\",\n    \"jpeg\",\n    \"png\",\n    \"gif\",\n    \"bmp\",\n    \"webp\",\n    \"svg\",\n    \"tiff\"\n];\nconst text$1 = [\n    \"css\",\n    \"csv\",\n    \"html\",\n    \"txt\"\n];\nconst map = {\n    zip: \"zip|compressed\",\n    epub: \"application/epub+zip\"\n};\nconst guesstimateMimeType = (extension = \"\")=>{\n    extension = extension.toLowerCase();\n    if (images.includes(extension)) {\n        return \"image/\" + (extension === \"jpg\" ? \"jpeg\" : extension === \"svg\" ? \"svg+xml\" : extension);\n    }\n    if (text$1.includes(extension)) {\n        return \"text/\" + extension;\n    }\n    return map[extension] || \"\";\n};\nconst requestDataTransferItems = (dataTransfer)=>new Promise((resolve, reject)=>{\n        // try to get links from transfer, if found we'll exit immediately (unless a file is in the dataTransfer as well, this is because Firefox could represent the file as a URL and a file object at the same time)\n        const links = getLinks(dataTransfer);\n        if (links.length && !hasFiles(dataTransfer)) {\n            return resolve(links);\n        }\n        // try to get files from the transfer\n        getFiles(dataTransfer).then(resolve);\n    });\n/**\n * Test if datatransfer has files\n */ const hasFiles = (dataTransfer)=>{\n    if (dataTransfer.files) return dataTransfer.files.length > 0;\n    return false;\n};\n/**\n * Extracts files from a DataTransfer object\n */ const getFiles = (dataTransfer)=>new Promise((resolve, reject)=>{\n        // get the transfer items as promises\n        const promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : [])// only keep file system items (files and directories)\n        .filter((item)=>isFileSystemItem(item))// map each item to promise\n        .map((item)=>getFilesFromItem(item));\n        // if is empty, see if we can extract some info from the files property as a fallback\n        if (!promisedFiles.length) {\n            // TODO: test for directories (should not be allowed)\n            // Use FileReader, problem is that the files property gets lost in the process\n            resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);\n            return;\n        }\n        // done!\n        Promise.all(promisedFiles).then((returnedFileGroups)=>{\n            // flatten groups\n            const files = [];\n            returnedFileGroups.forEach((group)=>{\n                files.push.apply(files, group);\n            });\n            // done (filter out empty files)!\n            resolve(files.filter((file)=>file).map((file)=>{\n                if (!file._relativePath) file._relativePath = file.webkitRelativePath;\n                return file;\n            }));\n        }).catch(console.error);\n    });\nconst isFileSystemItem = (item)=>{\n    if (isEntry(item)) {\n        const entry = getAsEntry(item);\n        if (entry) {\n            return entry.isFile || entry.isDirectory;\n        }\n    }\n    return item.kind === \"file\";\n};\nconst getFilesFromItem = (item)=>new Promise((resolve, reject)=>{\n        if (isDirectoryEntry(item)) {\n            getFilesInDirectory(getAsEntry(item)).then(resolve).catch(reject);\n            return;\n        }\n        resolve([\n            item.getAsFile()\n        ]);\n    });\nconst getFilesInDirectory = (entry)=>new Promise((resolve, reject)=>{\n        const files = [];\n        // the total entries to read\n        let dirCounter = 0;\n        let fileCounter = 0;\n        const resolveIfDone = ()=>{\n            if (fileCounter === 0 && dirCounter === 0) {\n                resolve(files);\n            }\n        };\n        // the recursive function\n        const readEntries = (dirEntry)=>{\n            dirCounter++;\n            const directoryReader = dirEntry.createReader();\n            // directories are returned in batches, we need to process all batches before we're done\n            const readBatch = ()=>{\n                directoryReader.readEntries((entries)=>{\n                    if (entries.length === 0) {\n                        dirCounter--;\n                        resolveIfDone();\n                        return;\n                    }\n                    entries.forEach((entry)=>{\n                        // recursively read more directories\n                        if (entry.isDirectory) {\n                            readEntries(entry);\n                        } else {\n                            // read as file\n                            fileCounter++;\n                            entry.file((file)=>{\n                                const correctedFile = correctMissingFileType(file);\n                                if (entry.fullPath) correctedFile._relativePath = entry.fullPath;\n                                files.push(correctedFile);\n                                fileCounter--;\n                                resolveIfDone();\n                            });\n                        }\n                    });\n                    // try to get next batch of files\n                    readBatch();\n                }, reject);\n            };\n            // read first batch of files\n            readBatch();\n        };\n        // go!\n        readEntries(entry);\n    });\nconst correctMissingFileType = (file)=>{\n    if (file.type.length) return file;\n    const date = file.lastModifiedDate;\n    const name = file.name;\n    const type = guesstimateMimeType(getExtensionFromFilename(file.name));\n    if (!type.length) return file;\n    file = file.slice(0, file.size, type);\n    file.name = name;\n    file.lastModifiedDate = date;\n    return file;\n};\nconst isDirectoryEntry = (item)=>isEntry(item) && (getAsEntry(item) || {}).isDirectory;\nconst isEntry = (item)=>\"webkitGetAsEntry\" in item;\nconst getAsEntry = (item)=>item.webkitGetAsEntry();\n/**\n * Extracts links from a DataTransfer object\n */ const getLinks = (dataTransfer)=>{\n    let links = [];\n    try {\n        // look in meta data property\n        links = getLinksFromTransferMetaData(dataTransfer);\n        if (links.length) {\n            return links;\n        }\n        links = getLinksFromTransferURLData(dataTransfer);\n    } catch (e) {\n    // nope nope nope (probably IE trouble)\n    }\n    return links;\n};\nconst getLinksFromTransferURLData = (dataTransfer)=>{\n    let data = dataTransfer.getData(\"url\");\n    if (typeof data === \"string\" && data.length) {\n        return [\n            data\n        ];\n    }\n    return [];\n};\nconst getLinksFromTransferMetaData = (dataTransfer)=>{\n    let data = dataTransfer.getData(\"text/html\");\n    if (typeof data === \"string\" && data.length) {\n        const matches = data.match(/src\\s*=\\s*\"(.+?)\"/);\n        if (matches) {\n            return [\n                matches[1]\n            ];\n        }\n    }\n    return [];\n};\nconst dragNDropObservers = [];\nconst eventPosition = (e)=>({\n        pageLeft: e.pageX,\n        pageTop: e.pageY,\n        scopeLeft: e.offsetX || e.layerX,\n        scopeTop: e.offsetY || e.layerY\n    });\nconst createDragNDropClient = (element, scopeToObserve, filterElement)=>{\n    const observer = getDragNDropObserver(scopeToObserve);\n    const client = {\n        element,\n        filterElement,\n        state: null,\n        ondrop: ()=>{},\n        onenter: ()=>{},\n        ondrag: ()=>{},\n        onexit: ()=>{},\n        onload: ()=>{},\n        allowdrop: ()=>{}\n    };\n    client.destroy = observer.addListener(client);\n    return client;\n};\nconst getDragNDropObserver = (element)=>{\n    // see if already exists, if so, return\n    const observer = dragNDropObservers.find((item)=>item.element === element);\n    if (observer) {\n        return observer;\n    }\n    // create new observer, does not yet exist for this element\n    const newObserver = createDragNDropObserver(element);\n    dragNDropObservers.push(newObserver);\n    return newObserver;\n};\nconst createDragNDropObserver = (element)=>{\n    const clients = [];\n    const routes = {\n        dragenter,\n        dragover,\n        dragleave,\n        drop\n    };\n    const handlers = {};\n    forin(routes, (event, createHandler)=>{\n        handlers[event] = createHandler(element, clients);\n        element.addEventListener(event, handlers[event], false);\n    });\n    const observer = {\n        element,\n        addListener: (client)=>{\n            // add as client\n            clients.push(client);\n            // return removeListener function\n            return ()=>{\n                // remove client\n                clients.splice(clients.indexOf(client), 1);\n                // if no more clients, clean up observer\n                if (clients.length === 0) {\n                    dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);\n                    forin(routes, (event)=>{\n                        element.removeEventListener(event, handlers[event], false);\n                    });\n                }\n            };\n        }\n    };\n    return observer;\n};\nconst elementFromPoint = (root, point)=>{\n    if (!(\"elementFromPoint\" in root)) {\n        root = document;\n    }\n    return root.elementFromPoint(point.x, point.y);\n};\nconst isEventTarget = (e, target)=>{\n    // get root\n    const root = getRootNode(target);\n    // get element at position\n    // if root is not actual shadow DOM and does not have elementFromPoint method, use the one on document\n    const elementAtPosition = elementFromPoint(root, {\n        x: e.pageX - window.pageXOffset,\n        y: e.pageY - window.pageYOffset\n    });\n    // test if target is the element or if one of its children is\n    return elementAtPosition === target || target.contains(elementAtPosition);\n};\nlet initialTarget = null;\nconst setDropEffect = (dataTransfer, effect)=>{\n    // is in try catch as IE11 will throw error if not\n    try {\n        dataTransfer.dropEffect = effect;\n    } catch (e) {}\n};\nconst dragenter = (root, clients)=>(e)=>{\n        e.preventDefault();\n        initialTarget = e.target;\n        clients.forEach((client)=>{\n            const { element, onenter } = client;\n            if (isEventTarget(e, element)) {\n                client.state = \"enter\";\n                // fire enter event\n                onenter(eventPosition(e));\n            }\n        });\n    };\nconst dragover = (root, clients)=>(e)=>{\n        e.preventDefault();\n        const dataTransfer = e.dataTransfer;\n        requestDataTransferItems(dataTransfer).then((items)=>{\n            let overDropTarget = false;\n            clients.some((client)=>{\n                const { filterElement, element, onenter, onexit, ondrag, allowdrop } = client;\n                // by default we can drop\n                setDropEffect(dataTransfer, \"copy\");\n                // allow transfer of these items\n                const allowsTransfer = allowdrop(items);\n                // only used when can be dropped on page\n                if (!allowsTransfer) {\n                    setDropEffect(dataTransfer, \"none\");\n                    return;\n                }\n                // targetting this client\n                if (isEventTarget(e, element)) {\n                    overDropTarget = true;\n                    // had no previous state, means we are entering this client\n                    if (client.state === null) {\n                        client.state = \"enter\";\n                        onenter(eventPosition(e));\n                        return;\n                    }\n                    // now over element (no matter if it allows the drop or not)\n                    client.state = \"over\";\n                    // needs to allow transfer\n                    if (filterElement && !allowsTransfer) {\n                        setDropEffect(dataTransfer, \"none\");\n                        return;\n                    }\n                    // dragging\n                    ondrag(eventPosition(e));\n                } else {\n                    // should be over an element to drop\n                    if (filterElement && !overDropTarget) {\n                        setDropEffect(dataTransfer, \"none\");\n                    }\n                    // might have just left this client?\n                    if (client.state) {\n                        client.state = null;\n                        onexit(eventPosition(e));\n                    }\n                }\n            });\n        });\n    };\nconst drop = (root, clients)=>(e)=>{\n        e.preventDefault();\n        const dataTransfer = e.dataTransfer;\n        requestDataTransferItems(dataTransfer).then((items)=>{\n            clients.forEach((client)=>{\n                const { filterElement, element, ondrop, onexit, allowdrop } = client;\n                client.state = null;\n                // if we're filtering on element we need to be over the element to drop\n                if (filterElement && !isEventTarget(e, element)) return;\n                // no transfer for this client\n                if (!allowdrop(items)) return onexit(eventPosition(e));\n                // we can drop these items on this client\n                ondrop(eventPosition(e), items);\n            });\n        });\n    };\nconst dragleave = (root, clients)=>(e)=>{\n        if (initialTarget !== e.target) {\n            return;\n        }\n        clients.forEach((client)=>{\n            const { onexit } = client;\n            client.state = null;\n            onexit(eventPosition(e));\n        });\n    };\nconst createHopper = (scope, validateItems, options)=>{\n    // is now hopper scope\n    scope.classList.add(\"filepond--hopper\");\n    // shortcuts\n    const { catchesDropsOnPage, requiresDropOnElement, filterItems = (items)=>items } = options;\n    // create a dnd client\n    const client = createDragNDropClient(scope, catchesDropsOnPage ? document.documentElement : scope, requiresDropOnElement);\n    // current client state\n    let lastState = \"\";\n    let currentState = \"\";\n    // determines if a file may be dropped\n    client.allowdrop = (items)=>{\n        // TODO: if we can, throw error to indicate the items cannot by dropped\n        return validateItems(filterItems(items));\n    };\n    client.ondrop = (position, items)=>{\n        const filteredItems = filterItems(items);\n        if (!validateItems(filteredItems)) {\n            api.ondragend(position);\n            return;\n        }\n        currentState = \"drag-drop\";\n        api.onload(filteredItems, position);\n    };\n    client.ondrag = (position)=>{\n        api.ondrag(position);\n    };\n    client.onenter = (position)=>{\n        currentState = \"drag-over\";\n        api.ondragstart(position);\n    };\n    client.onexit = (position)=>{\n        currentState = \"drag-exit\";\n        api.ondragend(position);\n    };\n    const api = {\n        updateHopperState: ()=>{\n            if (lastState !== currentState) {\n                scope.dataset.hopperState = currentState;\n                lastState = currentState;\n            }\n        },\n        onload: ()=>{},\n        ondragstart: ()=>{},\n        ondrag: ()=>{},\n        ondragend: ()=>{},\n        destroy: ()=>{\n            // destroy client\n            client.destroy();\n        }\n    };\n    return api;\n};\nlet listening = false;\nconst listeners$1 = [];\nconst handlePaste = (e)=>{\n    // if is pasting in input or textarea and the target is outside of a filepond scope, ignore\n    const activeEl = document.activeElement;\n    const isActiveElementEditable = activeEl && (/textarea|input/i.test(activeEl.nodeName) || activeEl.getAttribute(\"contenteditable\") === \"true\");\n    if (isActiveElementEditable) {\n        // test textarea or input is contained in filepond root\n        let inScope = false;\n        let element = activeEl;\n        while(element !== document.body){\n            if (element.classList.contains(\"filepond--root\")) {\n                inScope = true;\n                break;\n            }\n            element = element.parentNode;\n        }\n        if (!inScope) return;\n    }\n    requestDataTransferItems(e.clipboardData).then((files)=>{\n        // no files received\n        if (!files.length) {\n            return;\n        }\n        // notify listeners of received files\n        listeners$1.forEach((listener)=>listener(files));\n    });\n};\nconst listen = (cb)=>{\n    // can't add twice\n    if (listeners$1.includes(cb)) {\n        return;\n    }\n    // add initial listener\n    listeners$1.push(cb);\n    // setup paste listener for entire page\n    if (listening) {\n        return;\n    }\n    listening = true;\n    document.addEventListener(\"paste\", handlePaste);\n};\nconst unlisten = (listener)=>{\n    arrayRemove(listeners$1, listeners$1.indexOf(listener));\n    // clean up\n    if (listeners$1.length === 0) {\n        document.removeEventListener(\"paste\", handlePaste);\n        listening = false;\n    }\n};\nconst createPaster = ()=>{\n    const cb = (files)=>{\n        api.onload(files);\n    };\n    const api = {\n        destroy: ()=>{\n            unlisten(cb);\n        },\n        onload: ()=>{}\n    };\n    listen(cb);\n    return api;\n};\n/**\n * Creates the file view\n */ const create$d = ({ root, props })=>{\n    root.element.id = `filepond--assistant-${props.id}`;\n    attr(root.element, \"role\", \"alert\");\n    attr(root.element, \"aria-live\", \"polite\");\n    attr(root.element, \"aria-relevant\", \"additions\");\n};\nlet addFilesNotificationTimeout = null;\nlet notificationClearTimeout = null;\nconst filenames = [];\nconst assist = (root, message)=>{\n    root.element.textContent = message;\n};\nconst clear$1 = (root)=>{\n    root.element.textContent = \"\";\n};\nconst listModified = (root, filename, label)=>{\n    const total = root.query(\"GET_TOTAL_ITEMS\");\n    assist(root, `${label} ${filename}, ${total} ${total === 1 ? root.query(\"GET_LABEL_FILE_COUNT_SINGULAR\") : root.query(\"GET_LABEL_FILE_COUNT_PLURAL\")}`);\n    // clear group after set amount of time so the status is not read twice\n    clearTimeout(notificationClearTimeout);\n    notificationClearTimeout = setTimeout(()=>{\n        clear$1(root);\n    }, 1500);\n};\nconst isUsingFilePond = (root)=>root.element.parentNode.contains(document.activeElement);\nconst itemAdded = ({ root, action })=>{\n    if (!isUsingFilePond(root)) {\n        return;\n    }\n    root.element.textContent = \"\";\n    const item = root.query(\"GET_ITEM\", action.id);\n    filenames.push(item.filename);\n    clearTimeout(addFilesNotificationTimeout);\n    addFilesNotificationTimeout = setTimeout(()=>{\n        listModified(root, filenames.join(\", \"), root.query(\"GET_LABEL_FILE_ADDED\"));\n        filenames.length = 0;\n    }, 750);\n};\nconst itemRemoved = ({ root, action })=>{\n    if (!isUsingFilePond(root)) {\n        return;\n    }\n    const item = action.item;\n    listModified(root, item.filename, root.query(\"GET_LABEL_FILE_REMOVED\"));\n};\nconst itemProcessed = ({ root, action })=>{\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n    const item = root.query(\"GET_ITEM\", action.id);\n    const filename = item.filename;\n    const label = root.query(\"GET_LABEL_FILE_PROCESSING_COMPLETE\");\n    assist(root, `${filename} ${label}`);\n};\nconst itemProcessedUndo = ({ root, action })=>{\n    const item = root.query(\"GET_ITEM\", action.id);\n    const filename = item.filename;\n    const label = root.query(\"GET_LABEL_FILE_PROCESSING_ABORTED\");\n    assist(root, `${filename} ${label}`);\n};\nconst itemError = ({ root, action })=>{\n    const item = root.query(\"GET_ITEM\", action.id);\n    const filename = item.filename;\n    // will also notify the user when FilePond is not being used, as the user might be occupied with other activities while uploading a file\n    assist(root, `${action.status.main} ${filename} ${action.status.sub}`);\n};\nconst assistant = createView({\n    create: create$d,\n    ignoreRect: true,\n    ignoreRectUpdate: true,\n    write: createRoute({\n        DID_LOAD_ITEM: itemAdded,\n        DID_REMOVE_ITEM: itemRemoved,\n        DID_COMPLETE_ITEM_PROCESSING: itemProcessed,\n        DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,\n        DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,\n        DID_THROW_ITEM_REMOVE_ERROR: itemError,\n        DID_THROW_ITEM_LOAD_ERROR: itemError,\n        DID_THROW_ITEM_INVALID: itemError,\n        DID_THROW_ITEM_PROCESSING_ERROR: itemError\n    }),\n    tag: \"span\",\n    name: \"assistant\"\n});\nconst toCamels = (string, separator = \"-\")=>string.replace(new RegExp(`${separator}.`, \"g\"), (sub)=>sub.charAt(1).toUpperCase());\nconst debounce = (func, interval = 16, immidiateOnly = true)=>{\n    let last = Date.now();\n    let timeout = null;\n    return (...args)=>{\n        clearTimeout(timeout);\n        const dist = Date.now() - last;\n        const fn = ()=>{\n            last = Date.now();\n            func(...args);\n        };\n        if (dist < interval) {\n            // we need to delay by the difference between interval and dist\n            // for example: if distance is 10 ms and interval is 16 ms,\n            // we need to wait an additional 6ms before calling the function)\n            if (!immidiateOnly) {\n                timeout = setTimeout(fn, interval - dist);\n            }\n        } else {\n            // go!\n            fn();\n        }\n    };\n};\nconst MAX_FILES_LIMIT = 1000000;\nconst prevent = (e)=>e.preventDefault();\nconst create$e = ({ root, props })=>{\n    // Add id\n    const id = root.query(\"GET_ID\");\n    if (id) {\n        root.element.id = id;\n    }\n    // Add className\n    const className = root.query(\"GET_CLASS_NAME\");\n    if (className) {\n        className.split(\" \").filter((name)=>name.length).forEach((name)=>{\n            root.element.classList.add(name);\n        });\n    }\n    // Field label\n    root.ref.label = root.appendChildView(root.createChildView(dropLabel, {\n        ...props,\n        translateY: null,\n        caption: root.query(\"GET_LABEL_IDLE\")\n    }));\n    // List of items\n    root.ref.list = root.appendChildView(root.createChildView(listScroller, {\n        translateY: null\n    }));\n    // Background panel\n    root.ref.panel = root.appendChildView(root.createChildView(panel, {\n        name: \"panel-root\"\n    }));\n    // Assistant notifies assistive tech when content changes\n    root.ref.assistant = root.appendChildView(root.createChildView(assistant, {\n        ...props\n    }));\n    // Data\n    root.ref.data = root.appendChildView(root.createChildView(data, {\n        ...props\n    }));\n    // Measure (tests if fixed height was set)\n    // DOCTYPE needs to be set for this to work\n    root.ref.measure = createElement$1(\"div\");\n    root.ref.measure.style.height = \"100%\";\n    root.element.appendChild(root.ref.measure);\n    // information on the root height or fixed height status\n    root.ref.bounds = null;\n    // apply initial style properties\n    root.query(\"GET_STYLES\").filter((style)=>!isEmpty(style.value)).map(({ name, value })=>{\n        root.element.dataset[name] = value;\n    });\n    // determine if width changed\n    root.ref.widthPrevious = null;\n    root.ref.widthUpdated = debounce(()=>{\n        root.ref.updateHistory = [];\n        root.dispatch(\"DID_RESIZE_ROOT\");\n    }, 250);\n    // history of updates\n    root.ref.previousAspectRatio = null;\n    root.ref.updateHistory = [];\n    // prevent scrolling and zooming on iOS (only if supports pointer events, for then we can enable reorder)\n    const canHover = window.matchMedia(\"(pointer: fine) and (hover: hover)\").matches;\n    const hasPointerEvents = \"PointerEvent\" in window;\n    if (root.query(\"GET_ALLOW_REORDER\") && hasPointerEvents && !canHover) {\n        root.element.addEventListener(\"touchmove\", prevent, {\n            passive: false\n        });\n        root.element.addEventListener(\"gesturestart\", prevent);\n    }\n    // add credits\n    const credits = root.query(\"GET_CREDITS\");\n    const hasCredits = credits.length === 2;\n    if (hasCredits) {\n        const frag = document.createElement(\"a\");\n        frag.className = \"filepond--credits\";\n        frag.href = credits[0];\n        frag.tabIndex = -1;\n        frag.target = \"_blank\";\n        frag.rel = \"noopener noreferrer nofollow\";\n        frag.textContent = credits[1];\n        root.element.appendChild(frag);\n        root.ref.credits = frag;\n    }\n};\nconst write$9 = ({ root, props, actions })=>{\n    // route actions\n    route$5({\n        root,\n        props,\n        actions\n    });\n    // apply style properties\n    actions.filter((action)=>/^DID_SET_STYLE_/.test(action.type)).filter((action)=>!isEmpty(action.data.value)).map(({ type, data })=>{\n        const name = toCamels(type.substring(8).toLowerCase(), \"_\");\n        root.element.dataset[name] = data.value;\n        root.invalidateLayout();\n    });\n    if (root.rect.element.hidden) return;\n    if (root.rect.element.width !== root.ref.widthPrevious) {\n        root.ref.widthPrevious = root.rect.element.width;\n        root.ref.widthUpdated();\n    }\n    // get box bounds, we do this only once\n    let bounds = root.ref.bounds;\n    if (!bounds) {\n        bounds = root.ref.bounds = calculateRootBoundingBoxHeight(root);\n        // destroy measure element\n        root.element.removeChild(root.ref.measure);\n        root.ref.measure = null;\n    }\n    // get quick references to various high level parts of the upload tool\n    const { hopper, label, list, panel } = root.ref;\n    // sets correct state to hopper scope\n    if (hopper) {\n        hopper.updateHopperState();\n    }\n    // bool to indicate if we're full or not\n    const aspectRatio = root.query(\"GET_PANEL_ASPECT_RATIO\");\n    const isMultiItem = root.query(\"GET_ALLOW_MULTIPLE\");\n    const totalItems = root.query(\"GET_TOTAL_ITEMS\");\n    const maxItems = isMultiItem ? root.query(\"GET_MAX_FILES\") || MAX_FILES_LIMIT : 1;\n    const atMaxCapacity = totalItems === maxItems;\n    // action used to add item\n    const addAction = actions.find((action)=>action.type === \"DID_ADD_ITEM\");\n    // if reached max capacity and we've just reached it\n    if (atMaxCapacity && addAction) {\n        // get interaction type\n        const interactionMethod = addAction.data.interactionMethod;\n        // hide label\n        label.opacity = 0;\n        if (isMultiItem) {\n            label.translateY = -40;\n        } else {\n            if (interactionMethod === InteractionMethod.API) {\n                label.translateX = 40;\n            } else if (interactionMethod === InteractionMethod.BROWSE) {\n                label.translateY = 40;\n            } else {\n                label.translateY = 30;\n            }\n        }\n    } else if (!atMaxCapacity) {\n        label.opacity = 1;\n        label.translateX = 0;\n        label.translateY = 0;\n    }\n    const listItemMargin = calculateListItemMargin(root);\n    const listHeight = calculateListHeight(root);\n    const labelHeight = label.rect.element.height;\n    const currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;\n    const listMarginTop = atMaxCapacity ? list.rect.element.marginTop : 0;\n    const listMarginBottom = totalItems === 0 ? 0 : list.rect.element.marginBottom;\n    const visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;\n    const boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;\n    // link list to label bottom position\n    list.translateY = Math.max(0, currentLabelHeight - list.rect.element.marginTop) - listItemMargin.top;\n    if (aspectRatio) {\n        // fixed aspect ratio\n        // calculate height based on width\n        const width = root.rect.element.width;\n        const height = width * aspectRatio;\n        // clear history if aspect ratio has changed\n        if (aspectRatio !== root.ref.previousAspectRatio) {\n            root.ref.previousAspectRatio = aspectRatio;\n            root.ref.updateHistory = [];\n        }\n        // remember this width\n        const history = root.ref.updateHistory;\n        history.push(width);\n        const MAX_BOUNCES = 2;\n        if (history.length > MAX_BOUNCES * 2) {\n            const l = history.length;\n            const bottom = l - 10;\n            let bounces = 0;\n            for(let i = l; i >= bottom; i--){\n                if (history[i] === history[i - 2]) {\n                    bounces++;\n                }\n                if (bounces >= MAX_BOUNCES) {\n                    // dont adjust height\n                    return;\n                }\n            }\n        }\n        // fix height of panel so it adheres to aspect ratio\n        panel.scalable = false;\n        panel.height = height;\n        // available height for list\n        const listAvailableHeight = // the height of the panel minus the label height\n        height - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n        if (listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n        // set container bounds (so pushes siblings downwards)\n        root.height = height;\n    } else if (bounds.fixedHeight) {\n        // fixed height\n        // fix height of panel\n        panel.scalable = false;\n        // available height for list\n        const listAvailableHeight = // the height of the panel minus the label height\n        bounds.fixedHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n        // set list height\n        if (listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n    // no need to set container bounds as these are handles by CSS fixed height\n    } else if (bounds.cappedHeight) {\n        // max-height\n        // not a fixed height panel\n        const isCappedHeight = visualHeight >= bounds.cappedHeight;\n        const panelHeight = Math.min(bounds.cappedHeight, visualHeight);\n        panel.scalable = true;\n        panel.height = isCappedHeight ? panelHeight : panelHeight - listItemMargin.top - listItemMargin.bottom;\n        // available height for list\n        const listAvailableHeight = // the height of the panel minus the label height\n        panelHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom\n        (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list\n        (atMaxCapacity ? listMarginTop : 0);\n        // set list height (if is overflowing)\n        if (visualHeight > bounds.cappedHeight && listHeight.visual > listAvailableHeight) {\n            list.overflow = listAvailableHeight;\n        } else {\n            list.overflow = null;\n        }\n        // set container bounds (so pushes siblings downwards)\n        root.height = Math.min(bounds.cappedHeight, boundsHeight - listItemMargin.top - listItemMargin.bottom);\n    } else {\n        // flexible height\n        // not a fixed height panel\n        const itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;\n        panel.scalable = true;\n        panel.height = Math.max(labelHeight, visualHeight - itemMargin);\n        // set container bounds (so pushes siblings downwards)\n        root.height = Math.max(labelHeight, boundsHeight - itemMargin);\n    }\n    // move credits to bottom\n    if (root.ref.credits && panel.heightCurrent) root.ref.credits.style.transform = `translateY(${panel.heightCurrent}px)`;\n};\nconst calculateListItemMargin = (root)=>{\n    const item = root.ref.list.childViews[0].childViews[0];\n    return item ? {\n        top: item.rect.element.marginTop,\n        bottom: item.rect.element.marginBottom\n    } : {\n        top: 0,\n        bottom: 0\n    };\n};\nconst calculateListHeight = (root)=>{\n    let visual = 0;\n    let bounds = 0;\n    // get file list reference\n    const scrollList = root.ref.list;\n    const itemList = scrollList.childViews[0];\n    const visibleChildren = itemList.childViews.filter((child)=>child.rect.element.height);\n    const children = root.query(\"GET_ACTIVE_ITEMS\").map((item)=>visibleChildren.find((child)=>child.id === item.id)).filter((item)=>item);\n    // no children, done!\n    if (children.length === 0) return {\n        visual,\n        bounds\n    };\n    const horizontalSpace = itemList.rect.element.width;\n    const dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);\n    const childRect = children[0].rect.element;\n    const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;\n    const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;\n    const itemWidth = childRect.width + itemHorizontalMargin;\n    const itemHeight = childRect.height + itemVerticalMargin;\n    const newItem = typeof dragIndex !== \"undefined\" && dragIndex >= 0 ? 1 : 0;\n    const removedItem = children.find((child)=>child.markedForRemoval && child.opacity < 0.45) ? -1 : 0;\n    const verticalItemCount = children.length + newItem + removedItem;\n    const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);\n    // stack\n    if (itemsPerRow === 1) {\n        children.forEach((item)=>{\n            const height = item.rect.element.height + itemVerticalMargin;\n            bounds += height;\n            visual += height * item.opacity;\n        });\n    } else {\n        bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;\n        visual = bounds;\n    }\n    return {\n        visual,\n        bounds\n    };\n};\nconst calculateRootBoundingBoxHeight = (root)=>{\n    const height = root.ref.measureHeight || null;\n    const cappedHeight = parseInt(root.style.maxHeight, 10) || null;\n    const fixedHeight = height === 0 ? null : height;\n    return {\n        cappedHeight,\n        fixedHeight\n    };\n};\nconst exceedsMaxFiles = (root, items)=>{\n    const allowReplace = root.query(\"GET_ALLOW_REPLACE\");\n    const allowMultiple = root.query(\"GET_ALLOW_MULTIPLE\");\n    const totalItems = root.query(\"GET_TOTAL_ITEMS\");\n    let maxItems = root.query(\"GET_MAX_FILES\");\n    // total amount of items being dragged\n    const totalBrowseItems = items.length;\n    // if does not allow multiple items and dragging more than one item\n    if (!allowMultiple && totalBrowseItems > 1) {\n        root.dispatch(\"DID_THROW_MAX_FILES\", {\n            source: items,\n            error: createResponse(\"warning\", 0, \"Max files\")\n        });\n        return true;\n    }\n    // limit max items to one if not allowed to drop multiple items\n    maxItems = allowMultiple ? maxItems : 1;\n    if (!allowMultiple && allowReplace) {\n        // There is only one item, so there is room to replace or add an item\n        return false;\n    }\n    // no more room?\n    const hasMaxItems = isInt(maxItems);\n    if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {\n        root.dispatch(\"DID_THROW_MAX_FILES\", {\n            source: items,\n            error: createResponse(\"warning\", 0, \"Max files\")\n        });\n        return true;\n    }\n    return false;\n};\nconst getDragIndex = (list, children, position)=>{\n    const itemList = list.childViews[0];\n    return getItemIndexByPosition(itemList, children, {\n        left: position.scopeLeft - itemList.rect.element.left,\n        top: position.scopeTop - (list.rect.outer.top + list.rect.element.marginTop + list.rect.element.scrollTop)\n    });\n};\n/**\n * Enable or disable file drop functionality\n */ const toggleDrop = (root)=>{\n    const isAllowed = root.query(\"GET_ALLOW_DROP\");\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.hopper) {\n        const hopper = createHopper(root.element, (items)=>{\n            // allow quick validation of dropped items\n            const beforeDropFile = root.query(\"GET_BEFORE_DROP_FILE\") || (()=>true);\n            // all items should be validated by all filters as valid\n            const dropValidation = root.query(\"GET_DROP_VALIDATION\");\n            return dropValidation ? items.every((item)=>applyFilters(\"ALLOW_HOPPER_ITEM\", item, {\n                    query: root.query\n                }).every((result)=>result === true) && beforeDropFile(item)) : true;\n        }, {\n            filterItems: (items)=>{\n                const ignoredFiles = root.query(\"GET_IGNORED_FILES\");\n                return items.filter((item)=>{\n                    if (isFile(item)) {\n                        return !ignoredFiles.includes(item.name.toLowerCase());\n                    }\n                    return true;\n                });\n            },\n            catchesDropsOnPage: root.query(\"GET_DROP_ON_PAGE\"),\n            requiresDropOnElement: root.query(\"GET_DROP_ON_ELEMENT\")\n        });\n        hopper.onload = (items, position)=>{\n            // get item children elements and sort based on list sort\n            const list = root.ref.list.childViews[0];\n            const visibleChildren = list.childViews.filter((child)=>child.rect.element.height);\n            const children = root.query(\"GET_ACTIVE_ITEMS\").map((item)=>visibleChildren.find((child)=>child.id === item.id)).filter((item)=>item);\n            applyFilterChain(\"ADD_ITEMS\", items, {\n                dispatch: root.dispatch\n            }).then((queue)=>{\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n                // go\n                root.dispatch(\"ADD_ITEMS\", {\n                    items: queue,\n                    index: getDragIndex(root.ref.list, children, position),\n                    interactionMethod: InteractionMethod.DROP\n                });\n            });\n            root.dispatch(\"DID_DROP\", {\n                position\n            });\n            root.dispatch(\"DID_END_DRAG\", {\n                position\n            });\n        };\n        hopper.ondragstart = (position)=>{\n            root.dispatch(\"DID_START_DRAG\", {\n                position\n            });\n        };\n        hopper.ondrag = debounce((position)=>{\n            root.dispatch(\"DID_DRAG\", {\n                position\n            });\n        });\n        hopper.ondragend = (position)=>{\n            root.dispatch(\"DID_END_DRAG\", {\n                position\n            });\n        };\n        root.ref.hopper = hopper;\n        root.ref.drip = root.appendChildView(root.createChildView(drip));\n    } else if (!enabled && root.ref.hopper) {\n        root.ref.hopper.destroy();\n        root.ref.hopper = null;\n        root.removeChildView(root.ref.drip);\n    }\n};\n/**\n * Enable or disable browse functionality\n */ const toggleBrowse = (root, props)=>{\n    const isAllowed = root.query(\"GET_ALLOW_BROWSE\");\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.browser) {\n        root.ref.browser = root.appendChildView(root.createChildView(browser, {\n            ...props,\n            onload: (items)=>{\n                applyFilterChain(\"ADD_ITEMS\", items, {\n                    dispatch: root.dispatch\n                }).then((queue)=>{\n                    // these files don't fit so stop here\n                    if (exceedsMaxFiles(root, queue)) return false;\n                    // add items!\n                    root.dispatch(\"ADD_ITEMS\", {\n                        items: queue,\n                        index: -1,\n                        interactionMethod: InteractionMethod.BROWSE\n                    });\n                });\n            }\n        }), 0);\n    } else if (!enabled && root.ref.browser) {\n        root.removeChildView(root.ref.browser);\n        root.ref.browser = null;\n    }\n};\n/**\n * Enable or disable paste functionality\n */ const togglePaste = (root)=>{\n    const isAllowed = root.query(\"GET_ALLOW_PASTE\");\n    const isDisabled = root.query(\"GET_DISABLED\");\n    const enabled = isAllowed && !isDisabled;\n    if (enabled && !root.ref.paster) {\n        root.ref.paster = createPaster();\n        root.ref.paster.onload = (items)=>{\n            applyFilterChain(\"ADD_ITEMS\", items, {\n                dispatch: root.dispatch\n            }).then((queue)=>{\n                // these files don't fit so stop here\n                if (exceedsMaxFiles(root, queue)) return false;\n                // add items!\n                root.dispatch(\"ADD_ITEMS\", {\n                    items: queue,\n                    index: -1,\n                    interactionMethod: InteractionMethod.PASTE\n                });\n            });\n        };\n    } else if (!enabled && root.ref.paster) {\n        root.ref.paster.destroy();\n        root.ref.paster = null;\n    }\n};\n/**\n * Route actions\n */ const route$5 = createRoute({\n    DID_SET_ALLOW_BROWSE: ({ root, props })=>{\n        toggleBrowse(root, props);\n    },\n    DID_SET_ALLOW_DROP: ({ root })=>{\n        toggleDrop(root);\n    },\n    DID_SET_ALLOW_PASTE: ({ root })=>{\n        togglePaste(root);\n    },\n    DID_SET_DISABLED: ({ root, props })=>{\n        toggleDrop(root);\n        togglePaste(root);\n        toggleBrowse(root, props);\n        const isDisabled = root.query(\"GET_DISABLED\");\n        if (isDisabled) {\n            root.element.dataset.disabled = \"disabled\";\n        } else {\n            // delete root.element.dataset.disabled; <= this does not work on iOS 10\n            root.element.removeAttribute(\"data-disabled\");\n        }\n    }\n});\nconst root = createView({\n    name: \"root\",\n    read: ({ root })=>{\n        if (root.ref.measure) {\n            root.ref.measureHeight = root.ref.measure.offsetHeight;\n        }\n    },\n    create: create$e,\n    write: write$9,\n    destroy: ({ root })=>{\n        if (root.ref.paster) {\n            root.ref.paster.destroy();\n        }\n        if (root.ref.hopper) {\n            root.ref.hopper.destroy();\n        }\n        root.element.removeEventListener(\"touchmove\", prevent);\n        root.element.removeEventListener(\"gesturestart\", prevent);\n    },\n    mixins: {\n        styles: [\n            \"height\"\n        ]\n    }\n});\n// creates the app\nconst createApp = (initialOptions = {})=>{\n    // let element\n    let originalElement = null;\n    // get default options\n    const defaultOptions = getOptions();\n    // create the data store, this will contain all our app info\n    const store = createStore(// initial state (should be serializable)\n    createInitialState(defaultOptions), // queries\n    [\n        queries,\n        createOptionQueries(defaultOptions)\n    ], // action handlers\n    [\n        actions,\n        createOptionActions(defaultOptions)\n    ]);\n    // set initial options\n    store.dispatch(\"SET_OPTIONS\", {\n        options: initialOptions\n    });\n    // kick thread if visibility changes\n    const visibilityHandler = ()=>{\n        if (document.hidden) return;\n        store.dispatch(\"KICK\");\n    };\n    document.addEventListener(\"visibilitychange\", visibilityHandler);\n    // re-render on window resize start and finish\n    let resizeDoneTimer = null;\n    let isResizing = false;\n    let isResizingHorizontally = false;\n    let initialWindowWidth = null;\n    let currentWindowWidth = null;\n    const resizeHandler = ()=>{\n        if (!isResizing) {\n            isResizing = true;\n        }\n        clearTimeout(resizeDoneTimer);\n        resizeDoneTimer = setTimeout(()=>{\n            isResizing = false;\n            initialWindowWidth = null;\n            currentWindowWidth = null;\n            if (isResizingHorizontally) {\n                isResizingHorizontally = false;\n                store.dispatch(\"DID_STOP_RESIZE\");\n            }\n        }, 500);\n    };\n    window.addEventListener(\"resize\", resizeHandler);\n    // render initial view\n    const view = root(store, {\n        id: getUniqueId()\n    });\n    //\n    // PRIVATE API -------------------------------------------------------------------------------------\n    //\n    let isResting = false;\n    let isHidden = false;\n    const readWriteApi = {\n        // necessary for update loop\n        /**\n         * Reads from dom (never call manually)\n         * @private\n         */ _read: ()=>{\n            // test if we're resizing horizontally\n            // TODO: see if we can optimize this by measuring root rect\n            if (isResizing) {\n                currentWindowWidth = window.innerWidth;\n                if (!initialWindowWidth) {\n                    initialWindowWidth = currentWindowWidth;\n                }\n                if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {\n                    store.dispatch(\"DID_START_RESIZE\");\n                    isResizingHorizontally = true;\n                }\n            }\n            if (isHidden && isResting) {\n                // test if is no longer hidden\n                isResting = view.element.offsetParent === null;\n            }\n            // if resting, no need to read as numbers will still all be correct\n            if (isResting) return;\n            // read view data\n            view._read();\n            // if is hidden we need to know so we exit rest mode when revealed\n            isHidden = view.rect.element.hidden;\n        },\n        /**\n         * Writes to dom (never call manually)\n         * @private\n         */ _write: (ts)=>{\n            // get all actions from store\n            const actions = store.processActionQueue()// filter out set actions (these will automatically trigger DID_SET)\n            .filter((action)=>!/^SET_/.test(action.type));\n            // if was idling and no actions stop here\n            if (isResting && !actions.length) return;\n            // some actions might trigger events\n            routeActionsToEvents(actions);\n            // update the view\n            isResting = view._write(ts, actions, isResizingHorizontally);\n            // will clean up all archived items\n            removeReleasedItems(store.query(\"GET_ITEMS\"));\n            // now idling\n            if (isResting) {\n                store.processDispatchQueue();\n            }\n        }\n    };\n    //\n    // EXPOSE EVENTS -------------------------------------------------------------------------------------\n    //\n    const createEvent = (name)=>(data)=>{\n            // create default event\n            const event = {\n                type: name\n            };\n            // no data to add\n            if (!data) {\n                return event;\n            }\n            // copy relevant props\n            if (data.hasOwnProperty(\"error\")) {\n                event.error = data.error ? {\n                    ...data.error\n                } : null;\n            }\n            if (data.status) {\n                event.status = {\n                    ...data.status\n                };\n            }\n            if (data.file) {\n                event.output = data.file;\n            }\n            // only source is available, else add item if possible\n            if (data.source) {\n                event.file = data.source;\n            } else if (data.item || data.id) {\n                const item = data.item ? data.item : store.query(\"GET_ITEM\", data.id);\n                event.file = item ? createItemAPI(item) : null;\n            }\n            // map all items in a possible items array\n            if (data.items) {\n                event.items = data.items.map(createItemAPI);\n            }\n            // if this is a progress event add the progress amount\n            if (/progress/.test(name)) {\n                event.progress = data.progress;\n            }\n            // copy relevant props\n            if (data.hasOwnProperty(\"origin\") && data.hasOwnProperty(\"target\")) {\n                event.origin = data.origin;\n                event.target = data.target;\n            }\n            return event;\n        };\n    const eventRoutes = {\n        DID_DESTROY: createEvent(\"destroy\"),\n        DID_INIT: createEvent(\"init\"),\n        DID_THROW_MAX_FILES: createEvent(\"warning\"),\n        DID_INIT_ITEM: createEvent(\"initfile\"),\n        DID_START_ITEM_LOAD: createEvent(\"addfilestart\"),\n        DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent(\"addfileprogress\"),\n        DID_LOAD_ITEM: createEvent(\"addfile\"),\n        DID_THROW_ITEM_INVALID: [\n            createEvent(\"error\"),\n            createEvent(\"addfile\")\n        ],\n        DID_THROW_ITEM_LOAD_ERROR: [\n            createEvent(\"error\"),\n            createEvent(\"addfile\")\n        ],\n        DID_THROW_ITEM_REMOVE_ERROR: [\n            createEvent(\"error\"),\n            createEvent(\"removefile\")\n        ],\n        DID_PREPARE_OUTPUT: createEvent(\"preparefile\"),\n        DID_START_ITEM_PROCESSING: createEvent(\"processfilestart\"),\n        DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent(\"processfileprogress\"),\n        DID_ABORT_ITEM_PROCESSING: createEvent(\"processfileabort\"),\n        DID_COMPLETE_ITEM_PROCESSING: createEvent(\"processfile\"),\n        DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent(\"processfiles\"),\n        DID_REVERT_ITEM_PROCESSING: createEvent(\"processfilerevert\"),\n        DID_THROW_ITEM_PROCESSING_ERROR: [\n            createEvent(\"error\"),\n            createEvent(\"processfile\")\n        ],\n        DID_REMOVE_ITEM: createEvent(\"removefile\"),\n        DID_UPDATE_ITEMS: createEvent(\"updatefiles\"),\n        DID_ACTIVATE_ITEM: createEvent(\"activatefile\"),\n        DID_REORDER_ITEMS: createEvent(\"reorderfiles\")\n    };\n    const exposeEvent = (event)=>{\n        // create event object to be dispatched\n        const detail = {\n            pond: exports,\n            ...event\n        };\n        delete detail.type;\n        view.element.dispatchEvent(new CustomEvent(`FilePond:${event.type}`, {\n            // event info\n            detail,\n            // event behaviour\n            bubbles: true,\n            cancelable: true,\n            composed: true\n        }));\n        // event object to params used for `on()` event handlers and callbacks `oninit()`\n        const params = [];\n        // if is possible error event, make it the first param\n        if (event.hasOwnProperty(\"error\")) {\n            params.push(event.error);\n        }\n        // file is always section\n        if (event.hasOwnProperty(\"file\")) {\n            params.push(event.file);\n        }\n        // append other props\n        const filtered = [\n            \"type\",\n            \"error\",\n            \"file\"\n        ];\n        Object.keys(event).filter((key)=>!filtered.includes(key)).forEach((key)=>params.push(event[key]));\n        // on(type, () => { })\n        exports.fire(event.type, ...params);\n        // oninit = () => {}\n        const handler = store.query(`GET_ON${event.type.toUpperCase()}`);\n        if (handler) {\n            handler(...params);\n        }\n    };\n    const routeActionsToEvents = (actions)=>{\n        if (!actions.length) return;\n        actions.filter((action)=>eventRoutes[action.type]).forEach((action)=>{\n            const routes = eventRoutes[action.type];\n            (Array.isArray(routes) ? routes : [\n                routes\n            ]).forEach((route)=>{\n                // this isn't fantastic, but because of the stacking of settimeouts plugins can handle the did_load before the did_init\n                if (action.type === \"DID_INIT_ITEM\") {\n                    exposeEvent(route(action.data));\n                } else {\n                    setTimeout(()=>{\n                        exposeEvent(route(action.data));\n                    }, 0);\n                }\n            });\n        });\n    };\n    //\n    // PUBLIC API -------------------------------------------------------------------------------------\n    //\n    const setOptions = (options)=>store.dispatch(\"SET_OPTIONS\", {\n            options\n        });\n    const getFile = (query)=>store.query(\"GET_ACTIVE_ITEM\", query);\n    const prepareFile = (query)=>new Promise((resolve, reject)=>{\n            store.dispatch(\"REQUEST_ITEM_PREPARE\", {\n                query,\n                success: (item)=>{\n                    resolve(item);\n                },\n                failure: (error)=>{\n                    reject(error);\n                }\n            });\n        });\n    const addFile = (source, options = {})=>new Promise((resolve, reject)=>{\n            addFiles([\n                {\n                    source,\n                    options\n                }\n            ], {\n                index: options.index\n            }).then((items)=>resolve(items && items[0])).catch(reject);\n        });\n    const isFilePondFile = (obj)=>obj.file && obj.id;\n    const removeFile = (query, options)=>{\n        // if only passed options\n        if (typeof query === \"object\" && !isFilePondFile(query) && !options) {\n            options = query;\n            query = undefined;\n        }\n        // request item removal\n        store.dispatch(\"REMOVE_ITEM\", {\n            ...options,\n            query\n        });\n        // see if item has been removed\n        return store.query(\"GET_ACTIVE_ITEM\", query) === null;\n    };\n    const addFiles = (...args)=>new Promise((resolve, reject)=>{\n            const sources = [];\n            const options = {};\n            // user passed a sources array\n            if (isArray(args[0])) {\n                sources.push.apply(sources, args[0]);\n                Object.assign(options, args[1] || {});\n            } else {\n                // user passed sources as arguments, last one might be options object\n                const lastArgument = args[args.length - 1];\n                if (typeof lastArgument === \"object\" && !(lastArgument instanceof Blob)) {\n                    Object.assign(options, args.pop());\n                }\n                // add rest to sources\n                sources.push(...args);\n            }\n            store.dispatch(\"ADD_ITEMS\", {\n                items: sources,\n                index: options.index,\n                interactionMethod: InteractionMethod.API,\n                success: resolve,\n                failure: reject\n            });\n        });\n    const getFiles = ()=>store.query(\"GET_ACTIVE_ITEMS\");\n    const processFile = (query)=>new Promise((resolve, reject)=>{\n            store.dispatch(\"REQUEST_ITEM_PROCESSING\", {\n                query,\n                success: (item)=>{\n                    resolve(item);\n                },\n                failure: (error)=>{\n                    reject(error);\n                }\n            });\n        });\n    const prepareFiles = (...args)=>{\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        const items = queries.length ? queries : getFiles();\n        return Promise.all(items.map(prepareFile));\n    };\n    const processFiles = (...args)=>{\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        if (!queries.length) {\n            const files = getFiles().filter((item)=>!(item.status === ItemStatus.IDLE && item.origin === FileOrigin.LOCAL) && item.status !== ItemStatus.PROCESSING && item.status !== ItemStatus.PROCESSING_COMPLETE && item.status !== ItemStatus.PROCESSING_REVERT_ERROR);\n            return Promise.all(files.map(processFile));\n        }\n        return Promise.all(queries.map(processFile));\n    };\n    const removeFiles = (...args)=>{\n        const queries = Array.isArray(args[0]) ? args[0] : args;\n        let options;\n        if (typeof queries[queries.length - 1] === \"object\") {\n            options = queries.pop();\n        } else if (Array.isArray(args[0])) {\n            options = args[1];\n        }\n        const files = getFiles();\n        if (!queries.length) return Promise.all(files.map((file)=>removeFile(file, options)));\n        // when removing by index the indexes shift after each file removal so we need to convert indexes to ids\n        const mappedQueries = queries.map((query)=>isNumber(query) ? files[query] ? files[query].id : null : query).filter((query)=>query);\n        return mappedQueries.map((q)=>removeFile(q, options));\n    };\n    const exports = {\n        // supports events\n        ...on(),\n        // inject private api methods\n        ...readWriteApi,\n        // inject all getters and setters\n        ...createOptionAPI(store, defaultOptions),\n        /**\n         * Override options defined in options object\n         * @param options\n         */ setOptions,\n        /**\n         * Load the given file\n         * @param source - the source of the file (either a File, base64 data uri or url)\n         * @param options - object, { index: 0 }\n         */ addFile,\n        /**\n         * Load the given files\n         * @param sources - the sources of the files to load\n         * @param options - object, { index: 0 }\n         */ addFiles,\n        /**\n         * Returns the file objects matching the given query\n         * @param query { string, number, null }\n         */ getFile,\n        /**\n         * Upload file with given name\n         * @param query { string, number, null  }\n         */ processFile,\n        /**\n         * Request prepare output for file with given name\n         * @param query { string, number, null  }\n         */ prepareFile,\n        /**\n         * Removes a file by its name\n         * @param query { string, number, null  }\n         */ removeFile,\n        /**\n         * Moves a file to a new location in the files list\n         */ moveFile: (query, index)=>store.dispatch(\"MOVE_ITEM\", {\n                query,\n                index\n            }),\n        /**\n         * Returns all files (wrapped in public api)\n         */ getFiles,\n        /**\n         * Starts uploading all files\n         */ processFiles,\n        /**\n         * Clears all files from the files list\n         */ removeFiles,\n        /**\n         * Starts preparing output of all files\n         */ prepareFiles,\n        /**\n         * Sort list of files\n         */ sort: (compare)=>store.dispatch(\"SORT\", {\n                compare\n            }),\n        /**\n         * Browse the file system for a file\n         */ browse: ()=>{\n            // needs to be trigger directly as user action needs to be traceable (is not traceable in requestAnimationFrame)\n            var input = view.element.querySelector(\"input[type=file]\");\n            if (input) {\n                input.click();\n            }\n        },\n        /**\n         * Destroys the app\n         */ destroy: ()=>{\n            // request destruction\n            exports.fire(\"destroy\", view.element);\n            // stop active processes (file uploads, fetches, stuff like that)\n            // loop over items and depending on states call abort for ongoing processes\n            store.dispatch(\"ABORT_ALL\");\n            // destroy view\n            view._destroy();\n            // stop listening to resize\n            window.removeEventListener(\"resize\", resizeHandler);\n            // stop listening to the visiblitychange event\n            document.removeEventListener(\"visibilitychange\", visibilityHandler);\n            // dispatch destroy\n            store.dispatch(\"DID_DESTROY\");\n        },\n        /**\n         * Inserts the plugin before the target element\n         */ insertBefore: (element)=>insertBefore(view.element, element),\n        /**\n         * Inserts the plugin after the target element\n         */ insertAfter: (element)=>insertAfter(view.element, element),\n        /**\n         * Appends the plugin to the target element\n         */ appendTo: (element)=>element.appendChild(view.element),\n        /**\n         * Replaces an element with the app\n         */ replaceElement: (element)=>{\n            // insert the app before the element\n            insertBefore(view.element, element);\n            // remove the original element\n            element.parentNode.removeChild(element);\n            // remember original element\n            originalElement = element;\n        },\n        /**\n         * Restores the original element\n         */ restoreElement: ()=>{\n            if (!originalElement) {\n                return; // no element to restore\n            }\n            // restore original element\n            insertAfter(originalElement, view.element);\n            // remove our element\n            view.element.parentNode.removeChild(view.element);\n            // remove reference\n            originalElement = null;\n        },\n        /**\n         * Returns true if the app root is attached to given element\n         * @param element\n         */ isAttachedTo: (element)=>view.element === element || originalElement === element,\n        /**\n         * Returns the root element\n         */ element: {\n            get: ()=>view.element\n        },\n        /**\n         * Returns the current pond status\n         */ status: {\n            get: ()=>store.query(\"GET_STATUS\")\n        }\n    };\n    // Done!\n    store.dispatch(\"DID_INIT\");\n    // create actual api object\n    return createObject(exports);\n};\nconst createAppObject = (customOptions = {})=>{\n    // default options\n    const defaultOptions = {};\n    forin(getOptions(), (key, value)=>{\n        defaultOptions[key] = value[0];\n    });\n    // set app options\n    const app = createApp({\n        // default options\n        ...defaultOptions,\n        // custom options\n        ...customOptions\n    });\n    // return the plugin instance\n    return app;\n};\nconst lowerCaseFirstLetter = (string)=>string.charAt(0).toLowerCase() + string.slice(1);\nconst attributeNameToPropertyName = (attributeName)=>toCamels(attributeName.replace(/^data-/, \"\"));\nconst mapObject = (object, propertyMap)=>{\n    // remove unwanted\n    forin(propertyMap, (selector, mapping)=>{\n        forin(object, (property, value)=>{\n            // create regexp shortcut\n            const selectorRegExp = new RegExp(selector);\n            // tests if\n            const matches = selectorRegExp.test(property);\n            // no match, skip\n            if (!matches) {\n                return;\n            }\n            // if there's a mapping, the original property is always removed\n            delete object[property];\n            // should only remove, we done!\n            if (mapping === false) {\n                return;\n            }\n            // move value to new property\n            if (isString(mapping)) {\n                object[mapping] = value;\n                return;\n            }\n            // move to group\n            const group = mapping.group;\n            if (isObject(mapping) && !object[group]) {\n                object[group] = {};\n            }\n            object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, \"\"))] = value;\n        });\n        // do submapping\n        if (mapping.mapping) {\n            mapObject(object[mapping.group], mapping.mapping);\n        }\n    });\n};\nconst getAttributesAsObject = (node, attributeMapping = {})=>{\n    // turn attributes into object\n    const attributes = [];\n    forin(node.attributes, (index)=>{\n        attributes.push(node.attributes[index]);\n    });\n    const output = attributes.filter((attribute)=>attribute.name).reduce((obj, attribute)=>{\n        const value = attr(node, attribute.name);\n        obj[attributeNameToPropertyName(attribute.name)] = value === attribute.name ? true : value;\n        return obj;\n    }, {});\n    // do mapping of object properties\n    mapObject(output, attributeMapping);\n    return output;\n};\nconst createAppAtElement = (element, options = {})=>{\n    // how attributes of the input element are mapped to the options for the plugin\n    const attributeMapping = {\n        // translate to other name\n        \"^class$\": \"className\",\n        \"^multiple$\": \"allowMultiple\",\n        \"^capture$\": \"captureMethod\",\n        \"^webkitdirectory$\": \"allowDirectoriesOnly\",\n        // group under single property\n        \"^server\": {\n            group: \"server\",\n            mapping: {\n                \"^process\": {\n                    group: \"process\"\n                },\n                \"^revert\": {\n                    group: \"revert\"\n                },\n                \"^fetch\": {\n                    group: \"fetch\"\n                },\n                \"^restore\": {\n                    group: \"restore\"\n                },\n                \"^load\": {\n                    group: \"load\"\n                }\n            }\n        },\n        // don't include in object\n        \"^type$\": false,\n        \"^files$\": false\n    };\n    // add additional option translators\n    applyFilters(\"SET_ATTRIBUTE_TO_OPTION_MAP\", attributeMapping);\n    // create final options object by setting options object and then overriding options supplied on element\n    const mergedOptions = {\n        ...options\n    };\n    const attributeOptions = getAttributesAsObject(element.nodeName === \"FIELDSET\" ? element.querySelector(\"input[type=file]\") : element, attributeMapping);\n    // merge with options object\n    Object.keys(attributeOptions).forEach((key)=>{\n        if (isObject(attributeOptions[key])) {\n            if (!isObject(mergedOptions[key])) {\n                mergedOptions[key] = {};\n            }\n            Object.assign(mergedOptions[key], attributeOptions[key]);\n        } else {\n            mergedOptions[key] = attributeOptions[key];\n        }\n    });\n    // if parent is a fieldset, get files from parent by selecting all input fields that are not file upload fields\n    // these will then be automatically set to the initial files\n    mergedOptions.files = (options.files || []).concat(Array.from(element.querySelectorAll(\"input:not([type=file])\")).map((input)=>({\n            source: input.value,\n            options: {\n                type: input.dataset.type\n            }\n        })));\n    // build plugin\n    const app = createAppObject(mergedOptions);\n    // add already selected files\n    if (element.files) {\n        Array.from(element.files).forEach((file)=>{\n            app.addFile(file);\n        });\n    }\n    // replace the target element\n    app.replaceElement(element);\n    // expose\n    return app;\n};\n// if an element is passed, we create the instance at that element, if not, we just create an up object\nconst createApp$1 = (...args)=>isNode(args[0]) ? createAppAtElement(...args) : createAppObject(...args);\nconst PRIVATE_METHODS = [\n    \"fire\",\n    \"_read\",\n    \"_write\"\n];\nconst createAppAPI = (app)=>{\n    const api = {};\n    copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);\n    return api;\n};\n/**\n * Replaces placeholders in given string with replacements\n * @param string - \"Foo {bar}\"\"\n * @param replacements - { \"bar\": 10 }\n */ const replaceInString = (string, replacements)=>string.replace(/(?:{([a-zA-Z]+)})/g, (match, group)=>replacements[group]);\nconst createWorker = (fn)=>{\n    const workerBlob = new Blob([\n        \"(\",\n        fn.toString(),\n        \")()\"\n    ], {\n        type: \"application/javascript\"\n    });\n    const workerURL = URL.createObjectURL(workerBlob);\n    const worker = new Worker(workerURL);\n    return {\n        transfer: (message, cb)=>{},\n        post: (message, cb, transferList)=>{\n            const id = getUniqueId();\n            worker.onmessage = (e)=>{\n                if (e.data.id === id) {\n                    cb(e.data.message);\n                }\n            };\n            worker.postMessage({\n                id,\n                message\n            }, transferList);\n        },\n        terminate: ()=>{\n            worker.terminate();\n            URL.revokeObjectURL(workerURL);\n        }\n    };\n};\nconst loadImage = (url)=>new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve(img);\n        };\n        img.onerror = (e)=>{\n            reject(e);\n        };\n        img.src = url;\n    });\nconst renameFile = (file, name)=>{\n    const renamedFile = file.slice(0, file.size, file.type);\n    renamedFile.lastModifiedDate = file.lastModifiedDate;\n    renamedFile.name = name;\n    return renamedFile;\n};\nconst copyFile = (file)=>renameFile(file, file.name);\n// already registered plugins (can't register twice)\nconst registeredPlugins = [];\n// pass utils to plugin\nconst createAppPlugin = (plugin)=>{\n    // already registered\n    if (registeredPlugins.includes(plugin)) {\n        return;\n    }\n    // remember this plugin\n    registeredPlugins.push(plugin);\n    // setup!\n    const pluginOutline = plugin({\n        addFilter,\n        utils: {\n            Type,\n            forin,\n            isString,\n            isFile,\n            toNaturalFileSize,\n            replaceInString,\n            getExtensionFromFilename,\n            getFilenameWithoutExtension,\n            guesstimateMimeType,\n            getFileFromBlob,\n            getFilenameFromURL,\n            createRoute,\n            createWorker,\n            createView,\n            createItemAPI,\n            loadImage,\n            copyFile,\n            renameFile,\n            createBlob,\n            applyFilterChain,\n            text,\n            getNumericAspectRatioFromString\n        },\n        views: {\n            fileActionButton\n        }\n    });\n    // add plugin options to default options\n    extendDefaultOptions(pluginOutline.options);\n};\n// feature detection used by supported() method\nconst isOperaMini = ()=>Object.prototype.toString.call(window.operamini) === \"[object OperaMini]\";\nconst hasPromises = ()=>\"Promise\" in window;\nconst hasBlobSlice = ()=>\"slice\" in Blob.prototype;\nconst hasCreateObjectURL = ()=>\"URL\" in window && \"createObjectURL\" in window.URL;\nconst hasVisibility = ()=>\"visibilityState\" in document;\nconst hasTiming = ()=>\"performance\" in window; // iOS 8.x\nconst hasCSSSupports = ()=>\"supports\" in (window.CSS || {}); // use to detect Safari 9+\nconst isIE11 = ()=>/MSIE|Trident/.test(window.navigator.userAgent);\nconst supported = (()=>{\n    // Runs immediately and then remembers result for subsequent calls\n    const isSupported = // Has to be a browser\n    isBrowser() && // Can't run on Opera Mini due to lack of everything\n    !isOperaMini() && // Require these APIs to feature detect a modern browser\n    hasVisibility() && hasPromises() && hasBlobSlice() && hasCreateObjectURL() && hasTiming() && // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)\n    (hasCSSSupports() || isIE11());\n    return ()=>isSupported;\n})();\n/**\n * Plugin internal state (over all instances)\n */ const state = {\n    // active app instances, used to redraw the apps and to find the later\n    apps: []\n};\n// plugin name\nconst name = \"filepond\";\n/**\n * Public Plugin methods\n */ const fn = ()=>{};\nlet Status$1 = {};\nlet FileStatus = {};\nlet FileOrigin$1 = {};\nlet OptionTypes = {};\nlet create$f = fn;\nlet destroy = fn;\nlet parse = fn;\nlet find = fn;\nlet registerPlugin = fn;\nlet getOptions$1 = fn;\nlet setOptions$1 = fn;\n// if not supported, no API\nif (supported()) {\n    // start painter and fire load event\n    createPainter(()=>{\n        state.apps.forEach((app)=>app._read());\n    }, (ts)=>{\n        state.apps.forEach((app)=>app._write(ts));\n    });\n    // fire loaded event so we know when FilePond is available\n    const dispatch = ()=>{\n        // let others know we have area ready\n        document.dispatchEvent(new CustomEvent(\"FilePond:loaded\", {\n            detail: {\n                supported,\n                create: create$f,\n                destroy,\n                parse,\n                find,\n                registerPlugin,\n                setOptions: setOptions$1\n            }\n        }));\n        // clean up event\n        document.removeEventListener(\"DOMContentLoaded\", dispatch);\n    };\n    if (document.readyState !== \"loading\") {\n        // move to back of execution queue, FilePond should have been exported by then\n        setTimeout(()=>dispatch(), 0);\n    } else {\n        document.addEventListener(\"DOMContentLoaded\", dispatch);\n    }\n    // updates the OptionTypes object based on the current options\n    const updateOptionTypes = ()=>forin(getOptions(), (key, value)=>{\n            OptionTypes[key] = value[1];\n        });\n    Status$1 = {\n        ...Status\n    };\n    FileOrigin$1 = {\n        ...FileOrigin\n    };\n    FileStatus = {\n        ...ItemStatus\n    };\n    OptionTypes = {};\n    updateOptionTypes();\n    // create method, creates apps and adds them to the app array\n    create$f = (...args)=>{\n        const app = createApp$1(...args);\n        app.on(\"destroy\", destroy);\n        state.apps.push(app);\n        return createAppAPI(app);\n    };\n    // destroys apps and removes them from the app array\n    destroy = (hook)=>{\n        // returns true if the app was destroyed successfully\n        const indexToRemove = state.apps.findIndex((app)=>app.isAttachedTo(hook));\n        if (indexToRemove >= 0) {\n            // remove from apps\n            const app = state.apps.splice(indexToRemove, 1)[0];\n            // restore original dom element\n            app.restoreElement();\n            return true;\n        }\n        return false;\n    };\n    // parses the given context for plugins (does not include the context element itself)\n    parse = (context)=>{\n        // get all possible hooks\n        const matchedHooks = Array.from(context.querySelectorAll(`.${name}`));\n        // filter out already active hooks\n        const newHooks = matchedHooks.filter((newHook)=>!state.apps.find((app)=>app.isAttachedTo(newHook)));\n        // create new instance for each hook\n        return newHooks.map((hook)=>create$f(hook));\n    };\n    // returns an app based on the given element hook\n    find = (hook)=>{\n        const app = state.apps.find((app)=>app.isAttachedTo(hook));\n        if (!app) {\n            return null;\n        }\n        return createAppAPI(app);\n    };\n    // adds a plugin extension\n    registerPlugin = (...plugins)=>{\n        // register plugins\n        plugins.forEach(createAppPlugin);\n        // update OptionTypes, each plugin might have extended the default options\n        updateOptionTypes();\n    };\n    getOptions$1 = ()=>{\n        const opts = {};\n        forin(getOptions(), (key, value)=>{\n            opts[key] = value[0];\n        });\n        return opts;\n    };\n    setOptions$1 = (opts)=>{\n        if (isObject(opts)) {\n            // update existing plugins\n            state.apps.forEach((app)=>{\n                app.setOptions(opts);\n            });\n            // override defaults\n            setOptions(opts);\n        }\n        // return new options\n        return getOptions$1();\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUVELGtCQUFrQixHQUVsQixNQUFNQSxTQUFTQyxDQUFBQSxRQUFTQSxpQkFBaUJDO0FBRXpDLE1BQU1DLGNBQWMsQ0FBQ0MsY0FBY0MsVUFBVSxFQUFFLEVBQUVDLFVBQVUsRUFBRTtJQUN6RCxpQkFBaUI7SUFDakIsTUFBTUMsUUFBUTtRQUNWLEdBQUdILFlBQVk7SUFDbkI7SUFFQSwyRUFBMkU7SUFDM0UsTUFBTUksY0FBYyxFQUFFO0lBQ3RCLE1BQU1DLGdCQUFnQixFQUFFO0lBRXhCLDJDQUEyQztJQUMzQyxNQUFNQyxXQUFXLElBQU87WUFBRSxHQUFHSCxLQUFLO1FBQUM7SUFFbkMsd0VBQXdFO0lBQ3hFLE1BQU1JLHFCQUFxQjtRQUN2QiwrQkFBK0I7UUFDL0IsTUFBTUMsUUFBUTtlQUFJSjtTQUFZO1FBRTlCLHdEQUF3RDtRQUN4REEsWUFBWUssTUFBTSxHQUFHO1FBRXJCLE9BQU9EO0lBQ1g7SUFFQSx3REFBd0Q7SUFDeEQsTUFBTUUsdUJBQXVCO1FBQ3pCLCtCQUErQjtRQUMvQixNQUFNRixRQUFRO2VBQUlIO1NBQWM7UUFFaEMsd0RBQXdEO1FBQ3hEQSxjQUFjSSxNQUFNLEdBQUc7UUFFdkIsNkJBQTZCO1FBQzdCRCxNQUFNRyxPQUFPLENBQUMsQ0FBQyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtZQUN6QkMsU0FBU0YsTUFBTUM7UUFDbkI7SUFDSjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNQyxXQUFXLENBQUNGLE1BQU1DLE1BQU1FO1FBQzFCLGdFQUFnRTtRQUNoRSxJQUFJQSxjQUFjLENBQUNDLFNBQVNDLE1BQU0sRUFBRTtZQUNoQ1osY0FBY2EsSUFBSSxDQUFDO2dCQUFFTjtnQkFBTUM7WUFBSztZQUNoQztRQUNKO1FBRUEsa0RBQWtEO1FBQ2xELElBQUlNLGNBQWMsQ0FB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QUFTSztJQUN6QztJQUVBLGlEQUFpRDtJQUNqRGgvQixPQUFPZy9CLENBQUFBO1FBQ0gsTUFBTXZFLE1BQU01OUMsTUFBTXloRCxJQUFJLENBQUN0K0IsSUFBSSxDQUFDeTZCLENBQUFBLE1BQU9BLElBQUlILFlBQVksQ0FBQzBFO1FBQ3BELElBQUksQ0FBQ3ZFLEtBQUs7WUFDTixPQUFPO1FBQ1g7UUFDQSxPQUFPa0IsYUFBYWxCO0lBQ3hCO0lBRUEsMEJBQTBCO0lBQzFCbUUsaUJBQWlCLENBQUMsR0FBR1U7UUFDakIsbUJBQW1CO1FBQ25CQSxRQUFRamlELE9BQU8sQ0FBQzYvQztRQUVoQiwwRUFBMEU7UUFDMUU2QjtJQUNKO0lBRUFGLGVBQWU7UUFDWCxNQUFNcmxDLE9BQU8sQ0FBQztRQUNkL2EsTUFBTTZhLGNBQWMsQ0FBQzNhLEtBQUtwQztZQUN0QmlkLElBQUksQ0FBQzdhLElBQUksR0FBR3BDLEtBQUssQ0FBQyxFQUFFO1FBQ3hCO1FBQ0EsT0FBT2lkO0lBQ1g7SUFFQXNsQyxlQUFldGxDLENBQUFBO1FBQ1gsSUFBSTlILFNBQVM4SCxPQUFPO1lBQ2hCLDBCQUEwQjtZQUMxQjNjLE1BQU15aEQsSUFBSSxDQUFDamhELE9BQU8sQ0FBQ285QyxDQUFBQTtnQkFDZkEsSUFBSWxoQyxVQUFVLENBQUNDO1lBQ25CO1lBRUEsb0JBQW9CO1lBQ3BCRCxXQUFXQztRQUNmO1FBRUEscUJBQXFCO1FBQ3JCLE9BQU9xbEM7SUFDWDtBQUNKO0FBZUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aW4tZXh0cmFjdG9yLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kL2Rpc3QvZmlsZXBvbmQuZXNtLmpzPzE3ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBGaWxlUG9uZCA0LjMyLjZcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCwgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQvXG4gKiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9wcWluYS5ubC9maWxlcG9uZC8gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cblxuY29uc3QgaXNOb2RlID0gdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW5pdGlhbFN0YXRlLCBxdWVyaWVzID0gW10sIGFjdGlvbnMgPSBbXSkgPT4ge1xuICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIC4uLmluaXRpYWxTdGF0ZSxcbiAgICB9O1xuXG4gICAgLy8gY29udGFpbnMgYWxsIGFjdGlvbnMgZm9yIG5leHQgZnJhbWUsIGlzIGNsZWFyIHdoZW4gYWN0aW9ucyBhcmUgcmVxdWVzdGVkXG4gICAgY29uc3QgYWN0aW9uUXVldWUgPSBbXTtcbiAgICBjb25zdCBkaXNwYXRjaFF1ZXVlID0gW107XG5cbiAgICAvLyByZXR1cm5zIGEgZHVwbGljYXRlIG9mIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiAoeyAuLi5zdGF0ZSB9KTtcblxuICAgIC8vIHJldHVybnMgYSBkdXBsaWNhdGUgb2YgdGhlIGFjdGlvbnMgYXJyYXkgYW5kIGNsZWFycyB0aGUgYWN0aW9ucyBhcnJheVxuICAgIGNvbnN0IHByb2Nlc3NBY3Rpb25RdWV1ZSA9ICgpID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIGNvcHkgb2YgYWN0aW9ucyBxdWV1ZVxuICAgICAgICBjb25zdCBxdWV1ZSA9IFsuLi5hY3Rpb25RdWV1ZV07XG5cbiAgICAgICAgLy8gY2xlYXIgYWN0aW9ucyBxdWV1ZSAod2UgZG9uJ3Qgd2FudCBubyBkb3VibGUgYWN0aW9ucylcbiAgICAgICAgYWN0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gcXVldWU7XG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3NlcyBhY3Rpb25zIHRoYXQgbWlnaHQgYmxvY2sgdGhlIG1haW4gVUkgdGhyZWFkXG4gICAgY29uc3QgcHJvY2Vzc0Rpc3BhdGNoUXVldWUgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBjb3B5IG9mIGFjdGlvbnMgcXVldWVcbiAgICAgICAgY29uc3QgcXVldWUgPSBbLi4uZGlzcGF0Y2hRdWV1ZV07XG5cbiAgICAgICAgLy8gY2xlYXIgYWN0aW9ucyBxdWV1ZSAod2UgZG9uJ3Qgd2FudCBubyBkb3VibGUgYWN0aW9ucylcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5sZW5ndGggPSAwO1xuXG4gICAgICAgIC8vIG5vdyBkaXNwYXRjaCB0aGVzZSBhY3Rpb25zXG4gICAgICAgIHF1ZXVlLmZvckVhY2goKHsgdHlwZSwgZGF0YSB9KSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCh0eXBlLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBuZXcgYWN0aW9uLCBjYWxscyBpdHMgaGFuZGxlciBhbmRcbiAgICBjb25zdCBkaXNwYXRjaCA9ICh0eXBlLCBkYXRhLCBpc0Jsb2NraW5nKSA9PiB7XG4gICAgICAgIC8vIGlzIGJsb2NraW5nIGFjdGlvbiAoc2hvdWxkIG5ldmVyIGJsb2NrIGlmIGRvY3VtZW50IGlzIGhpZGRlbilcbiAgICAgICAgaWYgKGlzQmxvY2tpbmcgJiYgIWRvY3VtZW50LmhpZGRlbikge1xuICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgdHlwZSwgZGF0YSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoaXMgYWN0aW9uIGhhcyBhIGhhbmRsZXIsIGhhbmRsZSB0aGUgYWN0aW9uXG4gICAgICAgIGlmIChhY3Rpb25IYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcnNbdHlwZV0oZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3cgYWRkIGFjdGlvblxuICAgICAgICBhY3Rpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcXVlcnkgPSAoc3RyLCAuLi5hcmdzKSA9PiAocXVlcnlIYW5kbGVzW3N0cl0gPyBxdWVyeUhhbmRsZXNbc3RyXSguLi5hcmdzKSA6IG51bGwpO1xuXG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgcHJvY2Vzc0FjdGlvblF1ZXVlLFxuICAgICAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHF1ZXJ5LFxuICAgIH07XG5cbiAgICBsZXQgcXVlcnlIYW5kbGVzID0ge307XG4gICAgcXVlcmllcy5mb3JFYWNoKHF1ZXJ5ID0+IHtcbiAgICAgICAgcXVlcnlIYW5kbGVzID0ge1xuICAgICAgICAgICAgLi4ucXVlcnkoc3RhdGUpLFxuICAgICAgICAgICAgLi4ucXVlcnlIYW5kbGVzLFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgbGV0IGFjdGlvbkhhbmRsZXJzID0ge307XG4gICAgYWN0aW9ucy5mb3JFYWNoKGFjdGlvbiA9PiB7XG4gICAgICAgIGFjdGlvbkhhbmRsZXJzID0ge1xuICAgICAgICAgICAgLi4uYWN0aW9uKGRpc3BhdGNoLCBxdWVyeSwgc3RhdGUpLFxuICAgICAgICAgICAgLi4uYWN0aW9uSGFuZGxlcnMsXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxuY29uc3QgZGVmaW5lUHJvcGVydHkgPSAob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmpbcHJvcGVydHldID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgeyAuLi5kZWZpbml0aW9uIH0pO1xufTtcblxuY29uc3QgZm9yaW4gPSAob2JqLCBjYikgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZU9iamVjdCA9IGRlZmluaXRpb24gPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKGRlZmluaXRpb24sIHByb3BlcnR5ID0+IHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eSwgZGVmaW5pdGlvbltwcm9wZXJ0eV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBhdHRyID0gKG5vZGUsIG5hbWUsIHZhbHVlID0gbnVsbCkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSkgfHwgbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbn07XG5cbmNvbnN0IG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbmNvbnN0IHN2Z0VsZW1lbnRzID0gWydzdmcnLCAncGF0aCddOyAvLyBvbmx5IHN2ZyBlbGVtZW50cyB1c2VkXG5cbmNvbnN0IGlzU1ZHRWxlbWVudCA9IHRhZyA9PiBzdmdFbGVtZW50cy5pbmNsdWRlcyh0YWcpO1xuXG5jb25zdCBjcmVhdGVFbGVtZW50ID0gKHRhZywgY2xhc3NOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+IHtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgY2xhc3NOYW1lID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU1ZHRWxlbWVudCh0YWcpXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKGlzU1ZHRWxlbWVudCh0YWcpKSB7XG4gICAgICAgICAgICBhdHRyKGVsZW1lbnQsICdjbGFzcycsIGNsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JpbihhdHRyaWJ1dGVzLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5jb25zdCBhcHBlbmRDaGlsZCA9IHBhcmVudCA9PiAoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgcGFyZW50LmNoaWxkcmVuW2luZGV4XSkge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBwYXJlbnQuY2hpbGRyZW5baW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbn07XG5cbmNvbnN0IGFwcGVuZENoaWxkVmlldyA9IChwYXJlbnQsIGNoaWxkVmlld3MpID0+ICh2aWV3LCBpbmRleCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGluZGV4LCAwLCB2aWV3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZFZpZXdzLnB1c2godmlldyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXc7XG59O1xuXG5jb25zdCByZW1vdmVDaGlsZFZpZXcgPSAocGFyZW50LCBjaGlsZFZpZXdzKSA9PiB2aWV3ID0+IHtcbiAgICAvLyByZW1vdmUgZnJvbSBjaGlsZCB2aWV3c1xuICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG5cbiAgICAvLyByZW1vdmUgdGhlIGVsZW1lbnRcbiAgICBpZiAodmlldy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXc7XG59O1xuXG5jb25zdCBJU19CUk9XU0VSID0gKCgpID0+XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpKCk7XG5jb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiBJU19CUk9XU0VSO1xuXG5jb25zdCB0ZXN0RWxlbWVudCA9IGlzQnJvd3NlcigpID8gY3JlYXRlRWxlbWVudCgnc3ZnJykgOiB7fTtcbmNvbnN0IGdldENoaWxkQ291bnQgPVxuICAgICdjaGlsZHJlbicgaW4gdGVzdEVsZW1lbnQgPyBlbCA9PiBlbC5jaGlsZHJlbi5sZW5ndGggOiBlbCA9PiBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcblxuY29uc3QgZ2V0Vmlld1JlY3QgPSAoZWxlbWVudFJlY3QsIGNoaWxkVmlld3MsIG9mZnNldCwgc2NhbGUpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gb2Zmc2V0WzBdIHx8IGVsZW1lbnRSZWN0LmxlZnQ7XG4gICAgY29uc3QgdG9wID0gb2Zmc2V0WzFdIHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICBjb25zdCByaWdodCA9IGxlZnQgKyBlbGVtZW50UmVjdC53aWR0aDtcbiAgICBjb25zdCBib3R0b20gPSB0b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQgKiAoc2NhbGVbMV0gfHwgMSk7XG5cbiAgICBjb25zdCByZWN0ID0ge1xuICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGl0c2VsZlxuICAgICAgICBlbGVtZW50OiB7XG4gICAgICAgICAgICAuLi5lbGVtZW50UmVjdCxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuLCBkb2VzIG5vdCBpbmNsdWRlIGFueSBtYXJnaW5zXG4gICAgICAgIGlubmVyOiB7XG4gICAgICAgICAgICBsZWZ0OiBlbGVtZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AsXG4gICAgICAgICAgICByaWdodDogZWxlbWVudFJlY3QucmlnaHQsXG4gICAgICAgICAgICBib3R0b206IGVsZW1lbnRSZWN0LmJvdHRvbSxcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0aGUgcmVjdGFuZ2xlIG9mIHRoZSBlbGVtZW50IGV4cGFuZGVkIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuIGluY2x1ZGluZyBvd24gbWFyZ2luIGFuZCBjaGlsZCBtYXJnaW5zXG4gICAgICAgIC8vIG1hcmdpbnMgd2lsbCBiZSBhZGRlZCBhZnRlciB3ZSd2ZSByZWNhbGN1bGF0ZWQgdGhlIHNpemVcbiAgICAgICAgb3V0ZXI6IHtcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gZXhwYW5kIHJlY3QgdG8gZml0IGFsbCBjaGlsZCByZWN0YW5nbGVzXG4gICAgY2hpbGRWaWV3c1xuICAgICAgICAuZmlsdGVyKGNoaWxkVmlldyA9PiAhY2hpbGRWaWV3LmlzUmVjdElnbm9yZWQoKSlcbiAgICAgICAgLm1hcChjaGlsZFZpZXcgPT4gY2hpbGRWaWV3LnJlY3QpXG4gICAgICAgIC5mb3JFYWNoKGNoaWxkVmlld1JlY3QgPT4ge1xuICAgICAgICAgICAgZXhwYW5kUmVjdChyZWN0LmlubmVyLCB7IC4uLmNoaWxkVmlld1JlY3QuaW5uZXIgfSk7XG4gICAgICAgICAgICBleHBhbmRSZWN0KHJlY3Qub3V0ZXIsIHsgLi4uY2hpbGRWaWV3UmVjdC5vdXRlciB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgaW5uZXIgd2lkdGggYW5kIGhlaWdodFxuICAgIGNhbGN1bGF0ZVJlY3RTaXplKHJlY3QuaW5uZXIpO1xuXG4gICAgLy8gYXBwZW5kIGFkZGl0aW9uYWwgbWFyZ2luICh0b3AgYW5kIGxlZnQgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW4gdG9wIGFuZCBsZWZ0IGF1dG9tYXRpY2FsbHkpXG4gICAgcmVjdC5vdXRlci5ib3R0b20gKz0gcmVjdC5lbGVtZW50Lm1hcmdpbkJvdHRvbTtcbiAgICByZWN0Lm91dGVyLnJpZ2h0ICs9IHJlY3QuZWxlbWVudC5tYXJnaW5SaWdodDtcblxuICAgIC8vIGNhbGN1bGF0ZSBvdXRlciB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgY2FsY3VsYXRlUmVjdFNpemUocmVjdC5vdXRlcik7XG5cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbmNvbnN0IGV4cGFuZFJlY3QgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICAgIC8vIGFkanVzdCBmb3IgcGFyZW50IG9mZnNldFxuICAgIGNoaWxkLnRvcCArPSBwYXJlbnQudG9wO1xuICAgIGNoaWxkLnJpZ2h0ICs9IHBhcmVudC5sZWZ0O1xuICAgIGNoaWxkLmJvdHRvbSArPSBwYXJlbnQudG9wO1xuICAgIGNoaWxkLmxlZnQgKz0gcGFyZW50LmxlZnQ7XG5cbiAgICBpZiAoY2hpbGQuYm90dG9tID4gcGFyZW50LmJvdHRvbSkge1xuICAgICAgICBwYXJlbnQuYm90dG9tID0gY2hpbGQuYm90dG9tO1xuICAgIH1cblxuICAgIGlmIChjaGlsZC5yaWdodCA+IHBhcmVudC5yaWdodCkge1xuICAgICAgICBwYXJlbnQucmlnaHQgPSBjaGlsZC5yaWdodDtcbiAgICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVSZWN0U2l6ZSA9IHJlY3QgPT4ge1xuICAgIHJlY3Qud2lkdGggPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0O1xuICAgIHJlY3QuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbn07XG5cbmNvbnN0IGlzTnVtYmVyID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHBvc2l0aW9uIGlzIGF0IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0gcG9zaXRpb25cbiAqIEBwYXJhbSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHZlbG9jaXR5XG4gKiBAcGFyYW0gZXJyb3JNYXJnaW5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCB0aGVyZVlldCA9IChwb3NpdGlvbiwgZGVzdGluYXRpb24sIHZlbG9jaXR5LCBlcnJvck1hcmdpbiA9IDAuMDAxKSA9PiB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHBvc2l0aW9uIC0gZGVzdGluYXRpb24pIDwgZXJyb3JNYXJnaW4gJiYgTWF0aC5hYnModmVsb2NpdHkpIDwgZXJyb3JNYXJnaW47XG59O1xuXG4vKipcbiAqIFNwcmluZyBhbmltYXRpb25cbiAqL1xuY29uc3Qgc3ByaW5nID1cbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAoeyBzdGlmZm5lc3MgPSAwLjUsIGRhbXBpbmcgPSAwLjc1LCBtYXNzID0gMTAgfSA9IHt9KSA9PlxuICAgICAgICAvLyBtZXRob2QgZGVmaW5pdGlvblxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgbGV0IHJlc3RpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlcyBzcHJpbmcgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlID0gKHRzLCBza2lwVG9FbmRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGluIHJlc3QsIGRvbid0IGFuaW1hdGVcbiAgICAgICAgICAgICAgICBpZiAocmVzdGluZykgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZCBhdCBsZWFzdCBhIHRhcmdldCBvciBwb3NpdGlvbiB0byBkbyBzcHJpbmd5IHRoaW5nc1xuICAgICAgICAgICAgICAgIGlmICghKGlzTnVtYmVyKHRhcmdldCkgJiYgaXNOdW1iZXIocG9zaXRpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHNwcmluZyBmb3JjZVxuICAgICAgICAgICAgICAgIGNvbnN0IGYgPSAtKHBvc2l0aW9uIC0gdGFyZ2V0KSAqIHN0aWZmbmVzcztcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB2ZWxvY2l0eSBieSBhZGRpbmcgZm9yY2UgYmFzZWQgb24gbWFzc1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ICs9IGYgLyBtYXNzO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIGJ5IGFkZGluZyB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHZlbG9jaXR5O1xuXG4gICAgICAgICAgICAgICAgLy8gc2xvdyBkb3duIGJhc2VkIG9uIGFtb3VudCBvZiBkYW1waW5nXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkgKj0gZGFtcGluZztcblxuICAgICAgICAgICAgICAgIC8vIHdlJ3ZlIGFycml2ZWQgaWYgd2UncmUgbmVhciB0YXJnZXQgYW5kIG91ciB2ZWxvY2l0eSBpcyBuZWFyIHplcm9cbiAgICAgICAgICAgICAgICBpZiAodGhlcmVZZXQocG9zaXRpb24sIHRhcmdldCwgdmVsb2NpdHkpIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm9uY29tcGxldGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByb2dyZXNzIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IG5ldyB0YXJnZXQgdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzZXRUYXJnZXQgPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudGx5IGhhcyBubyBwb3NpdGlvbiwgc2V0IHRhcmdldCBhbmQgcG9zaXRpb24gdG8gdGhpcyB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcih2YWx1ZSkgJiYgIWlzTnVtYmVyKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG5leHQgdGFyZ2V0IHZhbHVlIHdpbGwgbm90IGJlIGFuaW1hdGVkIHRvXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgc3RhcnQgbW92aW5nIHRvIHRhcmdldFxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBhdCB0YXJnZXRcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IHRhcmdldCB8fCB0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgcmVzdGluZyBhcyB0YXJnZXQgaXMgY3VycmVudCBwb3NpdGlvbiwgc3RvcCBtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkb25lIVxuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZShwb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIG5lZWQgJ2FwaScgdG8gY2FsbCBvbnVwZGF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgY29uc3QgYXBpID0gY3JlYXRlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBzZXRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGFyZ2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHJlc3RpbmcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbnVwZGF0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICAgICAgb25jb21wbGV0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuY29uc3QgZWFzZUxpbmVhciA9IHQgPT4gdDtcbmNvbnN0IGVhc2VJbk91dFF1YWQgPSB0ID0+ICh0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQpO1xuXG5jb25zdCB0d2VlbiA9XG4gICAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgICAoeyBkdXJhdGlvbiA9IDUwMCwgZWFzaW5nID0gZWFzZUluT3V0UXVhZCwgZGVsYXkgPSAwIH0gPSB7fSkgPT5cbiAgICAgICAgLy8gbWV0aG9kIGRlZmluaXRpb25cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCB0O1xuICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICBsZXQgcmVzdGluZyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgcmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlID0gKHRzLCBza2lwVG9FbmRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN0aW5nIHx8IHRhcmdldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRzIC0gc3RhcnQgPCBkZWxheSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdCA9IHRzIC0gc3RhcnQgLSBkZWxheTtcblxuICAgICAgICAgICAgICAgIGlmICh0ID49IGR1cmF0aW9uIHx8IHNraXBUb0VuZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwID0gcmV2ZXJzZSA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUocCAqIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5vbmNvbXBsZXRlKHAgKiB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gdCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBhcGkub251cGRhdGUoKHQgPj0gMCA/IGVhc2luZyhyZXZlcnNlID8gMSAtIHAgOiBwKSA6IDApICogdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBuZWVkICdhcGknIHRvIGNhbGwgb251cGRhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gKHJldmVyc2UgPyAwIDogdGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9udXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkub25jb21wbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHR3ZWVuIHRvIGEgc21hbGxlciB2YWx1ZSBhbmQgaGF2ZSBhIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCB0d2VlbmluZyB0byBhIHNtYWxsZXIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCdzIGdvIVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHJlc3RpbmcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbnVwZGF0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICAgICAgb25jb21wbGV0ZTogdmFsdWUgPT4ge30sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgfTtcblxuY29uc3QgYW5pbWF0b3IgPSB7XG4gICAgc3ByaW5nLFxuICAgIHR3ZWVuLFxufTtcblxuLypcbiB7IHR5cGU6ICdzcHJpbmcnLCBzdGlmZm5lc3M6IC41LCBkYW1waW5nOiAuNzUsIG1hc3M6IDEwIH07XG4geyB0cmFuc2xhdGlvbjogeyB0eXBlOiAnc3ByaW5nJywgLi4uIH0sIC4uLiB9XG4geyB0cmFuc2xhdGlvbjogeyB4OiB7IHR5cGU6ICdzcHJpbmcnLCAuLi4gfSB9IH1cbiovXG5jb25zdCBjcmVhdGVBbmltYXRvciA9IChkZWZpbml0aW9uLCBjYXRlZ29yeSwgcHJvcGVydHkpID0+IHtcbiAgICAvLyBkZWZhdWx0IGlzIHNpbmdsZSBkZWZpbml0aW9uXG4gICAgLy8gd2UgY2hlY2sgaWYgdHJhbnNmb3JtIGlzIHNldCwgaWYgc28sIHdlIGNoZWNrIGlmIHByb3BlcnR5IGlzIHNldFxuICAgIGNvbnN0IGRlZiA9XG4gICAgICAgIGRlZmluaXRpb25bY2F0ZWdvcnldICYmIHR5cGVvZiBkZWZpbml0aW9uW2NhdGVnb3J5XVtwcm9wZXJ0eV0gPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IGRlZmluaXRpb25bY2F0ZWdvcnldW3Byb3BlcnR5XVxuICAgICAgICAgICAgOiBkZWZpbml0aW9uW2NhdGVnb3J5XSB8fCBkZWZpbml0aW9uO1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnID8gZGVmIDogZGVmLnR5cGU7XG4gICAgY29uc3QgcHJvcHMgPSB0eXBlb2YgZGVmID09PSAnb2JqZWN0JyA/IHsgLi4uZGVmIH0gOiB7fTtcblxuICAgIHJldHVybiBhbmltYXRvclt0eXBlXSA/IGFuaW1hdG9yW3R5cGVdKHByb3BzKSA6IG51bGw7XG59O1xuXG5jb25zdCBhZGRHZXRTZXQgPSAoa2V5cywgb2JqLCBwcm9wcywgb3ZlcndyaXRlID0gZmFsc2UpID0+IHtcbiAgICBvYmogPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmogOiBbb2JqXTtcbiAgICBvYmouZm9yRWFjaChvID0+IHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGtleTtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSAoKSA9PiBwcm9wc1trZXldO1xuICAgICAgICAgICAgbGV0IHNldHRlciA9IHZhbHVlID0+IChwcm9wc1trZXldID0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0ga2V5LmtleTtcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSBrZXkuZ2V0dGVyIHx8IGdldHRlcjtcbiAgICAgICAgICAgICAgICBzZXR0ZXIgPSBrZXkuc2V0dGVyIHx8IHNldHRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9bbmFtZV0gJiYgIW92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLy8gYWRkIHRvIHN0YXRlLFxuLy8gYWRkIGdldHRlcnMgYW5kIHNldHRlcnMgdG8gaW50ZXJuYWwgYW5kIGV4dGVybmFsIGFwaSAoaWYgbm90IHNldClcbi8vIHNldHVwIGFuaW1hdG9yc1xuXG5jb25zdCBhbmltYXRpb25zID0gKHsgbWl4aW5Db25maWcsIHZpZXdQcm9wcywgdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEkgfSkgPT4ge1xuICAgIC8vIGluaXRpYWwgcHJvcGVydGllc1xuICAgIGNvbnN0IGluaXRpYWxQcm9wcyA9IHsgLi4udmlld1Byb3BzIH07XG5cbiAgICAvLyBsaXN0IG9mIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcblxuICAgIC8vIHNldHVwIGFuaW1hdG9yc1xuICAgIGZvcmluKG1peGluQ29uZmlnLCAocHJvcGVydHksIGFuaW1hdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBhbmltYXRvciA9IGNyZWF0ZUFuaW1hdG9yKGFuaW1hdGlvbik7XG4gICAgICAgIGlmICghYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gdGhlIGFuaW1hdG9yIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmlldyBzdGF0ZSB2YWx1ZVxuICAgICAgICBhbmltYXRvci5vbnVwZGF0ZSA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgIHZpZXdQcm9wc1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgYW5pbWF0b3IgdGFyZ2V0XG4gICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IGluaXRpYWxQcm9wc1twcm9wZXJ0eV07XG5cbiAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyBzZXQsIHNldCB0aGUgYW5pbWF0b3IgdGFyZ2V0IHZhbHVlXG4gICAgICAgIGNvbnN0IHByb3AgPSB7XG4gICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgc2V0dGVyOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYWxyZWFkeSBhdCB0YXJnZXQsIHdlIGRvbmUhXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yLnRhcmdldCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFuaW1hdG9yLnRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldHRlcjogKCkgPT4gdmlld1Byb3BzW3Byb3BlcnR5XSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICBhZGRHZXRTZXQoW3Byb3BdLCBbdmlld0ludGVybmFsQVBJLCB2aWV3RXh0ZXJuYWxBUEldLCB2aWV3UHJvcHMsIHRydWUpO1xuXG4gICAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdCBmb3IgZWFzeSB1cGRhdGluZyBmcm9tIHRoZSBfd3JpdGUgbWV0aG9kXG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRvcik7XG4gICAgfSk7XG5cbiAgICAvLyBleHBvc2UgaW50ZXJuYWwgd3JpdGUgYXBpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IHRzID0+IHtcbiAgICAgICAgICAgIGxldCBza2lwVG9FbmRTdGF0ZSA9IGRvY3VtZW50LmhpZGRlbjtcbiAgICAgICAgICAgIGxldCByZXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uLnJlc3RpbmcpIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uaW50ZXJwb2xhdGUodHMsIHNraXBUb0VuZFN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Rpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHt9LFxuICAgIH07XG59O1xuXG5jb25zdCBhZGRFdmVudCA9IGVsZW1lbnQgPT4gKHR5cGUsIGZuKSA9PiB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuKTtcbn07XG5cbmNvbnN0IHJlbW92ZUV2ZW50ID0gZWxlbWVudCA9PiAodHlwZSwgZm4pID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4pO1xufTtcblxuLy8gbWl4aW5cbmNvbnN0IGxpc3RlbmVycyA9ICh7XG4gICAgbWl4aW5Db25maWcsXG4gICAgdmlld1Byb3BzLFxuICAgIHZpZXdJbnRlcm5hbEFQSSxcbiAgICB2aWV3RXh0ZXJuYWxBUEksXG4gICAgdmlld1N0YXRlLFxuICAgIHZpZXcsXG59KSA9PiB7XG4gICAgY29uc3QgZXZlbnRzID0gW107XG5cbiAgICBjb25zdCBhZGQgPSBhZGRFdmVudCh2aWV3LmVsZW1lbnQpO1xuICAgIGNvbnN0IHJlbW92ZSA9IHJlbW92ZUV2ZW50KHZpZXcuZWxlbWVudCk7XG5cbiAgICB2aWV3RXh0ZXJuYWxBUEkub24gPSAodHlwZSwgZm4pID0+IHtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGZuLFxuICAgICAgICB9KTtcbiAgICAgICAgYWRkKHR5cGUsIGZuKTtcbiAgICB9O1xuXG4gICAgdmlld0V4dGVybmFsQVBJLm9mZiA9ICh0eXBlLCBmbikgPT4ge1xuICAgICAgICBldmVudHMuc3BsaWNlKGV2ZW50cy5maW5kSW5kZXgoZXZlbnQgPT4gZXZlbnQudHlwZSA9PT0gdHlwZSAmJiBldmVudC5mbiA9PT0gZm4pLCAxKTtcbiAgICAgICAgcmVtb3ZlKHR5cGUsIGZuKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIG5vdCBidXN5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZShldmVudC50eXBlLCBldmVudC5mbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuLy8gYWRkIHRvIGV4dGVybmFsIGFwaSBhbmQgbGluayB0byBwcm9wc1xuXG5jb25zdCBhcGlzID0gKHsgbWl4aW5Db25maWcsIHZpZXdQcm9wcywgdmlld0V4dGVybmFsQVBJIH0pID0+IHtcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIHZpZXdFeHRlcm5hbEFQSSwgdmlld1Byb3BzKTtcbn07XG5cbmNvbnN0IGlzRGVmaW5lZCA9IHZhbHVlID0+IHZhbHVlICE9IG51bGw7XG5cbi8vIGFkZCB0byBzdGF0ZSxcbi8vIGFkZCBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRvIGludGVybmFsIGFuZCBleHRlcm5hbCBhcGkgKGlmIG5vdCBzZXQpXG4vLyBzZXQgaW5pdGlhbCBzdGF0ZSBiYXNlZCBvbiBwcm9wcyBpbiB2aWV3UHJvcHNcbi8vIGFwcGx5IGFzIHRyYW5zZm9ybXMgZWFjaCBmcmFtZVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHNjYWxlWDogMSxcbiAgICBzY2FsZVk6IDEsXG4gICAgdHJhbnNsYXRlWDogMCxcbiAgICB0cmFuc2xhdGVZOiAwLFxuICAgIHJvdGF0ZVg6IDAsXG4gICAgcm90YXRlWTogMCxcbiAgICByb3RhdGVaOiAwLFxuICAgIG9yaWdpblg6IDAsXG4gICAgb3JpZ2luWTogMCxcbn07XG5cbmNvbnN0IHN0eWxlcyA9ICh7IG1peGluQ29uZmlnLCB2aWV3UHJvcHMsIHZpZXdJbnRlcm5hbEFQSSwgdmlld0V4dGVybmFsQVBJLCB2aWV3IH0pID0+IHtcbiAgICAvLyBpbml0aWFsIHByb3BzXG4gICAgY29uc3QgaW5pdGlhbFByb3BzID0geyAuLi52aWV3UHJvcHMgfTtcblxuICAgIC8vIGN1cnJlbnQgcHJvcHNcbiAgICBjb25zdCBjdXJyZW50UHJvcHMgPSB7fTtcblxuICAgIC8vIHdlIHdpbGwgYWRkIHRob3NlIHByb3BlcnRpZXMgdG8gdGhlIGV4dGVybmFsIEFQSSBhbmQgbGluayB0aGVtIHRvIHRoZSB2aWV3U3RhdGVcbiAgICBhZGRHZXRTZXQobWl4aW5Db25maWcsIFt2aWV3SW50ZXJuYWxBUEksIHZpZXdFeHRlcm5hbEFQSV0sIHZpZXdQcm9wcyk7XG5cbiAgICAvLyBvdmVycmlkZSByZWN0IG9uIGludGVybmFsIGFuZCBleHRlcm5hbCByZWN0IGdldHRlciBzbyBpdCB0YWtlcyBpbiBhY2NvdW50IHRyYW5zZm9ybXNcbiAgICBjb25zdCBnZXRPZmZzZXQgPSAoKSA9PiBbdmlld1Byb3BzWyd0cmFuc2xhdGVYJ10gfHwgMCwgdmlld1Byb3BzWyd0cmFuc2xhdGVZJ10gfHwgMF07XG4gICAgY29uc3QgZ2V0U2NhbGUgPSAoKSA9PiBbdmlld1Byb3BzWydzY2FsZVgnXSB8fCAwLCB2aWV3UHJvcHNbJ3NjYWxlWSddIHx8IDBdO1xuICAgIGNvbnN0IGdldFJlY3QgPSAoKSA9PlxuICAgICAgICB2aWV3LnJlY3QgPyBnZXRWaWV3UmVjdCh2aWV3LnJlY3QsIHZpZXcuY2hpbGRWaWV3cywgZ2V0T2Zmc2V0KCksIGdldFNjYWxlKCkpIDogbnVsbDtcbiAgICB2aWV3SW50ZXJuYWxBUEkucmVjdCA9IHsgZ2V0OiBnZXRSZWN0IH07XG4gICAgdmlld0V4dGVybmFsQVBJLnJlY3QgPSB7IGdldDogZ2V0UmVjdCB9O1xuXG4gICAgLy8gYXBwbHkgdmlldyBwcm9wc1xuICAgIG1peGluQ29uZmlnLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdmlld1Byb3BzW2tleV0gPVxuICAgICAgICAgICAgdHlwZW9mIGluaXRpYWxQcm9wc1trZXldID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzW2tleV0gOiBpbml0aWFsUHJvcHNba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIGV4cG9zZSBhcGlcbiAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gc2VlIGlmIHByb3BzIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKCFwcm9wc0hhdmVDaGFuZ2VkKGN1cnJlbnRQcm9wcywgdmlld1Byb3BzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92ZXMgZWxlbWVudCB0byBjb3JyZWN0IHBvc2l0aW9uIG9uIHNjcmVlblxuICAgICAgICAgICAgYXBwbHlTdHlsZXModmlldy5lbGVtZW50LCB2aWV3UHJvcHMpO1xuXG4gICAgICAgICAgICAvLyBzdG9yZSBuZXcgdHJhbnNmb3Jtc1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjdXJyZW50UHJvcHMsIHsgLi4udmlld1Byb3BzIH0pO1xuXG4gICAgICAgICAgICAvLyBubyBsb25nZXIgYnVzeVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6ICgpID0+IHt9LFxuICAgIH07XG59O1xuXG5jb25zdCBwcm9wc0hhdmVDaGFuZ2VkID0gKGN1cnJlbnRQcm9wcywgbmV3UHJvcHMpID0+IHtcbiAgICAvLyBkaWZmZXJlbnQgYW1vdW50IG9mIGtleXNcbiAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudFByb3BzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKG5ld1Byb3BzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gbGV0cyBhbmFseXplIHRoZSBpbmRpdmlkdWFsIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIG5ld1Byb3BzKSB7XG4gICAgICAgIGlmIChuZXdQcm9wc1twcm9wXSAhPT0gY3VycmVudFByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGFwcGx5U3R5bGVzID0gKFxuICAgIGVsZW1lbnQsXG4gICAge1xuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwZXJzcGVjdGl2ZSxcbiAgICAgICAgdHJhbnNsYXRlWCxcbiAgICAgICAgdHJhbnNsYXRlWSxcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVksXG4gICAgICAgIHJvdGF0ZVgsXG4gICAgICAgIHJvdGF0ZVksXG4gICAgICAgIHJvdGF0ZVosXG4gICAgICAgIG9yaWdpblgsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgfVxuKSA9PiB7XG4gICAgbGV0IHRyYW5zZm9ybXMgPSAnJztcbiAgICBsZXQgc3R5bGVzID0gJyc7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNmb3JtIG9yaWdpblxuICAgIGlmIChpc0RlZmluZWQob3JpZ2luWCkgfHwgaXNEZWZpbmVkKG9yaWdpblkpKSB7XG4gICAgICAgIHN0eWxlcyArPSBgdHJhbnNmb3JtLW9yaWdpbjogJHtvcmlnaW5YIHx8IDB9cHggJHtvcmlnaW5ZIHx8IDB9cHg7YDtcbiAgICB9XG5cbiAgICAvLyB0cmFuc2Zvcm0gb3JkZXIgaXMgcmVsZXZhbnRcbiAgICAvLyAwLiBwZXJzcGVjdGl2ZVxuICAgIGlmIChpc0RlZmluZWQocGVyc3BlY3RpdmUpKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHBlcnNwZWN0aXZlKCR7cGVyc3BlY3RpdmV9cHgpIGA7XG4gICAgfVxuXG4gICAgLy8gMS4gdHJhbnNsYXRlXG4gICAgaWYgKGlzRGVmaW5lZCh0cmFuc2xhdGVYKSB8fCBpc0RlZmluZWQodHJhbnNsYXRlWSkpIHtcbiAgICAgICAgdHJhbnNmb3JtcyArPSBgdHJhbnNsYXRlM2QoJHt0cmFuc2xhdGVYIHx8IDB9cHgsICR7dHJhbnNsYXRlWSB8fCAwfXB4LCAwKSBgO1xuICAgIH1cblxuICAgIC8vIDIuIHNjYWxlXG4gICAgaWYgKGlzRGVmaW5lZChzY2FsZVgpIHx8IGlzRGVmaW5lZChzY2FsZVkpKSB7XG4gICAgICAgIHRyYW5zZm9ybXMgKz0gYHNjYWxlM2QoJHtpc0RlZmluZWQoc2NhbGVYKSA/IHNjYWxlWCA6IDF9LCAke1xuICAgICAgICAgICAgaXNEZWZpbmVkKHNjYWxlWSkgPyBzY2FsZVkgOiAxXG4gICAgICAgIH0sIDEpIGA7XG4gICAgfVxuXG4gICAgLy8gMy4gcm90YXRlXG4gICAgaWYgKGlzRGVmaW5lZChyb3RhdGVaKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGByb3RhdGVaKCR7cm90YXRlWn1yYWQpIGA7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChyb3RhdGVYKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGByb3RhdGVYKCR7cm90YXRlWH1yYWQpIGA7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVmaW5lZChyb3RhdGVZKSkge1xuICAgICAgICB0cmFuc2Zvcm1zICs9IGByb3RhdGVZKCR7cm90YXRlWX1yYWQpIGA7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRyYW5zZm9ybXNcbiAgICBpZiAodHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICAgICAgc3R5bGVzICs9IGB0cmFuc2Zvcm06JHt0cmFuc2Zvcm1zfTtgO1xuICAgIH1cblxuICAgIC8vIGFkZCBvcGFjaXR5XG4gICAgaWYgKGlzRGVmaW5lZChvcGFjaXR5KSkge1xuICAgICAgICBzdHlsZXMgKz0gYG9wYWNpdHk6JHtvcGFjaXR5fTtgO1xuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoIHplcm8sIHdlIG1ha2UgdGhlIGVsZW1lbnQgaW5hY2Nlc3NpYmxlXG4gICAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gYHZpc2liaWxpdHk6aGlkZGVuO2A7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSdyZSBiZWxvdyAxMDAlIG9wYWNpdHkgdGhpcyBlbGVtZW50IGNhbid0IGJlIGNsaWNrZWRcbiAgICAgICAgaWYgKG9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gYHBvaW50ZXItZXZlbnRzOm5vbmU7YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBoZWlnaHRcbiAgICBpZiAoaXNEZWZpbmVkKGhlaWdodCkpIHtcbiAgICAgICAgc3R5bGVzICs9IGBoZWlnaHQ6JHtoZWlnaHR9cHg7YDtcbiAgICB9XG5cbiAgICAvLyBhZGQgd2lkdGhcbiAgICBpZiAoaXNEZWZpbmVkKHdpZHRoKSkge1xuICAgICAgICBzdHlsZXMgKz0gYHdpZHRoOiR7d2lkdGh9cHg7YDtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBzdHlsZXNcbiAgICBjb25zdCBlbGVtZW50Q3VycmVudFN0eWxlID0gZWxlbWVudC5lbGVtZW50Q3VycmVudFN0eWxlIHx8ICcnO1xuXG4gICAgLy8gaWYgbmV3IHN0eWxlcyBkb2VzIG5vdCBtYXRjaCBjdXJyZW50IHN0eWxlcywgbGV0cyB1cGRhdGUhXG4gICAgaWYgKHN0eWxlcy5sZW5ndGggIT09IGVsZW1lbnRDdXJyZW50U3R5bGUubGVuZ3RoIHx8IHN0eWxlcyAhPT0gZWxlbWVudEN1cnJlbnRTdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSBzdHlsZXM7XG4gICAgICAgIC8vIHN0b3JlIGN1cnJlbnQgc3R5bGVzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gdG8gbmV3IHN0eWxlcyBsYXRlciBvblxuICAgICAgICAvLyBfbm90XyBnZXR0aW5nIHRoZSBzdHlsZSB2YWx1ZSBpcyBmYXN0ZXJcbiAgICAgICAgZWxlbWVudC5lbGVtZW50Q3VycmVudFN0eWxlID0gc3R5bGVzO1xuICAgIH1cbn07XG5cbmNvbnN0IE1peGlucyA9IHtcbiAgICBzdHlsZXMsXG4gICAgbGlzdGVuZXJzLFxuICAgIGFuaW1hdGlvbnMsXG4gICAgYXBpcyxcbn07XG5cbmNvbnN0IHVwZGF0ZVJlY3QgPSAocmVjdCA9IHt9LCBlbGVtZW50ID0ge30sIHN0eWxlID0ge30pID0+IHtcbiAgICBpZiAoIWVsZW1lbnQubGF5b3V0Q2FsY3VsYXRlZCkge1xuICAgICAgICByZWN0LnBhZGRpbmdUb3AgPSBwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgcmVjdC5tYXJnaW5Ub3AgPSBwYXJzZUludChzdHlsZS5tYXJnaW5Ub3AsIDEwKSB8fCAwO1xuICAgICAgICByZWN0Lm1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQsIDEwKSB8fCAwO1xuICAgICAgICByZWN0Lm1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkJvdHRvbSwgMTApIHx8IDA7XG4gICAgICAgIHJlY3QubWFyZ2luTGVmdCA9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSB8fCAwO1xuICAgICAgICBlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlY3QubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCB8fCAwO1xuICAgIHJlY3QudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICByZWN0LndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAwO1xuICAgIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMDtcblxuICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoO1xuICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyByZWN0LmhlaWdodDtcblxuICAgIHJlY3Quc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICByZWN0LmhpZGRlbiA9IGVsZW1lbnQub2Zmc2V0UGFyZW50ID09PSBudWxsO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG59O1xuXG5jb25zdCBjcmVhdGVWaWV3ID1cbiAgICAvLyBkZWZhdWx0IHZpZXcgZGVmaW5pdGlvblxuICAgICh7XG4gICAgICAgIC8vIGVsZW1lbnQgZGVmaW5pdGlvblxuICAgICAgICB0YWcgPSAnZGl2JyxcbiAgICAgICAgbmFtZSA9IG51bGwsXG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7fSxcblxuICAgICAgICAvLyB2aWV3IGludGVyYWN0aW9uXG4gICAgICAgIHJlYWQgPSAoKSA9PiB7fSxcbiAgICAgICAgd3JpdGUgPSAoKSA9PiB7fSxcbiAgICAgICAgY3JlYXRlID0gKCkgPT4ge30sXG4gICAgICAgIGRlc3Ryb3kgPSAoKSA9PiB7fSxcblxuICAgICAgICAvLyBob29rc1xuICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCA9IChjaGlsZCwgYWN0aW9ucykgPT4gYWN0aW9ucyxcbiAgICAgICAgZGlkQ3JlYXRlVmlldyA9ICgpID0+IHt9LFxuICAgICAgICBkaWRXcml0ZVZpZXcgPSAoKSA9PiB7fSxcblxuICAgICAgICAvLyByZWN0IHJlbGF0ZWRcbiAgICAgICAgaWdub3JlUmVjdCA9IGZhbHNlLFxuICAgICAgICBpZ25vcmVSZWN0VXBkYXRlID0gZmFsc2UsXG5cbiAgICAgICAgLy8gbWl4aW5zXG4gICAgICAgIG1peGlucyA9IFtdLFxuICAgIH0gPSB7fSkgPT4gKFxuICAgICAgICAvLyBlYWNoIHZpZXcgcmVxdWlyZXMgcmVmZXJlbmNlIHRvIHN0b3JlXG4gICAgICAgIHN0b3JlLFxuICAgICAgICAvLyBzcGVjaWZpYyBwcm9wZXJ0aWVzIGZvciB0aGlzIHZpZXdcbiAgICAgICAgcHJvcHMgPSB7fVxuICAgICkgPT4ge1xuICAgICAgICAvLyByb290IGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHRhZywgYGZpbGVwb25kLS0ke25hbWV9YCwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgLy8gc3R5bGUgcmVmZXJlbmNlIHNob3VsZCBhbHNvIG5vdCBiZSBjaGFuZ2VkXG4gICAgICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5cbiAgICAgICAgLy8gZWxlbWVudCByZWN0YW5nbGVcbiAgICAgICAgY29uc3QgcmVjdCA9IHVwZGF0ZVJlY3QoKTtcbiAgICAgICAgbGV0IGZyYW1lUmVjdCA9IG51bGw7XG5cbiAgICAgICAgLy8gcmVzdCBzdGF0ZVxuICAgICAgICBsZXQgaXNSZXN0aW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcHJldHR5IHNlbGYgZXhwbGFuYXRvcnlcbiAgICAgICAgY29uc3QgY2hpbGRWaWV3cyA9IFtdO1xuXG4gICAgICAgIC8vIGxvYWRlZCBtaXhpbnNcbiAgICAgICAgY29uc3QgYWN0aXZlTWl4aW5zID0gW107XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IHJlZiA9IHt9O1xuXG4gICAgICAgIC8vIHN0YXRlIHVzZWQgZm9yIGVhY2ggaW5zdGFuY2VcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7fTtcblxuICAgICAgICAvLyBsaXN0IG9mIHdyaXRlcnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB0byB1cGRhdGUgdGhpcyB2aWV3XG4gICAgICAgIGNvbnN0IHdyaXRlcnMgPSBbXG4gICAgICAgICAgICB3cml0ZSwgLy8gZGVmYXVsdCB3cml0ZXJcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCByZWFkZXJzID0gW1xuICAgICAgICAgICAgcmVhZCwgLy8gZGVmYXVsdCByZWFkZXJcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBkZXN0cm95ZXJzID0gW1xuICAgICAgICAgICAgZGVzdHJveSwgLy8gZGVmYXVsdCBkZXN0cm95XG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gY29yZSB2aWV3IG1ldGhvZHNcbiAgICAgICAgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGdldENoaWxkVmlld3MgPSAoKSA9PiBjaGlsZFZpZXdzLmNvbmNhdCgpO1xuICAgICAgICBjb25zdCBnZXRSZWZlcmVuY2UgPSAoKSA9PiByZWY7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUNoaWxkVmlldyA9IHN0b3JlID0+ICh2aWV3LCBwcm9wcykgPT4gdmlldyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICBjb25zdCBnZXRSZWN0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyYW1lUmVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFtZVJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZVJlY3QgPSBnZXRWaWV3UmVjdChyZWN0LCBjaGlsZFZpZXdzLCBbMCwgMF0sIFsxLCAxXSk7XG4gICAgICAgICAgICByZXR1cm4gZnJhbWVSZWN0O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXRTdHlsZSA9ICgpID0+IHN0eWxlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWFkIGRhdGEgZnJvbSBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IF9yZWFkID0gKCkgPT4ge1xuICAgICAgICAgICAgZnJhbWVSZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gcmVhZCBjaGlsZCB2aWV3c1xuICAgICAgICAgICAgY2hpbGRWaWV3cy5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLl9yZWFkKCkpO1xuXG4gICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSAhKGlnbm9yZVJlY3RVcGRhdGUgJiYgcmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlUmVjdChyZWN0LCBlbGVtZW50LCBzdHlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IHsgcm9vdDogaW50ZXJuYWxBUEksIHByb3BzLCByZWN0IH07XG4gICAgICAgICAgICByZWFkZXJzLmZvckVhY2gocmVhZGVyID0+IHJlYWRlcihhcGkpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGUgZGF0YSB0byBET01cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IF93cml0ZSA9ICh0cywgZnJhbWVBY3Rpb25zLCBzaG91bGRPcHRpbWl6ZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucywgd2UgYXNzdW1lIHRoYXQgdGhlIHZpZXcgaXMgcmVzdGluZ1xuICAgICAgICAgICAgbGV0IHJlc3RpbmcgPSBmcmFtZUFjdGlvbnMubGVuZ3RoID09PSAwO1xuXG4gICAgICAgICAgICAvLyB3cml0ZXJzXG4gICAgICAgICAgICB3cml0ZXJzLmZvckVhY2god3JpdGVyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXJSZXN0aW5nID0gd3JpdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IGludGVybmFsQVBJLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBmcmFtZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZXJSZXN0aW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJ1biBtaXhpbnNcbiAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKG1peGluID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1peGlucyBpcyBzdGlsbCBidXN5IGFmdGVyIHdyaXRlIG9wZXJhdGlvbiwgd2UgYXJlIG5vdCByZXN0aW5nXG4gICAgICAgICAgICAgICAgY29uc3QgbWl4aW5SZXN0aW5nID0gbWl4aW4ud3JpdGUodHMpO1xuICAgICAgICAgICAgICAgIGlmIChtaXhpblJlc3RpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlcyBjaGlsZCB2aWV3cyB0aGF0IGFyZSBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhlIERPTVxuICAgICAgICAgICAgY2hpbGRWaWV3c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoY2hpbGQgPT4gISFjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBhIGNoaWxkIHZpZXcgaXMgbm90IHJlc3RpbmcsIHdlIGFyZSBub3QgcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFJlc3RpbmcgPSBjaGlsZC5fd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckZyYW1lQWN0aW9uc0ZvckNoaWxkKGNoaWxkLCBmcmFtZUFjdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkT3B0aW1pemVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFJlc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgbmV3IGVsZW1lbnRzIHRvIERPTSBhbmQgdXBkYXRlIHRob3NlXG4gICAgICAgICAgICBjaGlsZFZpZXdzXG4gICAgICAgICAgICAgICAgLy8uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVuZCB0byBET01cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxBUEkuYXBwZW5kQ2hpbGQoY2hpbGQuZWxlbWVudCwgaW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgcmVhZCAobmVlZCB0byBrbm93IHRoZSBzaXplIG9mIHRoZXNlIGVsZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5fcmVhZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWNhbGwgd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3dyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZChjaGlsZCwgZnJhbWVBY3Rpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZE9wdGltaXplXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBhZGRlZCBzb210aGluZyB0byB0aGUgZG9tLCBubyByZXN0XG4gICAgICAgICAgICAgICAgICAgIHJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHJlc3Rpbmcgc3RhdGVcbiAgICAgICAgICAgIGlzUmVzdGluZyA9IHJlc3Rpbmc7XG5cbiAgICAgICAgICAgIGRpZFdyaXRlVmlldyh7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgcm9vdDogaW50ZXJuYWxBUEksXG4gICAgICAgICAgICAgICAgYWN0aW9uczogZnJhbWVBY3Rpb25zLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdHMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gbGV0IHBhcmVudCBrbm93IGlmIHdlIGFyZSByZXN0aW5nXG4gICAgICAgICAgICByZXR1cm4gcmVzdGluZztcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBfZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZU1peGlucy5mb3JFYWNoKG1peGluID0+IG1peGluLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICBkZXN0cm95ZXJzLmZvckVhY2goZGVzdHJveWVyID0+IHtcbiAgICAgICAgICAgICAgICBkZXN0cm95ZXIoeyByb290OiBpbnRlcm5hbEFQSSwgcHJvcHMgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5fZGVzdHJveSgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzaGFyZWRBUElcbiAgICAgICAgY29uc3Qgc2hhcmVkQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldEVsZW1lbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldFN0eWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkVmlld3M6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldENoaWxkVmlld3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHByaXZhdGUgQVBJIGRlZmluaXRpb25cbiAgICAgICAgY29uc3QgaW50ZXJuYWxBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgLi4uc2hhcmVkQVBJRGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldFJlY3QsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBhY2Nlc3MgdG8gY3VzdG9tIGNoaWxkcmVuIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIHJlZjoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0UmVmZXJlbmNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gZG9tIG1vZGlmaWVyc1xuICAgICAgICAgICAgaXM6IG5lZWRsZSA9PiBuYW1lID09PSBuZWVkbGUsXG4gICAgICAgICAgICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQoZWxlbWVudCksXG4gICAgICAgICAgICBjcmVhdGVDaGlsZFZpZXc6IGNyZWF0ZUNoaWxkVmlldyhzdG9yZSksXG4gICAgICAgICAgICBsaW5rVmlldzogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgY2hpbGRWaWV3cy5wdXNoKHZpZXcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVubGlua1ZpZXc6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIGNoaWxkVmlld3Muc3BsaWNlKGNoaWxkVmlld3MuaW5kZXhPZih2aWV3KSwgMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwZW5kQ2hpbGRWaWV3OiBhcHBlbmRDaGlsZFZpZXcoZWxlbWVudCwgY2hpbGRWaWV3cyksXG4gICAgICAgICAgICByZW1vdmVDaGlsZFZpZXc6IHJlbW92ZUNoaWxkVmlldyhlbGVtZW50LCBjaGlsZFZpZXdzKSxcbiAgICAgICAgICAgIHJlZ2lzdGVyV3JpdGVyOiB3cml0ZXIgPT4gd3JpdGVycy5wdXNoKHdyaXRlciksXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcjogcmVhZGVyID0+IHJlYWRlcnMucHVzaChyZWFkZXIpLFxuICAgICAgICAgICAgcmVnaXN0ZXJEZXN0cm95ZXI6IGRlc3Ryb3llciA9PiBkZXN0cm95ZXJzLnB1c2goZGVzdHJveWVyKSxcbiAgICAgICAgICAgIGludmFsaWRhdGVMYXlvdXQ6ICgpID0+IChlbGVtZW50LmxheW91dENhbGN1bGF0ZWQgPSBmYWxzZSksXG5cbiAgICAgICAgICAgIC8vIGFjY2VzcyB0byBkYXRhIHN0b3JlXG4gICAgICAgICAgICBkaXNwYXRjaDogc3RvcmUuZGlzcGF0Y2gsXG4gICAgICAgICAgICBxdWVyeTogc3RvcmUucXVlcnksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcHVibGljIHZpZXcgQVBJIG1ldGhvZHNcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxBUElEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgICAgIGdldDogZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZFZpZXdzOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiBnZXRDaGlsZFZpZXdzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGdldFJlY3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdGluZzoge1xuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gaXNSZXN0aW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzUmVjdElnbm9yZWQ6ICgpID0+IGlnbm9yZVJlY3QsXG4gICAgICAgICAgICBfcmVhZCxcbiAgICAgICAgICAgIF93cml0ZSxcbiAgICAgICAgICAgIF9kZXN0cm95LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1peGluIEFQSSBtZXRob2RzXG4gICAgICAgIGNvbnN0IG1peGluQVBJRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnNoYXJlZEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiByZWN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgbWl4aW4gZnVuY3Rpb25hbGl0eVxuICAgICAgICBPYmplY3Qua2V5cyhtaXhpbnMpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgc3R5bGVzIHRvIHRoZSBiYWNrIG9mIHRoZSBtaXhpbiBsaXN0IChzbyBhZGp1c3RtZW50cyBvZiBvdGhlciBtaXhpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIHByb3BzIGNvcnJlY3RseSlcbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gJ3N0eWxlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChiID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWl4aW5BUEkgPSBNaXhpbnNba2V5XSh7XG4gICAgICAgICAgICAgICAgICAgIG1peGluQ29uZmlnOiBtaXhpbnNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgdmlld1Byb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgdmlld1N0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmlld0ludGVybmFsQVBJOiBpbnRlcm5hbEFQSURlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHZpZXdFeHRlcm5hbEFQSTogZXh0ZXJuYWxBUElEZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjcmVhdGVPYmplY3QobWl4aW5BUElEZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChtaXhpbkFQSSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVNaXhpbnMucHVzaChtaXhpbkFQSSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY29uc3RydWN0IHByaXZhdGUgYXBpXG4gICAgICAgIGNvbnN0IGludGVybmFsQVBJID0gY3JlYXRlT2JqZWN0KGludGVybmFsQVBJRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB2aWV3XG4gICAgICAgIGNyZWF0ZSh7XG4gICAgICAgICAgICByb290OiBpbnRlcm5hbEFQSSxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcHBlbmQgY3JlYXRlZCBjaGlsZCB2aWV3cyB0byByb290IG5vZGVcbiAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGdldENoaWxkQ291bnQoZWxlbWVudCk7IC8vIG5lZWQgdG8ga25vdyB0aGUgY3VycmVudCBjaGlsZCBjb3VudCBzbyBhcHBlbmRpbmcgaGFwcGVucyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgIGNoaWxkVmlld3MuZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpbnRlcm5hbEFQSS5hcHBlbmRDaGlsZChjaGlsZC5lbGVtZW50LCBjaGlsZENvdW50ICsgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjYWxsIGRpZCBjcmVhdGVcbiAgICAgICAgZGlkQ3JlYXRlVmlldyhpbnRlcm5hbEFQSSk7XG5cbiAgICAgICAgLy8gZXhwb3NlIHB1YmxpYyBhcGlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHRlcm5hbEFQSURlZmluaXRpb24pO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZVBhaW50ZXIgPSAocmVhZCwgd3JpdGUsIGZwcyA9IDYwKSA9PiB7XG4gICAgY29uc3QgbmFtZSA9ICdfX2ZyYW1lUGFpbnRlcic7XG5cbiAgICAvLyBzZXQgZ2xvYmFsIHBhaW50ZXJcbiAgICBpZiAod2luZG93W25hbWVdKSB7XG4gICAgICAgIHdpbmRvd1tuYW1lXS5yZWFkZXJzLnB1c2gocmVhZCk7XG4gICAgICAgIHdpbmRvd1tuYW1lXS53cml0ZXJzLnB1c2god3JpdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2luZG93W25hbWVdID0ge1xuICAgICAgICByZWFkZXJzOiBbcmVhZF0sXG4gICAgICAgIHdyaXRlcnM6IFt3cml0ZV0sXG4gICAgfTtcblxuICAgIGNvbnN0IHBhaW50ZXIgPSB3aW5kb3dbbmFtZV07XG5cbiAgICBjb25zdCBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG4gICAgbGV0IGxhc3QgPSBudWxsO1xuICAgIGxldCBpZCA9IG51bGw7XG4gICAgbGV0IHJlcXVlc3RUaWNrID0gbnVsbDtcbiAgICBsZXQgY2FuY2VsVGljayA9IG51bGw7XG5cbiAgICBjb25zdCBzZXRUaW1lclR5cGUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gKCkgPT4gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGljayhwZXJmb3JtYW5jZS5ub3coKSksIGludGVydmFsKTtcbiAgICAgICAgICAgIGNhbmNlbFRpY2sgPSAoKSA9PiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gKCkgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgICAgICAgIGNhbmNlbFRpY2sgPSAoKSA9PiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxUaWNrKSBjYW5jZWxUaWNrKCk7XG4gICAgICAgIHNldFRpbWVyVHlwZSgpO1xuICAgICAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRpY2sgPSB0cyA9PiB7XG4gICAgICAgIC8vIHF1ZXVlIG5leHQgdGlja1xuICAgICAgICBpZCA9IHJlcXVlc3RUaWNrKHRpY2spO1xuXG4gICAgICAgIC8vIGxpbWl0IGZwc1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QgPSB0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdHMgLSBsYXN0O1xuXG4gICAgICAgIGlmIChkZWx0YSA8PSBpbnRlcnZhbCkge1xuICAgICAgICAgICAgLy8gc2tpcCBmcmFtZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxpZ24gbmV4dCBmcmFtZVxuICAgICAgICBsYXN0ID0gdHMgLSAoZGVsdGEgJSBpbnRlcnZhbCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHZpZXdcbiAgICAgICAgcGFpbnRlci5yZWFkZXJzLmZvckVhY2gocmVhZCA9PiByZWFkKCkpO1xuICAgICAgICBwYWludGVyLndyaXRlcnMuZm9yRWFjaCh3cml0ZSA9PiB3cml0ZSh0cykpO1xuICAgIH07XG5cbiAgICBzZXRUaW1lclR5cGUoKTtcbiAgICB0aWNrKHBlcmZvcm1hbmNlLm5vdygpKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHBhdXNlOiAoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxUaWNrKGlkKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlUm91dGUgPSAocm91dGVzLCBmbikgPT4gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgPSBbXSwgdGltZXN0YW1wLCBzaG91bGRPcHRpbWl6ZSB9KSA9PiB7XG4gICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiByb3V0ZXNbYWN0aW9uLnR5cGVdKVxuICAgICAgICAuZm9yRWFjaChhY3Rpb24gPT5cbiAgICAgICAgICAgIHJvdXRlc1thY3Rpb24udHlwZV0oeyByb290LCBwcm9wcywgYWN0aW9uOiBhY3Rpb24uZGF0YSwgdGltZXN0YW1wLCBzaG91bGRPcHRpbWl6ZSB9KVxuICAgICAgICApO1xuICAgIGlmIChmbikge1xuICAgICAgICBmbih7IHJvb3QsIHByb3BzLCBhY3Rpb25zLCB0aW1lc3RhbXAsIHNob3VsZE9wdGltaXplIH0pO1xuICAgIH1cbn07XG5cbmNvbnN0IGluc2VydEJlZm9yZSA9IChuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSA9PlxuICAgIHJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG5cbmNvbnN0IGluc2VydEFmdGVyID0gKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpID0+IHtcbiAgICByZXR1cm4gcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlLm5leHRTaWJsaW5nKTtcbn07XG5cbmNvbnN0IGlzQXJyYXkgPSB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKTtcblxuY29uc3QgaXNFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09IG51bGw7XG5cbmNvbnN0IHRyaW0gPSBzdHIgPT4gc3RyLnRyaW0oKTtcblxuY29uc3QgdG9TdHJpbmcgPSB2YWx1ZSA9PiAnJyArIHZhbHVlO1xuXG5jb25zdCB0b0FycmF5ID0gKHZhbHVlLCBzcGxpdHRlciA9ICcsJykgPT4ge1xuICAgIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSlcbiAgICAgICAgLnNwbGl0KHNwbGl0dGVyKVxuICAgICAgICAubWFwKHRyaW0pXG4gICAgICAgIC5maWx0ZXIoc3RyID0+IHN0ci5sZW5ndGgpO1xufTtcblxuY29uc3QgaXNCb29sZWFuID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbmNvbnN0IHRvQm9vbGVhbiA9IHZhbHVlID0+IChpc0Jvb2xlYW4odmFsdWUpID8gdmFsdWUgOiB2YWx1ZSA9PT0gJ3RydWUnKTtcblxuY29uc3QgaXNTdHJpbmcgPSB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG5jb25zdCB0b051bWJlciA9IHZhbHVlID0+XG4gICAgaXNOdW1iZXIodmFsdWUpID8gdmFsdWUgOiBpc1N0cmluZyh2YWx1ZSkgPyB0b1N0cmluZyh2YWx1ZSkucmVwbGFjZSgvW2Etel0rL2dpLCAnJykgOiAwO1xuXG5jb25zdCB0b0ludCA9IHZhbHVlID0+IHBhcnNlSW50KHRvTnVtYmVyKHZhbHVlKSwgMTApO1xuXG5jb25zdCB0b0Zsb2F0ID0gdmFsdWUgPT4gcGFyc2VGbG9hdCh0b051bWJlcih2YWx1ZSkpO1xuXG5jb25zdCBpc0ludCA9IHZhbHVlID0+IGlzTnVtYmVyKHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuXG5jb25zdCB0b0J5dGVzID0gKHZhbHVlLCBiYXNlID0gMTAwMCkgPT4ge1xuICAgIC8vIGlzIGluIGJ5dGVzXG4gICAgaWYgKGlzSW50KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gaXMgbmF0dXJhbCBmaWxlIHNpemVcbiAgICBsZXQgbmF0dXJhbEZpbGVTaXplID0gdG9TdHJpbmcodmFsdWUpLnRyaW0oKTtcblxuICAgIC8vIGlmIGlzIHZhbHVlIGluIG1lZ2FieXRlc1xuICAgIGlmICgvTUIkL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9NQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlICogYmFzZTtcbiAgICB9XG5cbiAgICAvLyBpZiBpcyB2YWx1ZSBpbiBraWxvYnl0ZXNcbiAgICBpZiAoL0tCL2kudGVzdChuYXR1cmFsRmlsZVNpemUpKSB7XG4gICAgICAgIG5hdHVyYWxGaWxlU2l6ZSA9IG5hdHVyYWxGaWxlU2l6ZS5yZXBsYWNlKC9LQiRpLywgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIHRvSW50KG5hdHVyYWxGaWxlU2l6ZSkgKiBiYXNlO1xuICAgIH1cblxuICAgIHJldHVybiB0b0ludChuYXR1cmFsRmlsZVNpemUpO1xufTtcblxuY29uc3QgaXNGdW5jdGlvbiA9IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuY29uc3QgdG9GdW5jdGlvblJlZmVyZW5jZSA9IHN0cmluZyA9PiB7XG4gICAgbGV0IHJlZiA9IHNlbGY7XG4gICAgbGV0IGxldmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgIGxldCBsZXZlbCA9IG51bGw7XG4gICAgd2hpbGUgKChsZXZlbCA9IGxldmVscy5zaGlmdCgpKSkge1xuICAgICAgICByZWYgPSByZWZbbGV2ZWxdO1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn07XG5cbmNvbnN0IG1ldGhvZHMgPSB7XG4gICAgcHJvY2VzczogJ1BPU1QnLFxuICAgIHBhdGNoOiAnUEFUQ0gnLFxuICAgIHJldmVydDogJ0RFTEVURScsXG4gICAgZmV0Y2g6ICdHRVQnLFxuICAgIHJlc3RvcmU6ICdHRVQnLFxuICAgIGxvYWQ6ICdHRVQnLFxufTtcblxuY29uc3QgY3JlYXRlU2VydmVyQVBJID0gb3V0bGluZSA9PiB7XG4gICAgY29uc3QgYXBpID0ge307XG5cbiAgICBhcGkudXJsID0gaXNTdHJpbmcob3V0bGluZSkgPyBvdXRsaW5lIDogb3V0bGluZS51cmwgfHwgJyc7XG4gICAgYXBpLnRpbWVvdXQgPSBvdXRsaW5lLnRpbWVvdXQgPyBwYXJzZUludChvdXRsaW5lLnRpbWVvdXQsIDEwKSA6IDA7XG4gICAgYXBpLmhlYWRlcnMgPSBvdXRsaW5lLmhlYWRlcnMgPyBvdXRsaW5lLmhlYWRlcnMgOiB7fTtcblxuICAgIGZvcmluKG1ldGhvZHMsIGtleSA9PiB7XG4gICAgICAgIGFwaVtrZXldID0gY3JlYXRlQWN0aW9uKGtleSwgb3V0bGluZVtrZXldLCBtZXRob2RzW2tleV0sIGFwaS50aW1lb3V0LCBhcGkuaGVhZGVycyk7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgcHJvY2VzcyBpZiBubyB1cmwgb3IgcHJvY2VzcyBvbiBvdXRsaW5lXG4gICAgYXBpLnByb2Nlc3MgPSBvdXRsaW5lLnByb2Nlc3MgfHwgaXNTdHJpbmcob3V0bGluZSkgfHwgb3V0bGluZS51cmwgPyBhcGkucHJvY2VzcyA6IG51bGw7XG5cbiAgICAvLyBzcGVjaWFsIHRyZWF0bWVudCBmb3IgcmVtb3ZlXG4gICAgYXBpLnJlbW92ZSA9IG91dGxpbmUucmVtb3ZlIHx8IG51bGw7XG5cbiAgICAvLyByZW1vdmUgZ2VuZXJpYyBoZWFkZXJzIGZyb20gYXBpIG9iamVjdFxuICAgIGRlbGV0ZSBhcGkuaGVhZGVycztcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBjcmVhdGVBY3Rpb24gPSAobmFtZSwgb3V0bGluZSwgbWV0aG9kLCB0aW1lb3V0LCBoZWFkZXJzKSA9PiB7XG4gICAgLy8gaXMgZXhwbGljaXRlbHkgc2V0IHRvIG51bGwgc28gZGlzYWJsZVxuICAgIGlmIChvdXRsaW5lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGlzIGN1c3RvbSBmdW5jdGlvbiwgZG9uZSEgRGV2IGhhbmRsZXMgZXZlcnl0aGluZy5cbiAgICBpZiAodHlwZW9mIG91dGxpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG91dGxpbmU7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgYWN0aW9uIG9iamVjdFxuICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgdXJsOiBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ1BBVENIJyA/IGA/JHtuYW1lfT1gIDogJycsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgb25sb2FkOiBudWxsLFxuICAgICAgICBvbmRhdGE6IG51bGwsXG4gICAgICAgIG9uZXJyb3I6IG51bGwsXG4gICAgfTtcblxuICAgIC8vIGlzIGEgc2luZ2xlIHVybFxuICAgIGlmIChpc1N0cmluZyhvdXRsaW5lKSkge1xuICAgICAgICBhY3Rpb24udXJsID0gb3V0bGluZTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBvdmVyd3JpdGVcbiAgICBPYmplY3QuYXNzaWduKGFjdGlvbiwgb3V0bGluZSk7XG5cbiAgICAvLyBzZWUgaWYgc2hvdWxkIHJlZm9ybWF0IGhlYWRlcnM7XG4gICAgaWYgKGlzU3RyaW5nKGFjdGlvbi5oZWFkZXJzKSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGFjdGlvbi5oZWFkZXJzLnNwbGl0KC86KC4rKS8pO1xuICAgICAgICBhY3Rpb24uaGVhZGVycyA9IHtcbiAgICAgICAgICAgIGhlYWRlcjogcGFydHNbMF0sXG4gICAgICAgICAgICB2YWx1ZTogcGFydHNbMV0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgYm9vbCB3aXRoQ3JlZGVudGlhbHNcbiAgICBhY3Rpb24ud2l0aENyZWRlbnRpYWxzID0gdG9Cb29sZWFuKGFjdGlvbi53aXRoQ3JlZGVudGlhbHMpO1xuXG4gICAgcmV0dXJuIGFjdGlvbjtcbn07XG5cbmNvbnN0IHRvU2VydmVyQVBJID0gdmFsdWUgPT4gY3JlYXRlU2VydmVyQVBJKHZhbHVlKTtcblxuY29uc3QgaXNOdWxsID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGw7XG5cbmNvbnN0IGlzT2JqZWN0ID0gdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcblxuY29uc3QgaXNBUEkgPSB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgIGlzU3RyaW5nKHZhbHVlLnVybCkgJiZcbiAgICAgICAgaXNPYmplY3QodmFsdWUucHJvY2VzcykgJiZcbiAgICAgICAgaXNPYmplY3QodmFsdWUucmV2ZXJ0KSAmJlxuICAgICAgICBpc09iamVjdCh2YWx1ZS5yZXN0b3JlKSAmJlxuICAgICAgICBpc09iamVjdCh2YWx1ZS5mZXRjaClcbiAgICApO1xufTtcblxuY29uc3QgZ2V0VHlwZSA9IHZhbHVlID0+IHtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAoaXNJbnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnaW50JztcbiAgICB9XG5cbiAgICBpZiAoL15bMC05XSsgPyg/OkdCfE1CfEtCKSQvZ2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdieXRlcyc7XG4gICAgfVxuXG4gICAgaWYgKGlzQVBJKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJ2FwaSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZTtcbn07XG5cbmNvbnN0IHJlcGxhY2VTaW5nbGVRdW90ZXMgPSBzdHIgPT5cbiAgICBzdHJcbiAgICAgICAgLnJlcGxhY2UoL3tcXHMqJy9nLCAne1wiJylcbiAgICAgICAgLnJlcGxhY2UoLydcXHMqfS9nLCAnXCJ9JylcbiAgICAgICAgLnJlcGxhY2UoLydcXHMqOi9nLCAnXCI6JylcbiAgICAgICAgLnJlcGxhY2UoLzpcXHMqJy9nLCAnOlwiJylcbiAgICAgICAgLnJlcGxhY2UoLyxcXHMqJy9nLCAnLFwiJylcbiAgICAgICAgLnJlcGxhY2UoLydcXHMqLC9nLCAnXCIsJyk7XG5cbmNvbnN0IGNvbnZlcnNpb25UYWJsZSA9IHtcbiAgICBhcnJheTogdG9BcnJheSxcbiAgICBib29sZWFuOiB0b0Jvb2xlYW4sXG4gICAgaW50OiB2YWx1ZSA9PiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdieXRlcycgPyB0b0J5dGVzKHZhbHVlKSA6IHRvSW50KHZhbHVlKSksXG4gICAgbnVtYmVyOiB0b0Zsb2F0LFxuICAgIGZsb2F0OiB0b0Zsb2F0LFxuICAgIGJ5dGVzOiB0b0J5dGVzLFxuICAgIHN0cmluZzogdmFsdWUgPT4gKGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiB0b1N0cmluZyh2YWx1ZSkpLFxuICAgIGZ1bmN0aW9uOiB2YWx1ZSA9PiB0b0Z1bmN0aW9uUmVmZXJlbmNlKHZhbHVlKSxcbiAgICBzZXJ2ZXJhcGk6IHRvU2VydmVyQVBJLFxuICAgIG9iamVjdDogdmFsdWUgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVwbGFjZVNpbmdsZVF1b3Rlcyh2YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5jb25zdCBjb252ZXJ0VG8gPSAodmFsdWUsIHR5cGUpID0+IGNvbnZlcnNpb25UYWJsZVt0eXBlXSh2YWx1ZSk7XG5cbmNvbnN0IGdldFZhbHVlQnlUeXBlID0gKG5ld1ZhbHVlLCBkZWZhdWx0VmFsdWUsIHZhbHVlVHlwZSkgPT4ge1xuICAgIC8vIGNhbiBhbHdheXMgYXNzaWduIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAobmV3VmFsdWUgPT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB0eXBlIG9mIHRoZSBuZXcgdmFsdWVcbiAgICBsZXQgbmV3VmFsdWVUeXBlID0gZ2V0VHlwZShuZXdWYWx1ZSk7XG5cbiAgICAvLyBpcyB2YWxpZCB0eXBlP1xuICAgIGlmIChuZXdWYWx1ZVR5cGUgIT09IHZhbHVlVHlwZSkge1xuICAgICAgICAvLyBpcyBzdHJpbmcgaW5wdXQsIGxldCdzIGF0dGVtcHQgdG8gY29udmVydFxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRUbyhuZXdWYWx1ZSwgdmFsdWVUeXBlKTtcblxuICAgICAgICAvLyB3aGF0IGlzIHRoZSB0eXBlIG5vd1xuICAgICAgICBuZXdWYWx1ZVR5cGUgPSBnZXRUeXBlKGNvbnZlcnRlZFZhbHVlKTtcblxuICAgICAgICAvLyBubyB2YWxpZCBjb252ZXJzaW9ucyBmb3VuZFxuICAgICAgICBpZiAoY29udmVydGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGBUcnlpbmcgdG8gYXNzaWduIHZhbHVlIHdpdGggaW5jb3JyZWN0IHR5cGUgdG8gXCIke29wdGlvbn1cIiwgYWxsb3dlZCB0eXBlOiBcIiR7dmFsdWVUeXBlfVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29udmVydGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gbmV3IHZhbHVlXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufTtcblxuY29uc3QgY3JlYXRlT3B0aW9uID0gKGRlZmF1bHRWYWx1ZSwgdmFsdWVUeXBlKSA9PiB7XG4gICAgbGV0IGN1cnJlbnRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6ICgpID0+IGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgc2V0OiBuZXdWYWx1ZSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBnZXRWYWx1ZUJ5VHlwZShuZXdWYWx1ZSwgZGVmYXVsdFZhbHVlLCB2YWx1ZVR5cGUpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG5jb25zdCBjcmVhdGVPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgZm9yaW4ob3B0aW9ucywgcHJvcCA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRlZmluaXRpb24gPSBvcHRpb25zW3Byb3BdO1xuICAgICAgICBvYmpbcHJvcF0gPSBjcmVhdGVPcHRpb24ob3B0aW9uRGVmaW5pdGlvblswXSwgb3B0aW9uRGVmaW5pdGlvblsxXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdChvYmopO1xufTtcblxuY29uc3QgY3JlYXRlSW5pdGlhbFN0YXRlID0gb3B0aW9ucyA9PiAoe1xuICAgIC8vIG1vZGVsXG4gICAgaXRlbXM6IFtdLFxuXG4gICAgLy8gdGltZW91dCB1c2VkIGZvciBjYWxsaW5nIHVwZGF0ZSBpdGVtc1xuICAgIGxpc3RVcGRhdGVUaW1lb3V0OiBudWxsLFxuXG4gICAgLy8gdGltZW91dCB1c2VkIGZvciBzdGFja2luZyBtZXRhZGF0YSB1cGRhdGVzXG4gICAgaXRlbVVwZGF0ZVRpbWVvdXQ6IG51bGwsXG5cbiAgICAvLyBxdWV1ZSBvZiBpdGVtcyB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZFxuICAgIHByb2Nlc3NpbmdRdWV1ZTogW10sXG5cbiAgICAvLyBvcHRpb25zXG4gICAgb3B0aW9uczogY3JlYXRlT3B0aW9ucyhvcHRpb25zKSxcbn0pO1xuXG5jb25zdCBmcm9tQ2FtZWxzID0gKHN0cmluZywgc2VwYXJhdG9yID0gJy0nKSA9PlxuICAgIHN0cmluZ1xuICAgICAgICAuc3BsaXQoLyg/PVtBLVpdKS8pXG4gICAgICAgIC5tYXAocGFydCA9PiBwYXJ0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC5qb2luKHNlcGFyYXRvcik7XG5cbmNvbnN0IGNyZWF0ZU9wdGlvbkFQSSA9IChzdG9yZSwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGtleSA9PiB7XG4gICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm9wdGlvbnNba2V5XSxcbiAgICAgICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKGBTRVRfJHtmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBjcmVhdGVPcHRpb25BY3Rpb25zID0gb3B0aW9ucyA9PiAoZGlzcGF0Y2gsIHF1ZXJ5LCBzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvcmluKG9wdGlvbnMsIGtleSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBmcm9tQ2FtZWxzKGtleSwgJ18nKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIG9ialtgU0VUXyR7bmFtZX1gXSA9IGFjdGlvbiA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm9wdGlvbnNba2V5XSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3BlLCBmYWlsZWRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gd2Ugc3VjY2Vzc2Z1bGx5IHNldCB0aGUgdmFsdWUgb2YgdGhpcyBvcHRpb25cbiAgICAgICAgICAgIGRpc3BhdGNoKGBESURfU0VUXyR7bmFtZX1gLCB7IHZhbHVlOiBzdGF0ZS5vcHRpb25zW2tleV0gfSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IGNyZWF0ZU9wdGlvblF1ZXJpZXMgPSBvcHRpb25zID0+IHN0YXRlID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3JpbihvcHRpb25zLCBrZXkgPT4ge1xuICAgICAgICBvYmpbYEdFVF8ke2Zyb21DYW1lbHMoa2V5LCAnXycpLnRvVXBwZXJDYXNlKCl9YF0gPSBhY3Rpb24gPT4gc3RhdGUub3B0aW9uc1trZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5jb25zdCBJbnRlcmFjdGlvbk1ldGhvZCA9IHtcbiAgICBBUEk6IDEsXG4gICAgRFJPUDogMixcbiAgICBCUk9XU0U6IDMsXG4gICAgUEFTVEU6IDQsXG4gICAgTk9ORTogNSxcbn07XG5cbmNvbnN0IGdldFVuaXF1ZUlkID0gKCkgPT5cbiAgICBNYXRoLnJhbmRvbSgpXG4gICAgICAgIC50b1N0cmluZygzNilcbiAgICAgICAgLnN1YnN0cmluZygyLCAxMSk7XG5cbmNvbnN0IGFycmF5UmVtb3ZlID0gKGFyciwgaW5kZXgpID0+IGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuXG5jb25zdCBydW4gPSAoY2IsIHN5bmMpID0+IHtcbiAgICBpZiAoc3luYykge1xuICAgICAgICBjYigpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgxKS50aGVuKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICB9XG59O1xuXG5jb25zdCBvbiA9ICgpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICBjb25zdCBvZmYgPSAoZXZlbnQsIGNiKSA9PiB7XG4gICAgICAgIGFycmF5UmVtb3ZlKFxuICAgICAgICAgICAgbGlzdGVuZXJzLFxuICAgICAgICAgICAgbGlzdGVuZXJzLmZpbmRJbmRleChsaXN0ZW5lciA9PiBsaXN0ZW5lci5ldmVudCA9PT0gZXZlbnQgJiYgKGxpc3RlbmVyLmNiID09PSBjYiB8fCAhY2IpKVxuICAgICAgICApO1xuICAgIH07XG4gICAgY29uc3QgZmlyZSA9IChldmVudCwgYXJncywgc3luYykgPT4ge1xuICAgICAgICBsaXN0ZW5lcnNcbiAgICAgICAgICAgIC5maWx0ZXIobGlzdGVuZXIgPT4gbGlzdGVuZXIuZXZlbnQgPT09IGV2ZW50KVxuICAgICAgICAgICAgLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYilcbiAgICAgICAgICAgIC5mb3JFYWNoKGNiID0+IHJ1bigoKSA9PiBjYiguLi5hcmdzKSwgc3luYykpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlyZVN5bmM6IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgZmlyZShldmVudCwgYXJncywgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmU6IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgZmlyZShldmVudCwgYXJncywgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBvbjogKGV2ZW50LCBjYikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goeyBldmVudCwgY2IgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT25jZTogKGV2ZW50LCBjYikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIGNiOiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvZmYoZXZlbnQsIGNiKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvZmYsXG4gICAgfTtcbn07XG5cbmNvbnN0IGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QgPSAoc3JjLCB0YXJnZXQsIGV4Y2x1ZGVkKSA9PiB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3JjKVxuICAgICAgICAuZmlsdGVyKHByb3BlcnR5ID0+ICFleGNsdWRlZC5pbmNsdWRlcyhwcm9wZXJ0eSkpXG4gICAgICAgIC5mb3JFYWNoKGtleSA9PlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywga2V5KSlcbiAgICAgICAgKTtcbn07XG5cbmNvbnN0IFBSSVZBVEUgPSBbXG4gICAgJ2ZpcmUnLFxuICAgICdwcm9jZXNzJyxcbiAgICAncmV2ZXJ0JyxcbiAgICAnbG9hZCcsXG4gICAgJ29uJyxcbiAgICAnb2ZmJyxcbiAgICAnb25PbmNlJyxcbiAgICAncmV0cnlMb2FkJyxcbiAgICAnZXh0ZW5kJyxcbiAgICAnYXJjaGl2ZScsXG4gICAgJ2FyY2hpdmVkJyxcbiAgICAncmVsZWFzZScsXG4gICAgJ3JlbGVhc2VkJyxcbiAgICAncmVxdWVzdFByb2Nlc3NpbmcnLFxuICAgICdmcmVlemUnLFxuXTtcblxuY29uc3QgY3JlYXRlSXRlbUFQSSA9IGl0ZW0gPT4ge1xuICAgIGNvbnN0IGFwaSA9IHt9O1xuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoaXRlbSwgYXBpLCBQUklWQVRFKTtcbiAgICByZXR1cm4gYXBpO1xufTtcblxuY29uc3QgcmVtb3ZlUmVsZWFzZWRJdGVtcyA9IGl0ZW1zID0+IHtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5yZWxlYXNlZCkge1xuICAgICAgICAgICAgYXJyYXlSZW1vdmUoaXRlbXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgSXRlbVN0YXR1cyA9IHtcbiAgICBJTklUOiAxLFxuICAgIElETEU6IDIsXG4gICAgUFJPQ0VTU0lOR19RVUVVRUQ6IDksXG4gICAgUFJPQ0VTU0lORzogMyxcbiAgICBQUk9DRVNTSU5HX0NPTVBMRVRFOiA1LFxuICAgIFBST0NFU1NJTkdfRVJST1I6IDYsXG4gICAgUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IDEwLFxuICAgIExPQURJTkc6IDcsXG4gICAgTE9BRF9FUlJPUjogOCxcbn07XG5cbmNvbnN0IEZpbGVPcmlnaW4gPSB7XG4gICAgSU5QVVQ6IDEsXG4gICAgTElNQk86IDIsXG4gICAgTE9DQUw6IDMsXG59O1xuXG5jb25zdCBnZXROb25OdW1lcmljID0gc3RyID0+IC9bXjAtOV0rLy5leGVjKHN0cik7XG5cbmNvbnN0IGdldERlY2ltYWxTZXBhcmF0b3IgPSAoKSA9PiBnZXROb25OdW1lcmljKCgxLjEpLnRvTG9jYWxlU3RyaW5nKCkpWzBdO1xuXG5jb25zdCBnZXRUaG91c2FuZHNTZXBhcmF0b3IgPSAoKSA9PiB7XG4gICAgLy8gQWRkZWQgZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHJldHVybiB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvciAoaGFwcGVuZCBvbiBuYXRpdmUgYnJvd3NlciBBbmRyb2lkIDQuNC40KVxuICAgIC8vIFdlIGNoZWNrIGFnYWluc3QgdGhlIG5vcm1hbCB0b1N0cmluZyBvdXRwdXQgYW5kIGlmIHRoZXkncmUgdGhlIHNhbWUgcmV0dXJuIGEgY29tbWEgd2hlbiBkZWNpbWFsIHNlcGFyYXRvciBpcyBhIGRvdFxuICAgIGNvbnN0IGRlY2ltYWxTZXBhcmF0b3IgPSBnZXREZWNpbWFsU2VwYXJhdG9yKCk7XG4gICAgY29uc3QgdGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvciA9ICgxMDAwLjApLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgY29uc3QgdGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvciA9ICgxMDAwLjApLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRob3VzYW5kc1N0cmluZ1dpdGhTZXBhcmF0b3IgIT09IHRob3VzYW5kc1N0cmluZ1dpdGhvdXRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGdldE5vbk51bWVyaWModGhvdXNhbmRzU3RyaW5nV2l0aFNlcGFyYXRvcilbMF07XG4gICAgfVxuICAgIHJldHVybiBkZWNpbWFsU2VwYXJhdG9yID09PSAnLicgPyAnLCcgOiAnLic7XG59O1xuXG5jb25zdCBUeXBlID0ge1xuICAgIEJPT0xFQU46ICdib29sZWFuJyxcbiAgICBJTlQ6ICdpbnQnLFxuICAgIE5VTUJFUjogJ251bWJlcicsXG4gICAgU1RSSU5HOiAnc3RyaW5nJyxcbiAgICBBUlJBWTogJ2FycmF5JyxcbiAgICBPQkpFQ1Q6ICdvYmplY3QnLFxuICAgIEZVTkNUSU9OOiAnZnVuY3Rpb24nLFxuICAgIEFDVElPTjogJ2FjdGlvbicsXG4gICAgU0VSVkVSX0FQSTogJ3NlcnZlcmFwaScsXG4gICAgUkVHRVg6ICdyZWdleCcsXG59O1xuXG4vLyBhbGwgcmVnaXN0ZXJlZCBmaWx0ZXJzXG5jb25zdCBmaWx0ZXJzID0gW107XG5cbi8vIGxvb3BzIG92ZXIgbWF0Y2hpbmcgZmlsdGVycyBhbmQgcGFzc2VzIG9wdGlvbnMgdG8gZWFjaCBmaWx0ZXIsIHJldHVybmluZyB0aGUgbWFwcGVkIHJlc3VsdHNcbmNvbnN0IGFwcGx5RmlsdGVyQ2hhaW4gPSAoa2V5LCB2YWx1ZSwgdXRpbHMpID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIGZpbHRlcnMgZm9yIHRoaXMga2V5XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRmlsdGVycyA9IGZpbHRlcnMuZmlsdGVyKGYgPT4gZi5rZXkgPT09IGtleSkubWFwKGYgPT4gZi5jYik7XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBub3dcbiAgICAgICAgaWYgKG1hdGNoaW5nRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyIHRvIGtpY2sgdGhpbmdzIG9mXG4gICAgICAgIGNvbnN0IGluaXRpYWxGaWx0ZXIgPSBtYXRjaGluZ0ZpbHRlcnMuc2hpZnQoKTtcblxuICAgICAgICAvLyBjaGFpbiBmaWx0ZXJzXG4gICAgICAgIG1hdGNoaW5nRmlsdGVyc1xuICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAvLyBsb29wIG92ZXIgcHJvbWlzZXMgcGFzc2luZyB2YWx1ZSB0byBuZXh0IHByb21pc2VcbiAgICAgICAgICAgICAgICAoY3VycmVudCwgbmV4dCkgPT4gY3VycmVudC50aGVuKHZhbHVlID0+IG5leHQodmFsdWUsIHV0aWxzKSksXG5cbiAgICAgICAgICAgICAgICAvLyBjYWxsIGluaXRpYWwgZmlsdGVyLCB3aWxsIHJldHVybiBhIHByb21pc2VcbiAgICAgICAgICAgICAgICBpbml0aWFsRmlsdGVyKHZhbHVlLCB1dGlscylcblxuICAgICAgICAgICAgICAgIC8vIGFsbCBleGVjdXRlZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4odmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSkpXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4gcmVqZWN0KGVycm9yKSk7XG4gICAgfSk7XG5cbmNvbnN0IGFwcGx5RmlsdGVycyA9IChrZXksIHZhbHVlLCB1dGlscykgPT5cbiAgICBmaWx0ZXJzLmZpbHRlcihmID0+IGYua2V5ID09PSBrZXkpLm1hcChmID0+IGYuY2IodmFsdWUsIHV0aWxzKSk7XG5cbi8vIGFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBsaXN0XG5jb25zdCBhZGRGaWx0ZXIgPSAoa2V5LCBjYikgPT4gZmlsdGVycy5wdXNoKHsga2V5LCBjYiB9KTtcblxuY29uc3QgZXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSBhZGRpdGlvbmFsT3B0aW9ucyA9PiBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG5cbmNvbnN0IGdldE9wdGlvbnMgPSAoKSA9PiAoeyAuLi5kZWZhdWx0T3B0aW9ucyB9KTtcblxuY29uc3Qgc2V0T3B0aW9ucyA9IG9wdHMgPT4ge1xuICAgIGZvcmluKG9wdHMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIGtleSBkb2VzIG5vdCBleGlzdCwgc28gdGhpcyBvcHRpb24gY2Fubm90IGJlIHNldFxuICAgICAgICBpZiAoIWRlZmF1bHRPcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzBdID0gZ2V0VmFsdWVCeVR5cGUoXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zW2tleV1bMF0sXG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9uc1trZXldWzFdXG4gICAgICAgICk7XG4gICAgfSk7XG59O1xuXG4vLyBkZWZhdWx0IG9wdGlvbnMgb24gYXBwXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyB0aGUgaWQgdG8gYWRkIHRvIHRoZSByb290IGVsZW1lbnRcbiAgICBpZDogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgIC8vIGlucHV0IGZpZWxkIG5hbWUgdG8gdXNlXG4gICAgbmFtZTogWydmaWxlcG9uZCcsIFR5cGUuU1RSSU5HXSxcblxuICAgIC8vIGRpc2FibGUgdGhlIGZpZWxkXG4gICAgZGlzYWJsZWQ6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSxcblxuICAgIC8vIGNsYXNzbmFtZSB0byBwdXQgb24gd3JhcHBlclxuICAgIGNsYXNzTmFtZTogW251bGwsIFR5cGUuU1RSSU5HXSxcblxuICAgIC8vIGlzIHRoZSBmaWVsZCByZXF1aXJlZFxuICAgIHJlcXVpcmVkOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBBbGxvdyBtZWRpYSBjYXB0dXJlIHdoZW4gdmFsdWUgaXMgc2V0XG4gICAgY2FwdHVyZU1ldGhvZDogW251bGwsIFR5cGUuU1RSSU5HXSxcbiAgICAvLyAtIFwiY2FtZXJhXCIsIFwibWljcm9waG9uZVwiIG9yIFwiY2FtY29yZGVyXCIsXG4gICAgLy8gLSBEb2VzIG5vdCB3b3JrIHdpdGggbXVsdGlwbGUgb24gYXBwbGUgZGV2aWNlc1xuICAgIC8vIC0gSWYgc2V0LCBhY2NlcHRlZEZpbGVUeXBlcyBtdXN0IGJlIG1hZGUgdG8gbWF0Y2ggd2l0aCBtZWRpYSB3aWxkY2FyZCBcImltYWdlLypcIiwgXCJhdWRpby8qXCIgb3IgXCJ2aWRlby8qXCJcblxuICAgIC8vIHN5bmMgYGFjY2VwdGVkRmlsZVR5cGVzYCBwcm9wZXJ0eSB3aXRoIGBhY2NlcHRgIGF0dHJpYnV0ZVxuICAgIGFsbG93U3luY0FjY2VwdEF0dHJpYnV0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBGZWF0dXJlIHRvZ2dsZXNcbiAgICBhbGxvd0Ryb3A6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBvZiBmaWxlc1xuICAgIGFsbG93QnJvd3NlOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgYnJvd3NpbmcgdGhlIGZpbGUgc3lzdGVtXG4gICAgYWxsb3dQYXN0ZTogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHBhc3RpbmcgZmlsZXNcbiAgICBhbGxvd011bHRpcGxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IG11bHRpcGxlIGZpbGVzIChkaXNhYmxlZCBieSBkZWZhdWx0LCBhcyBtdWx0aXBsZSBhdHRyaWJ1dGUgaXMgYWxzbyByZXF1aXJlZCBvbiBpbnB1dCB0byBhbGxvdyBtdWx0aXBsZSlcbiAgICBhbGxvd1JlcGxhY2U6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBkcm9wcGluZyBhIGZpbGUgb24gb3RoZXIgZmlsZSB0byByZXBsYWNlIGl0IChvbmx5IHdvcmtzIHdoZW4gbXVsdGlwbGUgaXMgc2V0IHRvIGZhbHNlKVxuICAgIGFsbG93UmV2ZXJ0OiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3dzIHVzZXIgdG8gcmV2ZXJ0IGZpbGUgdXBsb2FkXG4gICAgYWxsb3dSZW1vdmU6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyB1c2VyIHRvIHJlbW92ZSBhIGZpbGVcbiAgICBhbGxvd1Byb2Nlc3M6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvd3MgdXNlciB0byBwcm9jZXNzIGEgZmlsZSwgd2hlbiBzZXQgdG8gZmFsc2UsIHRoaXMgcmVtb3ZlcyB0aGUgZmlsZSB1cGxvYWQgYnV0dG9uXG4gICAgYWxsb3dSZW9yZGVyOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIEFsbG93IHJlb3JkZXJpbmcgb2YgZmlsZXNcbiAgICBhbGxvd0RpcmVjdG9yaWVzT25seTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBBbGxvdyBvbmx5IHNlbGVjdGluZyBkaXJlY3RvcmllcyB3aXRoIGJyb3dzZSAobm8gc3VwcG9ydCBmb3IgZmlsdGVyaW5nIGRuZCBhdCB0aGlzIHBvaW50KVxuXG4gICAgLy8gVHJ5IHN0b3JlIGZpbGUgaWYgYHNlcnZlcmAgbm90IHNldFxuICAgIHN0b3JlQXNGaWxlOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBSZXZlcnQgbW9kZVxuICAgIGZvcmNlUmV2ZXJ0OiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sIC8vIFNldCB0byAnZm9yY2UnIHRvIHJlcXVpcmUgdGhlIGZpbGUgdG8gYmUgcmV2ZXJ0ZWQgYmVmb3JlIHJlbW92YWxcblxuICAgIC8vIElucHV0IHJlcXVpcmVtZW50c1xuICAgIG1heEZpbGVzOiBbbnVsbCwgVHlwZS5JTlRdLCAvLyBNYXggbnVtYmVyIG9mIGZpbGVzXG4gICAgY2hlY2tWYWxpZGl0eTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGVzIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlc1xuXG4gICAgLy8gV2hlcmUgdG8gcHV0IGZpbGVcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSwgLy8gU2V0IHRvIGZhbHNlIHRvIGFsd2F5cyBhZGQgaXRlbXMgdG8gYmVnaW4gb3IgZW5kIG9mIGxpc3RcbiAgICBpdGVtSW5zZXJ0TG9jYXRpb246IFsnYmVmb3JlJywgVHlwZS5TVFJJTkddLCAvLyBEZWZhdWx0IGluZGV4IGluIGxpc3QgdG8gYWRkIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIGRyb3BwZWQgYXQgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgIGl0ZW1JbnNlcnRJbnRlcnZhbDogWzc1LCBUeXBlLklOVF0sXG5cbiAgICAvLyBEcmFnICduIERyb3AgcmVsYXRlZFxuICAgIGRyb3BPblBhZ2U6IFtmYWxzZSwgVHlwZS5CT09MRUFOXSwgLy8gQWxsb3cgZHJvcHBpbmcgb2YgZmlsZXMgYW55d2hlcmUgb24gcGFnZSAocHJldmVudHMgYnJvd3NlciBmcm9tIG9wZW5pbmcgZmlsZSBpZiBkcm9wcGVkIG91dHNpZGUgb2YgVXApXG4gICAgZHJvcE9uRWxlbWVudDogW3RydWUsIFR5cGUuQk9PTEVBTl0sIC8vIERyb3AgbmVlZHMgdG8gaGFwcGVuIG9uIGVsZW1lbnQgKHNldCB0byBmYWxzZSB0byBhbHNvIGxvYWQgZHJvcHMgb3V0c2lkZSBvZiBVcClcbiAgICBkcm9wVmFsaWRhdGlvbjogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgb3IgZGlzYWJsZSB2YWxpZGF0aW5nIGZpbGVzIG9uIGRyb3BcbiAgICBpZ25vcmVkRmlsZXM6IFtbJy5kc19zdG9yZScsICd0aHVtYnMuZGInLCAnZGVza3RvcC5pbmknXSwgVHlwZS5BUlJBWV0sXG5cbiAgICAvLyBVcGxvYWQgcmVsYXRlZFxuICAgIGluc3RhbnRVcGxvYWQ6IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBTaG91bGQgdXBsb2FkIGZpbGVzIGltbWVkaWF0ZWx5IG9uIGRyb3BcbiAgICBtYXhQYXJhbGxlbFVwbG9hZHM6IFsyLCBUeXBlLklOVF0sIC8vIE1heGltdW0gZmlsZXMgdG8gdXBsb2FkIGluIHBhcmFsbGVsXG4gICAgYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb246IFt0cnVlLCBUeXBlLkJPT0xFQU5dLCAvLyBpZiB0cnVlIHVwbG9hZHMgdGFrZSBhdCBsZWFzdCA3NTAgbXMsIHRoaXMgZW5zdXJlcyB0aGUgdXNlciBzZWVzIHRoZSB1cGxvYWQgcHJvZ3Jlc3MgZ2l2aW5nIHRydXN0IHRoZSB1cGxvYWQgYWN0dWFsbHkgaGFwcGVuZWRcblxuICAgIC8vIENodW5rc1xuICAgIGNodW5rVXBsb2FkczogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBFbmFibGUgY2h1bmtlZCB1cGxvYWRzXG4gICAgY2h1bmtGb3JjZTogW2ZhbHNlLCBUeXBlLkJPT0xFQU5dLCAvLyBGb3JjZSB1c2Ugb2YgY2h1bmsgdXBsb2FkcyBldmVuIGZvciBmaWxlcyBzbWFsbGVyIHRoYW4gY2h1bmsgc2l6ZVxuICAgIGNodW5rU2l6ZTogWzUwMDAwMDAsIFR5cGUuSU5UXSwgLy8gU2l6ZSBvZiBjaHVua3MgKDVNQiBkZWZhdWx0KVxuICAgIGNodW5rUmV0cnlEZWxheXM6IFtbNTAwLCAxMDAwLCAzMDAwXSwgVHlwZS5BUlJBWV0sIC8vIEFtb3VudCBvZiB0aW1lcyB0byByZXRyeSB1cGxvYWQgb2YgYSBjaHVuayB3aGVuIGl0IGZhaWxzXG5cbiAgICAvLyBUaGUgc2VydmVyIGFwaSBlbmQgcG9pbnRzIHRvIHVzZSBmb3IgdXBsb2FkaW5nIChzZWUgZG9jcylcbiAgICBzZXJ2ZXI6IFtudWxsLCBUeXBlLlNFUlZFUl9BUEldLFxuXG4gICAgLy8gRmlsZSBzaXplIGNhbGN1bGF0aW9ucywgY2FuIHNldCB0byAxMDI0LCB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgZGlzcGxheSwgcHJvcGVydGllcyB1c2UgZmlsZSBzaXplIGJhc2UgMTAwMFxuICAgIGZpbGVTaXplQmFzZTogWzEwMDAsIFR5cGUuSU5UXSxcblxuICAgIC8vIExhYmVscyBhbmQgc3RhdHVzIG1lc3NhZ2VzXG4gICAgbGFiZWxGaWxlU2l6ZUJ5dGVzOiBbJ2J5dGVzJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVNpemVLaWxvYnl0ZXM6IFsnS0InLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlU2l6ZU1lZ2FieXRlczogWydNQicsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVTaXplR2lnYWJ5dGVzOiBbJ0dCJywgVHlwZS5TVFJJTkddLFxuXG4gICAgbGFiZWxEZWNpbWFsU2VwYXJhdG9yOiBbZ2V0RGVjaW1hbFNlcGFyYXRvcigpLCBUeXBlLlNUUklOR10sIC8vIERlZmF1bHQgaXMgbG9jYWxlIHNlcGFyYXRvclxuICAgIGxhYmVsVGhvdXNhbmRzU2VwYXJhdG9yOiBbZ2V0VGhvdXNhbmRzU2VwYXJhdG9yKCksIFR5cGUuU1RSSU5HXSwgLy8gRGVmYXVsdCBpcyBsb2NhbGUgc2VwYXJhdG9yXG5cbiAgICBsYWJlbElkbGU6IFtcbiAgICAgICAgJ0RyYWcgJiBEcm9wIHlvdXIgZmlsZXMgb3IgPHNwYW4gY2xhc3M9XCJmaWxlcG9uZC0tbGFiZWwtYWN0aW9uXCI+QnJvd3NlPC9zcGFuPicsXG4gICAgICAgIFR5cGUuU1RSSU5HLFxuICAgIF0sXG4gICAgbGFiZWxJbnZhbGlkRmllbGQ6IFsnRmllbGQgY29udGFpbnMgaW52YWxpZCBmaWxlcycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVXYWl0aW5nRm9yU2l6ZTogWydXYWl0aW5nIGZvciBzaXplJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVNpemVOb3RBdmFpbGFibGU6IFsnU2l6ZSBub3QgYXZhaWxhYmxlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZUNvdW50U2luZ3VsYXI6IFsnZmlsZSBpbiBsaXN0JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZUNvdW50UGx1cmFsOiBbJ2ZpbGVzIGluIGxpc3QnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlTG9hZGluZzogWydMb2FkaW5nJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZUFkZGVkOiBbJ0FkZGVkJywgVHlwZS5TVFJJTkddLCAvLyBhc3Npc3RpdmUgb25seVxuICAgIGxhYmVsRmlsZUxvYWRFcnJvcjogWydFcnJvciBkdXJpbmcgbG9hZCcsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVSZW1vdmVkOiBbJ1JlbW92ZWQnLCBUeXBlLlNUUklOR10sIC8vIGFzc2lzdGl2ZSBvbmx5XG4gICAgbGFiZWxGaWxlUmVtb3ZlRXJyb3I6IFsnRXJyb3IgZHVyaW5nIHJlbW92ZScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nOiBbJ1VwbG9hZGluZycsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEZpbGVQcm9jZXNzaW5nQ29tcGxldGU6IFsnVXBsb2FkIGNvbXBsZXRlJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsRmlsZVByb2Nlc3NpbmdBYm9ydGVkOiBbJ1VwbG9hZCBjYW5jZWxsZWQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ0Vycm9yOiBbJ0Vycm9yIGR1cmluZyB1cGxvYWQnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxGaWxlUHJvY2Vzc2luZ1JldmVydEVycm9yOiBbJ0Vycm9yIGR1cmluZyByZXZlcnQnLCBUeXBlLlNUUklOR10sXG5cbiAgICBsYWJlbFRhcFRvQ2FuY2VsOiBbJ3RhcCB0byBjYW5jZWwnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxUYXBUb1JldHJ5OiBbJ3RhcCB0byByZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbFRhcFRvVW5kbzogWyd0YXAgdG8gdW5kbycsIFR5cGUuU1RSSU5HXSxcblxuICAgIGxhYmVsQnV0dG9uUmVtb3ZlSXRlbTogWydSZW1vdmUnLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25BYm9ydEl0ZW1Mb2FkOiBbJ0Fib3J0JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uUmV0cnlJdGVtTG9hZDogWydSZXRyeScsIFR5cGUuU1RSSU5HXSxcbiAgICBsYWJlbEJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IFsnQ2FuY2VsJywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uVW5kb0l0ZW1Qcm9jZXNzaW5nOiBbJ1VuZG8nLCBUeXBlLlNUUklOR10sXG4gICAgbGFiZWxCdXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiBbJ1JldHJ5JywgVHlwZS5TVFJJTkddLFxuICAgIGxhYmVsQnV0dG9uUHJvY2Vzc0l0ZW06IFsnVXBsb2FkJywgVHlwZS5TVFJJTkddLFxuXG4gICAgLy8gbWFrZSBzdXJlIHdpZHRoIGFuZCBoZWlnaHQgcGx1cyB2aWV3cG94IGFyZSBldmVuIG51bWJlcnMgc28gaWNvbnMgYXJlIG5pY2VseSBjZW50ZXJlZFxuICAgIGljb25SZW1vdmU6IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTExLjU4NiAxM2wtMi4yOTMgMi4yOTNhMSAxIDAgMCAwIDEuNDE0IDEuNDE0TDEzIDE0LjQxNGwyLjI5MyAyLjI5M2ExIDEgMCAwIDAgMS40MTQtMS40MTRMMTQuNDE0IDEzbDIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNC0xLjQxNEwxMyAxMS41ODZsLTIuMjkzLTIuMjkzYTEgMSAwIDAgMC0xLjQxNCAxLjQxNEwxMS41ODYgMTN6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cIm5vbnplcm9cIi8+PC9zdmc+JyxcbiAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgXSxcbiAgICBpY29uUHJvY2VzczogW1xuICAgICAgICAnPHN2ZyB3aWR0aD1cIjI2XCIgaGVpZ2h0PVwiMjZcIiB2aWV3Qm94PVwiMCAwIDI2IDI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMTQgMTAuNDE0djMuNTg1YTEgMSAwIDAgMS0yIDB2LTMuNTg1bC0xLjI5MyAxLjI5M2ExIDEgMCAwIDEtMS40MTQtMS40MTVsMy0zYTEgMSAwIDAgMSAxLjQxNCAwbDMgM2ExIDEgMCAwIDEtMS40MTQgMS40MTVMMTQgMTAuNDE0ek05IDE4YTEgMSAwIDAgMSAwLTJoOGExIDEgMCAwIDEgMCAySDl6XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgXSxcbiAgICBpY29uUmV0cnk6IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTEwLjgxIDkuMTg1bC0uMDM4LjAyQTQuOTk3IDQuOTk3IDAgMCAwIDggMTMuNjgzYTUgNSAwIDAgMCA1IDUgNSA1IDAgMCAwIDUtNSAxIDEgMCAwIDEgMiAwQTcgNyAwIDEgMSA5LjcyMiA3LjQ5NmwtLjg0Mi0uMjFhLjk5OS45OTkgMCAxIDEgLjQ4NC0xLjk0bDMuMjMuODA2Yy41MzUuMTMzLjg2LjY3NS43MyAxLjIxbC0uODA0IDMuMjMzYS45OTcuOTk3IDAgMCAxLTEuMjEuNzMuOTk3Ljk5NyAwIDAgMS0uNzMtMS4yMWwuMjMtLjkyOHYtLjAwMnpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICBUeXBlLlNUUklORyxcbiAgICBdLFxuICAgIGljb25VbmRvOiBbXG4gICAgICAgICc8c3ZnIHdpZHRoPVwiMjZcIiBoZWlnaHQ9XCIyNlwiIHZpZXdCb3g9XCIwIDAgMjYgMjZcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk05LjE4NSAxMC44MWwuMDItLjAzOEE0Ljk5NyA0Ljk5NyAwIDAgMSAxMy42ODMgOGE1IDUgMCAwIDEgNSA1IDUgNSAwIDAgMS01IDUgMSAxIDAgMCAwIDAgMkE3IDcgMCAxIDAgNy40OTYgOS43MjJsLS4yMS0uODQyYS45OTkuOTk5IDAgMSAwLTEuOTQuNDg0bC44MDYgMy4yM2MuMTMzLjUzNS42NzUuODYgMS4yMS43M2wzLjIzMy0uODAzYS45OTcuOTk3IDAgMCAwIC43My0xLjIxLjk5Ny45OTcgMCAwIDAtMS4yMS0uNzNsLS45MjguMjMtLjAwMi0uMDAxelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBmaWxsLXJ1bGU9XCJub256ZXJvXCIvPjwvc3ZnPicsXG4gICAgICAgIFR5cGUuU1RSSU5HLFxuICAgIF0sXG4gICAgaWNvbkRvbmU6IFtcbiAgICAgICAgJzxzdmcgd2lkdGg9XCIyNlwiIGhlaWdodD1cIjI2XCIgdmlld0JveD1cIjAgMCAyNiAyNlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTE4LjI5MyA5LjI5M2ExIDEgMCAwIDEgMS40MTQgMS40MTRsLTcuMDAyIDdhMSAxIDAgMCAxLTEuNDE0IDBsLTMuOTk4LTRhMSAxIDAgMSAxIDEuNDE0LTEuNDE0TDEyIDE1LjU4Nmw2LjI5NC02LjI5M3pcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgZmlsbC1ydWxlPVwibm9uemVyb1wiLz48L3N2Zz4nLFxuICAgICAgICBUeXBlLlNUUklORyxcbiAgICBdLFxuXG4gICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICBvbmluaXQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbndhcm5pbmc6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmVycm9yOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hY3RpdmF0ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmluaXRmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25hZGRmaWxlc3RhcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbmFkZGZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9uYWRkZmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVzdGFydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVwcm9ncmVzczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVhYm9ydDogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucHJvY2Vzc2ZpbGVyZXZlcnQ6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByb2Nlc3NmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb25wcm9jZXNzZmlsZXM6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnJlbW92ZWZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBvbnByZXBhcmVmaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgb251cGRhdGVmaWxlczogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIG9ucmVvcmRlcmZpbGVzOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG5cbiAgICAvLyBob29rc1xuICAgIGJlZm9yZURyb3BGaWxlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgYmVmb3JlQWRkRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuICAgIGJlZm9yZVJlbW92ZUZpbGU6IFtudWxsLCBUeXBlLkZVTkNUSU9OXSxcbiAgICBiZWZvcmVQcmVwYXJlRmlsZTogW251bGwsIFR5cGUuRlVOQ1RJT05dLFxuXG4gICAgLy8gc3R5bGVzXG4gICAgc3R5bGVQYW5lbExheW91dDogW251bGwsIFR5cGUuU1RSSU5HXSwgLy8gbnVsbCAnaW50ZWdyYXRlZCcsICdjb21wYWN0JywgJ2NpcmNsZSdcbiAgICBzdHlsZVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sIC8vIG51bGwgb3IgJzM6Micgb3IgMVxuICAgIHN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW86IFtudWxsLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVCdXR0b25SZW1vdmVJdGVtUG9zaXRpb246IFsnbGVmdCcsIFR5cGUuU1RSSU5HXSxcbiAgICBzdHlsZUJ1dHRvblByb2Nlc3NJdGVtUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVMb2FkSW5kaWNhdG9yUG9zaXRpb246IFsncmlnaHQnLCBUeXBlLlNUUklOR10sXG4gICAgc3R5bGVQcm9ncmVzc0luZGljYXRvclBvc2l0aW9uOiBbJ3JpZ2h0JywgVHlwZS5TVFJJTkddLFxuICAgIHN0eWxlQnV0dG9uUmVtb3ZlSXRlbUFsaWduOiBbZmFsc2UsIFR5cGUuQk9PTEVBTl0sXG5cbiAgICAvLyBjdXN0b20gaW5pdGlhbCBmaWxlcyBhcnJheVxuICAgIGZpbGVzOiBbW10sIFR5cGUuQVJSQVldLFxuXG4gICAgLy8gc2hvdyBzdXBwb3J0IGJ5IGRpc3BsYXlpbmcgY3JlZGl0c1xuICAgIGNyZWRpdHM6IFtbJ2h0dHBzOi8vcHFpbmEubmwvJywgJ1Bvd2VyZWQgYnkgUFFJTkEnXSwgVHlwZS5BUlJBWV0sXG59O1xuXG5jb25zdCBnZXRJdGVtQnlRdWVyeSA9IChpdGVtcywgcXVlcnkpID0+IHtcbiAgICAvLyBqdXN0IHJldHVybiBmaXJzdCBpbmRleFxuICAgIGlmIChpc0VtcHR5KHF1ZXJ5KSkge1xuICAgICAgICByZXR1cm4gaXRlbXNbMF0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvLyBxdWVyeSBpcyBpbmRleFxuICAgIGlmIChpc0ludChxdWVyeSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zW3F1ZXJ5XSB8fCBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIHF1ZXJ5IGlzIGl0ZW0sIGdldCB0aGUgaWRcbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LmlkO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZSBxdWVyeSBpcyBhIHN0cmluZyBhbmQgcmV0dXJuIGl0ZW0gYnkgaWRcbiAgICByZXR1cm4gaXRlbXMuZmluZChpdGVtID0+IGl0ZW0uaWQgPT09IHF1ZXJ5KSB8fCBudWxsO1xufTtcblxuY29uc3QgZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyA9IGFzcGVjdFJhdGlvID0+IHtcbiAgICBpZiAoaXNFbXB0eShhc3BlY3RSYXRpbykpIHtcbiAgICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAoLzovLnRlc3QoYXNwZWN0UmF0aW8pKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzWzFdIC8gcGFydHNbMF07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KGFzcGVjdFJhdGlvKTtcbn07XG5cbmNvbnN0IGdldEFjdGl2ZUl0ZW1zID0gaXRlbXMgPT4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gIWl0ZW0uYXJjaGl2ZWQpO1xuXG5jb25zdCBTdGF0dXMgPSB7XG4gICAgRU1QVFk6IDAsXG4gICAgSURMRTogMSwgLy8gd2FpdGluZ1xuICAgIEVSUk9SOiAyLCAvLyBhIGZpbGUgaXMgaW4gZXJyb3Igc3RhdGVcbiAgICBCVVNZOiAzLCAvLyBidXN5IHByb2Nlc3Npbmcgb3IgbG9hZGluZ1xuICAgIFJFQURZOiA0LCAvLyBhbGwgZmlsZXMgdXBsb2FkZWRcbn07XG5cbmxldCByZXMgPSBudWxsO1xuY29uc3QgY2FuVXBkYXRlRmlsZUlucHV0ID0gKCkgPT4ge1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKTtcbiAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQobmV3IEZpbGUoWydoZWxsbyB3b3JsZCddLCAnVGhpc19Xb3Jrcy50eHQnKSk7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnZmlsZScpO1xuICAgICAgICAgICAgZWwuZmlsZXMgPSBkYXRhVHJhbnNmZXIuZmlsZXM7XG4gICAgICAgICAgICByZXMgPSBlbC5maWxlcy5sZW5ndGggPT09IDE7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmNvbnN0IElURU1fRVJST1IgPSBbXG4gICAgSXRlbVN0YXR1cy5MT0FEX0VSUk9SLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUixcbiAgICBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SLFxuXTtcbmNvbnN0IElURU1fQlVTWSA9IFtcbiAgICBJdGVtU3RhdHVzLkxPQURJTkcsXG4gICAgSXRlbVN0YXR1cy5QUk9DRVNTSU5HLFxuICAgIEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQsXG4gICAgSXRlbVN0YXR1cy5JTklULFxuXTtcbmNvbnN0IElURU1fUkVBRFkgPSBbSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFXTtcblxuY29uc3QgaXNJdGVtSW5FcnJvclN0YXRlID0gaXRlbSA9PiBJVEVNX0VSUk9SLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcbmNvbnN0IGlzSXRlbUluQnVzeVN0YXRlID0gaXRlbSA9PiBJVEVNX0JVU1kuaW5jbHVkZXMoaXRlbS5zdGF0dXMpO1xuY29uc3QgaXNJdGVtSW5SZWFkeVN0YXRlID0gaXRlbSA9PiBJVEVNX1JFQURZLmluY2x1ZGVzKGl0ZW0uc3RhdHVzKTtcblxuY29uc3QgaXNBc3luYyA9IHN0YXRlID0+XG4gICAgaXNPYmplY3Qoc3RhdGUub3B0aW9ucy5zZXJ2ZXIpICYmXG4gICAgKGlzT2JqZWN0KHN0YXRlLm9wdGlvbnMuc2VydmVyLnByb2Nlc3MpIHx8IGlzRnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIucHJvY2VzcykpO1xuXG5jb25zdCBxdWVyaWVzID0gc3RhdGUgPT4gKHtcbiAgICBHRVRfU1RBVFVTOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgIGNvbnN0IHsgRU1QVFksIEVSUk9SLCBCVVNZLCBJRExFLCBSRUFEWSB9ID0gU3RhdHVzO1xuXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWTtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JbkVycm9yU3RhdGUpKSByZXR1cm4gRVJST1I7XG5cbiAgICAgICAgaWYgKGl0ZW1zLnNvbWUoaXNJdGVtSW5CdXN5U3RhdGUpKSByZXR1cm4gQlVTWTtcblxuICAgICAgICBpZiAoaXRlbXMuc29tZShpc0l0ZW1JblJlYWR5U3RhdGUpKSByZXR1cm4gUkVBRFk7XG5cbiAgICAgICAgcmV0dXJuIElETEU7XG4gICAgfSxcblxuICAgIEdFVF9JVEVNOiBxdWVyeSA9PiBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpLFxuXG4gICAgR0VUX0FDVElWRV9JVEVNOiBxdWVyeSA9PiBnZXRJdGVtQnlRdWVyeShnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcyksIHF1ZXJ5KSxcblxuICAgIEdFVF9BQ1RJVkVfSVRFTVM6ICgpID0+IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKSxcblxuICAgIEdFVF9JVEVNUzogKCkgPT4gc3RhdGUuaXRlbXMsXG5cbiAgICBHRVRfSVRFTV9OQU1FOiBxdWVyeSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZW5hbWUgOiBudWxsO1xuICAgIH0sXG5cbiAgICBHRVRfSVRFTV9TSVpFOiBxdWVyeSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZmlsZVNpemUgOiBudWxsO1xuICAgIH0sXG5cbiAgICBHRVRfU1RZTEVTOiAoKSA9PlxuICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZS5vcHRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4gL15zdHlsZS8udGVzdChrZXkpKVxuICAgICAgICAgICAgLm1hcChvcHRpb24gPT4gKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0YXRlLm9wdGlvbnNbb3B0aW9uXSxcbiAgICAgICAgICAgIH0pKSxcblxuICAgIEdFVF9QQU5FTF9BU1BFQ1RfUkFUSU86ICgpID0+IHtcbiAgICAgICAgY29uc3QgaXNTaGFwZUNpcmNsZSA9IC9jaXJjbGUvLnRlc3Qoc3RhdGUub3B0aW9ucy5zdHlsZVBhbmVsTGF5b3V0KTtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpc1NoYXBlQ2lyY2xlXG4gICAgICAgICAgICA/IDFcbiAgICAgICAgICAgIDogZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyhzdGF0ZS5vcHRpb25zLnN0eWxlUGFuZWxBc3BlY3RSYXRpbyk7XG4gICAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICB9LFxuXG4gICAgR0VUX0lURU1fUEFORUxfQVNQRUNUX1JBVElPOiAoKSA9PiBzdGF0ZS5vcHRpb25zLnN0eWxlSXRlbVBhbmVsQXNwZWN0UmF0aW8sXG5cbiAgICBHRVRfSVRFTVNfQllfU1RBVFVTOiBzdGF0dXMgPT5cbiAgICAgICAgZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZpbHRlcihpdGVtID0+IGl0ZW0uc3RhdHVzID09PSBzdGF0dXMpLFxuXG4gICAgR0VUX1RPVEFMX0lURU1TOiAoKSA9PiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykubGVuZ3RoLFxuXG4gICAgU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUOiAoKSA9PlxuICAgICAgICBzdGF0ZS5vcHRpb25zLnN0b3JlQXNGaWxlICYmIGNhblVwZGF0ZUZpbGVJbnB1dCgpICYmICFpc0FzeW5jKHN0YXRlKSxcblxuICAgIElTX0FTWU5DOiAoKSA9PiBpc0FzeW5jKHN0YXRlKSxcblxuICAgIEdFVF9GSUxFX1NJWkVfTEFCRUxTOiBxdWVyeSA9PiAoe1xuICAgICAgICBsYWJlbEJ5dGVzOiBxdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9CWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxLaWxvYnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0tJTE9CWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxNZWdhYnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX01FR0FCWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWxHaWdhYnl0ZXM6IHF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9TSVpFX0dJR0FCWVRFUycpIHx8IHVuZGVmaW5lZCxcbiAgICB9KSxcbn0pO1xuXG5jb25zdCBoYXNSb29tRm9ySXRlbSA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBjb3VudCA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKS5sZW5ndGg7XG5cbiAgICAvLyBpZiBjYW5ub3QgaGF2ZSBtdWx0aXBsZSBpdGVtcywgdG8gYWRkIG9uZSBpdGVtIGl0IHNob3VsZCBjdXJyZW50bHkgbm90IGNvbnRhaW4gaXRlbXNcbiAgICBpZiAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gY291bnQgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gaWYgYWxsb3dzIG11bHRpcGxlIGl0ZW1zLCB3ZSBjaGVjayBpZiBhIG1heCBpdGVtIGNvdW50IGhhcyBiZWVuIHNldCwgaWYgbm90LCB0aGVyZSdzIG5vIGxpbWl0XG4gICAgY29uc3QgbWF4RmlsZUNvdW50ID0gc3RhdGUub3B0aW9ucy5tYXhGaWxlcztcbiAgICBpZiAobWF4RmlsZUNvdW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHdlIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNvdW50IGlzIHNtYWxsZXIgdGhhbiB0aGUgbWF4IGNvdW50LCBpZiBzbywgYW5vdGhlciBmaWxlIGNhbiBzdGlsbCBiZSBhZGRlZFxuICAgIGlmIChjb3VudCA8IG1heEZpbGVDb3VudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHJvb20gZm9yIGFub3RoZXIgZmlsZVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGxpbWl0ID0gKHZhbHVlLCBtaW4sIG1heCkgPT4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG5cbmNvbnN0IGFycmF5SW5zZXJ0ID0gKGFyciwgaW5kZXgsIGl0ZW0pID0+IGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuXG5jb25zdCBpbnNlcnRJdGVtID0gKGl0ZW1zLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgIGlmIChpc0VtcHR5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGlmIGluZGV4IGlzIHVuZGVmaW5lZCwgYXBwZW5kXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLy8gbGltaXQgdGhlIGluZGV4IHRvIHRoZSBzaXplIG9mIHRoZSBpdGVtcyBhcnJheVxuICAgIGluZGV4ID0gbGltaXQoaW5kZXgsIDAsIGl0ZW1zLmxlbmd0aCk7XG5cbiAgICAvLyBhZGQgaXRlbSB0byBhcnJheVxuICAgIGFycmF5SW5zZXJ0KGl0ZW1zLCBpbmRleCwgaXRlbSk7XG5cbiAgICAvLyBleHBvc2VcbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbmNvbnN0IGlzQmFzZTY0RGF0YVVSSSA9IHN0ciA9PlxuICAgIC9eXFxzKmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyg7W2Etei1dKz1bYS16MC05LV0rKT8pPyg7YmFzZTY0KT8sKFthLXowLTkhJCYnLCgpKis7PVxcLS5ffjpAXFwvPyVcXHNdKilcXHMqJC9pLnRlc3QoXG4gICAgICAgIHN0clxuICAgICk7XG5cbmNvbnN0IGdldEZpbGVuYW1lRnJvbVVSTCA9IHVybCA9PlxuICAgIGAke3VybH1gXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5wb3AoKVxuICAgICAgICAuc3BsaXQoJz8nKVxuICAgICAgICAuc2hpZnQoKTtcblxuY29uc3QgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lID0gbmFtZSA9PiBuYW1lLnNwbGl0KCcuJykucG9wKCk7XG5cbmNvbnN0IGd1ZXNzdGltYXRlRXh0ZW5zaW9uID0gdHlwZSA9PiB7XG4gICAgLy8gaWYgbm8gZXh0ZW5zaW9uIHN1cHBsaWVkLCBleGl0IGhlcmVcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBnZXQgc3VidHlwZVxuICAgIGNvbnN0IHN1YnR5cGUgPSB0eXBlLnNwbGl0KCcvJykucG9wKCk7XG5cbiAgICAvLyBpcyBzdmcgc3VidHlwZVxuICAgIGlmICgvc3ZnLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnc3ZnJztcbiAgICB9XG5cbiAgICBpZiAoL3ppcHxjb21wcmVzc2VkLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAnemlwJztcbiAgICB9XG5cbiAgICBpZiAoL3BsYWluLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIHJldHVybiAndHh0JztcbiAgICB9XG5cbiAgICBpZiAoL21zd29yZC8udGVzdChzdWJ0eXBlKSkge1xuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgdmFsaWQgc3VidHlwZVxuICAgIGlmICgvW2Etel0rLy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgICAgIC8vIGFsd2F5cyB1c2UganBnIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3VidHlwZSA9PT0gJ2pwZWcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2pwZyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gc3VidHlwZVxuICAgICAgICByZXR1cm4gc3VidHlwZTtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG59O1xuXG5jb25zdCBsZWZ0UGFkID0gKHZhbHVlLCBwYWRkaW5nID0gJycpID0+IChwYWRkaW5nICsgdmFsdWUpLnNsaWNlKC1wYWRkaW5nLmxlbmd0aCk7XG5cbmNvbnN0IGdldERhdGVTdHJpbmcgPSAoZGF0ZSA9IG5ldyBEYXRlKCkpID0+XG4gICAgYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS0ke2xlZnRQYWQoZGF0ZS5nZXRNb250aCgpICsgMSwgJzAwJyl9LSR7bGVmdFBhZChcbiAgICAgICAgZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICcwMCdcbiAgICApfV8ke2xlZnRQYWQoZGF0ZS5nZXRIb3VycygpLCAnMDAnKX0tJHtsZWZ0UGFkKGRhdGUuZ2V0TWludXRlcygpLCAnMDAnKX0tJHtsZWZ0UGFkKFxuICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgJzAwJ1xuICAgICl9YDtcblxuY29uc3QgZ2V0RmlsZUZyb21CbG9iID0gKGJsb2IsIGZpbGVuYW1lLCB0eXBlID0gbnVsbCwgZXh0ZW5zaW9uID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPVxuICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gYmxvYi5zbGljZSgwLCBibG9iLnNpemUsIHR5cGUpXG4gICAgICAgICAgICA6IGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xuICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBjb3B5IHJlbGF0aXZlIHBhdGhcbiAgICBpZiAoYmxvYi5fcmVsYXRpdmVQYXRoKSBmaWxlLl9yZWxhdGl2ZVBhdGggPSBibG9iLl9yZWxhdGl2ZVBhdGg7XG5cbiAgICAvLyBpZiBibG9iIGhhcyBuYW1lIHByb3BlcnR5LCB1c2UgYXMgZmlsZW5hbWUgaWYgbm8gZmlsZW5hbWUgc3VwcGxpZWRcbiAgICBpZiAoIWlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgICBmaWxlbmFtZSA9IGdldERhdGVTdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvLyBpZiBmaWxlbmFtZSBzdXBwbGllZCBidXQgbm8gZXh0ZW5zaW9uIGFuZCBmaWxlbmFtZSBoYXMgZXh0ZW5zaW9uXG4gICAgaWYgKGZpbGVuYW1lICYmIGV4dGVuc2lvbiA9PT0gbnVsbCAmJiBnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUoZmlsZW5hbWUpKSB7XG4gICAgICAgIGZpbGUubmFtZSA9IGZpbGVuYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbiB8fCBndWVzc3RpbWF0ZUV4dGVuc2lvbihmaWxlLnR5cGUpO1xuICAgICAgICBmaWxlLm5hbWUgPSBmaWxlbmFtZSArIChleHRlbnNpb24gPyAnLicgKyBleHRlbnNpb24gOiAnJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG59O1xuXG5jb25zdCBnZXRCbG9iQnVpbGRlciA9ICgpID0+IHtcbiAgICByZXR1cm4gKHdpbmRvdy5CbG9iQnVpbGRlciA9XG4gICAgICAgIHdpbmRvdy5CbG9iQnVpbGRlciB8fFxuICAgICAgICB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHxcbiAgICAgICAgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8XG4gICAgICAgIHdpbmRvdy5NU0Jsb2JCdWlsZGVyKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUJsb2IgPSAoYXJyYXlCdWZmZXIsIG1pbWVUeXBlKSA9PiB7XG4gICAgY29uc3QgQkIgPSBnZXRCbG9iQnVpbGRlcigpO1xuXG4gICAgaWYgKEJCKSB7XG4gICAgICAgIGNvbnN0IGJiID0gbmV3IEJCKCk7XG4gICAgICAgIGJiLmFwcGVuZChhcnJheUJ1ZmZlcik7XG4gICAgICAgIHJldHVybiBiYi5nZXRCbG9iKG1pbWVUeXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW2FycmF5QnVmZmVyXSwge1xuICAgICAgICB0eXBlOiBtaW1lVHlwZSxcbiAgICB9KTtcbn07XG5cbmNvbnN0IGdldEJsb2JGcm9tQnl0ZVN0cmluZ1dpdGhNaW1lVHlwZSA9IChieXRlU3RyaW5nLCBtaW1lVHlwZSkgPT4ge1xuICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgICBjb25zdCBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQmxvYihhYiwgbWltZVR5cGUpO1xufTtcblxuY29uc3QgZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSSA9IGRhdGFVUkkgPT4ge1xuICAgIHJldHVybiAoL15kYXRhOiguKyk7Ly5leGVjKGRhdGFVUkkpIHx8IFtdKVsxXSB8fCBudWxsO1xufTtcblxuY29uc3QgZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJID0gZGF0YVVSSSA9PiB7XG4gICAgLy8gZ2V0IGRhdGEgcGFydCBvZiBzdHJpbmcgKHJlbW92ZSBkYXRhOmltYWdlL2pwZWcuLi4sKVxuICAgIGNvbnN0IGRhdGEgPSBkYXRhVVJJLnNwbGl0KCcsJylbMV07XG5cbiAgICAvLyByZW1vdmUgYW55IHdoaXRlc3BhY2UgYXMgdGhhdCBjYXVzZXMgSW52YWxpZENoYXJhY3RlckVycm9yIGluIElFXG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvXFxzL2csICcnKTtcbn07XG5cbmNvbnN0IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSSA9IGRhdGFVUkkgPT4ge1xuICAgIHJldHVybiBhdG9iKGdldEJhc2U2NERhdGFGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSk7XG59O1xuXG5jb25zdCBnZXRCbG9iRnJvbUJhc2U2NERhdGFVUkkgPSBkYXRhVVJJID0+IHtcbiAgICBjb25zdCBtaW1lVHlwZSA9IGdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkoZGF0YVVSSSk7XG4gICAgY29uc3QgYnl0ZVN0cmluZyA9IGdldEJ5dGVTdHJpbmdGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKTtcblxuICAgIHJldHVybiBnZXRCbG9iRnJvbUJ5dGVTdHJpbmdXaXRoTWltZVR5cGUoYnl0ZVN0cmluZywgbWltZVR5cGUpO1xufTtcblxuY29uc3QgZ2V0RmlsZUZyb21CYXNlNjREYXRhVVJJID0gKGRhdGFVUkksIGZpbGVuYW1lLCBleHRlbnNpb24pID0+IHtcbiAgICByZXR1cm4gZ2V0RmlsZUZyb21CbG9iKGdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSShkYXRhVVJJKSwgZmlsZW5hbWUsIG51bGwsIGV4dGVuc2lvbik7XG59O1xuXG5jb25zdCBnZXRGaWxlTmFtZUZyb21IZWFkZXIgPSBoZWFkZXIgPT4ge1xuICAgIC8vIHRlc3QgaWYgaXMgY29udGVudCBkaXNwb3NpdGlvbiBoZWFkZXIsIGlmIG5vdCBleGl0XG4gICAgaWYgKCEvXmNvbnRlbnQtZGlzcG9zaXRpb246L2kudGVzdChoZWFkZXIpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGdldCBmaWxlbmFtZSBwYXJ0c1xuICAgIGNvbnN0IG1hdGNoZXMgPSBoZWFkZXJcbiAgICAgICAgLnNwbGl0KC9maWxlbmFtZT18ZmlsZW5hbWVcXCo9LisnJy8pXG4gICAgICAgIC5zcGxpY2UoMSlcbiAgICAgICAgLm1hcChuYW1lID0+IG5hbWUudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbO1wiJ117MCwyfSQvZywgJycpKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZS5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoID8gZGVjb2RlVVJJKG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSkgOiBudWxsO1xufTtcblxuY29uc3QgZ2V0RmlsZVNpemVGcm9tSGVhZGVyID0gaGVhZGVyID0+IHtcbiAgICBpZiAoL2NvbnRlbnQtbGVuZ3RoOi9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICBjb25zdCBzaXplID0gaGVhZGVyLm1hdGNoKC9bMC05XSsvKVswXTtcbiAgICAgICAgcmV0dXJuIHNpemUgPyBwYXJzZUludChzaXplLCAxMCkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyID0gaGVhZGVyID0+IHtcbiAgICBpZiAoL3gtY29udGVudC10cmFuc2Zlci1pZDovaS50ZXN0KGhlYWRlcikpIHtcbiAgICAgICAgY29uc3QgaWQgPSAoaGVhZGVyLnNwbGl0KCc6JylbMV0gfHwgJycpLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGlkIHx8IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyA9IGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgc2l6ZTogbnVsbCxcbiAgICB9O1xuXG4gICAgY29uc3Qgcm93cyA9IGhlYWRlcnMuc3BsaXQoJ1xcbicpO1xuICAgIGZvciAobGV0IGhlYWRlciBvZiByb3dzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRGaWxlTmFtZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGluZm8ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRGaWxlU2l6ZUZyb21IZWFkZXIoaGVhZGVyKTtcbiAgICAgICAgaWYgKHNpemUpIHtcbiAgICAgICAgICAgIGluZm8uc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGdldFRyYW5mc2VySWRGcm9tSGVhZGVyKGhlYWRlcik7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGluZm8uc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbn07XG5cbmNvbnN0IGNyZWF0ZUZpbGVMb2FkZXIgPSBmZXRjaEZuID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICBzaXplOiBudWxsLFxuICAgICAgICB0aW1lc3RhbXA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCBnZXRQcm9ncmVzcyA9ICgpID0+IHN0YXRlLnByb2dyZXNzO1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVxdWVzdCAmJiBzdGF0ZS5yZXF1ZXN0LmFib3J0KSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZCBzb3VyY2VcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBnZXQgcXVpY2sgcmVmZXJlbmNlXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcblxuICAgICAgICBhcGkuZmlyZSgnaW5pdCcsIHNvdXJjZSk7XG5cbiAgICAgICAgLy8gTG9hZCBGaWxlc1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgYXBpLmZpcmUoJ2xvYWQnLCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgIC8vIExvYWQgYmxvYnMsIHNldCBkZWZhdWx0IG5hbWUgdG8gY3VycmVudCBkYXRlXG4gICAgICAgICAgICBhcGkuZmlyZSgnbG9hZCcsIGdldEZpbGVGcm9tQmxvYihzb3VyY2UsIHNvdXJjZS5uYW1lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIExvYWQgYmFzZSA2NCwgc2V0IGRlZmF1bHQgbmFtZSB0byBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgZ2V0RmlsZUZyb21CYXNlNjREYXRhVVJJKHNvdXJjZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVhbCBhcyBpZiBpcyBleHRlcm5hbCBVUkwsIGxldCdzIGxvYWQgaXQhXG4gICAgICAgICAgICBsb2FkVVJMKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9hZHMgYSB1cmxcbiAgICBjb25zdCBsb2FkVVJMID0gdXJsID0+IHtcbiAgICAgICAgLy8gaXMgcmVtb3RlIHVybCBhbmQgbm8gZmV0Y2ggbWV0aG9kIHN1cHBsaWVkXG4gICAgICAgIGlmICghZmV0Y2hGbikge1xuICAgICAgICAgICAgYXBpLmZpcmUoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgYm9keTogXCJDYW4ndCBsb2FkIFVSTFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IDQwMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBsb2FkIGZpbGVcbiAgICAgICAgc3RhdGUucmVxdWVzdCA9IGZldGNoRm4oXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgICAgICAgICBzdGF0ZS5jb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyB0dXJuIGJsb2IgcmVzcG9uc2UgaW50byBhIGZpbGVcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZ2V0RmlsZUZyb21CbG9iKHJlc3BvbnNlLCByZXNwb25zZS5uYW1lIHx8IGdldEZpbGVuYW1lRnJvbVVSTCh1cmwpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcGkuZmlyZShcbiAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgYmxvYiwgd2UgZ28gd2l0aCBibG9iLCBpZiBubyByZXNwb25zZSwgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgaW5zdGFuY2VvZiBCbG9iID8gcmVzcG9uc2UgOiByZXNwb25zZSA/IHJlc3BvbnNlLmJvZHkgOiBudWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoXG4gICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGNvbXB1dGFibGUsIGN1cnJlbnQsIHRvdGFsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdGVkIHNvbWUgbWV0YSBkYXRhIGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAodG90YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc2l6ZSA9IHRvdGFsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgIHN0YXRlLmR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXRlLnRpbWVzdGFtcDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGNvbXB1dGUgcHJvZ3Jlc3MsIHdlJ3JlIG5vdCBnb2luZyB0byBmaXJlIHByb2dyZXNzIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICghY29tcHV0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgcGVyY2VudGFnZVxuICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gY3VycmVudCAvIHRvdGFsO1xuXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ3Byb2dyZXNzJywgc3RhdGUucHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnYWJvcnQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZWluZm8gPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnID8gcmVzcG9uc2UgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhcGkuZmlyZSgnbWV0YScsIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3RhdGUuc2l6ZSB8fCBmaWxlaW5mby5zaXplLFxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZWluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBmaWxlaW5mby5zb3VyY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgLi4ub24oKSxcbiAgICAgICAgc2V0U291cmNlOiBzb3VyY2UgPT4gKHN0YXRlLnNvdXJjZSA9IHNvdXJjZSksXG4gICAgICAgIGdldFByb2dyZXNzLCAvLyBmaWxlIGxvYWQgcHJvZ3Jlc3NcbiAgICAgICAgYWJvcnQsIC8vIGFib3J0IGZpbGUgbG9hZFxuICAgICAgICBsb2FkLCAvLyBzdGFydCBsb2FkXG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBpc0dldCA9IG1ldGhvZCA9PiAvR0VUfEhFQUQvLnRlc3QobWV0aG9kKTtcblxuY29uc3Qgc2VuZFJlcXVlc3QgPSAoZGF0YSwgdXJsLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICBvbmhlYWRlcnM6ICgpID0+IHt9LFxuICAgICAgICBvbnByb2dyZXNzOiAoKSA9PiB7fSxcbiAgICAgICAgb25sb2FkOiAoKSA9PiB7fSxcbiAgICAgICAgb250aW1lb3V0OiAoKSA9PiB7fSxcbiAgICAgICAgb25lcnJvcjogKCkgPT4ge30sXG4gICAgICAgIG9uYWJvcnQ6ICgpID0+IHt9LFxuICAgICAgICBhYm9ydDogKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gdGltZW91dCBpZGVudGlmaWVyLCBvbmx5IHVzZWQgd2hlbiB0aW1lb3V0IGlzIGRlZmluZWRcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgIGxldCBoZWFkZXJzUmVjZWl2ZWQgPSBmYWxzZTtcblxuICAgIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIC8vIGVuY29kZSB1cmxcbiAgICB1cmwgPSBlbmNvZGVVUkkodXJsKTtcblxuICAgIC8vIGlmIG1ldGhvZCBpcyBHRVQsIGFkZCBhbnkgcmVjZWl2ZWQgZGF0YSB0byB1cmxcblxuICAgIGlmIChpc0dldChvcHRpb25zLm1ldGhvZCkgJiYgZGF0YSkge1xuICAgICAgICB1cmwgPSBgJHt1cmx9JHtlbmNvZGVVUklDb21wb25lbnQodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IEpTT04uc3RyaW5naWZ5KGRhdGEpKX1gO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSByZXF1ZXN0XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBwcm9ncmVzcyBvZiBsb2FkXG4gICAgY29uc3QgcHJvY2VzcyA9IGlzR2V0KG9wdGlvbnMubWV0aG9kKSA/IHhociA6IHhoci51cGxvYWQ7XG4gICAgcHJvY2Vzcy5vbnByb2dyZXNzID0gZSA9PiB7XG4gICAgICAgIC8vIG5vIHByb2dyZXNzIGV2ZW50IHdoZW4gYWJvcnRlZCAoIG9ucHJvZ3Jlc3MgaXMgY2FsbGVkIG9uY2UgYWZ0ZXIgYWJvcnQoKSApXG4gICAgICAgIGlmIChhYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcGkub25wcm9ncmVzcyhlLmxlbmd0aENvbXB1dGFibGUsIGUubG9hZGVkLCBlLnRvdGFsKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZXMgdG8gZ2V0IGhlYWRlciBpbmZvIHRvIHRoZSBhcHAgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIC8vIG5vdCBpbnRlcmVzdGluZyBpbiB0aGVzZSBzdGF0ZXMgKCd1bnNlbnQnIGFuZCAnb3BlbmVuZCcgYXMgdGhleSBkb24ndCBnaXZlIHVzIGFueSBhZGRpdGlvbmFsIGluZm8pXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIHNlcnZlciByZXNwb25zZVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaGVhZGVyc1JlY2VpdmVkID0gdHJ1ZTtcblxuICAgICAgICAvLyB3ZSd2ZSBwcm9iYWJseSByZWNlaXZlZCBzb21lIHVzZWZ1bCBkYXRhIGluIHJlc3BvbnNlIGhlYWRlcnNcbiAgICAgICAgYXBpLm9uaGVhZGVycyh4aHIpO1xuICAgIH07XG5cbiAgICAvLyBsb2FkIHN1Y2Nlc3NmdWxcbiAgICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBpcyBjbGFzc2lmaWVkIGFzIHZhbGlkIHJlc3BvbnNlXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICBhcGkub25sb2FkKHhocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcGkub25lcnJvcih4aHIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGVycm9yIGR1cmluZyBsb2FkXG4gICAgeGhyLm9uZXJyb3IgPSAoKSA9PiBhcGkub25lcnJvcih4aHIpO1xuXG4gICAgLy8gcmVxdWVzdCBhYm9ydGVkXG4gICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBhcGkub25hYm9ydCgpO1xuICAgIH07XG5cbiAgICAvLyByZXF1ZXN0IHRpbWVvdXRcbiAgICB4aHIub250aW1lb3V0ID0gKCkgPT4gYXBpLm9udGltZW91dCh4aHIpO1xuXG4gICAgLy8gb3BlbiB1cCBvcGVuIHVwIVxuICAgIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgLy8gc2V0IHRpbWVvdXQgaWYgZGVmaW5lZCAoZG8gaXQgYWZ0ZXIgb3BlbiBzbyBJRTExIHBsYXlzIGJhbGwpXG4gICAgaWYgKGlzSW50KG9wdGlvbnMudGltZW91dCkpIHtcbiAgICAgICAgeGhyLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuXG4gICAgLy8gYWRkIGhlYWRlcnNcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5oZWFkZXJzW2tleV0pKTtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvLyBzZXQgdHlwZSBvZiByZXNwb25zZVxuICAgIGlmIChvcHRpb25zLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gc2V0IGNyZWRlbnRpYWxzXG4gICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxldCdzIHNlbmQgb3VyIGRhdGFcbiAgICB4aHIuc2VuZChkYXRhKTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5jb25zdCBjcmVhdGVSZXNwb25zZSA9ICh0eXBlLCBjb2RlLCBib2R5LCBoZWFkZXJzKSA9PiAoe1xuICAgIHR5cGUsXG4gICAgY29kZSxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG59KTtcblxuY29uc3QgY3JlYXRlVGltZW91dFJlc3BvbnNlID0gY2IgPT4geGhyID0+IHtcbiAgICBjYihjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnVGltZW91dCcsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xufTtcblxuY29uc3QgaGFzUVMgPSBzdHIgPT4gL1xcPy8udGVzdChzdHIpO1xuY29uc3QgYnVpbGRVUkwgPSAoLi4ucGFydHMpID0+IHtcbiAgICBsZXQgdXJsID0gJyc7XG4gICAgcGFydHMuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICAgICAgdXJsICs9IGhhc1FTKHVybCkgJiYgaGFzUVMocGFydCkgPyBwYXJ0LnJlcGxhY2UoL1xcPy8sICcmJykgOiBwYXJ0O1xuICAgIH0pO1xuICAgIHJldHVybiB1cmw7XG59O1xuXG5jb25zdCBjcmVhdGVGZXRjaEZ1bmN0aW9uID0gKGFwaVVybCA9ICcnLCBhY3Rpb24pID0+IHtcbiAgICAvLyBjdXN0b20gaGFuZGxlciAoc2hvdWxkIGFsc28gaGFuZGxlIGZpbGUsIGxvYWQsIGVycm9yLCBwcm9ncmVzcyBhbmQgYWJvcnQpXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvLyBubyBhY3Rpb24gc3VwcGxpZWRcbiAgICBpZiAoIWFjdGlvbiB8fCAhaXNTdHJpbmcoYWN0aW9uLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IG9ubG9hZCBoYW5sZGVyXG4gICAgY29uc3Qgb25sb2FkID0gYWN0aW9uLm9ubG9hZCB8fCAocmVzID0+IHJlcyk7XG4gICAgY29uc3Qgb25lcnJvciA9IGFjdGlvbi5vbmVycm9yIHx8IChyZXMgPT4gbnVsbCk7XG5cbiAgICAvLyBpbnRlcm5hbCBoYW5kbGVyXG4gICAgcmV0dXJuICh1cmwsIGxvYWQsIGVycm9yLCBwcm9ncmVzcywgYWJvcnQsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgLy8gZG8gbG9jYWwgb3IgcmVtb3RlIHJlcXVlc3QgYmFzZWQgb24gaWYgdGhlIHVybCBpcyBleHRlcm5hbFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3QodXJsLCBidWlsZFVSTChhcGlVcmwsIGFjdGlvbi51cmwpLCB7XG4gICAgICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIGdldCBmaWxlbmFtZVxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSByZXNwb25zZVxuICAgICAgICAgICAgbG9hZChcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgJ2xvYWQnLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24ubWV0aG9kID09PSAnSEVBRCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRGaWxlRnJvbUJsb2Iob25sb2FkKHhoci5yZXNwb25zZSksIGZpbGVuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmhlYWRlcnMgPSB4aHIgPT4ge1xuICAgICAgICAgICAgaGVhZGVycyhjcmVhdGVSZXNwb25zZSgnaGVhZGVycycsIHhoci5zdGF0dXMsIG51bGwsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xufTtcblxuY29uc3QgQ2h1bmtTdGF0dXMgPSB7XG4gICAgUVVFVUVEOiAwLFxuICAgIENPTVBMRVRFOiAxLFxuICAgIFBST0NFU1NJTkc6IDIsXG4gICAgRVJST1I6IDMsXG4gICAgV0FJVElORzogNCxcbn07XG5cbi8qXG5mdW5jdGlvbiBzaWduYXR1cmU6XG4gIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgIGFib3J0OigpID0+IHt9XG4gIH1cbn1cbiovXG5cbi8vIGFwaVVybCwgYWN0aW9uLCBuYW1lLCBmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCwgdHJhbnNmZXIsIG9wdGlvbnNcbmNvbnN0IHByb2Nlc3NGaWxlQ2h1bmtlZCA9IChcbiAgICBhcGlVcmwsXG4gICAgYWN0aW9uLFxuICAgIG5hbWUsXG4gICAgZmlsZSxcbiAgICBtZXRhZGF0YSxcbiAgICBsb2FkLFxuICAgIGVycm9yLFxuICAgIHByb2dyZXNzLFxuICAgIGFib3J0LFxuICAgIHRyYW5zZmVyLFxuICAgIG9wdGlvbnNcbikgPT4ge1xuICAgIC8vIGFsbCBjaHVua3NcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBjb25zdCB7IGNodW5rVHJhbnNmZXJJZCwgY2h1bmtTZXJ2ZXIsIGNodW5rU2l6ZSwgY2h1bmtSZXRyeURlbGF5cyB9ID0gb3B0aW9ucztcblxuICAgIC8vIGRlZmF1bHQgc3RhdGVcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgc2VydmVySWQ6IGNodW5rVHJhbnNmZXJJZCxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgfTtcblxuICAgIC8vIHNldCBvbmxvYWQgaGFuZGxlcnNcbiAgICBjb25zdCBvbmRhdGEgPSBhY3Rpb24ub25kYXRhIHx8IChmZCA9PiBmZCk7XG4gICAgY29uc3Qgb25sb2FkID1cbiAgICAgICAgYWN0aW9uLm9ubG9hZCB8fFxuICAgICAgICAoKHhociwgbWV0aG9kKSA9PlxuICAgICAgICAgICAgbWV0aG9kID09PSAnSEVBRCcgPyB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1VwbG9hZC1PZmZzZXQnKSA6IHhoci5yZXNwb25zZSk7XG4gICAgY29uc3Qgb25lcnJvciA9IGFjdGlvbi5vbmVycm9yIHx8IChyZXMgPT4gbnVsbCk7XG5cbiAgICAvLyBjcmVhdGUgc2VydmVyIGhvb2tcbiAgICBjb25zdCByZXF1ZXN0VHJhbnNmZXJJZCA9IGNiID0+IHtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgICAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgICAgIGlmIChpc09iamVjdChtZXRhZGF0YSkpIGZvcm1EYXRhLmFwcGVuZChuYW1lLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkpO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhmaWxlLCBtZXRhZGF0YSlcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmFjdGlvbixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3Qob25kYXRhKGZvcm1EYXRhKSwgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT5cbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIH07XG5cbiAgICBjb25zdCByZXF1ZXN0VHJhbnNmZXJPZmZzZXQgPSBjYiA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RVcmwgPSBidWlsZFVSTChhcGlVcmwsIGNodW5rU2VydmVyLnVybCwgc3RhdGUuc2VydmVySWQpO1xuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBhY3Rpb24uaGVhZGVycyhzdGF0ZS5zZXJ2ZXJJZClcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5hY3Rpb24uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3QobnVsbCwgcmVxdWVzdFVybCwgcmVxdWVzdFBhcmFtcyk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4gY2Iob25sb2FkKHhociwgcmVxdWVzdFBhcmFtcy5tZXRob2QpKTtcblxuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT5cbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIH07XG5cbiAgICAvLyBjcmVhdGUgY2h1bmtzXG4gICAgY29uc3QgbGFzdENodW5rSW5kZXggPSBNYXRoLmZsb29yKGZpbGUuc2l6ZSAvIGNodW5rU2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdENodW5rSW5kZXg7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogY2h1bmtTaXplO1xuICAgICAgICBjb25zdCBkYXRhID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSwgJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKTtcbiAgICAgICAgY2h1bmtzW2ldID0ge1xuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzaXplOiBkYXRhLnNpemUsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICAgICAgcmV0cmllczogWy4uLmNodW5rUmV0cnlEZWxheXNdLFxuICAgICAgICAgICAgc3RhdHVzOiBDaHVua1N0YXR1cy5RVUVVRUQsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHJlcXVlc3Q6IG51bGwsXG4gICAgICAgICAgICB0aW1lb3V0OiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcyA9ICgpID0+IGxvYWQoc3RhdGUuc2VydmVySWQpO1xuXG4gICAgY29uc3QgY2FuUHJvY2Vzc0NodW5rID0gY2h1bmsgPT5cbiAgICAgICAgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5RVUVVRUQgfHwgY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5FUlJPUjtcblxuICAgIGNvbnN0IHByb2Nlc3NDaHVuayA9IGNodW5rID0+IHtcbiAgICAgICAgLy8gcHJvY2Vzc2luZyBpcyBwYXVzZWQsIHdhaXQgaGVyZVxuICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIGdldCBuZXh0IGNodW5rIHRvIHByb2Nlc3NcbiAgICAgICAgY2h1bmsgPSBjaHVuayB8fCBjaHVua3MuZmluZChjYW5Qcm9jZXNzQ2h1bmspO1xuXG4gICAgICAgIC8vIG5vIG1vcmUgY2h1bmtzIHRvIHByb2Nlc3NcbiAgICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICAgICAgLy8gYWxsIGRvbmU/XG4gICAgICAgICAgICBpZiAoY2h1bmtzLmV2ZXJ5KGNodW5rID0+IGNodW5rLnN0YXR1cyA9PT0gQ2h1bmtTdGF0dXMuQ09NUExFVEUpKSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVQcm9jZXNzaW5nQ2h1bmtzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIGNodW5rIHRvIGhhbmRsZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IHByb2Nlc3NpbmcgdGhpcyBjaHVua1xuICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HO1xuICAgICAgICBjaHVuay5wcm9ncmVzcyA9IG51bGw7XG5cbiAgICAgICAgLy8gYWxsb3cgcGFyc2luZyBvZiBmb3JtZGF0YVxuICAgICAgICBjb25zdCBvbmRhdGEgPSBjaHVua1NlcnZlci5vbmRhdGEgfHwgKGZkID0+IGZkKTtcbiAgICAgICAgY29uc3Qgb25lcnJvciA9IGNodW5rU2VydmVyLm9uZXJyb3IgfHwgKHJlcyA9PiBudWxsKTtcbiAgICAgICAgY29uc3Qgb25sb2FkID0gY2h1bmtTZXJ2ZXIub25sb2FkIHx8ICgoKSA9PiB7fSk7XG5cbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IG9iamVjdFxuICAgICAgICBjb25zdCByZXF1ZXN0VXJsID0gYnVpbGRVUkwoYXBpVXJsLCBjaHVua1NlcnZlci51cmwsIHN0YXRlLnNlcnZlcklkKTtcblxuICAgICAgICBjb25zdCBoZWFkZXJzID1cbiAgICAgICAgICAgIHR5cGVvZiBjaHVua1NlcnZlci5oZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgPyBjaHVua1NlcnZlci5oZWFkZXJzKGNodW5rKVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmNodW5rU2VydmVyLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IGNodW5rLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAnVXBsb2FkLU5hbWUnOiBmaWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAoY2h1bmsucmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG9uZGF0YShjaHVuay5kYXRhKSwgcmVxdWVzdFVybCwge1xuICAgICAgICAgICAgLi4uY2h1bmtTZXJ2ZXIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICAgICAgLy8gYWxsb3cgaG9va2luZyBpbnRvIHJlcXVlc3QgcmVzdWx0XG4gICAgICAgICAgICBvbmxvYWQoeGhyLCBjaHVuay5pbmRleCwgY2h1bmtzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIGRvbmUhXG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHJlcXVlc3QgcmVmZXJlbmNlXG4gICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyBtb3JlIGNodW5rc1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IChsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICAgICAgICBjaHVuay5wcm9ncmVzcyA9IGxlbmd0aENvbXB1dGFibGUgPyBsb2FkZWQgOiBudWxsO1xuICAgICAgICAgICAgdXBkYXRlVG90YWxQcm9ncmVzcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub25lcnJvciA9IHhociA9PiB7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5FUlJPUjtcbiAgICAgICAgICAgIGNodW5rLnJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgY2h1bmsuZXJyb3IgPSBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25lcnJvcih4aHIucmVzcG9uc2UpIHx8IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0geGhyID0+IHtcbiAgICAgICAgICAgIGNodW5rLnN0YXR1cyA9IENodW5rU3RhdHVzLkVSUk9SO1xuICAgICAgICAgICAgY2h1bmsucmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXJldHJ5UHJvY2Vzc0NodW5rKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVRpbWVvdXRSZXNwb25zZShlcnJvcikoeGhyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXF1ZXN0Lm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5RVUVVRUQ7XG4gICAgICAgICAgICBjaHVuay5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHJldHJ5UHJvY2Vzc0NodW5rID0gY2h1bmsgPT4ge1xuICAgICAgICAvLyBubyBtb3JlIHJldHJpZXMgbGVmdFxuICAgICAgICBpZiAoY2h1bmsucmV0cmllcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBuZXcgcmV0cnlcbiAgICAgICAgY2h1bmsuc3RhdHVzID0gQ2h1bmtTdGF0dXMuV0FJVElORztcbiAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICBjaHVuay50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9LCBjaHVuay5yZXRyaWVzLnNoaWZ0KCkpO1xuXG4gICAgICAgIC8vIHdlJ3JlIGdvaW5nIHRvIHJldHJ5XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVUb3RhbFByb2dyZXNzID0gKCkgPT4ge1xuICAgICAgICAvLyBjYWxjdWxhdGUgdG90YWwgcHJvZ3Jlc3MgZnJhY3Rpb25cbiAgICAgICAgY29uc3QgdG90YWxCeXRlc1RyYW5zZmVyZWQgPSBjaHVua3MucmVkdWNlKChwLCBjaHVuaykgPT4ge1xuICAgICAgICAgICAgaWYgKHAgPT09IG51bGwgfHwgY2h1bmsucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHAgKyBjaHVuay5wcm9ncmVzcztcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgLy8gY2FuJ3QgY29tcHV0ZSBwcm9ncmVzc1xuICAgICAgICBpZiAodG90YWxCeXRlc1RyYW5zZmVyZWQgPT09IG51bGwpIHJldHVybiBwcm9ncmVzcyhmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHByb2dyZXNzIHZhbHVlc1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBjaHVua3MucmVkdWNlKCh0b3RhbCwgY2h1bmspID0+IHRvdGFsICsgY2h1bmsuc2l6ZSwgMCk7XG5cbiAgICAgICAgLy8gY2FuIHVwZGF0ZSBwcm9ncmVzcyBpbmRpY2F0b3JcbiAgICAgICAgcHJvZ3Jlc3ModHJ1ZSwgdG90YWxCeXRlc1RyYW5zZmVyZWQsIHRvdGFsU2l6ZSk7XG4gICAgfTtcblxuICAgIC8vIHByb2Nlc3MgbmV3IGNodW5rc1xuICAgIGNvbnN0IHByb2Nlc3NDaHVua3MgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsUHJvY2Vzc2luZyA9IGNodW5rcy5maWx0ZXIoY2h1bmsgPT4gY2h1bmsuc3RhdHVzID09PSBDaHVua1N0YXR1cy5QUk9DRVNTSU5HKVxuICAgICAgICAgICAgLmxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsUHJvY2Vzc2luZyA+PSAxKSByZXR1cm47XG4gICAgICAgIHByb2Nlc3NDaHVuaygpO1xuICAgIH07XG5cbiAgICBjb25zdCBhYm9ydENodW5rcyA9ICgpID0+IHtcbiAgICAgICAgY2h1bmtzLmZvckVhY2goY2h1bmsgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNodW5rLnRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKGNodW5rLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjaHVuay5yZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBsZXQncyBnbyFcbiAgICBpZiAoIXN0YXRlLnNlcnZlcklkKSB7XG4gICAgICAgIHJlcXVlc3RUcmFuc2ZlcklkKHNlcnZlcklkID0+IHtcbiAgICAgICAgICAgIC8vIHN0b3AgaGVyZSBpZiBhYm9ydGVkLCBtaWdodCBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gcmVxdWVzdCBhbmQgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHBhc3MgYmFjayB0byBpdGVtIHNvIHdlIGNhbiB1c2UgaXQgaWYgc29tZXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgICAgICAgIHRyYW5zZmVyKHNlcnZlcklkKTtcblxuICAgICAgICAgICAgLy8gc3RvcmUgaW50ZXJuYWxseVxuICAgICAgICAgICAgc3RhdGUuc2VydmVySWQgPSBzZXJ2ZXJJZDtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVua3MoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdFRyYW5zZmVyT2Zmc2V0KG9mZnNldCA9PiB7XG4gICAgICAgICAgICAvLyBzdG9wIGhlcmUgaWYgYWJvcnRlZCwgbWlnaHQgaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIHJlcXVlc3QgYW5kIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAoc3RhdGUuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBtYXJrIGNodW5rcyB3aXRoIGxvd2VyIG9mZnNldCBhcyBjb21wbGV0ZVxuICAgICAgICAgICAgY2h1bmtzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihjaHVuayA9PiBjaHVuay5vZmZzZXQgPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjaHVuay5zdGF0dXMgPSBDaHVua1N0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsucHJvZ3Jlc3MgPSBjaHVuay5zaXplO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmtzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGFib3J0Q2h1bmtzKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbi8qXG5mdW5jdGlvbiBzaWduYXR1cmU6XG4gIChmaWxlLCBtZXRhZGF0YSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzLCBhYm9ydCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgYWJvcnQ6KCkgPT4ge31cbiAgfVxufVxuKi9cbmNvbnN0IGNyZWF0ZUZpbGVQcm9jZXNzb3JGdW5jdGlvbiA9IChhcGlVcmwsIGFjdGlvbiwgbmFtZSwgb3B0aW9ucykgPT4gKFxuICAgIGZpbGUsXG4gICAgbWV0YWRhdGEsXG4gICAgbG9hZCxcbiAgICBlcnJvcixcbiAgICBwcm9ncmVzcyxcbiAgICBhYm9ydCxcbiAgICB0cmFuc2ZlclxuKSA9PiB7XG4gICAgLy8gbm8gZmlsZSByZWNlaXZlZFxuICAgIGlmICghZmlsZSkgcmV0dXJuO1xuXG4gICAgLy8gaWYgd2FzIHBhc3NlZCBhIGZpbGUsIGFuZCB3ZSBjYW4gY2h1bmsgaXQsIGV4aXQgaGVyZVxuICAgIGNvbnN0IGNhbkNodW5rVXBsb2FkID0gb3B0aW9ucy5jaHVua1VwbG9hZHM7XG4gICAgY29uc3Qgc2hvdWxkQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiBmaWxlLnNpemUgPiBvcHRpb25zLmNodW5rU2l6ZTtcbiAgICBjb25zdCB3aWxsQ2h1bmtVcGxvYWQgPSBjYW5DaHVua1VwbG9hZCAmJiAoc2hvdWxkQ2h1bmtVcGxvYWQgfHwgb3B0aW9ucy5jaHVua0ZvcmNlKTtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIEJsb2IgJiYgd2lsbENodW5rVXBsb2FkKVxuICAgICAgICByZXR1cm4gcHJvY2Vzc0ZpbGVDaHVua2VkKFxuICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIGxvYWQsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHByb2dyZXNzLFxuICAgICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgICB0cmFuc2ZlcixcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgIC8vIHNldCBoYW5kbGVyc1xuICAgIGNvbnN0IG9uZGF0YSA9IGFjdGlvbi5vbmRhdGEgfHwgKGZkID0+IGZkKTtcbiAgICBjb25zdCBvbmxvYWQgPSBhY3Rpb24ub25sb2FkIHx8IChyZXMgPT4gcmVzKTtcbiAgICBjb25zdCBvbmVycm9yID0gYWN0aW9uLm9uZXJyb3IgfHwgKHJlcyA9PiBudWxsKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPVxuICAgICAgICB0eXBlb2YgYWN0aW9uLmhlYWRlcnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYWN0aW9uLmhlYWRlcnMoZmlsZSwgbWV0YWRhdGEpIHx8IHt9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFjdGlvbi5oZWFkZXJzLFxuICAgICAgICAgICAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgLi4uYWN0aW9uLFxuICAgICAgICBoZWFkZXJzLFxuICAgIH07XG5cbiAgICAvLyBjcmVhdGUgZm9ybWRhdGEgb2JqZWN0XG4gICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAvLyBhZGQgbWV0YWRhdGEgdW5kZXIgc2FtZSBuYW1lXG4gICAgaWYgKGlzT2JqZWN0KG1ldGFkYXRhKSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQobmFtZSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBUdXJuIGludG8gYW4gYXJyYXkgb2Ygb2JqZWN0cyBzbyBubyBtYXR0ZXIgd2hhdCB0aGUgaW5wdXQsIHdlIGNhbiBoYW5kbGUgaXQgdGhlIHNhbWUgd2F5XG4gICAgKGZpbGUgaW5zdGFuY2VvZiBCbG9iID8gW3sgbmFtZTogbnVsbCwgZmlsZSB9XSA6IGZpbGUpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBpdGVtLmZpbGUsXG4gICAgICAgICAgICBpdGVtLm5hbWUgPT09IG51bGwgPyBpdGVtLmZpbGUubmFtZSA6IGAke2l0ZW0ubmFtZX0ke2l0ZW0uZmlsZS5uYW1lfWBcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIHNlbmQgcmVxdWVzdCBvYmplY3RcbiAgICBjb25zdCByZXF1ZXN0ID0gc2VuZFJlcXVlc3Qob25kYXRhKGZvcm1EYXRhKSwgYnVpbGRVUkwoYXBpVXJsLCBhY3Rpb24udXJsKSwgcmVxdWVzdFBhcmFtcyk7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSB4aHIgPT4ge1xuICAgICAgICBsb2FkKGNyZWF0ZVJlc3BvbnNlKCdsb2FkJywgeGhyLnN0YXR1cywgb25sb2FkKHhoci5yZXNwb25zZSksIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSB4aHIgPT4ge1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gY3JlYXRlVGltZW91dFJlc3BvbnNlKGVycm9yKTtcbiAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBhYm9ydDtcblxuICAgIC8vIHNob3VsZCByZXR1cm4gcmVxdWVzdFxuICAgIHJldHVybiByZXF1ZXN0O1xufTtcblxuY29uc3QgY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24gPSAoYXBpVXJsID0gJycsIGFjdGlvbiwgbmFtZSwgb3B0aW9ucykgPT4ge1xuICAgIC8vIGN1c3RvbSBoYW5kbGVyIChzaG91bGQgYWxzbyBoYW5kbGUgZmlsZSwgbG9hZCwgZXJyb3IsIHByb2dyZXNzIGFuZCBhYm9ydClcbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuICguLi5wYXJhbXMpID0+IGFjdGlvbihuYW1lLCAuLi5wYXJhbXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkXG4gICAgaWYgKCFhY3Rpb24gfHwgIWlzU3RyaW5nKGFjdGlvbi51cmwpKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGludGVybmFsIGhhbmRsZXJcbiAgICByZXR1cm4gY3JlYXRlRmlsZVByb2Nlc3NvckZ1bmN0aW9uKGFwaVVybCwgYWN0aW9uLCBuYW1lLCBvcHRpb25zKTtcbn07XG5cbi8qXG4gZnVuY3Rpb24gc2lnbmF0dXJlOlxuICh1bmlxdWVGaWxlSWQsIGxvYWQsIGVycm9yKSA9PiB7IH1cbiAqL1xuY29uc3QgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24gPSAoYXBpVXJsID0gJycsIGFjdGlvbikgPT4ge1xuICAgIC8vIGlzIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfVxuXG4gICAgLy8gbm8gYWN0aW9uIHN1cHBsaWVkLCByZXR1cm4gc3R1YiBmdW5jdGlvbiwgaW50ZXJmYWNlIHdpbGwgd29yaywgYnV0IGZpbGUgd29uJ3QgYmUgcmVtb3ZlZFxuICAgIGlmICghYWN0aW9uIHx8ICFpc1N0cmluZyhhY3Rpb24udXJsKSkge1xuICAgICAgICByZXR1cm4gKHVuaXF1ZUZpbGVJZCwgbG9hZCkgPT4gbG9hZCgpO1xuICAgIH1cblxuICAgIC8vIHNldCBvbmxvYWQgaGFubGRlclxuICAgIGNvbnN0IG9ubG9hZCA9IGFjdGlvbi5vbmxvYWQgfHwgKHJlcyA9PiByZXMpO1xuICAgIGNvbnN0IG9uZXJyb3IgPSBhY3Rpb24ub25lcnJvciB8fCAocmVzID0+IG51bGwpO1xuXG4gICAgLy8gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm4gKHVuaXF1ZUZpbGVJZCwgbG9hZCwgZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KFxuICAgICAgICAgICAgdW5pcXVlRmlsZUlkLFxuICAgICAgICAgICAgYXBpVXJsICsgYWN0aW9uLnVybCxcbiAgICAgICAgICAgIGFjdGlvbiAvLyBjb250YWlucyBtZXRob2QsIGhlYWRlcnMgYW5kIHdpdGhDcmVkZW50aWFscyBwcm9wZXJ0aWVzXG4gICAgICAgICk7XG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0geGhyID0+IHtcbiAgICAgICAgICAgIGxvYWQoXG4gICAgICAgICAgICAgICAgY3JlYXRlUmVzcG9uc2UoXG4gICAgICAgICAgICAgICAgICAgICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlc3BvbnNlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBvbmVycm9yKHhoci5yZXNwb25zZSkgfHwgeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH07XG59O1xuXG5jb25zdCBnZXRSYW5kb21OdW1iZXIgPSAobWluID0gMCwgbWF4ID0gMSkgPT4gbWluICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pO1xuXG5jb25zdCBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIgPSAoXG4gICAgY2IsXG4gICAgZHVyYXRpb24gPSAxMDAwLFxuICAgIG9mZnNldCA9IDAsXG4gICAgdGlja01pbiA9IDI1LFxuICAgIHRpY2tNYXggPSAyNTBcbikgPT4ge1xuICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgICBsZXQgcnVudGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgICAgbGV0IGRlbGF5ID0gZ2V0UmFuZG9tTnVtYmVyKHRpY2tNaW4sIHRpY2tNYXgpO1xuXG4gICAgICAgIGlmIChydW50aW1lICsgZGVsYXkgPiBkdXJhdGlvbikge1xuICAgICAgICAgICAgZGVsYXkgPSBydW50aW1lICsgZGVsYXkgLSBkdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcm9ncmVzcyA9IHJ1bnRpbWUgLyBkdXJhdGlvbjtcbiAgICAgICAgaWYgKHByb2dyZXNzID49IDEgfHwgZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICBjYigxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiKHByb2dyZXNzKTtcblxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCh0aWNrLCBkZWxheSk7XG4gICAgfTtcblxuICAgIGlmIChkdXJhdGlvbiA+IDApIHRpY2soKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUZpbGVQcm9jZXNzb3IgPSAocHJvY2Vzc0ZuLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgcGVyY2VpdmVkUHJvZ3Jlc3M6IDAsXG4gICAgICAgIHBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlcjogbnVsbCxcbiAgICAgICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgICAgIHRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgcGVyY2VpdmVkRHVyYXRpb246IDAsXG4gICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICByZXF1ZXN0OiBudWxsLFxuICAgICAgICByZXNwb25zZTogbnVsbCxcbiAgICB9O1xuXG4gICAgY29uc3QgeyBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IHByb2Nlc3MgPSAoZmlsZSwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NGbiA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdlJ3ZlIG5vdCB5ZXQgc3RhcnRlZCB0aGUgcmVhbCBkb3dubG9hZCwgc3RvcCBoZXJlXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBtaWdodCBub3QgZ28gdGhyb3VnaCwgZm9yIGluc3RhbmNlLCB0aGVyZSBtaWdodCBiZSBzb21lIHNlcnZlciB0cm91YmxlXG4gICAgICAgICAgICAvLyBpZiBzdGF0ZS5wcm9ncmVzcyBpcyBudWxsLCB0aGUgc2VydmVyIGRvZXMgbm90IGFsbG93IGNvbXB1dGluZyBwcm9ncmVzcyBhbmQgd2Ugc2hvdyB0aGUgc3Bpbm5lciBpbnN0ZWFkXG4gICAgICAgICAgICBpZiAoc3RhdGUuZHVyYXRpb24gPT09IDAgfHwgc3RhdGUucHJvZ3Jlc3MgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gYXMgd2UncmUgbm93IHByb2Nlc3NpbmcsIGZpcmUgdGhlIHByb2dyZXNzIGV2ZW50XG4gICAgICAgICAgICBhcGkuZmlyZSgncHJvZ3Jlc3MnLCBhcGkuZ2V0UHJvZ3Jlc3MoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgY29tcGxldGVGbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkLXBlcmNlaXZlZCcsIHN0YXRlLnJlc3BvbnNlLmJvZHkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxldCdzIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgICAgYXBpLmZpcmUoJ3N0YXJ0Jyk7XG5cbiAgICAgICAgLy8gc2V0IHJlcXVlc3Qgc3RhcnRcbiAgICAgICAgc3RhdGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcblxuICAgICAgICAvLyBjcmVhdGUgcGVyY2VpdmVkIHBlcmZvcm1hbmNlIHByb2dyZXNzIGluZGljYXRvclxuICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIgPSBjcmVhdGVQZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIoXG4gICAgICAgICAgICBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWREdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGF0ZS50aW1lc3RhbXA7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBmYWtlIHByb2dyZXNzIGlzIGRvbmUsIGFuZCBhIHJlc3BvbnNlIGhhcyBiZWVuIHJlY2VpdmVkLFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSd2ZSBub3QgeWV0IGNhbGxlZCB0aGUgY29tcGxldGUgbWV0aG9kXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnJlc3BvbnNlICYmIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzID09PSAxICYmICFzdGF0ZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHJhbmRvbSBkZWxheSBhcyBpbiBhIGxpc3Qgb2YgZmlsZXMgeW91IHN0YXJ0IG5vdGljaW5nXG4gICAgICAgICAgICAvLyBmaWxlcyB1cGxvYWRpbmcgYXQgdGhlIGV4YWN0IHNhbWUgc3BlZWRcbiAgICAgICAgICAgIGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uID8gZ2V0UmFuZG9tTnVtYmVyKDc1MCwgMTUwMCkgOiAwXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gcmVtZW1iZXIgcmVxdWVzdCBzbyB3ZSBjYW4gYWJvcnQgaXQgbGF0ZXJcbiAgICAgICAgc3RhdGUucmVxdWVzdCA9IHByb2Nlc3NGbihcbiAgICAgICAgICAgIC8vIHRoZSBmaWxlIHRvIHByb2Nlc3NcbiAgICAgICAgICAgIGZpbGUsXG5cbiAgICAgICAgICAgIC8vIHRoZSBtZXRhZGF0YSB0byBzZW5kIGFsb25nXG4gICAgICAgICAgICBtZXRhZGF0YSxcblxuICAgICAgICAgICAgLy8gY2FsbGJhY2tzIChsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCB0cmFuc2ZlcilcbiAgICAgICAgICAgIC8vIGxvYWQgZXhwZWN0cyB0aGUgYm9keSB0byBiZSBhIHNlcnZlciBpZCBpZlxuICAgICAgICAgICAgLy8geW91IHdhbnQgdG8gbWFrZSB1c2Ugb2YgcmV2ZXJ0XG4gICAgICAgICAgICByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2UgcHV0IHRoZSByZXNwb25zZSBpbiBzdGF0ZSBzbyB3ZSBjYW4gYWNjZXNzXG4gICAgICAgICAgICAgICAgLy8gaXQgb3V0c2lkZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgICAgIHN0YXRlLnJlc3BvbnNlID0gaXNPYmplY3QocmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgJHtyZXNwb25zZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgcHJvZ3Jlc3MgdG8gMSBhcyB3ZSdyZSBub3cgZG9uZVxuICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbCBsb2FkIGlzIGRvbmUgbGV0J3Mgc2hhcmUgcmVzdWx0c1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCdsb2FkJywgc3RhdGUucmVzcG9uc2UuYm9keSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgcmVhbGx5IGRvbmVcbiAgICAgICAgICAgICAgICAvLyBpZiBwZXJjZWl2ZWQgcHJvZ3Jlc3MgaXMgMSAoIHdhaXQgZm9yIHBlcmNlaXZlZCBwcm9ncmVzcyB0byBjb21wbGV0ZSApXG4gICAgICAgICAgICAgICAgLy8gb3IgaWYgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcHJvZ3Jlc3MgKCBudWxsIClcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICFhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAoYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb24gJiYgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPT09IDEpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlRm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBlcnJvciBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0eXBlLCBjb2RlLCBib2R5XG4gICAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIHVwZGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIuY2xlYXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvdGhlcnMgYWJvdXQgdGhpcyBlcnJvclxuICAgICAgICAgICAgICAgIGFwaS5maXJlKFxuICAgICAgICAgICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgJHtlcnJvcn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGFjdHVhbCBwcm9jZXNzaW5nIHByb2dyZXNzXG4gICAgICAgICAgICAoY29tcHV0YWJsZSwgY3VycmVudCwgdG90YWwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYWN0dWFsIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgc3RhdGUuZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhdGUudGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGFjdHVhbCBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2dyZXNzID0gY29tcHV0YWJsZSA/IGN1cnJlbnQgLyB0b3RhbCA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBhYm9ydCBkb2VzIG5vdCBleHBlY3QgYSB2YWx1ZVxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgdXBkYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLnBlcmNlaXZlZFBlcmZvcm1hbmNlVXBkYXRlci5jbGVhcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyZSB0aGUgYWJvcnQgZXZlbnQgc28gd2UgY2FuIHN3aXRjaCB2aXN1YWxzXG4gICAgICAgICAgICAgICAgYXBpLmZpcmUoJ2Fib3J0Jywgc3RhdGUucmVzcG9uc2UgPyBzdGF0ZS5yZXNwb25zZS5ib2R5IDogbnVsbCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgaWQgZm9yIHRoaXMgdHJhbnNmZXJcbiAgICAgICAgICAgIHRyYW5zZmVySWQgPT4ge1xuICAgICAgICAgICAgICAgIGFwaS5maXJlKCd0cmFuc2ZlcicsIHRyYW5zZmVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IHtcbiAgICAgICAgLy8gbm8gcmVxdWVzdCBydW5uaW5nLCBjYW4ndCBhYm9ydFxuICAgICAgICBpZiAoIXN0YXRlLnJlcXVlc3QpIHJldHVybjtcblxuICAgICAgICAvLyBzdG9wIHVwZGF0ZXJcbiAgICAgICAgc3RhdGUucGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gYWJvcnQgYWN0dWFsIHJlcXVlc3RcbiAgICAgICAgaWYgKHN0YXRlLnJlcXVlc3QuYWJvcnQpIHN0YXRlLnJlcXVlc3QuYWJvcnQoKTtcblxuICAgICAgICAvLyBpZiBoYXMgcmVzcG9uc2Ugb2JqZWN0LCB3ZSd2ZSBjb21wbGV0ZWQgdGhlIHJlcXVlc3RcbiAgICAgICAgc3RhdGUuY29tcGxldGUgPSB0cnVlO1xuICAgIH07XG5cbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgc3RhdGUuY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGVyY2VpdmVkUHJvZ3Jlc3MgPSAwO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcyA9IDA7XG4gICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHN0YXRlLnBlcmNlaXZlZER1cmF0aW9uID0gMDtcbiAgICAgICAgc3RhdGUuZHVyYXRpb24gPSAwO1xuICAgICAgICBzdGF0ZS5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgc3RhdGUucmVzcG9uc2UgPSBudWxsO1xuICAgIH07XG5cbiAgICBjb25zdCBnZXRQcm9ncmVzcyA9IGFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uXG4gICAgICAgID8gKCkgPT4gKHN0YXRlLnByb2dyZXNzID8gTWF0aC5taW4oc3RhdGUucHJvZ3Jlc3MsIHN0YXRlLnBlcmNlaXZlZFByb2dyZXNzKSA6IG51bGwpXG4gICAgICAgIDogKCkgPT4gc3RhdGUucHJvZ3Jlc3MgfHwgbnVsbDtcblxuICAgIGNvbnN0IGdldER1cmF0aW9uID0gYWxsb3dNaW5pbXVtVXBsb2FkRHVyYXRpb25cbiAgICAgICAgPyAoKSA9PiBNYXRoLm1pbihzdGF0ZS5kdXJhdGlvbiwgc3RhdGUucGVyY2VpdmVkRHVyYXRpb24pXG4gICAgICAgIDogKCkgPT4gc3RhdGUuZHVyYXRpb247XG5cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIC4uLm9uKCksXG4gICAgICAgIHByb2Nlc3MsIC8vIHN0YXJ0IHByb2Nlc3NpbmcgZmlsZVxuICAgICAgICBhYm9ydCwgLy8gYWJvcnQgYWN0aXZlIHByb2Nlc3MgcmVxdWVzdFxuICAgICAgICBnZXRQcm9ncmVzcyxcbiAgICAgICAgZ2V0RHVyYXRpb24sXG4gICAgICAgIHJlc2V0LFxuICAgIH07XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxuY29uc3QgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uID0gbmFtZSA9PiBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpIHx8IG5hbWU7XG5cbmNvbnN0IGNyZWF0ZUZpbGVTdHViID0gc291cmNlID0+IHtcbiAgICBsZXQgZGF0YSA9IFtzb3VyY2UubmFtZSwgc291cmNlLnNpemUsIHNvdXJjZS50eXBlXTtcblxuICAgIC8vIGlzIGJsb2Igb3IgYmFzZTY0LCB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoZSBuYW1lXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2IgfHwgaXNCYXNlNjREYXRhVVJJKHNvdXJjZSkpIHtcbiAgICAgICAgZGF0YVswXSA9IHNvdXJjZS5uYW1lIHx8IGdldERhdGVTdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKGlzQmFzZTY0RGF0YVVSSShzb3VyY2UpKSB7XG4gICAgICAgIC8vIGlmIGlzIGJhc2U2NCBkYXRhIHVyaSB3ZSBuZWVkIHRvIGRldGVybWluZSB0aGUgYXZlcmFnZSBzaXplIGFuZCB0eXBlXG4gICAgICAgIGRhdGFbMV0gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBkYXRhWzJdID0gZ2V0TWltZVR5cGVGcm9tQmFzZTY0RGF0YVVSSShzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoc291cmNlKSkge1xuICAgICAgICAvLyB1cmxcbiAgICAgICAgZGF0YVswXSA9IGdldEZpbGVuYW1lRnJvbVVSTChzb3VyY2UpO1xuICAgICAgICBkYXRhWzFdID0gMDtcbiAgICAgICAgZGF0YVsyXSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRhdGFbMF0sXG4gICAgICAgIHNpemU6IGRhdGFbMV0sXG4gICAgICAgIHR5cGU6IGRhdGFbMl0sXG4gICAgfTtcbn07XG5cbmNvbnN0IGlzRmlsZSA9IHZhbHVlID0+ICEhKHZhbHVlIGluc3RhbmNlb2YgRmlsZSB8fCAodmFsdWUgaW5zdGFuY2VvZiBCbG9iICYmIHZhbHVlLm5hbWUpKTtcblxuY29uc3QgZGVlcENsb25lT2JqZWN0ID0gc3JjID0+IHtcbiAgICBpZiAoIWlzT2JqZWN0KHNyYykpIHJldHVybiBzcmM7XG4gICAgY29uc3QgdGFyZ2V0ID0gaXNBcnJheShzcmMpID8gW10gOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzcmMpIHtcbiAgICAgICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IHYgPSBzcmNba2V5XTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2ICYmIGlzT2JqZWN0KHYpID8gZGVlcENsb25lT2JqZWN0KHYpIDogdjtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmNvbnN0IGNyZWF0ZUl0ZW0gPSAob3JpZ2luID0gbnVsbCwgc2VydmVyRmlsZVJlZmVyZW5jZSA9IG51bGwsIGZpbGUgPSBudWxsKSA9PiB7XG4gICAgLy8gdW5pcXVlIGlkIGZvciB0aGlzIGl0ZW0sIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGl0ZW0gYWNyb3NzIHZpZXdzXG4gICAgY29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaXRlbSBzdGF0ZVxuICAgICAqL1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAvLyBpcyBhcmNoaXZlZFxuICAgICAgICBhcmNoaXZlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gaWYgaXMgZnJvemVuLCBubyBsb25nZXIgZmlyZXMgZXZlbnRzXG4gICAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHZpZXdcbiAgICAgICAgcmVsZWFzZWQ6IGZhbHNlLFxuXG4gICAgICAgIC8vIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICBzb3VyY2U6IG51bGwsXG5cbiAgICAgICAgLy8gZmlsZSBtb2RlbCByZWZlcmVuY2VcbiAgICAgICAgZmlsZSxcblxuICAgICAgICAvLyBpZCBvZiBmaWxlIG9uIHNlcnZlclxuICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlLFxuXG4gICAgICAgIC8vIGlkIG9mIGZpbGUgdHJhbnNmZXIgb24gc2VydmVyXG4gICAgICAgIHRyYW5zZmVySWQ6IG51bGwsXG5cbiAgICAgICAgLy8gaXMgYWJvcnRlZFxuICAgICAgICBwcm9jZXNzaW5nQWJvcnRlZDogZmFsc2UsXG5cbiAgICAgICAgLy8gY3VycmVudCBpdGVtIHN0YXR1c1xuICAgICAgICBzdGF0dXM6IHNlcnZlckZpbGVSZWZlcmVuY2UgPyBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUgOiBJdGVtU3RhdHVzLklOSVQsXG5cbiAgICAgICAgLy8gYWN0aXZlIHByb2Nlc3Nlc1xuICAgICAgICBhY3RpdmVMb2FkZXI6IG51bGwsXG4gICAgICAgIGFjdGl2ZVByb2Nlc3NvcjogbnVsbCxcbiAgICB9O1xuXG4gICAgLy8gY2FsbGJhY2sgdXNlZCB3aGVuIGFib3J0IHByb2Nlc3NpbmcgaXMgY2FsbGVkIHRvIGxpbmsgYmFjayB0byB0aGUgcmVzb2x2ZSBtZXRob2RcbiAgICBsZXQgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVybmFsbHkgYWRkZWQgaXRlbSBtZXRhZGF0YVxuICAgICAqL1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge307XG5cbiAgICAvLyBpdGVtIGRhdGFcbiAgICBjb25zdCBzZXRTdGF0dXMgPSBzdGF0dXMgPT4gKHN0YXRlLnN0YXR1cyA9IHN0YXR1cyk7XG5cbiAgICAvLyBmaXJlIGV2ZW50IHVubGVzcyB0aGUgaXRlbSBoYXMgYmVlbiBhcmNoaXZlZFxuICAgIGNvbnN0IGZpcmUgPSAoZXZlbnQsIC4uLnBhcmFtcykgPT4ge1xuICAgICAgICBpZiAoc3RhdGUucmVsZWFzZWQgfHwgc3RhdGUuZnJvemVuKSByZXR1cm47XG4gICAgICAgIGFwaS5maXJlKGV2ZW50LCAuLi5wYXJhbXMpO1xuICAgIH07XG5cbiAgICAvLyBmaWxlIGRhdGFcbiAgICBjb25zdCBnZXRGaWxlRXh0ZW5zaW9uID0gKCkgPT4gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKHN0YXRlLmZpbGUubmFtZSk7XG4gICAgY29uc3QgZ2V0RmlsZVR5cGUgPSAoKSA9PiBzdGF0ZS5maWxlLnR5cGU7XG4gICAgY29uc3QgZ2V0RmlsZVNpemUgPSAoKSA9PiBzdGF0ZS5maWxlLnNpemU7XG4gICAgY29uc3QgZ2V0RmlsZSA9ICgpID0+IHN0YXRlLmZpbGU7XG5cbiAgICAvL1xuICAgIC8vIGxvZ2ljIHRvIGxvYWQgYSBmaWxlXG4gICAgLy9cbiAgICBjb25zdCBsb2FkID0gKHNvdXJjZSwgbG9hZGVyLCBvbmxvYWQpID0+IHtcbiAgICAgICAgLy8gcmVtZW1iZXIgdGhlIG9yaWdpbmFsIGl0ZW0gc291cmNlXG4gICAgICAgIHN0YXRlLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgICAgICAvLyBzb3VyY2UgaXMga25vd25cbiAgICAgICAgYXBpLmZpcmVTeW5jKCdpbml0Jyk7XG5cbiAgICAgICAgLy8gZmlsZSBzdHViIGlzIGFscmVhZHkgdGhlcmVcbiAgICAgICAgaWYgKHN0YXRlLmZpbGUpIHtcbiAgICAgICAgICAgIGFwaS5maXJlU3luYygnbG9hZC1za2lwJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgYSBzdHViIGZpbGUgb2JqZWN0IHdoaWxlIGxvYWRpbmcgdGhlIGFjdHVhbCBkYXRhXG4gICAgICAgIHN0YXRlLmZpbGUgPSBjcmVhdGVGaWxlU3R1Yihzb3VyY2UpO1xuXG4gICAgICAgIC8vIHN0YXJ0cyBsb2FkaW5nXG4gICAgICAgIGxvYWRlci5vbignaW5pdCcsICgpID0+IHtcbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtaW5pdCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSdldmUgcmVjZWl2ZWQgYSBzaXplIGluZGljYXRpb24sIGxldCdzIHVwZGF0ZSB0aGUgc3R1YlxuICAgICAgICBsb2FkZXIub24oJ21ldGEnLCBtZXRhID0+IHtcbiAgICAgICAgICAgIC8vIHNldCBzaXplIG9mIGZpbGUgc3R1YlxuICAgICAgICAgICAgc3RhdGUuZmlsZS5zaXplID0gbWV0YS5zaXplO1xuXG4gICAgICAgICAgICAvLyBzZXQgbmFtZSBvZiBmaWxlIHN0dWJcbiAgICAgICAgICAgIHN0YXRlLmZpbGUuZmlsZW5hbWUgPSBtZXRhLmZpbGVuYW1lO1xuXG4gICAgICAgICAgICAvLyBpZiBoYXMgcmVjZWl2ZWQgc291cmNlLCB3ZSBkb25lXG4gICAgICAgICAgICBpZiAobWV0YS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBGaWxlT3JpZ2luLkxJTUJPO1xuICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBtZXRhLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0dXMgPSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNpemUgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRoZSBmaWxlIGlzIG5vdyBsb2FkaW5nIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3JzXG4gICAgICAgIGxvYWRlci5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FESU5HKTtcblxuICAgICAgICAgICAgZmlyZSgnbG9hZC1wcm9ncmVzcycsIHByb2dyZXNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYW4gZXJyb3Igd2FzIHRocm93biB3aGlsZSBsb2FkaW5nIHRoZSBmaWxlLCB3ZSBuZWVkIHRvIHN3aXRjaCB0byBlcnJvciBzdGF0ZVxuICAgICAgICBsb2FkZXIub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuTE9BRF9FUlJPUik7XG5cbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtcmVxdWVzdC1lcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdXNlciBvciBhbm90aGVyIHByb2Nlc3MgYWJvcnRlZCB0aGUgZmlsZSBsb2FkIChjYW5ub3QgcmV0cnkpXG4gICAgICAgIGxvYWRlci5vbignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JTklUKTtcbiAgICAgICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZG9uZSBsb2FkaW5nXG4gICAgICAgIGxvYWRlci5vbignbG9hZCcsIGZpbGUgPT4ge1xuICAgICAgICAgICAgLy8gYXMgd2UndmUgbm93IGxvYWRlZCB0aGUgZmlsZSB0aGUgbG9hZGVyIGlzIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gZmlsZSBoYXMgbG9hZGVkIHN1Y2Nlc2Z1bGx5XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgKHBvc3NpYmx5KSB0cmFuc2Zvcm1lZCBmaWxlXG4gICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGlzRmlsZShyZXN1bHQpID8gcmVzdWx0IDogc3RhdGUuZmlsZTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbGUgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPICYmIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSURMRSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZCcpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHNldCBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgICAgICAgc3RhdGUuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICAgICAgZmlyZSgnbG9hZC1tZXRhJyk7XG5cbiAgICAgICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5MT0FEX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBmaXJlKCdsb2FkLWZpbGUtZXJyb3InLCByZXN1bHQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlLCB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIG9ubG9hZCBtZXRob2RcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHNlcnZlciBpZCwgbGV0J3MgZ2l2ZSB0aGlzIGZpbGUgdGhlIGZ1bGwgdHJlYXRtZW50XG4gICAgICAgICAgICBvbmxvYWQoZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgbG9hZGVyIHNvdXJjZSBkYXRhXG4gICAgICAgIGxvYWRlci5zZXRTb3VyY2Uoc291cmNlKTtcblxuICAgICAgICAvLyBzZXQgYXMgYWN0aXZlIGxvYWRlclxuICAgICAgICBzdGF0ZS5hY3RpdmVMb2FkZXIgPSBsb2FkZXI7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgc291cmNlIGRhdGFcbiAgICAgICAgbG9hZGVyLmxvYWQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmV0cnlMb2FkID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFjdGl2ZUxvYWRlci5sb2FkKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFib3J0TG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZUxvYWRlcikge1xuICAgICAgICAgICAgc3RhdGUuYWN0aXZlTG9hZGVyLmFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuSU5JVCk7XG4gICAgICAgIGZpcmUoJ2xvYWQtYWJvcnQnKTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBsb2dpYyB0byBwcm9jZXNzIGEgZmlsZVxuICAgIC8vXG4gICAgY29uc3QgcHJvY2VzcyA9IChwcm9jZXNzb3IsIG9ucHJvY2VzcykgPT4ge1xuICAgICAgICAvLyBwcm9jZXNzaW5nIHdhcyBhYm9ydGVkXG4gICAgICAgIGlmIChzdGF0ZS5wcm9jZXNzaW5nQWJvcnRlZCkge1xuICAgICAgICAgICAgc3RhdGUucHJvY2Vzc2luZ0Fib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdyBwcm9jZXNzaW5nXG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkcpO1xuXG4gICAgICAgIC8vIHJlc2V0IGFib3J0IGNhbGxiYWNrXG4gICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gaWYgbm8gZmlsZSBsb2FkZWQgd2UnbGwgd2FpdCBmb3IgdGhlIGxvYWQgZXZlbnRcbiAgICAgICAgaWYgKCEoc3RhdGUuZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XG4gICAgICAgICAgICBhcGkub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcyhwcm9jZXNzb3IsIG9ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHVwIHByb2Nlc3NvclxuICAgICAgICBwcm9jZXNzb3Iub24oJ2xvYWQnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIC8vIG5lZWQgdGhpcyBpZCB0byBiZSBhYmxlIHRvIHJldmVydCB0aGUgdXBsb2FkXG4gICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWdpc3RlciB0cmFuc2ZlciBpZFxuICAgICAgICBwcm9jZXNzb3Iub24oJ3RyYW5zZmVyJywgdHJhbnNmZXJJZCA9PiB7XG4gICAgICAgICAgICAvLyBuZWVkIHRoaXMgaWQgdG8gYmUgYWJsZSB0byByZXZlcnQgdGhlIHVwbG9hZFxuICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IHRyYW5zZmVySWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignbG9hZC1wZXJjZWl2ZWQnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIC8vIG5vIGxvbmdlciByZXF1aXJlZFxuICAgICAgICAgICAgc3RhdGUuYWN0aXZlUHJvY2Vzc29yID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGlkIHRvIGJlIGFibGUgdG8gcmV2ZXIgdGhlIHVwbG9hZFxuICAgICAgICAgICAgc3RhdGUudHJhbnNmZXJJZCA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlID0gc2VydmVyRmlsZVJlZmVyZW5jZTtcblxuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSk7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWNvbXBsZXRlJywgc2VydmVyRmlsZVJlZmVyZW5jZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXN0YXJ0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbignZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgc2V0U3RhdHVzKEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19FUlJPUik7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLWVycm9yJywgZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwcm9jZXNzb3Iub24oJ2Fib3J0Jywgc2VydmVyRmlsZVJlZmVyZW5jZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiBmaWxlIHdhcyB1cGxvYWRlZCBidXQgcHJvY2Vzc2luZyB3YXMgY2FuY2VsbGVkIGR1cmluZyBwZXJjZWl2ZWQgcHJvY2Vzc29yIHRpbWUgc3RvcmUgZmlsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBzZXJ2ZXJGaWxlUmVmZXJlbmNlO1xuXG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgICAgLy8gaGFzIHRpbWVvdXQgc28gZG9lc24ndCBpbnRlcmZlcmUgd2l0aCByZW1vdmUgYWN0aW9uXG4gICAgICAgICAgICBpZiAoYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRQcm9jZXNzaW5nUmVxdWVzdENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb2Nlc3Nvci5vbigncHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBmaXJlKCdwcm9jZXNzLXByb2dyZXNzJywgcHJvZ3Jlc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aGVuIHN1Y2Nlc3NmdWxseSB0cmFuc2Zvcm1lZFxuICAgICAgICBjb25zdCBzdWNjZXNzID0gZmlsZSA9PiB7XG4gICAgICAgICAgICAvLyBpZiB3YXMgYXJjaGl2ZWQgaW4gdGhlIG1lYW4gdGltZSwgZG9uJ3QgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFyY2hpdmVkKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZmlsZSFcbiAgICAgICAgICAgIHByb2Nlc3Nvci5wcm9jZXNzKGZpbGUsIHsgLi4ubWV0YWRhdGEgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIHRyYW5zZm9ybSBwaGFzZVxuICAgICAgICBjb25zdCBlcnJvciA9IGNvbnNvbGUuZXJyb3I7XG5cbiAgICAgICAgLy8gc3RhcnQgcHJvY2Vzc2luZyB0aGUgZmlsZVxuICAgICAgICBvbnByb2Nlc3Moc3RhdGUuZmlsZSwgc3VjY2VzcywgZXJyb3IpO1xuXG4gICAgICAgIC8vIHNldCBhcyBhY3RpdmUgcHJvY2Vzc29yXG4gICAgICAgIHN0YXRlLmFjdGl2ZVByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdFByb2Nlc3NpbmcgPSAoKSA9PiB7XG4gICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gZmFsc2U7XG4gICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUVVFVUVEKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYWJvcnRQcm9jZXNzaW5nID0gKCkgPT5cbiAgICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmFjdGl2ZVByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdBYm9ydGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLklETEUpO1xuICAgICAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtYWJvcnQnKTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFib3J0UHJvY2Vzc2luZ1JlcXVlc3RDb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdGF0ZS5hY3RpdmVQcm9jZXNzb3IuYWJvcnQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIGxvZ2ljIHRvIHJldmVydCBhIHByb2Nlc3NlZCBmaWxlXG4gICAgLy9cbiAgICBjb25zdCByZXZlcnQgPSAocmV2ZXJ0RmlsZVVwbG9hZCwgZm9yY2VSZXZlcnQpID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIGEgY29tcGxldGVkIHVwbG9hZCB3aWxsIGhhdmUgYSBzZXJ2ZXJGaWxlUmVmZXJlbmNlLCBhIGZhaWxlZCBjaHVua2VkIHVwbG9hZCB3aGVyZVxuICAgICAgICAgICAgLy8gZ2V0dGluZyBhIHNlcnZlcklkIHN1Y2NlZWRlZCBidXQgPj0wIGNodW5rcyBoYXZlIGJlZW4gdXBsb2FkZWQgd2lsbCBoYXZlIHRyYW5zZmVySWQgc2V0XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJUcmFuc2ZlcklkID1cbiAgICAgICAgICAgICAgICBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlICE9PSBudWxsID8gc3RhdGUuc2VydmVyRmlsZVJlZmVyZW5jZSA6IHN0YXRlLnRyYW5zZmVySWQ7XG5cbiAgICAgICAgICAgIC8vIGNhbm5vdCByZXZlcnQgd2l0aG91dCBhIHNlcnZlciBpZCBmb3IgdGhpcyBwcm9jZXNzXG4gICAgICAgICAgICBpZiAoc2VydmVyVHJhbnNmZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJldmVydCB0aGUgdXBsb2FkIChmaXJlIGFuZCBmb3JnZXQpXG4gICAgICAgICAgICByZXZlcnRGaWxlVXBsb2FkKFxuICAgICAgICAgICAgICAgIHNlcnZlclRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBmaWxlIHNlcnZlciBpZCBhbmQgdHJhbnNmZXIgaWQgYXMgbm93IGl0J3Mgbm90IGF2YWlsYWJsZSBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnNlcnZlckZpbGVSZWZlcmVuY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmFuc2ZlcklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgZXJyb3Igc3RhdGUgd2hlbiByZXZlcnRpbmcgaXMgb3B0aW9uYWwsIGl0IHdpbGwgYWx3YXlzIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJldmVydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb2ggbm8gZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXR1cyhJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgZmlyZSgncHJvY2Vzcy1yZXZlcnQtZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBmaXJlIGV2ZW50XG4gICAgICAgICAgICBzZXRTdGF0dXMoSXRlbVN0YXR1cy5JRExFKTtcbiAgICAgICAgICAgIGZpcmUoJ3Byb2Nlc3MtcmV2ZXJ0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gZXhwb3NlZCBtZXRob2RzXG4gICAgY29uc3Qgc2V0TWV0YWRhdGEgPSAoa2V5LCB2YWx1ZSwgc2lsZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGtleXNbMF07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgICBsZXQgZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IChkYXRhID0gZGF0YVtrZXldKSk7XG5cbiAgICAgICAgLy8gY29tcGFyZSBvbGQgdmFsdWUgYWdhaW5zdCBuZXcgdmFsdWUsIGlmIHRoZXkncmUgdGhlIHNhbWUsIHdlJ3JlIG5vdCB1cGRhdGluZ1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoZGF0YVtsYXN0XSkgPT09IEpTT04uc3RyaW5naWZ5KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB2YWx1ZVxuICAgICAgICBkYXRhW2xhc3RdID0gdmFsdWU7XG5cbiAgICAgICAgLy8gZmlyZSB1cGRhdGVcbiAgICAgICAgZmlyZSgnbWV0YWRhdGEtdXBkYXRlJywge1xuICAgICAgICAgICAga2V5OiByb290LFxuICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhW3Jvb3RdLFxuICAgICAgICAgICAgc2lsZW50LFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0TWV0YWRhdGEgPSBrZXkgPT4gZGVlcENsb25lT2JqZWN0KGtleSA/IG1ldGFkYXRhW2tleV0gOiBtZXRhZGF0YSk7XG5cbiAgICBjb25zdCBhcGkgPSB7XG4gICAgICAgIGlkOiB7IGdldDogKCkgPT4gaWQgfSxcbiAgICAgICAgb3JpZ2luOiB7IGdldDogKCkgPT4gb3JpZ2luLCBzZXQ6IHZhbHVlID0+IChvcmlnaW4gPSB2YWx1ZSkgfSxcbiAgICAgICAgc2VydmVySWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5zZXJ2ZXJGaWxlUmVmZXJlbmNlIH0sXG4gICAgICAgIHRyYW5zZmVySWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS50cmFuc2ZlcklkIH0sXG4gICAgICAgIHN0YXR1czogeyBnZXQ6ICgpID0+IHN0YXRlLnN0YXR1cyB9LFxuICAgICAgICBmaWxlbmFtZTogeyBnZXQ6ICgpID0+IHN0YXRlLmZpbGUubmFtZSB9LFxuICAgICAgICBmaWxlbmFtZVdpdGhvdXRFeHRlbnNpb246IHsgZ2V0OiAoKSA9PiBnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24oc3RhdGUuZmlsZS5uYW1lKSB9LFxuICAgICAgICBmaWxlRXh0ZW5zaW9uOiB7IGdldDogZ2V0RmlsZUV4dGVuc2lvbiB9LFxuICAgICAgICBmaWxlVHlwZTogeyBnZXQ6IGdldEZpbGVUeXBlIH0sXG4gICAgICAgIGZpbGVTaXplOiB7IGdldDogZ2V0RmlsZVNpemUgfSxcbiAgICAgICAgZmlsZTogeyBnZXQ6IGdldEZpbGUgfSxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB7IGdldDogKCkgPT4gc3RhdGUuZmlsZS5fcmVsYXRpdmVQYXRoIH0sXG5cbiAgICAgICAgc291cmNlOiB7IGdldDogKCkgPT4gc3RhdGUuc291cmNlIH0sXG5cbiAgICAgICAgZ2V0TWV0YWRhdGEsXG4gICAgICAgIHNldE1ldGFkYXRhOiAoa2V5LCB2YWx1ZSwgc2lsZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBrZXk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRNZXRhZGF0YShrZXksIGRhdGFba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNZXRhZGF0YShrZXksIHZhbHVlLCBzaWxlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGV4dGVuZDogKG5hbWUsIGhhbmRsZXIpID0+IChpdGVtQVBJW25hbWVdID0gaGFuZGxlciksXG5cbiAgICAgICAgYWJvcnRMb2FkLFxuICAgICAgICByZXRyeUxvYWQsXG4gICAgICAgIHJlcXVlc3RQcm9jZXNzaW5nLFxuICAgICAgICBhYm9ydFByb2Nlc3NpbmcsXG5cbiAgICAgICAgbG9hZCxcbiAgICAgICAgcHJvY2VzcyxcbiAgICAgICAgcmV2ZXJ0LFxuXG4gICAgICAgIC4uLm9uKCksXG5cbiAgICAgICAgZnJlZXplOiAoKSA9PiAoc3RhdGUuZnJvemVuID0gdHJ1ZSksXG5cbiAgICAgICAgcmVsZWFzZTogKCkgPT4gKHN0YXRlLnJlbGVhc2VkID0gdHJ1ZSksXG4gICAgICAgIHJlbGVhc2VkOiB7IGdldDogKCkgPT4gc3RhdGUucmVsZWFzZWQgfSxcblxuICAgICAgICBhcmNoaXZlOiAoKSA9PiAoc3RhdGUuYXJjaGl2ZWQgPSB0cnVlKSxcbiAgICAgICAgYXJjaGl2ZWQ6IHsgZ2V0OiAoKSA9PiBzdGF0ZS5hcmNoaXZlZCB9LFxuXG4gICAgICAgIC8vIHJlcGxhY2Ugc291cmNlIGFuZCBmaWxlIG9iamVjdFxuICAgICAgICBzZXRGaWxlOiBmaWxlID0+IChzdGF0ZS5maWxlID0gZmlsZSksXG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBpdCBoZXJlIGluc3RlYWQgb2YgcmV0dXJuaW5nIGl0IGluc3RhbnRseSBzbyB3ZSBjYW4gZXh0ZW5kIGl0IGxhdGVyXG4gICAgY29uc3QgaXRlbUFQSSA9IGNyZWF0ZU9iamVjdChhcGkpO1xuXG4gICAgcmV0dXJuIGl0ZW1BUEk7XG59O1xuXG5jb25zdCBnZXRJdGVtSW5kZXhCeVF1ZXJ5ID0gKGl0ZW1zLCBxdWVyeSkgPT4ge1xuICAgIC8vIGp1c3QgcmV0dXJuIGZpcnN0IGluZGV4XG4gICAgaWYgKGlzRW1wdHkocXVlcnkpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIGludmFsaWQgcXVlcmllc1xuICAgIGlmICghaXNTdHJpbmcocXVlcnkpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gaXRlbSBieSBpZCAob3IgLTEgaWYgbm90IGZvdW5kKVxuICAgIHJldHVybiBpdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmlkID09PSBxdWVyeSk7XG59O1xuXG5jb25zdCBnZXRJdGVtQnlJZCA9IChpdGVtcywgaXRlbUlkKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBnZXRJdGVtSW5kZXhCeVF1ZXJ5KGl0ZW1zLCBpdGVtSWQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXNbaW5kZXhdIHx8IG51bGw7XG59O1xuXG5jb25zdCBmZXRjaEJsb2IgPSAodXJsLCBsb2FkLCBlcnJvciwgcHJvZ3Jlc3MsIGFib3J0LCBoZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHNlbmRSZXF1ZXN0KG51bGwsIHVybCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICByZXNwb25zZVR5cGU6ICdibG9iJyxcbiAgICB9KTtcblxuICAgIHJlcXVlc3Qub25sb2FkID0geGhyID0+IHtcbiAgICAgICAgLy8gZ2V0IGhlYWRlcnNcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTtcblxuICAgICAgICAvLyBnZXQgZmlsZW5hbWVcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBnZXRGaWxlSW5mb0Zyb21IZWFkZXJzKGhlYWRlcnMpLm5hbWUgfHwgZ2V0RmlsZW5hbWVGcm9tVVJMKHVybCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlXG4gICAgICAgIGxvYWQoY3JlYXRlUmVzcG9uc2UoJ2xvYWQnLCB4aHIuc3RhdHVzLCBnZXRGaWxlRnJvbUJsb2IoeGhyLnJlc3BvbnNlLCBmaWxlbmFtZSksIGhlYWRlcnMpKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbmVycm9yID0geGhyID0+IHtcbiAgICAgICAgZXJyb3IoY3JlYXRlUmVzcG9uc2UoJ2Vycm9yJywgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uaGVhZGVycyA9IHhociA9PiB7XG4gICAgICAgIGhlYWRlcnMoY3JlYXRlUmVzcG9uc2UoJ2hlYWRlcnMnLCB4aHIuc3RhdHVzLCBudWxsLCB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0UmVzcG9uc2UoZXJyb3IpO1xuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIHJlcXVlc3Qub25hYm9ydCA9IGFib3J0O1xuXG4gICAgLy8gc2hvdWxkIHJldHVybiByZXF1ZXN0XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5jb25zdCBnZXREb21haW5Gcm9tVVJMID0gdXJsID0+IHtcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgdXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIHJldHVybiB1cmxcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2I6JywgJycpXG4gICAgICAgIC5yZXBsYWNlKC8oW2Etel0pPzpcXC9cXC8vLCAnJDEnKVxuICAgICAgICAuc3BsaXQoJy8nKVswXTtcbn07XG5cbmNvbnN0IGlzRXh0ZXJuYWxVUkwgPSB1cmwgPT5cbiAgICAodXJsLmluZGV4T2YoJzonKSA+IC0xIHx8IHVybC5pbmRleE9mKCcvLycpID4gLTEpICYmXG4gICAgZ2V0RG9tYWluRnJvbVVSTChsb2NhdGlvbi5ocmVmKSAhPT0gZ2V0RG9tYWluRnJvbVVSTCh1cmwpO1xuXG5jb25zdCBkeW5hbWljTGFiZWwgPSBsYWJlbCA9PiAoLi4ucGFyYW1zKSA9PiAoaXNGdW5jdGlvbihsYWJlbCkgPyBsYWJlbCguLi5wYXJhbXMpIDogbGFiZWwpO1xuXG5jb25zdCBpc01vY2tJdGVtID0gaXRlbSA9PiAhaXNGaWxlKGl0ZW0uZmlsZSk7XG5cbmNvbnN0IGxpc3RVcGRhdGVkID0gKGRpc3BhdGNoLCBzdGF0ZSkgPT4ge1xuICAgIGNsZWFyVGltZW91dChzdGF0ZS5saXN0VXBkYXRlVGltZW91dCk7XG4gICAgc3RhdGUubGlzdFVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTVMnLCB7IGl0ZW1zOiBnZXRBY3RpdmVJdGVtcyhzdGF0ZS5pdGVtcykgfSk7XG4gICAgfSwgMCk7XG59O1xuXG5jb25zdCBvcHRpb25hbFByb21pc2UgPSAoZm4sIC4uLnBhcmFtcykgPT5cbiAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBmbiguLi5wYXJhbXMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzdWx0LnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuY29uc3Qgc29ydEl0ZW1zID0gKHN0YXRlLCBjb21wYXJlKSA9PiB7XG4gICAgc3RhdGUuaXRlbXMuc29ydCgoYSwgYikgPT4gY29tcGFyZShjcmVhdGVJdGVtQVBJKGEpLCBjcmVhdGVJdGVtQVBJKGIpKSk7XG59O1xuXG4vLyByZXR1cm5zIGl0ZW0gYmFzZWQgb24gc3RhdGVcbmNvbnN0IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlID0gKHN0YXRlLCBpdGVtSGFuZGxlcikgPT4gKHtcbiAgICBxdWVyeSxcbiAgICBzdWNjZXNzID0gKCkgPT4ge30sXG4gICAgZmFpbHVyZSA9ICgpID0+IHt9LFxuICAgIC4uLm9wdGlvbnNcbn0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRJdGVtQnlRdWVyeShzdGF0ZS5pdGVtcywgcXVlcnkpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgICBmYWlsdXJlKHtcbiAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnSXRlbSBub3QgZm91bmQnKSxcbiAgICAgICAgICAgIGZpbGU6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW1IYW5kbGVyKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMgfHwge30pO1xufTtcblxuY29uc3QgYWN0aW9ucyA9IChkaXNwYXRjaCwgcXVlcnksIHN0YXRlKSA9PiAoe1xuICAgIC8qKlxuICAgICAqIEFib3J0cyBhbGwgb25nb2luZyBwcm9jZXNzZXNcbiAgICAgKi9cbiAgICBBQk9SVF9BTEw6ICgpID0+IHtcbiAgICAgICAgZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBpdGVtLmZyZWV6ZSgpO1xuICAgICAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICAgICAgICAgIGl0ZW0uYWJvcnRQcm9jZXNzaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGluaXRpYWwgZmlsZXNcbiAgICAgKi9cbiAgICBESURfU0VUX0ZJTEVTOiAoeyB2YWx1ZSA9IFtdIH0pID0+IHtcbiAgICAgICAgLy8gbWFwIHZhbHVlcyB0byBmaWxlIG9iamVjdHNcbiAgICAgICAgY29uc3QgZmlsZXMgPSB2YWx1ZS5tYXAoZmlsZSA9PiAoe1xuICAgICAgICAgICAgc291cmNlOiBmaWxlLnNvdXJjZSA/IGZpbGUuc291cmNlIDogZmlsZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGZpbGUub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIGxvb3Agb3ZlciBmaWxlcywgaWYgZmlsZSBpcyBpbiBsaXN0LCBsZWF2ZSBpdCBiZSwgaWYgbm90LCByZW1vdmVcbiAgICAgICAgLy8gdGVzdCBpZiBpdGVtcyBzaG91bGQgYmUgbW92ZWRcbiAgICAgICAgbGV0IGFjdGl2ZUl0ZW1zID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpO1xuXG4gICAgICAgIGFjdGl2ZUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBpdGVtIG5vdCBpcyBpbiBuZXcgdmFsdWUsIHJlbW92ZVxuICAgICAgICAgICAgaWYgKCFmaWxlcy5maW5kKGZpbGUgPT4gZmlsZS5zb3VyY2UgPT09IGl0ZW0uc291cmNlIHx8IGZpbGUuc291cmNlID09PSBpdGVtLmZpbGUpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ1JFTU9WRV9JVEVNJywgeyBxdWVyeTogaXRlbSwgcmVtb3ZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIG5ldyBmaWxlc1xuICAgICAgICBhY3RpdmVJdGVtcyA9IGdldEFjdGl2ZUl0ZW1zKHN0YXRlLml0ZW1zKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIGZpbGUgaXMgYWxyZWFkeSBpbiBsaXN0XG4gICAgICAgICAgICBpZiAoYWN0aXZlSXRlbXMuZmluZChpdGVtID0+IGl0ZW0uc291cmNlID09PSBmaWxlLnNvdXJjZSB8fCBpdGVtLmZpbGUgPT09IGZpbGUuc291cmNlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIG5vdCBpbiBsaXN0LCBhZGRcbiAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5OT05FLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBESURfVVBEQVRFX0lURU1fTUVUQURBVEE6ICh7IGlkLCBhY3Rpb24sIGNoYW5nZSB9KSA9PiB7XG4gICAgICAgIC8vIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChjaGFuZ2Uuc2lsZW50KSByZXR1cm47XG5cbiAgICAgICAgLy8gaWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIGNsb3NlIHN1Y2Nlc3Npb24gd2UgY29tYmluZWQgYWxsIGNhbGxzIHRvZ2V0aGVyIHRvIHNhdmUgcmVzb3VyY2VzXG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS5pdGVtVXBkYXRlVGltZW91dCk7XG4gICAgICAgIHN0YXRlLml0ZW1VcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0SXRlbUJ5SWQoc3RhdGUuaXRlbXMsIGlkKTtcblxuICAgICAgICAgICAgLy8gb25seSByZXZlcnQgYW5kIGF0dGVtcHQgdG8gdXBsb2FkIHdoZW4gd2UncmUgdXBsb2FkaW5nIHRvIGEgc2VydmVyXG4gICAgICAgICAgICBpZiAoIXF1ZXJ5KCdJU19BU1lOQycpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIHdlIHVwZGF0ZSB0aGUgb3V0cHV0IGRhdGFcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdTSE9VTERfUFJFUEFSRV9PVVRQVVQnLCBmYWxzZSwge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UsXG4gICAgICAgICAgICAgICAgfSkudGhlbihzaG91bGRQcmVwYXJlT3V0cHV0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVQcmVwYXJlRmlsZSA9IHF1ZXJ5KCdHRVRfQkVGT1JFX1BSRVBBUkVfRklMRScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlUHJlcGFyZUZpbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRQcmVwYXJlT3V0cHV0KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkLCBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpcyBsb2NhbCBpdGVtIHdlIG5lZWQgdG8gZW5hYmxlIHVwbG9hZCBidXR0b24gc28gY2hhbmdlIGNhbiBiZSBwcm9wYWdhdGVkIHRvIHNlcnZlclxuICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxPQ0FMKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyRmlsZVJlZmVyZW5jZTogaXRlbS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvciBhc3luYyBzY2VuYXJpb3NcbiAgICAgICAgICAgIGNvbnN0IHVwbG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBwdXNoIHRoaXMgZm9yd2FyZCBhIGJpdCBzbyB0aGUgaW50ZXJmYWNlIGlzIHVwZGF0ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICAgICAgICAgIH0sIDMyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IHJldmVydCA9IGRvVXBsb2FkID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnJldmVydChcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZPUkNFX1JFVkVSVCcpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihkb1VwbG9hZCA/IHVwbG9hZCA6ICgpID0+IHt9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgYWJvcnQgPSBkb1VwbG9hZCA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKGRvVXBsb2FkID8gdXBsb2FkIDogKCkgPT4ge30pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIHJlLXVwbG9hZCB0aGUgZmlsZSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2ZXJ0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRseSB1cGxvYWRpbmcsIGNhbmNlbCB1cGxvYWRcbiAgICAgICAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFib3J0KHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQpIHtcbiAgICAgICAgICAgICAgICB1cGxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfSxcblxuICAgIE1PVkVfSVRFTTogKHsgcXVlcnksIGluZGV4IH0pID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBxdWVyeSk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBzdGF0ZS5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpbmRleCA9IGxpbWl0KGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gaW5kZXgpIHJldHVybjtcbiAgICAgICAgc3RhdGUuaXRlbXMuc3BsaWNlKGluZGV4LCAwLCBzdGF0ZS5pdGVtcy5zcGxpY2UoY3VycmVudEluZGV4LCAxKVswXSk7XG4gICAgfSxcblxuICAgIFNPUlQ6ICh7IGNvbXBhcmUgfSkgPT4ge1xuICAgICAgICBzb3J0SXRlbXMoc3RhdGUsIGNvbXBhcmUpO1xuICAgICAgICBkaXNwYXRjaCgnRElEX1NPUlRfSVRFTVMnLCB7XG4gICAgICAgICAgICBpdGVtczogcXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIEFERF9JVEVNUzogKHsgaXRlbXMsIGluZGV4LCBpbnRlcmFjdGlvbk1ldGhvZCwgc3VjY2VzcyA9ICgpID0+IHt9LCBmYWlsdXJlID0gKCkgPT4ge30gfSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCB0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsSXRlbXMgPSBxdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgICAgICAgICBjdXJyZW50SW5kZXggPSBpbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAwIDogdG90YWxJdGVtcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlnbm9yZWRGaWxlcyA9IHF1ZXJ5KCdHRVRfSUdOT1JFRF9GSUxFUycpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkRmlsZSA9IHNvdXJjZSA9PlxuICAgICAgICAgICAgaXNGaWxlKHNvdXJjZSkgPyAhaWdub3JlZEZpbGVzLmluY2x1ZGVzKHNvdXJjZS5uYW1lLnRvTG93ZXJDYXNlKCkpIDogIWlzRW1wdHkoc291cmNlKTtcbiAgICAgICAgY29uc3QgdmFsaWRJdGVtcyA9IGl0ZW1zLmZpbHRlcihpc1ZhbGlkRmlsZSk7XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB2YWxpZEl0ZW1zLm1hcChcbiAgICAgICAgICAgIHNvdXJjZSA9PlxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0FERF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZS5zb3VyY2UgfHwgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNvdXJjZS5vcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oc3VjY2VzcylcbiAgICAgICAgICAgIC5jYXRjaChmYWlsdXJlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNvdXJjZVxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwYXJhbSBpbnRlcmFjdGlvbk1ldGhvZFxuICAgICAqL1xuICAgIEFERF9JVEVNOiAoe1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGludGVyYWN0aW9uTWV0aG9kLFxuICAgICAgICBzdWNjZXNzID0gKCkgPT4ge30sXG4gICAgICAgIGZhaWx1cmUgPSAoKSA9PiB7fSxcbiAgICAgICAgb3B0aW9ucyA9IHt9LFxuICAgIH0pID0+IHtcbiAgICAgICAgLy8gaWYgbm8gc291cmNlIHN1cHBsaWVkXG4gICAgICAgIGlmIChpc0VtcHR5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCAnTm8gc291cmNlJyksXG4gICAgICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbnZhbGlkIGZpbGUgaXRlbXMsIHVzZWQgdG8gZmlsdGVyIGRyb3BwZWQgZGlyZWN0b3J5IGNvbnRlbnRzXG4gICAgICAgIGlmIChpc0ZpbGUoc291cmNlKSAmJiBzdGF0ZS5vcHRpb25zLmlnbm9yZWRGaWxlcy5pbmNsdWRlcyhzb3VyY2UubmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgLy8gZmFpbCBzaWxlbnRseVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVzdCBpZiB0aGVyZSdzIHN0aWxsIHJvb20gaW4gdGhlIGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgaWYgKCFoYXNSb29tRm9ySXRlbShzdGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIGlmIG11bHRpcGxlIGFsbG93ZWQsIHdlIGNhbid0IHJlcGxhY2VcbiAgICAgICAgICAgIC8vIG9yIGlmIG9ubHkgYSBzaW5nbGUgaXRlbSBpcyBhbGxvd2VkIGJ1dCB3ZSdyZSBub3QgYWxsb3dlZCB0byByZXBsYWNlIGl0IHdlIGV4aXRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLmFsbG93TXVsdGlwbGUgfHxcbiAgICAgICAgICAgICAgICAoIXN0YXRlLm9wdGlvbnMuYWxsb3dNdWx0aXBsZSAmJiAhc3RhdGUub3B0aW9ucy5hbGxvd1JlcGxhY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGNyZWF0ZVJlc3BvbnNlKCd3YXJuaW5nJywgMCwgJ01heCBmaWxlcycpO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19NQVhfRklMRVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3IsIGZpbGU6IG51bGwgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxldCdzIHJlcGxhY2UgdGhlIGl0ZW1cbiAgICAgICAgICAgIC8vIGlkIG9mIGZpcnN0IGl0ZW0gd2UncmUgYWJvdXQgdG8gcmVtb3ZlXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2V0QWN0aXZlSXRlbXMoc3RhdGUuaXRlbXMpWzBdO1xuXG4gICAgICAgICAgICAvLyBpZiBoYXMgYmVlbiBwcm9jZXNzZWQgcmVtb3ZlIGl0IGZyb20gdGhlIHNlcnZlciBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSB8fFxuICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfUkVWRVJUX0VSUk9SXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JjZVJldmVydCA9IHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJyk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZXZlcnQoXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJldmVydEZ1bmN0aW9uKHN0YXRlLm9wdGlvbnMuc2VydmVyLnVybCwgc3RhdGUub3B0aW9ucy5zZXJ2ZXIucmV2ZXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VSZXZlcnRcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm9yY2VSZXZlcnQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGFkZCBub3dcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdBRERfSVRFTScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25NZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsdXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHt9KTsgLy8gbm8gbmVlZCB0byBoYW5kbGUgdGhpcyBjYXRjaCBzdGF0ZSBmb3Igbm93XG5cbiAgICAgICAgICAgICAgICBpZiAoZm9yY2VSZXZlcnQpIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGZpcnN0IGl0ZW0gYXMgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGlzIGl0ZW1cbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3aGVyZSBkaWQgdGhlIGZpbGUgb3JpZ2luYXRlXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPT09ICdsb2NhbCdcbiAgICAgICAgICAgICAgICA/IEZpbGVPcmlnaW4uTE9DQUxcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMudHlwZSA9PT0gJ2xpbWJvJ1xuICAgICAgICAgICAgICAgID8gRmlsZU9yaWdpbi5MSU1CT1xuICAgICAgICAgICAgICAgIDogRmlsZU9yaWdpbi5JTlBVVDtcblxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYmxhbmsgaXRlbVxuICAgICAgICBjb25zdCBpdGVtID0gY3JlYXRlSXRlbShcbiAgICAgICAgICAgIC8vIHdoZXJlIGRpZCB0aGlzIGZpbGUgY29tZSBmcm9tXG4gICAgICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgICAgIC8vIGFuIGlucHV0IGZpbGUgbmV2ZXIgaGFzIGEgc2VydmVyIGZpbGUgcmVmZXJlbmNlXG4gICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVQgPyBudWxsIDogc291cmNlLFxuXG4gICAgICAgICAgICAvLyBmaWxlIG1vY2sgZGF0YSwgaWYgZGVmaW5lZFxuICAgICAgICAgICAgb3B0aW9ucy5maWxlXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gc2V0IGluaXRpYWwgbWV0YSBkYXRhXG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMubWV0YWRhdGEgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGl0ZW0uc2V0TWV0YWRhdGEoa2V5LCBvcHRpb25zLm1ldGFkYXRhW2tleV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGVkIHRoZSBpdGVtLCBsZXQgcGx1Z2lucyBhZGQgbWV0aG9kc1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0RJRF9DUkVBVEVfSVRFTScsIGl0ZW0sIHsgcXVlcnksIGRpc3BhdGNoIH0pO1xuXG4gICAgICAgIC8vIHdoZXJlIHRvIGluc2VydCBuZXcgaXRlbXNcbiAgICAgICAgY29uc3QgaXRlbUluc2VydExvY2F0aW9uID0gcXVlcnkoJ0dFVF9JVEVNX0lOU0VSVF9MT0NBVElPTicpO1xuXG4gICAgICAgIC8vIGFkanVzdCBpbmRleCBpZiBpcyBub3QgYWxsb3dlZCB0byBwaWNrIGxvY2F0aW9uXG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pdGVtSW5zZXJ0TG9jYXRpb25GcmVlZG9tKSB7XG4gICAgICAgICAgICBpbmRleCA9IGl0ZW1JbnNlcnRMb2NhdGlvbiA9PT0gJ2JlZm9yZScgPyAtMSA6IHN0YXRlLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBpdGVtIHRvIGxpc3RcbiAgICAgICAgaW5zZXJ0SXRlbShzdGF0ZS5pdGVtcywgaXRlbSwgaW5kZXgpO1xuXG4gICAgICAgIC8vIHNvcnQgaXRlbXMgaW4gbGlzdFxuICAgICAgICBpZiAoaXNGdW5jdGlvbihpdGVtSW5zZXJ0TG9jYXRpb24pICYmIHNvdXJjZSkge1xuICAgICAgICAgICAgc29ydEl0ZW1zKHN0YXRlLCBpdGVtSW5zZXJ0TG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGEgcXVpY2sgcmVmZXJlbmNlIHRvIHRoZSBpdGVtIGlkXG4gICAgICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcblxuICAgICAgICAvLyBvYnNlcnZlIGl0ZW0gZXZlbnRzXG4gICAgICAgIGl0ZW0ub24oJ2luaXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0lOSVRfSVRFTScsIHsgaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ2xvYWQtaW5pdCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfU1RBUlRfSVRFTV9MT0FEJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1tZXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9VUERBVEVfSVRFTV9NRVRBJywgeyBpZCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1wcm9ncmVzcycsIHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUycsIHsgaWQsIHByb2dyZXNzIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXJlcXVlc3QtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYWluU3RhdHVzID0gZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlTG9hZEVycm9yKShlcnJvcik7XG5cbiAgICAgICAgICAgIC8vIGlzIGNsaWVudCBlcnJvciwgbm8gd2F5IHRvIHJlY292ZXJcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID49IDQwMCAmJiBlcnJvci5jb2RlIDwgNTAwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBtYWluU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBgJHtlcnJvci5jb2RlfSAoJHtlcnJvci5ib2R5fSlgLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVqZWN0IHRoZSBmaWxlIHNvIGNhbiBiZSBkZWFsdCB3aXRoIHRocm91Z2ggQVBJXG4gICAgICAgICAgICAgICAgZmFpbHVyZSh7IGVycm9yLCBmaWxlOiBjcmVhdGVJdGVtQVBJKGl0ZW0pIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaXMgcG9zc2libGUgc2VydmVyIGVycm9yLCBzbyBtaWdodCBiZSBwb3NzaWJsZSB0byByZXRyeVxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0xPQURfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgIG1haW46IG1haW5TdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIHN1Yjogc3RhdGUub3B0aW9ucy5sYWJlbFRhcFRvUmV0cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLWZpbGUtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1RIUk9XX0lURU1fSU5WQUxJRCcsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXR1czogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3I6IGVycm9yLnN0YXR1cywgZmlsZTogY3JlYXRlSXRlbUFQSShpdGVtKSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbignbG9hZC1hYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGlkIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkLXNraXAnLCAoKSA9PiB7XG4gICAgICAgICAgICBpdGVtLm9uKCdtZXRhZGF0YS11cGRhdGUnLCBjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNGaWxlKGl0ZW0uZmlsZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX01FVEFEQVRBJywgeyBpZCwgY2hhbmdlIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRpc3BhdGNoKCdDT01QTEVURV9MT0FEX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGlkLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdGVtLm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQWRkID0gc2hvdWxkQWRkID0+IHtcbiAgICAgICAgICAgICAgICAvLyBubyBzaG91bGQgbm90IGFkZCB0aGlzIGZpbGVcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZEFkZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IGludGVyZXN0ZWQgaW4gbWV0YWRhdGEgdXBkYXRlc1xuICAgICAgICAgICAgICAgIGl0ZW0ub24oJ21ldGFkYXRhLXVwZGF0ZScsIGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVVBEQVRFX0lURU1fTUVUQURBVEEnLCB7IGlkLCBjaGFuZ2UgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBsZXQgcGx1Z2lucyBkZWNpZGUgaWYgdGhlIG91dHB1dCBkYXRhIHNob3VsZCBiZSBwcmVwYXJlZCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gbWVhbnMgd2UnbGwgZG8gdGhpcyBhbmQgd2FpdCBmb3IgaWRsZSBzdGF0ZVxuICAgICAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1NIT1VMRF9QUkVQQVJFX09VVFBVVCcsIGZhbHNlLCB7IGl0ZW0sIHF1ZXJ5IH0pLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFByZXBhcmVPdXRwdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGx1Z2lucyBkZXRlcm1pbmVkIHRoZSBvdXRwdXQgZGF0YSBzaG91bGQgYmUgcHJlcGFyZWQgKG9yIG5vdCksIGNhbiBiZSBhZGp1c3RlZCB3aXRoIGJlZm9yZVByZXBhcmVPdXRwdXQgaG9va1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlUHJlcGFyZUZpbGUgPSBxdWVyeSgnR0VUX0JFRk9SRV9QUkVQQVJFX0ZJTEUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmVQcmVwYXJlRmlsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRQcmVwYXJlT3V0cHV0ID0gYmVmb3JlUHJlcGFyZUZpbGUoaXRlbSwgc2hvdWxkUHJlcGFyZU91dHB1dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRDb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnQ09NUExFVEVfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFByZXBhcmVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGZvciBpZGxlIHN0YXRlIGFuZCB0aGVuIHJ1biBQUkVQQVJFX09VVFBVVFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnUkVRVUVTVF9QUkVQQVJFX09VVFBVVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZCwgZmlsZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpdGVtIGxvYWRlZCwgYWxsb3cgcGx1Z2lucyB0b1xuICAgICAgICAgICAgLy8gLSByZWFkIGRhdGEgKHF1aWNrbHkpXG4gICAgICAgICAgICAvLyAtIGFkZCBtZXRhZGF0YVxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignRElEX0xPQURfSVRFTScsIGl0ZW0sIHsgcXVlcnksIGRpc3BhdGNoIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFByb21pc2UocXVlcnkoJ0dFVF9CRUZPUkVfQUREX0ZJTEUnKSwgY3JlYXRlSXRlbUFQSShpdGVtKSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUFkZFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWUgfHwgIWUuZXJyb3IgfHwgIWUuc3RhdHVzKSByZXR1cm4gaGFuZGxlQWRkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX0lOVkFMSUQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3Mtc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcHJvZ3Jlc3MnLCBwcm9ncmVzcyA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1MnLCB7IGlkLCBwcm9ncmVzcyB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXRlbS5vbigncHJvY2Vzcy1lcnJvcicsIGVycm9yID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nRXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0LWVycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfUkVWRVJUX0VSUk9SJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgICAgICAgICBtYWluOiBkeW5hbWljTGFiZWwoc3RhdGUub3B0aW9ucy5sYWJlbEZpbGVQcm9jZXNzaW5nUmV2ZXJ0RXJyb3IpKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtY29tcGxldGUnLCBzZXJ2ZXJGaWxlUmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJywge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZCwgdmFsdWU6IHNlcnZlckZpbGVSZWZlcmVuY2UgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0ZW0ub24oJ3Byb2Nlc3MtcmV2ZXJ0JywgKCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJywgeyBpZCB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfREVGSU5FX1ZBTFVFJywgeyBpZCwgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxldCB2aWV3IGtub3cgdGhlIGl0ZW0gaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9BRERfSVRFTScsIHsgaWQsIGluZGV4LCBpbnRlcmFjdGlvbk1ldGhvZCB9KTtcblxuICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGxvYWRpbmcgdGhlIHNvdXJjZVxuICAgICAgICBjb25zdCB7IHVybCwgbG9hZCwgcmVzdG9yZSwgZmV0Y2ggfSA9IHN0YXRlLm9wdGlvbnMuc2VydmVyIHx8IHt9O1xuXG4gICAgICAgIGl0ZW0ubG9hZChcbiAgICAgICAgICAgIHNvdXJjZSxcblxuICAgICAgICAgICAgLy8gdGhpcyBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBsb2FkcyB0aGUgZmlsZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBmaWxlIChzdHJpbmcsIGJhc2U2NCwgYmxvYiwgZmlsZSkgYW5kIGxvY2F0aW9uIG9mIGZpbGUgKGxvY2FsLCByZW1vdGUsIGxpbWJvKVxuICAgICAgICAgICAgY3JlYXRlRmlsZUxvYWRlcihcbiAgICAgICAgICAgICAgICBvcmlnaW4gPT09IEZpbGVPcmlnaW4uSU5QVVRcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBpbnB1dCwgaWYgaXMgcmVtb3RlLCBzZWUgaWYgc2hvdWxkIHVzZSBjdXN0b20gZmV0Y2gsIGVsc2UgdXNlIGRlZmF1bHQgZmV0Y2hCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgaXNTdHJpbmcoc291cmNlKSAmJiBpc0V4dGVybmFsVVJMKHNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZldGNoRnVuY3Rpb24odXJsLCBmZXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyByZW1vdGUgdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZldGNoQmxvYiAvLyB0cnkgdG8gZmV0Y2ggdXJsXG4gICAgICAgICAgICAgICAgICAgIDogLy8gbGltYm8gb3IgbG9jYWxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPXG4gICAgICAgICAgICAgICAgICAgID8gY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIHJlc3RvcmUpIC8vIGxpbWJvXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlRmV0Y2hGdW5jdGlvbih1cmwsIGxvYWQpIC8vIGxvY2FsXG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBsb2FkZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIGZpbHRlcnNcbiAgICAgICAgICAgIChmaWxlLCBzdWNjZXNzLCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGxldCdzIHByb2Nlc3MgdGhlIGZpbGVcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdMT0FEX0ZJTEUnLCBmaWxlLCB7IHF1ZXJ5IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIFJFUVVFU1RfUFJFUEFSRV9PVVRQVVQ6ICh7IGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUgPSAoKSA9PiB7fSB9KSA9PiB7XG4gICAgICAgIC8vIGVycm9yIHJlc3BvbnNlIGlmIGl0ZW0gYXJjaGl2ZWRcbiAgICAgICAgY29uc3QgZXJyID0ge1xuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZVJlc3BvbnNlKCdlcnJvcicsIDAsICdJdGVtIG5vdCBmb3VuZCcpLFxuICAgICAgICAgICAgZmlsZTogbnVsbCxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIHdhaXRpbmcgdG8gYmUgcHJlcGFyZWRcbiAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgLy8gYWxsb3cgcGx1Z2lucyB0byBhbHRlciB0aGUgZmlsZSBkYXRhXG4gICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ1BSRVBBUkVfT1VUUFVUJywgaXRlbS5maWxlLCB7IHF1ZXJ5LCBpdGVtIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0NPTVBMRVRFX1BSRVBBUkVfT1VUUFVUJywgcmVzdWx0LCB7IHF1ZXJ5LCBpdGVtIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBoYW5kbGUgYXJjaGl2ZWQgaXRlbXMsIGFuIGl0ZW0gY291bGQgaGF2ZSBiZWVuIGFyY2hpdmVkIChsb2FkIGFib3J0ZWQpIHdoaWxlIGJlaW5nIHByZXBhcmVkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYXJjaGl2ZWQpIHJldHVybiBmYWlsdXJlKGVycik7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBkb25lIVxuICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgQ09NUExFVEVfTE9BRF9JVEVNOiAoeyBpdGVtLCBkYXRhIH0pID0+IHtcbiAgICAgICAgY29uc3QgeyBzdWNjZXNzLCBzb3VyY2UgfSA9IGRhdGE7XG5cbiAgICAgICAgLy8gc29ydCBpdGVtcyBpbiBsaXN0XG4gICAgICAgIGNvbnN0IGl0ZW1JbnNlcnRMb2NhdGlvbiA9IHF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT04nKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaXRlbUluc2VydExvY2F0aW9uKSAmJiBzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvcnRJdGVtcyhzdGF0ZSwgaXRlbUluc2VydExvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxldCBpbnRlcmZhY2Uga25vdyB0aGUgaXRlbSBoYXMgbG9hZGVkXG4gICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9JVEVNJywge1xuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIHNlcnZlckZpbGVSZWZlcmVuY2U6IGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLklOUFVUID8gbnVsbCA6IHNvdXJjZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaXRlbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbG9hZGVkIGFuZCBhZGRlZCB0byB0aGVcbiAgICAgICAgLy8gbGlzdCBvZiBpdGVtcyBzbyBjYW4gbm93IGJlIHNhZmVseSByZXR1cm5lZCBmb3IgdXNlXG4gICAgICAgIHN1Y2Nlc3MoY3JlYXRlSXRlbUFQSShpdGVtKSk7XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxvY2FsIHNlcnZlciBmaWxlIHdlIG5lZWQgdG8gc2hvdyBhIGRpZmZlcmVudCBzdGF0ZVxuICAgICAgICBpZiAoaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfTE9BRF9MT0NBTF9JVEVNJywgeyBpZDogaXRlbS5pZCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGlzIGEgdGVtcCBzZXJ2ZXIgZmlsZSB3ZSBwcmV2ZW50IGFzeW5jIHVwbG9hZCBjYWxsIGhlcmUgKGFzIHRoZSBmaWxlIGlzIGFscmVhZHkgb24gdGhlIHNlcnZlcilcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luID09PSBGaWxlT3JpZ2luLkxJTUJPKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJGaWxlUmVmZXJlbmNlOiBzb3VyY2UsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGlzcGF0Y2goJ0RJRF9ERUZJTkVfVkFMVUUnLCB7XG4gICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0uc2VydmVySWQgfHwgc291cmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZCB3ZSBhcmUgYWxsb3dlZCB0byB1cGxvYWQgdGhlIGZpbGUgaW1tZWRpYXRlbHksIGxldHMgZG8gaXRcbiAgICAgICAgaWYgKHF1ZXJ5KCdJU19BU1lOQycpICYmIHN0YXRlLm9wdGlvbnMuaW5zdGFudFVwbG9hZCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HJywgeyBxdWVyeTogaXRlbS5pZCB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBSRVRSWV9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtID0+IHtcbiAgICAgICAgLy8gdHJ5IGxvYWRpbmcgdGhlIHNvdXJjZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgIGl0ZW0ucmV0cnlMb2FkKCk7XG4gICAgfSksXG5cbiAgICBSRVFVRVNUX0lURU1fUFJFUEFSRTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIChpdGVtLCBzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgJ1JFUVVFU1RfUFJFUEFSRV9PVVRQVVQnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUFJFUEFSRV9PVVRQVVQnLCB7IGlkOiBpdGVtLmlkLCBmaWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGZpbGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgfSksXG5cbiAgICBSRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIChpdGVtLCBzdWNjZXNzLCBmYWlsdXJlKSA9PiB7XG4gICAgICAgIC8vIGNhbm5vdCBiZSBxdWV1ZWQgKG9yIGlzIGFscmVhZHkgcXVldWVkKVxuICAgICAgICBjb25zdCBpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nID1cbiAgICAgICAgICAgIC8vIHdhaXRpbmcgZm9yIHNvbWV0aGluZ1xuICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuSURMRSB8fFxuICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyB3ZW50IHdyb25nIGVhcmxpZXJcbiAgICAgICAgICAgIGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkdfRVJST1I7XG5cbiAgICAgICAgLy8gbm90IHJlYWR5IHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICBpZiAoIWl0ZW1DYW5CZVF1ZXVlZEZvclByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NOb3cgPSAoKSA9PlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSAoKSA9PiAoZG9jdW1lbnQuaGlkZGVuID8gcHJvY2Vzc05vdygpIDogc2V0VGltZW91dChwcm9jZXNzTm93LCAzMikpO1xuXG4gICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGRvbmUgcHJvY2Vzc2luZyBvciB0cmllZCB0byByZXZlcnQgYnV0IGRpZG4ndCB3b3JrLCB0cnkgYWdhaW5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX0NPTVBMRVRFIHx8XG4gICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19SRVZFUlRfRVJST1JcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7fSk7IC8vIGRvbid0IGNvbnRpbnVlIHdpdGggcHJvY2Vzc2luZyBpZiBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLnN0YXR1cyA9PT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hYm9ydFByb2Nlc3NpbmcoKS50aGVuKHByb2Nlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHJlYWR5IHF1ZXVlZCBmb3IgcHJvY2Vzc2luZ1xuICAgICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19RVUVVRUQpIHJldHVybjtcblxuICAgICAgICBpdGVtLnJlcXVlc3RQcm9jZXNzaW5nKCk7XG5cbiAgICAgICAgZGlzcGF0Y2goJ0RJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG5cbiAgICAgICAgZGlzcGF0Y2goJ1BST0NFU1NfSVRFTScsIHsgcXVlcnk6IGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUgfSwgdHJ1ZSk7XG4gICAgfSksXG5cbiAgICBQUk9DRVNTX0lURU06IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCAoaXRlbSwgc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXhQYXJhbGxlbFVwbG9hZHMgPSBxdWVyeSgnR0VUX01BWF9QQVJBTExFTF9VUExPQURTJyk7XG4gICAgICAgIGNvbnN0IHRvdGFsQ3VycmVudFVwbG9hZHMgPSBxdWVyeSgnR0VUX0lURU1TX0JZX1NUQVRVUycsIEl0ZW1TdGF0dXMuUFJPQ0VTU0lORykubGVuZ3RoO1xuXG4gICAgICAgIC8vIHF1ZXVlIGFuZCB3YWl0IHRpbGwgcXVldWUgaXMgZnJlZWQgdXBcbiAgICAgICAgaWYgKHRvdGFsQ3VycmVudFVwbG9hZHMgPT09IG1heFBhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAgICAgLy8gcXVldWUgZm9yIGxhdGVyIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzLFxuICAgICAgICAgICAgICAgIGZhaWx1cmUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gc3RvcCBpdCFcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdhcyBub3QgcXVldWVkIG9yIGlzIGFscmVhZHkgcHJvY2Vzc2luZyBleGl0IGhlcmVcbiAgICAgICAgaWYgKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcpIHJldHVybjtcblxuICAgICAgICBjb25zdCBwcm9jZXNzTmV4dCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWV1ZCBpdGVtc1xuICAgICAgICAgICAgY29uc3QgcXVldWVFbnRyeSA9IHN0YXRlLnByb2Nlc3NpbmdRdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgICAvLyBubyBpdGVtcyBsZWZ0XG4gICAgICAgICAgICBpZiAoIXF1ZXVlRW50cnkpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gZ2V0IGl0ZW0gcmVmZXJlbmNlXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdWNjZXNzLCBmYWlsdXJlIH0gPSBxdWV1ZUVudHJ5O1xuICAgICAgICAgICAgY29uc3QgaXRlbVJlZmVyZW5jZSA9IGdldEl0ZW1CeVF1ZXJ5KHN0YXRlLml0ZW1zLCBpZCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGl0ZW0gd2FzIGFyY2hpdmVkIHdoaWxlIGluIHF1ZXVlLCBqdW1wIHRvIG5leHRcbiAgICAgICAgICAgIGlmICghaXRlbVJlZmVyZW5jZSB8fCBpdGVtUmVmZXJlbmNlLmFyY2hpdmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc05leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgcXVldWVkIGl0ZW1cbiAgICAgICAgICAgIGRpc3BhdGNoKCdQUk9DRVNTX0lURU0nLCB7IHF1ZXJ5OiBpZCwgc3VjY2VzcywgZmFpbHVyZSB9LCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB3ZSBkb25lIGZ1bmN0aW9uXG4gICAgICAgIGl0ZW0ub25PbmNlKCdwcm9jZXNzLWNvbXBsZXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgICAgIHByb2Nlc3NOZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIGlmIG9yaWdpbiBpcyBsb2NhbCwgYW5kIHdlJ3JlIGluc3RhbnQgdXBsb2FkaW5nLCB0cmlnZ2VyIHJlbW92ZSBvZiBvcmlnaW5hbFxuICAgICAgICAgICAgLy8gYXMgcmV2ZXJ0IHdpbGwgcmVtb3ZlIGZpbGUgZnJvbSBsaXN0XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSBzdGF0ZS5vcHRpb25zLnNlcnZlcjtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbnRVcGxvYWQgPSBzdGF0ZS5vcHRpb25zLmluc3RhbnRVcGxvYWQ7XG4gICAgICAgICAgICBpZiAoaW5zdGFudFVwbG9hZCAmJiBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJiBpc0Z1bmN0aW9uKHNlcnZlci5yZW1vdmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuICAgICAgICAgICAgICAgIGl0ZW0ub3JpZ2luID0gRmlsZU9yaWdpbi5MSU1CTztcbiAgICAgICAgICAgICAgICBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZW1vdmUoaXRlbS5zb3VyY2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbGwgaXRlbXMgcHJvY2Vzc2VkPyBObyBlcnJvcnM/XG4gICAgICAgICAgICBjb25zdCBhbGxJdGVtc1Byb2Nlc3NlZCA9XG4gICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9JVEVNU19CWV9TVEFUVVMnLCBJdGVtU3RhdHVzLlBST0NFU1NJTkdfQ09NUExFVEUpLmxlbmd0aCA9PT1cbiAgICAgICAgICAgICAgICBzdGF0ZS5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYWxsSXRlbXNQcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lOR19BTEwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gd2UgZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgaXRlbS5vbk9uY2UoJ3Byb2Nlc3MtZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBmYWlsdXJlKHsgZXJyb3IsIGZpbGU6IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgfSk7XG4gICAgICAgICAgICBwcm9jZXNzTmV4dCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzdGFydCBmaWxlIHByb2Nlc3NpbmdcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICAgIGl0ZW0ucHJvY2VzcyhcbiAgICAgICAgICAgIGNyZWF0ZUZpbGVQcm9jZXNzb3IoXG4gICAgICAgICAgICAgICAgY3JlYXRlUHJvY2Vzc29yRnVuY3Rpb24ob3B0aW9ucy5zZXJ2ZXIudXJsLCBvcHRpb25zLnNlcnZlci5wcm9jZXNzLCBvcHRpb25zLm5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtUcmFuc2ZlcklkOiBpdGVtLnRyYW5zZmVySWQsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rU2VydmVyOiBvcHRpb25zLnNlcnZlci5wYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtVcGxvYWRzOiBvcHRpb25zLmNodW5rVXBsb2FkcyxcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtGb3JjZTogb3B0aW9ucy5jaHVua0ZvcmNlLFxuICAgICAgICAgICAgICAgICAgICBjaHVua1NpemU6IG9wdGlvbnMuY2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgICBjaHVua1JldHJ5RGVsYXlzOiBvcHRpb25zLmNodW5rUmV0cnlEZWxheXMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd01pbmltdW1VcGxvYWREdXJhdGlvbjogcXVlcnkoJ0dFVF9BTExPV19NSU5JTVVNX1VQTE9BRF9EVVJBVElPTicpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgZmlsZSBpcyBhYm91dCB0byBiZSBwcm9jZXNzZWQgc28gaXQgY2FuIGJlIHBpcGVkIHRocm91Z2ggdGhlIHRyYW5zZm9ybSBmaWx0ZXJzXG4gICAgICAgICAgICAoZmlsZSwgc3VjY2VzcywgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBwbHVnaW5zIHRvIGFsdGVyIHRoZSBmaWxlIGRhdGFcbiAgICAgICAgICAgICAgICBhcHBseUZpbHRlckNoYWluKCdQUkVQQVJFX09VVFBVVCcsIGZpbGUsIHsgcXVlcnksIGl0ZW0gfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnRElEX1BSRVBBUkVfT1VUUFVUJywgeyBpZDogaXRlbS5pZCwgZmlsZSB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9KSxcblxuICAgIFJFVFJZX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBkaXNwYXRjaCgnUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgIH0pLFxuXG4gICAgUkVRVUVTVF9SRU1PVkVfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBvcHRpb25hbFByb21pc2UocXVlcnkoJ0dFVF9CRUZPUkVfUkVNT1ZFX0ZJTEUnKSwgY3JlYXRlSXRlbUFQSShpdGVtKSkudGhlbihzaG91bGRSZW1vdmUgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGRSZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtIH0pO1xuICAgICAgICB9KTtcbiAgICB9KSxcblxuICAgIFJFTEVBU0VfSVRFTTogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICBpdGVtLnJlbGVhc2UoKTtcbiAgICB9KSxcblxuICAgIFJFTU9WRV9JVEVNOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgKGl0ZW0sIHN1Y2Nlc3MsIGZhaWx1cmUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlRnJvbVZpZXcgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyBnZXQgaWQgcmVmZXJlbmNlXG4gICAgICAgICAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG5cbiAgICAgICAgICAgIC8vIGFyY2hpdmUgdGhlIGl0ZW0sIHRoaXMgZG9lcyBub3QgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgIGdldEl0ZW1CeUlkKHN0YXRlLml0ZW1zLCBpZCkuYXJjaGl2ZSgpO1xuXG4gICAgICAgICAgICAvLyB0ZWxsIHRoZSB2aWV3IHRoZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGRpc3BhdGNoKCdESURfUkVNT1ZFX0lURU0nLCB7IGVycm9yOiBudWxsLCBpZCwgaXRlbSB9KTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSBsaXN0IGhhcyBiZWVuIG1vZGlmaWVkXG4gICAgICAgICAgICBsaXN0VXBkYXRlZChkaXNwYXRjaCwgc3RhdGUpO1xuXG4gICAgICAgICAgICAvLyBjb3JyZWN0bHkgcmVtb3ZlZFxuICAgICAgICAgICAgc3VjY2VzcyhjcmVhdGVJdGVtQVBJKGl0ZW0pKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgbG9jYWwgZmlsZSBhbmQgdGhlIGBzZXJ2ZXIucmVtb3ZlYCBmdW5jdGlvbiBoYXMgYmVlbiBjb25maWd1cmVkLFxuICAgICAgICAvLyBzZW5kIHNvdXJjZSB0aGVyZSBzbyBkZXYgY2FuIHJlbW92ZSBmaWxlIGZyb20gc2VydmVyXG4gICAgICAgIGNvbnN0IHNlcnZlciA9IHN0YXRlLm9wdGlvbnMuc2VydmVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTCAmJlxuICAgICAgICAgICAgc2VydmVyICYmXG4gICAgICAgICAgICBpc0Z1bmN0aW9uKHNlcnZlci5yZW1vdmUpICYmXG4gICAgICAgICAgICBvcHRpb25zLnJlbW92ZSAhPT0gZmFsc2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnRElEX1NUQVJUX0lURU1fUkVNT1ZFJywgeyBpZDogaXRlbS5pZCB9KTtcblxuICAgICAgICAgICAgc2VydmVyLnJlbW92ZShcbiAgICAgICAgICAgICAgICBpdGVtLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAoKSA9PiByZW1vdmVGcm9tVmlldygpLFxuICAgICAgICAgICAgICAgIHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1InLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnZXJyb3InLCAwLCBzdGF0dXMsIG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZHluYW1pY0xhYmVsKHN0YXRlLm9wdGlvbnMubGFiZWxGaWxlUmVtb3ZlRXJyb3IpKHN0YXR1cyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBzdGF0ZS5vcHRpb25zLmxhYmVsVGFwVG9SZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBpcyByZXF1ZXN0aW5nIHJldmVydCBhbmQgY2FuIHJldmVydCBuZWVkIHRvIGNhbGwgcmV2ZXJ0IGhhbmRsZXIgKG5vdCBjYWxsaW5nIHJlcXVlc3RfIGJlY2F1c2UgdGhhdCB3b3VsZCBhbHNvIHRyaWdnZXIgYmVmb3JlUmVtb3ZlSG9vaylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAob3B0aW9ucy5yZXZlcnQgJiYgaXRlbS5vcmlnaW4gIT09IEZpbGVPcmlnaW4uTE9DQUwgJiYgaXRlbS5zZXJ2ZXJJZCAhPT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAvLyBpZiBjaHVua2VkIHVwbG9hZHMgYXJlIGVuYWJsZWQgYW5kIHdlJ3JlIHVwbG9hZGluZyBpbiBjaHVua3MgZm9yIHRoaXMgc3BlY2lmaWMgZmlsZVxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBmaWxlIGlzbid0IGJpZyBlbm91Z2ggZm9yIGNodW5rZWQgdXBsb2FkcyBidXQgY2h1bmtGb3JjZSBpcyBzZXQgdGhlbiBjYWxsXG4gICAgICAgICAgICAgICAgLy8gcmV2ZXJ0IGJlZm9yZSByZW1vdmluZyBmcm9tIHRoZSB2aWV3Li4uXG4gICAgICAgICAgICAgICAgKHN0YXRlLm9wdGlvbnMuY2h1bmtVcGxvYWRzICYmIGl0ZW0uZmlsZS5zaXplID4gc3RhdGUub3B0aW9ucy5jaHVua1NpemUpIHx8XG4gICAgICAgICAgICAgICAgKHN0YXRlLm9wdGlvbnMuY2h1bmtVcGxvYWRzICYmIHN0YXRlLm9wdGlvbnMuY2h1bmtGb3JjZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXZlcnRGdW5jdGlvbihzdGF0ZS5vcHRpb25zLnNlcnZlci51cmwsIHN0YXRlLm9wdGlvbnMuc2VydmVyLnJldmVydCksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5KCdHRVRfRk9SQ0VfUkVWRVJUJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYW4gbm93IHNhZmVseSByZW1vdmUgZnJvbSB2aWV3XG4gICAgICAgICAgICByZW1vdmVGcm9tVmlldygpO1xuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBBQk9SVF9JVEVNX0xPQUQ6IGdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlKHN0YXRlLCBpdGVtID0+IHtcbiAgICAgICAgaXRlbS5hYm9ydExvYWQoKTtcbiAgICB9KSxcblxuICAgIEFCT1JUX0lURU1fUFJPQ0VTU0lORzogZ2V0SXRlbUJ5UXVlcnlGcm9tU3RhdGUoc3RhdGUsIGl0ZW0gPT4ge1xuICAgICAgICAvLyB0ZXN0IGlmIGlzIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgIGlmIChpdGVtLnNlcnZlcklkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgaWQ6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhYm9ydFxuICAgICAgICBpdGVtLmFib3J0UHJvY2Vzc2luZygpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkO1xuICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKCdSRU1PVkVfSVRFTScsIHsgcXVlcnk6IGl0ZW0uaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pLFxuXG4gICAgUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIC8vIG5vdCBpbnN0YW50IHVwbG9hZGluZywgcmV2ZXJ0IGltbWVkaWF0ZWx5XG4gICAgICAgIGlmICghc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkKSB7XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSdyZSBpbnN0YW50IHVwbG9hZGluZyB0aGUgZmlsZSB3aWxsIGFsc28gYmUgcmVtb3ZlZCBpZiB3ZSByZXZlcnQsXG4gICAgICAgIC8vIHNvIGlmIGEgYmVmb3JlIHJlbW92ZSBmaWxlIGhvb2sgaXMgZGVmaW5lZCB3ZSBuZWVkIHRvIHJ1biBpdCBub3dcbiAgICAgICAgY29uc3QgaGFuZGxlUmV2ZXJ0ID0gc2hvdWxkUmV2ZXJ0ID0+IHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkUmV2ZXJ0KSByZXR1cm47XG4gICAgICAgICAgICBkaXNwYXRjaCgnUkVWRVJUX0lURU1fUFJPQ0VTU0lORycsIHsgcXVlcnk6IGl0ZW0gfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZm4gPSBxdWVyeSgnR0VUX0JFRk9SRV9SRU1PVkVfRklMRScpO1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdFJlbW92ZVJlc3VsdCA9IGZuKGNyZWF0ZUl0ZW1BUEkoaXRlbSkpO1xuICAgICAgICBpZiAocmVxdWVzdFJlbW92ZVJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJldmVydCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdFJlbW92ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUmV2ZXJ0KHJlcXVlc3RSZW1vdmVSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UmVtb3ZlUmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcXVlc3RSZW1vdmVSZXN1bHQudGhlbihoYW5kbGVSZXZlcnQpO1xuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBSRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBnZXRJdGVtQnlRdWVyeUZyb21TdGF0ZShzdGF0ZSwgaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0ucmV2ZXJ0KFxuICAgICAgICAgICAgY3JlYXRlUmV2ZXJ0RnVuY3Rpb24oc3RhdGUub3B0aW9ucy5zZXJ2ZXIudXJsLCBzdGF0ZS5vcHRpb25zLnNlcnZlci5yZXZlcnQpLFxuICAgICAgICAgICAgcXVlcnkoJ0dFVF9GT1JDRV9SRVZFUlQnKVxuICAgICAgICApXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlID0gc3RhdGUub3B0aW9ucy5pbnN0YW50VXBsb2FkIHx8IGlzTW9ja0l0ZW0oaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IHF1ZXJ5OiBpdGVtLmlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4ge30pO1xuICAgIH0pLFxuXG4gICAgU0VUX09QVElPTlM6ICh7IG9wdGlvbnMgfSkgPT4ge1xuICAgICAgICAvLyBnZXQgYWxsIGtleXMgcGFzc2VkXG4gICAgICAgIGNvbnN0IG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcblxuICAgICAgICAvLyBnZXQgcHJpb3JpdGl6ZWQga2V5ZWQgdG8gaW5jbHVkZSAocmVtb3ZlIG9uY2Ugbm90IGluIG9wdGlvbnMgb2JqZWN0KVxuICAgICAgICBjb25zdCBwcmlvcml0aXplZE9wdGlvbktleXMgPSBQcmlvcml0aXplZE9wdGlvbnMuZmlsdGVyKGtleSA9PiBvcHRpb25LZXlzLmluY2x1ZGVzKGtleSkpO1xuXG4gICAgICAgIC8vIG9yZGVyIHRoZSBrZXlzLCBwcmlvcml0aXplZCBmaXJzdCwgdGhlbiByZXN0XG4gICAgICAgIGNvbnN0IG9yZGVyZWRPcHRpb25LZXlzID0gW1xuICAgICAgICAgICAgLy8gYWRkIHByaW9yaXRpemVkIGZpcnN0IGlmIHBhc3NlZCB0byBvcHRpb25zLCBlbHNlIHJlbW92ZVxuICAgICAgICAgICAgLi4ucHJpb3JpdGl6ZWRPcHRpb25LZXlzLFxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGR1cGxpY2F0ZSBrZXlzXG4gICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoa2V5ID0+ICFwcmlvcml0aXplZE9wdGlvbktleXMuaW5jbHVkZXMoa2V5KSksXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gZGlzcGF0Y2ggc2V0IGV2ZW50IGZvciBlYWNoIG9wdGlvblxuICAgICAgICBvcmRlcmVkT3B0aW9uS2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBkaXNwYXRjaChgU0VUXyR7ZnJvbUNhbWVscyhrZXksICdfJykudG9VcHBlckNhc2UoKX1gLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNba2V5XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IFByaW9yaXRpemVkT3B0aW9ucyA9IFtcbiAgICAnc2VydmVyJywgLy8gbXVzdCBiZSBwcm9jZXNzZWQgYmVmb3JlIFwiZmlsZXNcIlxuXTtcblxuY29uc3QgZm9ybWF0RmlsZW5hbWUgPSBuYW1lID0+IG5hbWU7XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnQkMSA9IHRhZ05hbWUgPT4ge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xufTtcblxuY29uc3QgdGV4dCA9IChub2RlLCB2YWx1ZSkgPT4ge1xuICAgIGxldCB0ZXh0Tm9kZSA9IG5vZGUuY2hpbGROb2Rlc1swXTtcbiAgICBpZiAoIXRleHROb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0ZXh0Tm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgfVxufTtcblxuY29uc3QgcG9sYXJUb0NhcnRlc2lhbiA9IChjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSA9PiB7XG4gICAgY29uc3QgYW5nbGVJblJhZGlhbnMgPSAoKChhbmdsZUluRGVncmVlcyAlIDM2MCkgLSA5MCkgKiBNYXRoLlBJKSAvIDE4MC4wO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNlbnRlclggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZUluUmFkaWFucyksXG4gICAgICAgIHk6IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUluUmFkaWFucyksXG4gICAgfTtcbn07XG5cbmNvbnN0IGRlc2NyaWJlQXJjID0gKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFyY1N3ZWVwKSA9PiB7XG4gICAgY29uc3Qgc3RhcnQgPSBwb2xhclRvQ2FydGVzaWFuKHgsIHksIHJhZGl1cywgZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZCA9IHBvbGFyVG9DYXJ0ZXNpYW4oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlKTtcbiAgICByZXR1cm4gWydNJywgc3RhcnQueCwgc3RhcnQueSwgJ0EnLCByYWRpdXMsIHJhZGl1cywgMCwgYXJjU3dlZXAsIDAsIGVuZC54LCBlbmQueV0uam9pbignICcpO1xufTtcblxuY29uc3QgcGVyY2VudGFnZUFyYyA9ICh4LCB5LCByYWRpdXMsIGZyb20sIHRvKSA9PiB7XG4gICAgbGV0IGFyY1N3ZWVwID0gMTtcbiAgICBpZiAodG8gPiBmcm9tICYmIHRvIC0gZnJvbSA8PSAwLjUpIHtcbiAgICAgICAgYXJjU3dlZXAgPSAwO1xuICAgIH1cbiAgICBpZiAoZnJvbSA+IHRvICYmIGZyb20gLSB0byA+PSAwLjUpIHtcbiAgICAgICAgYXJjU3dlZXAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpYmVBcmMoXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgTWF0aC5taW4oMC45OTk5LCBmcm9tKSAqIDM2MCxcbiAgICAgICAgTWF0aC5taW4oMC45OTk5LCB0bykgKiAzNjAsXG4gICAgICAgIGFyY1N3ZWVwXG4gICAgKTtcbn07XG5cbmNvbnN0IGNyZWF0ZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBzdGFydCBhdCAwXG4gICAgcHJvcHMuc3BpbiA9IGZhbHNlO1xuICAgIHByb3BzLnByb2dyZXNzID0gMDtcbiAgICBwcm9wcy5vcGFjaXR5ID0gMDtcblxuICAgIC8vIHN2Z1xuICAgIGNvbnN0IHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuICAgIHJvb3QucmVmLnBhdGggPSBjcmVhdGVFbGVtZW50KCdwYXRoJywge1xuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJyxcbiAgICB9KTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQocm9vdC5yZWYucGF0aCk7XG5cbiAgICByb290LnJlZi5zdmcgPSBzdmc7XG5cbiAgICByb290LmFwcGVuZENoaWxkKHN2Zyk7XG59O1xuXG5jb25zdCB3cml0ZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICBpZiAocHJvcHMub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmFsaWduKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcHJvcHMuYWxpZ247XG4gICAgfVxuXG4gICAgLy8gZ2V0IHdpZHRoIG9mIHN0cm9rZVxuICAgIGNvbnN0IHJpbmdTdHJva2VXaWR0aCA9IHBhcnNlSW50KGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS13aWR0aCcpLCAxMCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgc2l6ZSBvZiByaW5nXG4gICAgY29uc3Qgc2l6ZSA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoICogMC41O1xuXG4gICAgLy8gcmluZyBzdGF0ZVxuICAgIGxldCByaW5nRnJvbSA9IDA7XG4gICAgbGV0IHJpbmdUbyA9IDA7XG5cbiAgICAvLyBub3cgaW4gYnVzeSBtb2RlXG4gICAgaWYgKHByb3BzLnNwaW4pIHtcbiAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICByaW5nVG8gPSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmluZ0Zyb20gPSAwO1xuICAgICAgICByaW5nVG8gPSBwcm9wcy5wcm9ncmVzcztcbiAgICB9XG5cbiAgICAvLyBnZXQgYXJjIHBhdGhcbiAgICBjb25zdCBjb29yZGluYXRlcyA9IHBlcmNlbnRhZ2VBcmMoc2l6ZSwgc2l6ZSwgc2l6ZSAtIHJpbmdTdHJva2VXaWR0aCwgcmluZ0Zyb20sIHJpbmdUbyk7XG5cbiAgICAvLyB1cGRhdGUgcHJvZ3Jlc3MgYmFyXG4gICAgYXR0cihyb290LnJlZi5wYXRoLCAnZCcsIGNvb3JkaW5hdGVzKTtcblxuICAgIC8vIGhpZGUgd2hpbGUgY29udGFpbnMgMCB2YWx1ZVxuICAgIGF0dHIocm9vdC5yZWYucGF0aCwgJ3N0cm9rZS1vcGFjaXR5JywgcHJvcHMuc3BpbiB8fCBwcm9wcy5wcm9ncmVzcyA+IDAgPyAxIDogMCk7XG59O1xuXG5jb25zdCBwcm9ncmVzc0luZGljYXRvciA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2RpdicsXG4gICAgbmFtZTogJ3Byb2dyZXNzLWluZGljYXRvcicsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGNyZWF0ZSxcbiAgICB3cml0ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydwcm9ncmVzcycsICdzcGluJywgJ2FsaWduJ10sXG4gICAgICAgIHN0eWxlczogWydvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDUwMCB9LFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ByaW5nJyxcbiAgICAgICAgICAgICAgICBzdGlmZm5lc3M6IDAuOTUsXG4gICAgICAgICAgICAgICAgZGFtcGluZzogMC42NSxcbiAgICAgICAgICAgICAgICBtYXNzOiAxMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBjcmVhdGUkMSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICByb290LmVsZW1lbnQuaW5uZXJIVE1MID0gKHByb3BzLmljb24gfHwgJycpICsgYDxzcGFuPiR7cHJvcHMubGFiZWx9PC9zcGFuPmA7XG5cbiAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG5jb25zdCB3cml0ZSQxID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgaXNEaXNhYmxlZCB9ID0gcHJvcHM7XG4gICAgY29uc3Qgc2hvdWxkRGlzYWJsZSA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpIHx8IHByb3BzLm9wYWNpdHkgPT09IDA7XG5cbiAgICBpZiAoc2hvdWxkRGlzYWJsZSAmJiAhaXNEaXNhYmxlZCkge1xuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgYXR0cihyb290LmVsZW1lbnQsICdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgIH0gZWxzZSBpZiAoIXNob3VsZERpc2FibGUgJiYgaXNEaXNhYmxlZCkge1xuICAgICAgICBwcm9wcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxufTtcblxuY29uc3QgZmlsZUFjdGlvbkJ1dHRvbiA9IGNyZWF0ZVZpZXcoe1xuICAgIHRhZzogJ2J1dHRvbicsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICB0eXBlOiAnYnV0dG9uJyxcbiAgICB9LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBuYW1lOiAnZmlsZS1hY3Rpb24tYnV0dG9uJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydsYWJlbCddLFxuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGVuZXJzOiB0cnVlLFxuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMSxcbiAgICB3cml0ZTogd3JpdGUkMSxcbn0pO1xuXG5jb25zdCB0b05hdHVyYWxGaWxlU2l6ZSA9IChieXRlcywgZGVjaW1hbFNlcGFyYXRvciA9ICcuJywgYmFzZSA9IDEwMDAsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgbGFiZWxCeXRlcyA9ICdieXRlcycsXG4gICAgICAgIGxhYmVsS2lsb2J5dGVzID0gJ0tCJyxcbiAgICAgICAgbGFiZWxNZWdhYnl0ZXMgPSAnTUInLFxuICAgICAgICBsYWJlbEdpZ2FieXRlcyA9ICdHQicsXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBubyBuZWdhdGl2ZSBieXRlIHNpemVzXG4gICAgYnl0ZXMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGJ5dGVzKSk7XG5cbiAgICBjb25zdCBLQiA9IGJhc2U7XG4gICAgY29uc3QgTUIgPSBiYXNlICogYmFzZTtcbiAgICBjb25zdCBHQiA9IGJhc2UgKiBiYXNlICogYmFzZTtcblxuICAgIC8vIGp1c3QgYnl0ZXNcbiAgICBpZiAoYnl0ZXMgPCBLQikge1xuICAgICAgICByZXR1cm4gYCR7Ynl0ZXN9ICR7bGFiZWxCeXRlc31gO1xuICAgIH1cblxuICAgIC8vIGtpbG9ieXRlc1xuICAgIGlmIChieXRlcyA8IE1CKSB7XG4gICAgICAgIHJldHVybiBgJHtNYXRoLmZsb29yKGJ5dGVzIC8gS0IpfSAke2xhYmVsS2lsb2J5dGVzfWA7XG4gICAgfVxuXG4gICAgLy8gbWVnYWJ5dGVzXG4gICAgaWYgKGJ5dGVzIDwgR0IpIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW92ZURlY2ltYWxzV2hlblplcm8oYnl0ZXMgLyBNQiwgMSwgZGVjaW1hbFNlcGFyYXRvcil9ICR7bGFiZWxNZWdhYnl0ZXN9YDtcbiAgICB9XG5cbiAgICAvLyBnaWdhYnl0ZXNcbiAgICByZXR1cm4gYCR7cmVtb3ZlRGVjaW1hbHNXaGVuWmVybyhieXRlcyAvIEdCLCAyLCBkZWNpbWFsU2VwYXJhdG9yKX0gJHtsYWJlbEdpZ2FieXRlc31gO1xufTtcblxuY29uc3QgcmVtb3ZlRGVjaW1hbHNXaGVuWmVybyA9ICh2YWx1ZSwgZGVjaW1hbENvdW50LCBzZXBhcmF0b3IpID0+IHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgLnRvRml4ZWQoZGVjaW1hbENvdW50KVxuICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAuZmlsdGVyKHBhcnQgPT4gcGFydCAhPT0gJzAnKVxuICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xufTtcblxuY29uc3QgY3JlYXRlJDIgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gZmlsZW5hbWVcbiAgICBjb25zdCBmaWxlTmFtZSA9IGNyZWF0ZUVsZW1lbnQkMSgnc3BhbicpO1xuICAgIGZpbGVOYW1lLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1pbmZvLW1haW4nO1xuICAgIC8vIGhpZGUgZm9yIHNjcmVlbnJlYWRlcnNcbiAgICAvLyB0aGUgZmlsZSBpcyBjb250YWluZWQgaW4gYSBmaWVsZHNldCB3aXRoIGxlZ2VuZCB0aGF0IGNvbnRhaW5zIHRoZSBmaWxlbmFtZVxuICAgIC8vIG5vIG5lZWQgdG8gcmVhZCBpdCB0d2ljZVxuICAgIGF0dHIoZmlsZU5hbWUsICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChmaWxlTmFtZSk7XG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblxuICAgIC8vIGZpbGVzaXplXG4gICAgY29uc3QgZmlsZVNpemUgPSBjcmVhdGVFbGVtZW50JDEoJ3NwYW4nKTtcbiAgICBmaWxlU2l6ZS5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtaW5mby1zdWInO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZmlsZVNpemUpO1xuICAgIHJvb3QucmVmLmZpbGVTaXplID0gZmlsZVNpemU7XG5cbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICB0ZXh0KGZpbGVTaXplLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9XQUlUSU5HX0ZPUl9TSVpFJykpO1xuICAgIHRleHQoZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbn07XG5cbmNvbnN0IHVwZGF0ZUZpbGUgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgdGV4dChcbiAgICAgICAgcm9vdC5yZWYuZmlsZVNpemUsXG4gICAgICAgIHRvTmF0dXJhbEZpbGVTaXplKFxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSxcbiAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgIHJvb3QucXVlcnkoJ0dFVF9GSUxFX1NJWkVfQkFTRScpLFxuICAgICAgICAgICAgcm9vdC5xdWVyeSgnR0VUX0ZJTEVfU0laRV9MQUJFTFMnLCByb290LnF1ZXJ5KVxuICAgICAgICApXG4gICAgKTtcbiAgICB0ZXh0KHJvb3QucmVmLmZpbGVOYW1lLCBmb3JtYXRGaWxlbmFtZShyb290LnF1ZXJ5KCdHRVRfSVRFTV9OQU1FJywgcHJvcHMuaWQpKSk7XG59O1xuXG5jb25zdCB1cGRhdGVGaWxlU2l6ZU9uRXJyb3IgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gaWYgc2l6ZSBpcyBhdmFpbGFibGUgZG9uJ3QgZmFsbGJhY2sgdG8gdW5rbm93biBzaXplIG1lc3NhZ2VcbiAgICBpZiAoaXNJbnQocm9vdC5xdWVyeSgnR0VUX0lURU1fU0laRScsIHByb3BzLmlkKSkpIHtcbiAgICAgICAgdXBkYXRlRmlsZSh7IHJvb3QsIHByb3BzIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGV4dChyb290LnJlZi5maWxlU2l6ZSwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfU0laRV9OT1RfQVZBSUxBQkxFJykpO1xufTtcblxuY29uc3QgZmlsZUluZm8gPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZmlsZS1pbmZvJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlRmlsZSxcbiAgICAgICAgRElEX1VQREFURV9JVEVNX01FVEE6IHVwZGF0ZUZpbGUsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IHVwZGF0ZUZpbGVTaXplT25FcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogdXBkYXRlRmlsZVNpemVPbkVycm9yLFxuICAgIH0pLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMixcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICB0cmFuc2xhdGVYOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuY29uc3QgdG9QZXJjZW50YWdlID0gdmFsdWUgPT4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMCk7XG5cbmNvbnN0IGNyZWF0ZSQzID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgLy8gbWFpbiBzdGF0dXNcbiAgICBjb25zdCBtYWluID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgbWFpbi5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWZpbGUtc3RhdHVzLW1haW4nO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQobWFpbik7XG4gICAgcm9vdC5yZWYubWFpbiA9IG1haW47XG5cbiAgICAvLyBzdWIgc3RhdHVzXG4gICAgY29uc3Qgc3ViID0gY3JlYXRlRWxlbWVudCQxKCdzcGFuJyk7XG4gICAgc3ViLmNsYXNzTmFtZSA9ICdmaWxlcG9uZC0tZmlsZS1zdGF0dXMtc3ViJztcbiAgICByb290LmFwcGVuZENoaWxkKHN1Yik7XG4gICAgcm9vdC5yZWYuc3ViID0gc3ViO1xuXG4gICAgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyh7IHJvb3QsIGFjdGlvbjogeyBwcm9ncmVzczogbnVsbCB9IH0pO1xufTtcblxuY29uc3QgZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgdGl0bGUgPVxuICAgICAgICBhY3Rpb24ucHJvZ3Jlc3MgPT09IG51bGxcbiAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfTE9BRElORycpXG4gICAgICAgICAgICA6IGAke3Jvb3QucXVlcnkoJ0dFVF9MQUJFTF9GSUxFX0xPQURJTkcnKX0gJHt0b1BlcmNlbnRhZ2UoYWN0aW9uLnByb2dyZXNzKX0lYDtcbiAgICB0ZXh0KHJvb3QucmVmLm1haW4sIHRpdGxlKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG59O1xuXG5jb25zdCBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCB0aXRsZSA9XG4gICAgICAgIGFjdGlvbi5wcm9ncmVzcyA9PT0gbnVsbFxuICAgICAgICAgICAgPyByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HJylcbiAgICAgICAgICAgIDogYCR7cm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpfSAke3RvUGVyY2VudGFnZShhY3Rpb24ucHJvZ3Jlc3MpfSVgO1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgdGl0bGUpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX0NBTkNFTCcpKTtcbn07XG5cbmNvbnN0IGRpZFJlcXVlc3RJdGVtUHJvY2Vzc2luZyA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfUFJPQ0VTU0lORycpKTtcbiAgICB0ZXh0KHJvb3QucmVmLnN1Yiwgcm9vdC5xdWVyeSgnR0VUX0xBQkVMX1RBUF9UT19DQU5DRUwnKSk7XG59O1xuXG5jb25zdCBkaWRBYm9ydEl0ZW1Qcm9jZXNzaW5nID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKSk7XG4gICAgdGV4dChyb290LnJlZi5zdWIsIHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9UQVBfVE9fUkVUUlknKSk7XG59O1xuXG5jb25zdCBkaWRDb21wbGV0ZUl0ZW1Qcm9jZXNzaW5nID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJykpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfVEFQX1RPX1VORE8nKSk7XG59O1xuXG5jb25zdCBjbGVhciA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIHRleHQocm9vdC5yZWYubWFpbiwgJycpO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCAnJyk7XG59O1xuXG5jb25zdCBlcnJvciA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgdGV4dChyb290LnJlZi5tYWluLCBhY3Rpb24uc3RhdHVzLm1haW4pO1xuICAgIHRleHQocm9vdC5yZWYuc3ViLCBhY3Rpb24uc3RhdHVzLnN1Yik7XG59O1xuXG5jb25zdCBmaWxlU3RhdHVzID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ2ZpbGUtc3RhdHVzJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogY2xlYXIsXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjbGVhcixcbiAgICAgICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBkaWRSZXF1ZXN0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGRpZEFib3J0SXRlbVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6IGRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmcsXG4gICAgICAgIERJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTOiBkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogZGlkU2V0SXRlbUxvYWRQcm9ncmVzcyxcbiAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogZXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IGVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBlcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IGVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IGVycm9yLFxuICAgIH0pLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkMyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdvcGFjaXR5J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbi8qKlxuICogQnV0dG9uIGRlZmluaXRpb25zIGZvciB0aGUgZmlsZSB2aWV3XG4gKi9cblxuY29uc3QgQnV0dG9ucyA9IHtcbiAgICBBYm9ydEl0ZW1Mb2FkOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9BQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICBhY3Rpb246ICdBQk9SVF9JVEVNX0xPQUQnLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLWFib3J0LWl0ZW0tbG9hZCcsXG4gICAgICAgIGFsaWduOiAnTE9BRF9JTkRJQ0FUT1JfUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmV0cnlJdGVtTG9hZDoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9MT0FEJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFVFJZJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLWxvYWQnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmVtb3ZlSXRlbToge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVNT1ZFX0lURU0nLFxuICAgICAgICBhY3Rpb246ICdSRVFVRVNUX1JFTU9WRV9JVEVNJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFTU9WRScsXG4gICAgICAgIGNsYXNzTmFtZTogJ2ZpbGVwb25kLS1hY3Rpb24tcmVtb3ZlLWl0ZW0nLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTicsIC8vIGxlZnRcbiAgICB9LFxuICAgIFByb2Nlc3NJdGVtOiB7XG4gICAgICAgIGxhYmVsOiAnR0VUX0xBQkVMX0JVVFRPTl9QUk9DRVNTX0lURU0nLFxuICAgICAgICBhY3Rpb246ICdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsXG4gICAgICAgIGljb246ICdHRVRfSUNPTl9QUk9DRVNTJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1wcm9jZXNzLWl0ZW0nLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgQWJvcnRJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgYWN0aW9uOiAnQUJPUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1hYm9ydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmV0cnlJdGVtUHJvY2Vzc2luZzoge1xuICAgICAgICBsYWJlbDogJ0dFVF9MQUJFTF9CVVRUT05fUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgYWN0aW9uOiAnUkVUUllfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1JFVFJZJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnZmlsZXBvbmQtLWFjdGlvbi1yZXRyeS1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG4gICAgUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHtcbiAgICAgICAgbGFiZWw6ICdHRVRfTEFCRUxfQlVUVE9OX1VORE9fSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgYWN0aW9uOiAnUkVRVUVTVF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgaWNvbjogJ0dFVF9JQ09OX1VORE8nLFxuICAgICAgICBjbGFzc05hbWU6ICdmaWxlcG9uZC0tYWN0aW9uLXJldmVydC1pdGVtLXByb2Nlc3NpbmcnLFxuICAgICAgICBhbGlnbjogJ0JVVFRPTl9QUk9DRVNTX0lURU1fUE9TSVRJT04nLCAvLyByaWdodFxuICAgIH0sXG59O1xuXG4vLyBtYWtlIGEgbGlzdCBvZiBidXR0b25zLCB3ZSBjYW4gdGhlbiByZW1vdmUgYnV0dG9ucyBmcm9tIHRoaXMgbGlzdCBpZiB0aGV5J3JlIGRpc2FibGVkXG5jb25zdCBCdXR0b25LZXlzID0gW107XG5mb3JpbihCdXR0b25zLCBrZXkgPT4ge1xuICAgIEJ1dHRvbktleXMucHVzaChrZXkpO1xufSk7XG5cbmNvbnN0IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0ID0gcm9vdCA9PiB7XG4gICAgaWYgKGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50KHJvb3QpID09PSAncmlnaHQnKSByZXR1cm4gMDtcbiAgICBjb25zdCBidXR0b25SZWN0ID0gcm9vdC5yZWYuYnV0dG9uUmVtb3ZlSXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgcmV0dXJuIGJ1dHRvblJlY3QuaGlkZGVuID8gbnVsbCA6IGJ1dHRvblJlY3Qud2lkdGggKyBidXR0b25SZWN0LmxlZnQ7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVCdXR0b25XaWR0aCA9IHJvb3QgPT4ge1xuICAgIGNvbnN0IGJ1dHRvblJlY3QgPSByb290LnJlZi5idXR0b25BYm9ydEl0ZW1Mb2FkLnJlY3QuZWxlbWVudDtcbiAgICByZXR1cm4gYnV0dG9uUmVjdC53aWR0aDtcbn07XG5cbi8vIEZvcmNlIG9uIGZ1bGwgcGl4ZWxzIHNvIHRleHQgc3RheXMgY3JpcHNcbmNvbnN0IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldCA9IHJvb3QgPT5cbiAgICBNYXRoLmZsb29yKHJvb3QucmVmLmJ1dHRvblJlbW92ZUl0ZW0ucmVjdC5lbGVtZW50LmhlaWdodCAvIDQpO1xuY29uc3QgY2FsY3VsYXRlRmlsZUhvcml6b250YWxDZW50ZXJPZmZzZXQgPSByb290ID0+XG4gICAgTWF0aC5mbG9vcihyb290LnJlZi5idXR0b25SZW1vdmVJdGVtLnJlY3QuZWxlbWVudC5sZWZ0IC8gMik7XG5cbmNvbnN0IGdldExvYWRJbmRpY2F0b3JBbGlnbm1lbnQgPSByb290ID0+IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTicpO1xuY29uc3QgZ2V0UHJvY2Vzc0luZGljYXRvckFsaWdubWVudCA9IHJvb3QgPT4gcm9vdC5xdWVyeSgnR0VUX1NUWUxFX1BST0dSRVNTX0lORElDQVRPUl9QT1NJVElPTicpO1xuY29uc3QgZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQgPSByb290ID0+IHJvb3QucXVlcnkoJ0dFVF9TVFlMRV9CVVRUT05fUkVNT1ZFX0lURU1fUE9TSVRJT04nKTtcblxuY29uc3QgRGVmYXVsdFN0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJldHJ5SXRlbUxvYWQ6IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMCB9LFxuICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDAgfSxcbiAgICBidXR0b25SZXZlcnRJdGVtUHJvY2Vzc2luZzogeyBvcGFjaXR5OiAwIH0sXG4gICAgbG9hZFByb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRMb2FkSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgcHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIGFsaWduOiBnZXRQcm9jZXNzSW5kaWNhdG9yQWxpZ25tZW50IH0sXG4gICAgcHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yOiB7IG9wYWNpdHk6IDAsIHNjYWxlWDogMC43NSwgc2NhbGVZOiAwLjc1IH0sXG4gICAgaW5mbzogeyB0cmFuc2xhdGVYOiAwLCB0cmFuc2xhdGVZOiAwLCBvcGFjaXR5OiAwIH0sXG4gICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IDAsIHRyYW5zbGF0ZVk6IDAsIG9wYWNpdHk6IDAgfSxcbn07XG5cbmNvbnN0IElkbGVTdHlsZSA9IHtcbiAgICBidXR0b25SZW1vdmVJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICBidXR0b25Qcm9jZXNzSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIHN0YXR1czogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxufTtcblxuY29uc3QgUHJvY2Vzc2luZ1N0eWxlID0ge1xuICAgIGJ1dHRvbkFib3J0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgIHByb2Nlc3NQcm9ncmVzc0luZGljYXRvcjogeyBvcGFjaXR5OiAxIH0sXG4gICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbn07XG5cbmNvbnN0IFN0eWxlTWFwID0ge1xuICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0LCBvcGFjaXR5OiAxIH0sXG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiB7XG4gICAgICAgIGJ1dHRvbkFib3J0SXRlbUxvYWQ6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBsb2FkUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgIH0sXG4gICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjoge1xuICAgICAgICBidXR0b25SZXRyeUl0ZW1Mb2FkOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX1JFTU9WRToge1xuICAgICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMSwgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50IH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDAgfSxcbiAgICB9LFxuICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjoge1xuICAgICAgICBwcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3I6IHsgb3BhY2l0eTogMCwgYWxpZ246IGdldFJlbW92ZUluZGljYXRvckFsaWdtZW50IH0sXG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxLCB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIH0sXG4gICAgRElEX0xPQURfSVRFTTogSWRsZVN0eWxlLFxuICAgIERJRF9MT0FEX0xPQ0FMX0lURU06IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGluZm86IHsgdHJhbnNsYXRlWDogY2FsY3VsYXRlRmlsZUluZm9PZmZzZXQgfSxcbiAgICAgICAgc3RhdHVzOiB7IHRyYW5zbGF0ZVg6IGNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IH0sXG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiBQcm9jZXNzaW5nU3R5bGUsXG4gICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6IFByb2Nlc3NpbmdTdHlsZSxcbiAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiB7XG4gICAgICAgIGJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIHN0YXR1czogeyBvcGFjaXR5OiAxIH0sXG4gICAgfSxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiB7XG4gICAgICAgIGJ1dHRvblJlbW92ZUl0ZW06IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBidXR0b25SZXRyeUl0ZW1Qcm9jZXNzaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgc3RhdHVzOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgIH0sXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6IHtcbiAgICAgICAgYnV0dG9uUmV2ZXJ0SXRlbVByb2Nlc3Npbmc6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgICAgICBpbmZvOiB7IG9wYWNpdHk6IDEgfSxcbiAgICB9LFxuICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IHtcbiAgICAgICAgYnV0dG9uUmVtb3ZlSXRlbTogeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgIGJ1dHRvblByb2Nlc3NJdGVtOiB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgaW5mbzogeyB0cmFuc2xhdGVYOiBjYWxjdWxhdGVGaWxlSW5mb09mZnNldCB9LFxuICAgICAgICBzdGF0dXM6IHsgb3BhY2l0eTogMSB9LFxuICAgIH0sXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6IElkbGVTdHlsZSxcbn07XG5cbi8vIGNvbXBsZXRlIGluZGljYXRvciB2aWV3XG5jb25zdCBwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgcm9vdC5lbGVtZW50LmlubmVySFRNTCA9IHJvb3QucXVlcnkoJ0dFVF9JQ09OX0RPTkUnKTtcbiAgICB9LFxuICAgIG5hbWU6ICdwcm9jZXNzaW5nLWNvbXBsZXRlLWluZGljYXRvcicsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDI1MCB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBmaWxlIHZpZXdcbiAqL1xuY29uc3QgY3JlYXRlJDQgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gY29weSBCdXR0b25zIG9iamVjdFxuICAgIGNvbnN0IExvY2FsQnV0dG9ucyA9IE9iamVjdC5rZXlzKEJ1dHRvbnMpLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xuICAgICAgICBwcmV2W2N1cnJdID0geyAuLi5CdXR0b25zW2N1cnJdIH07XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHt9KTtcblxuICAgIGNvbnN0IHsgaWQgfSA9IHByb3BzO1xuXG4gICAgLy8gYWxsb3cgcmV2ZXJ0aW5nIHVwbG9hZFxuICAgIGNvbnN0IGFsbG93UmV2ZXJ0ID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1JFVkVSVCcpO1xuXG4gICAgLy8gYWxsb3cgcmVtb3ZlIGZpbGVcbiAgICBjb25zdCBhbGxvd1JlbW92ZSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19SRU1PVkUnKTtcblxuICAgIC8vIGFsbG93IHByb2Nlc3NpbmcgdXBsb2FkXG4gICAgY29uc3QgYWxsb3dQcm9jZXNzID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BST0NFU1MnKTtcblxuICAgIC8vIGlzIGluc3RhbnQgdXBsb2FkaW5nLCBuZWVkIHRoaXMgdG8gZGV0ZXJtaW5lIHRoZSBpY29uIG9mIHRoZSB1bmRvIGJ1dHRvblxuICAgIGNvbnN0IGluc3RhbnRVcGxvYWQgPSByb290LnF1ZXJ5KCdHRVRfSU5TVEFOVF9VUExPQUQnKTtcblxuICAgIC8vIGlzIGFzeW5jIHNldCB1cFxuICAgIGNvbnN0IGlzQXN5bmMgPSByb290LnF1ZXJ5KCdJU19BU1lOQycpO1xuXG4gICAgLy8gc2hvdWxkIGFsaWduIHJlbW92ZSBpdGVtIGJ1dHRvbnNcbiAgICBjb25zdCBhbGlnblJlbW92ZUl0ZW1CdXR0b24gPSByb290LnF1ZXJ5KCdHRVRfU1RZTEVfQlVUVE9OX1JFTU9WRV9JVEVNX0FMSUdOJyk7XG5cbiAgICAvLyBlbmFibGVkIGJ1dHRvbnMgYXJyYXlcbiAgICBsZXQgYnV0dG9uRmlsdGVyO1xuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICAgIGlmIChhbGxvd1Byb2Nlc3MgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgICAgICAvLyBvbmx5IHJlbW92ZSByZXZlcnQgYnV0dG9uXG4gICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBrZXkgPT4gIS9SZXZlcnRJdGVtUHJvY2Vzc2luZy8udGVzdChrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd1Byb2Nlc3MgJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHByb2Nlc3MgYnV0dG9uXG4gICAgICAgICAgICBidXR0b25GaWx0ZXIgPSBrZXkgPT4gIS9Qcm9jZXNzSXRlbXxSZXRyeUl0ZW1Qcm9jZXNzaW5nfEFib3J0SXRlbVByb2Nlc3NpbmcvLnRlc3Qoa2V5KTtcbiAgICAgICAgfSBlbHNlIGlmICghYWxsb3dQcm9jZXNzICYmICFhbGxvd1JldmVydCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBwcm9jZXNzIGJ1dHRvbnNcbiAgICAgICAgICAgIGJ1dHRvbkZpbHRlciA9IGtleSA9PiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIHByb2Nlc3MgY29udHJvbHMgYXZhaWxhYmxlXG4gICAgICAgIGJ1dHRvbkZpbHRlciA9IGtleSA9PiAhL1Byb2Nlc3MvLnRlc3Qoa2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmFibGVkQnV0dG9ucyA9IGJ1dHRvbkZpbHRlciA/IEJ1dHRvbktleXMuZmlsdGVyKGJ1dHRvbkZpbHRlcikgOiBCdXR0b25LZXlzLmNvbmNhdCgpO1xuXG4gICAgLy8gdXBkYXRlIGljb24gYW5kIGxhYmVsIGZvciByZXZlcnQgYnV0dG9uIHdoZW4gaW5zdGFudCB1cGxvYWRpbmdcbiAgICBpZiAoaW5zdGFudFVwbG9hZCAmJiBhbGxvd1JldmVydCkge1xuICAgICAgICBMb2NhbEJ1dHRvbnNbJ1JldmVydEl0ZW1Qcm9jZXNzaW5nJ10ubGFiZWwgPSAnR0VUX0xBQkVMX0JVVFRPTl9SRU1PVkVfSVRFTSc7XG4gICAgICAgIExvY2FsQnV0dG9uc1snUmV2ZXJ0SXRlbVByb2Nlc3NpbmcnXS5pY29uID0gJ0dFVF9JQ09OX1JFTU9WRSc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGxhc3QgYnV0dG9uIChyZXZlcnQpIGlmIG5vdCBhbGxvd2VkXG4gICAgaWYgKGlzQXN5bmMgJiYgIWFsbG93UmV2ZXJ0KSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSG9yaXpvbnRhbENlbnRlck9mZnNldDtcbiAgICAgICAgbWFwLmluZm8udHJhbnNsYXRlWSA9IGNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldDtcbiAgICAgICAgbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIC8vIHNob3VsZCBhbGlnbiBjZW50ZXJcbiAgICBpZiAoaXNBc3luYyAmJiAhYWxsb3dQcm9jZXNzKSB7XG4gICAgICAgIFtcbiAgICAgICAgICAgICdESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HJyxcbiAgICAgICAgICAgICdESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkcnLFxuICAgICAgICAgICAgJ0RJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTJyxcbiAgICAgICAgICAgICdESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SJyxcbiAgICAgICAgXS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBTdHlsZU1hcFtrZXldLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgU3R5bGVNYXBbJ0RJRF9USFJPV19JVEVNX1BST0NFU1NJTkdfRVJST1InXS5zdGF0dXMudHJhbnNsYXRlWCA9IGNhbGN1bGF0ZUJ1dHRvbldpZHRoO1xuICAgIH1cblxuICAgIC8vIG1vdmUgcmVtb3ZlIGJ1dHRvbiB0byByaWdodFxuICAgIGlmIChhbGlnblJlbW92ZUl0ZW1CdXR0b24gJiYgYWxsb3dSZXZlcnQpIHtcbiAgICAgICAgTG9jYWxCdXR0b25zWydSZXZlcnRJdGVtUHJvY2Vzc2luZyddLmFsaWduID0gJ0JVVFRPTl9SRU1PVkVfSVRFTV9QT1NJVElPTic7XG4gICAgICAgIGNvbnN0IG1hcCA9IFN0eWxlTWFwWydESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HJ107XG4gICAgICAgIG1hcC5pbmZvLnRyYW5zbGF0ZVggPSBjYWxjdWxhdGVGaWxlSW5mb09mZnNldDtcbiAgICAgICAgbWFwLnN0YXR1cy50cmFuc2xhdGVZID0gY2FsY3VsYXRlRmlsZVZlcnRpY2FsQ2VudGVyT2Zmc2V0O1xuICAgICAgICBtYXAucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yID0geyBvcGFjaXR5OiAxLCBzY2FsZVg6IDEsIHNjYWxlWTogMSB9O1xuICAgIH1cblxuICAgIC8vIHNob3cvaGlkZSBSZW1vdmVJdGVtIGJ1dHRvblxuICAgIGlmICghYWxsb3dSZW1vdmUpIHtcbiAgICAgICAgTG9jYWxCdXR0b25zWydSZW1vdmVJdGVtJ10uZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgYnV0dG9uIHZpZXdzXG4gICAgZm9yaW4oTG9jYWxCdXR0b25zLCAoa2V5LCBkZWZpbml0aW9uKSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBidXR0b25cbiAgICAgICAgY29uc3QgYnV0dG9uVmlldyA9IHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVBY3Rpb25CdXR0b24sIHtcbiAgICAgICAgICAgIGxhYmVsOiByb290LnF1ZXJ5KGRlZmluaXRpb24ubGFiZWwpLFxuICAgICAgICAgICAgaWNvbjogcm9vdC5xdWVyeShkZWZpbml0aW9uLmljb24pLFxuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIGFwcGVuZGVkP1xuICAgICAgICBpZiAoZW5hYmxlZEJ1dHRvbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZFZpZXcoYnV0dG9uVmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2dnbGVcbiAgICAgICAgaWYgKGRlZmluaXRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICBidXR0b25WaWV3LmVsZW1lbnQuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnaGlkZGVuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcG9zaXRpb24gYXR0cmlidXRlXG4gICAgICAgIGJ1dHRvblZpZXcuZWxlbWVudC5kYXRhc2V0LmFsaWduID0gcm9vdC5xdWVyeShgR0VUX1NUWUxFXyR7ZGVmaW5pdGlvbi5hbGlnbn1gKTtcblxuICAgICAgICAvLyBhZGQgY2xhc3NcbiAgICAgICAgYnV0dG9uVmlldy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoZGVmaW5pdGlvbi5jbGFzc05hbWUpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBpbnRlcmFjdGlvbnNcbiAgICAgICAgYnV0dG9uVmlldy5vbignY2xpY2snLCBlID0+IHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAoZGVmaW5pdGlvbi5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaChkZWZpbml0aW9uLmFjdGlvbiwgeyBxdWVyeTogaWQgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHNldCByZWZlcmVuY2VcbiAgICAgICAgcm9vdC5yZWZbYGJ1dHRvbiR7a2V5fWBdID0gYnV0dG9uVmlldztcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrbWFya1xuICAgIHJvb3QucmVmLnByb2Nlc3NpbmdDb21wbGV0ZUluZGljYXRvciA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3KVxuICAgICk7XG4gICAgcm9vdC5yZWYucHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yLmVsZW1lbnQuZGF0YXNldC5hbGlnbiA9IHJvb3QucXVlcnkoXG4gICAgICAgIGBHRVRfU1RZTEVfQlVUVE9OX1BST0NFU1NfSVRFTV9QT1NJVElPTmBcbiAgICApO1xuXG4gICAgLy8gY3JlYXRlIGZpbGUgaW5mbyB2aWV3XG4gICAgcm9vdC5yZWYuaW5mbyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGZpbGVJbmZvLCB7IGlkIH0pKTtcblxuICAgIC8vIGNyZWF0ZSBmaWxlIHN0YXR1cyB2aWV3XG4gICAgcm9vdC5yZWYuc3RhdHVzID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZmlsZVN0YXR1cywgeyBpZCB9KSk7XG5cbiAgICAvLyBhZGQgcHJvZ3Jlc3MgaW5kaWNhdG9yc1xuICAgIGNvbnN0IGxvYWRJbmRpY2F0b3JWaWV3ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcoXG4gICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KHByb2dyZXNzSW5kaWNhdG9yLCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgYWxpZ246IHJvb3QucXVlcnkoYEdFVF9TVFlMRV9MT0FEX0lORElDQVRPUl9QT1NJVElPTmApLFxuICAgICAgICB9KVxuICAgICk7XG4gICAgbG9hZEluZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tbG9hZC1pbmRpY2F0b3InKTtcbiAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3IgPSBsb2FkSW5kaWNhdG9yVmlldztcblxuICAgIGNvbnN0IHByb2dyZXNzSW5kaWNhdG9yVmlldyA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhwcm9ncmVzc0luZGljYXRvciwge1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIGFsaWduOiByb290LnF1ZXJ5KGBHRVRfU1RZTEVfUFJPR1JFU1NfSU5ESUNBVE9SX1BPU0lUSU9OYCksXG4gICAgICAgIH0pXG4gICAgKTtcbiAgICBwcm9ncmVzc0luZGljYXRvclZpZXcuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmaWxlcG9uZC0tcHJvY2Vzcy1pbmRpY2F0b3InKTtcbiAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3IgPSBwcm9ncmVzc0luZGljYXRvclZpZXc7XG5cbiAgICAvLyBjdXJyZW50IGFjdGl2ZSBzdHlsZXNcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMgPSBbXTtcbn07XG5cbmNvbnN0IHdyaXRlJDIgPSAoeyByb290LCBhY3Rpb25zLCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gcm91dGUgYWN0aW9uc1xuICAgIHJvdXRlKHsgcm9vdCwgYWN0aW9ucywgcHJvcHMgfSk7XG5cbiAgICAvLyBzZWxlY3QgbGFzdCBzdGF0ZSBjaGFuZ2UgYWN0aW9uXG4gICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgLmNvbmNhdCgpXG4gICAgICAgIC5maWx0ZXIoYWN0aW9uID0+IC9eRElEXy8udGVzdChhY3Rpb24udHlwZSkpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLmZpbmQoYWN0aW9uID0+IFN0eWxlTWFwW2FjdGlvbi50eXBlXSk7XG5cbiAgICAvLyBhIG5ldyBhY3Rpb24gaGFwcGVuZWQsIGxldCdzIGdldCB0aGUgbWF0Y2hpbmcgc3R5bGVzXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgICAvLyBkZWZpbmUgbmV3IGFjdGl2ZSBzdHlsZXNcbiAgICAgICAgcm9vdC5yZWYuYWN0aXZlU3R5bGVzID0gW107XG5cbiAgICAgICAgY29uc3Qgc3R5bGVzVG9BcHBseSA9IFN0eWxlTWFwW2FjdGlvbi50eXBlXTtcbiAgICAgICAgZm9yaW4oRGVmYXVsdFN0eWxlLCAobmFtZSwgZGVmYXVsdFN0eWxlcykgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IHJlZmVyZW5jZSB0byBjb250cm9sXG4gICAgICAgICAgICBjb25zdCBjb250cm9sID0gcm9vdC5yZWZbbmFtZV07XG5cbiAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBhbGwgc3R5bGVzIGZvciB0aGlzIGNvbnRyb2xcbiAgICAgICAgICAgIGZvcmluKGRlZmF1bHRTdHlsZXMsIChrZXksIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzVG9BcHBseVtuYW1lXSAmJiB0eXBlb2Ygc3R5bGVzVG9BcHBseVtuYW1lXVtrZXldICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdHlsZXNUb0FwcGx5W25hbWVdW2tleV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIHJvb3QucmVmLmFjdGl2ZVN0eWxlcy5wdXNoKHsgY29udHJvbCwga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhY3RpdmUgc3R5bGVzIHRvIGVsZW1lbnRcbiAgICByb290LnJlZi5hY3RpdmVTdHlsZXMuZm9yRWFjaCgoeyBjb250cm9sLCBrZXksIHZhbHVlIH0pID0+IHtcbiAgICAgICAgY29udHJvbFtrZXldID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocm9vdCkgOiB2YWx1ZTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IHJvdXRlID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtUHJvY2Vzc2luZy5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICB9LFxuICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fTE9BRDogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtTG9hZC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICB9LFxuICAgIERJRF9TRVRfTEFCRUxfQlVUVE9OX0FCT1JUX0lURU1fUkVNT1ZBTDogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYuYnV0dG9uQWJvcnRJdGVtUmVtb3ZhbC5sYWJlbCA9IGFjdGlvbi52YWx1ZTtcbiAgICB9LFxuICAgIERJRF9SRVFVRVNUX0lURU1fUFJPQ0VTU0lORzogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gdHJ1ZTtcbiAgICAgICAgcm9vdC5yZWYucHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gMDtcbiAgICB9LFxuICAgIERJRF9TVEFSVF9JVEVNX0xPQUQ6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LnJlZi5sb2FkUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICAgIHJvb3QucmVmLmxvYWRQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfU1RBUlRfSVRFTV9SRU1PVkU6ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICByb290LnJlZi5wcm9jZXNzUHJvZ3Jlc3NJbmRpY2F0b3Iuc3BpbiA9IHRydWU7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IDA7XG4gICAgfSxcbiAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnNwaW4gPSBmYWxzZTtcbiAgICAgICAgcm9vdC5yZWYubG9hZFByb2dyZXNzSW5kaWNhdG9yLnByb2dyZXNzID0gYWN0aW9uLnByb2dyZXNzO1xuICAgIH0sXG4gICAgRElEX1VQREFURV9JVEVNX1BST0NFU1NfUFJPR1JFU1M6ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5zcGluID0gZmFsc2U7XG4gICAgICAgIHJvb3QucmVmLnByb2Nlc3NQcm9ncmVzc0luZGljYXRvci5wcm9ncmVzcyA9IGFjdGlvbi5wcm9ncmVzcztcbiAgICB9LFxufSk7XG5cbmNvbnN0IGZpbGUgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ0LFxuICAgIHdyaXRlOiB3cml0ZSQyLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgbmFtZTogJ2ZpbGUnLFxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gKi9cbmNvbnN0IGNyZWF0ZSQ1ID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIGZpbGVuYW1lXG4gICAgcm9vdC5yZWYuZmlsZU5hbWUgPSBjcmVhdGVFbGVtZW50JDEoJ2xlZ2VuZCcpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmlsZU5hbWUpO1xuXG4gICAgLy8gZmlsZSBhcHBlbmRlZFxuICAgIHJvb3QucmVmLmZpbGUgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlLCB7IGlkOiBwcm9wcy5pZCB9KSk7XG5cbiAgICAvLyBkYXRhIGhhcyBtb3ZlZCB0byBkYXRhLmpzXG4gICAgcm9vdC5yZWYuZGF0YSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEYXRhIHN0b3JhZ2VcbiAqL1xuY29uc3QgZGlkTG9hZEl0ZW0gPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gdXBkYXRlcyB0aGUgbGVnZW5kIG9mIHRoZSBmaWVsZHNldCBzbyBzY3JlZW5yZWFkZXJzIGNhbiBiZXR0ZXIgZ3JvdXAgYnV0dG9uc1xuICAgIHRleHQocm9vdC5yZWYuZmlsZU5hbWUsIGZvcm1hdEZpbGVuYW1lKHJvb3QucXVlcnkoJ0dFVF9JVEVNX05BTUUnLCBwcm9wcy5pZCkpKTtcbn07XG5cbmNvbnN0IGZpbGVXcmFwcGVyID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkNSxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIHdyaXRlOiBjcmVhdGVSb3V0ZSh7XG4gICAgICAgIERJRF9MT0FEX0lURU06IGRpZExvYWRJdGVtLFxuICAgIH0pLFxuICAgIGRpZENyZWF0ZVZpZXc6IHJvb3QgPT4ge1xuICAgICAgICBhcHBseUZpbHRlcnMoJ0NSRUFURV9WSUVXJywgeyAuLi5yb290LCB2aWV3OiByb290IH0pO1xuICAgIH0sXG4gICAgdGFnOiAnZmllbGRzZXQnLFxuICAgIG5hbWU6ICdmaWxlLXdyYXBwZXInLFxufSk7XG5cbmNvbnN0IFBBTkVMX1NQUklOR19QUk9QUyA9IHsgdHlwZTogJ3NwcmluZycsIGRhbXBpbmc6IDAuNiwgbWFzczogNyB9O1xuXG5jb25zdCBjcmVhdGUkNiA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd0b3AnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgICAgICBzY2FsZVk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVk6IFBBTkVMX1NQUklOR19QUk9QUyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlczogWyd0cmFuc2xhdGVZJywgJ3NjYWxlWSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ2JvdHRvbScsXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWl4aW5zOiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiBQQU5FTF9TUFJJTkdfUFJPUFMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWSddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICBdLmZvckVhY2goc2VjdGlvbiA9PiB7XG4gICAgICAgIGNyZWF0ZVNlY3Rpb24ocm9vdCwgc2VjdGlvbiwgcHJvcHMubmFtZSk7XG4gICAgfSk7XG5cbiAgICByb290LmVsZW1lbnQuY2xhc3NMaXN0LmFkZChgZmlsZXBvbmQtLSR7cHJvcHMubmFtZX1gKTtcblxuICAgIHJvb3QucmVmLnNjYWxhYmxlID0gbnVsbDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNlY3Rpb24gPSAocm9vdCwgc2VjdGlvbiwgY2xhc3NOYW1lKSA9PiB7XG4gICAgY29uc3Qgdmlld0NvbnN0cnVjdG9yID0gY3JlYXRlVmlldyh7XG4gICAgICAgIG5hbWU6IGBwYW5lbC0ke3NlY3Rpb24ubmFtZX0gZmlsZXBvbmQtLSR7Y2xhc3NOYW1lfWAsXG4gICAgICAgIG1peGluczogc2VjdGlvbi5taXhpbnMsXG4gICAgICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCB2aWV3ID0gcm9vdC5jcmVhdGVDaGlsZFZpZXcodmlld0NvbnN0cnVjdG9yLCBzZWN0aW9uLnByb3BzKTtcblxuICAgIHJvb3QucmVmW3NlY3Rpb24ubmFtZV0gPSByb290LmFwcGVuZENoaWxkVmlldyh2aWV3KTtcbn07XG5cbmNvbnN0IHdyaXRlJDMgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gdXBkYXRlIHNjYWxhYmxlIHN0YXRlXG4gICAgaWYgKHJvb3QucmVmLnNjYWxhYmxlID09PSBudWxsIHx8IHByb3BzLnNjYWxhYmxlICE9PSByb290LnJlZi5zY2FsYWJsZSkge1xuICAgICAgICByb290LnJlZi5zY2FsYWJsZSA9IGlzQm9vbGVhbihwcm9wcy5zY2FsYWJsZSkgPyBwcm9wcy5zY2FsYWJsZSA6IHRydWU7XG4gICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LnNjYWxhYmxlID0gcm9vdC5yZWYuc2NhbGFibGU7XG4gICAgfVxuXG4gICAgLy8gbm8gaGVpZ2h0LCBjYW4ndCBzZXRcbiAgICBpZiAoIXByb3BzLmhlaWdodCkgcmV0dXJuO1xuXG4gICAgLy8gZ2V0IGNoaWxkIHJlY3RzXG4gICAgY29uc3QgdG9wUmVjdCA9IHJvb3QucmVmLnRvcC5yZWN0LmVsZW1lbnQ7XG4gICAgY29uc3QgYm90dG9tUmVjdCA9IHJvb3QucmVmLmJvdHRvbS5yZWN0LmVsZW1lbnQ7XG5cbiAgICAvLyBtYWtlIHN1cmUgaGVpZ2h0IG5ldmVyIGlzIHNtYWxsZXIgdGhhbiBib3R0b20gYW5kIHRvcCBzZWNpdG9uIGhlaWdodHMgY29tYmluZWQgKHdpbGwgcHJvYmFibHkgbmV2ZXIgaGFwcGVuLCBidXQgd2hvIGtub3dzKVxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHRvcFJlY3QuaGVpZ2h0ICsgYm90dG9tUmVjdC5oZWlnaHQsIHByb3BzLmhlaWdodCk7XG5cbiAgICAvLyBvZmZzZXQgY2VudGVyIHBhcnRcbiAgICByb290LnJlZi5jZW50ZXIudHJhbnNsYXRlWSA9IHRvcFJlY3QuaGVpZ2h0O1xuXG4gICAgLy8gc2NhbGUgY2VudGVyIHBhcnRcbiAgICAvLyB1c2UgbWF0aCBjZWlsIHRvIHByZXZlbnQgdHJhbnNwYXJlbnQgbGluZXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnNcbiAgICByb290LnJlZi5jZW50ZXIuc2NhbGVZID0gKGhlaWdodCAtIHRvcFJlY3QuaGVpZ2h0IC0gYm90dG9tUmVjdC5oZWlnaHQpIC8gMTAwO1xuXG4gICAgLy8gb2Zmc2V0IGJvdHRvbSBwYXJ0XG4gICAgcm9vdC5yZWYuYm90dG9tLnRyYW5zbGF0ZVkgPSBoZWlnaHQgLSBib3R0b21SZWN0LmhlaWdodDtcbn07XG5cbmNvbnN0IHBhbmVsID0gY3JlYXRlVmlldyh7XG4gICAgbmFtZTogJ3BhbmVsJyxcbiAgICByZWFkOiAoeyByb290LCBwcm9wcyB9KSA9PiAocHJvcHMuaGVpZ2h0Q3VycmVudCA9IHJvb3QucmVmLmJvdHRvbS50cmFuc2xhdGVZKSxcbiAgICB3cml0ZTogd3JpdGUkMyxcbiAgICBjcmVhdGU6IGNyZWF0ZSQ2LFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIGFwaXM6IFsnaGVpZ2h0JywgJ2hlaWdodEN1cnJlbnQnLCAnc2NhbGFibGUnXSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGNyZWF0ZURyYWdIZWxwZXIgPSBpdGVtcyA9PiB7XG4gICAgY29uc3QgaXRlbUlkcyA9IGl0ZW1zLm1hcChpdGVtID0+IGl0ZW0uaWQpO1xuICAgIGxldCBwcmV2SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbmRleDogKCkgPT4gcHJldkluZGV4LFxuICAgICAgICBnZXRJdGVtSW5kZXg6IGl0ZW0gPT4gaXRlbUlkcy5pbmRleE9mKGl0ZW0uaWQpLFxuICAgIH07XG59O1xuXG5jb25zdCBJVEVNX1RSQU5TTEFURV9TUFJJTkcgPSB7XG4gICAgdHlwZTogJ3NwcmluZycsXG4gICAgc3RpZmZuZXNzOiAwLjc1LFxuICAgIGRhbXBpbmc6IDAuNDUsXG4gICAgbWFzczogMTAsXG59O1xuXG5jb25zdCBJVEVNX1NDQUxFX1NQUklORyA9ICdzcHJpbmcnO1xuXG5jb25zdCBTdGF0ZU1hcCA9IHtcbiAgICBESURfU1RBUlRfSVRFTV9MT0FEOiAnYnVzeScsXG4gICAgRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1M6ICdsb2FkaW5nJyxcbiAgICBESURfVEhST1dfSVRFTV9JTlZBTElEOiAnbG9hZC1pbnZhbGlkJyxcbiAgICBESURfVEhST1dfSVRFTV9MT0FEX0VSUk9SOiAnbG9hZC1lcnJvcicsXG4gICAgRElEX0xPQURfSVRFTTogJ2lkbGUnLFxuICAgIERJRF9USFJPV19JVEVNX1JFTU9WRV9FUlJPUjogJ3JlbW92ZS1lcnJvcicsXG4gICAgRElEX1NUQVJUX0lURU1fUkVNT1ZFOiAnYnVzeScsXG4gICAgRElEX1NUQVJUX0lURU1fUFJPQ0VTU0lORzogJ2J1c3kgcHJvY2Vzc2luZycsXG4gICAgRElEX1JFUVVFU1RfSVRFTV9QUk9DRVNTSU5HOiAnYnVzeSBwcm9jZXNzaW5nJyxcbiAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogJ3Byb2Nlc3NpbmcnLFxuICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkc6ICdwcm9jZXNzaW5nLWNvbXBsZXRlJyxcbiAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiAncHJvY2Vzc2luZy1lcnJvcicsXG4gICAgRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1I6ICdwcm9jZXNzaW5nLXJldmVydC1lcnJvcicsXG4gICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogJ2NhbmNlbGxlZCcsXG4gICAgRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkc6ICdpZGxlJyxcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gKi9cbmNvbnN0IGNyZWF0ZSQ3ID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIC8vIHNlbGVjdFxuICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZSA9PiByb290LmRpc3BhdGNoKCdESURfQUNUSVZBVEVfSVRFTScsIHsgaWQ6IHByb3BzLmlkIH0pO1xuXG4gICAgLy8gc2V0IGlkXG4gICAgcm9vdC5lbGVtZW50LmlkID0gYGZpbGVwb25kLS1pdGVtLSR7cHJvcHMuaWR9YDtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyBmaWxlIHZpZXdcbiAgICByb290LnJlZi5jb250YWluZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhyb290LmNyZWF0ZUNoaWxkVmlldyhmaWxlV3JhcHBlciwgeyBpZDogcHJvcHMuaWQgfSkpO1xuXG4gICAgLy8gZmlsZSBwYW5lbFxuICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ2l0ZW0tcGFuZWwnIH0pKTtcblxuICAgIC8vIGRlZmF1bHQgc3RhcnQgaGVpZ2h0XG4gICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gbnVsbDtcblxuICAgIC8vIGJ5IGRlZmF1bHQgbm90IG1hcmtlZCBmb3IgcmVtb3ZhbFxuICAgIHByb3BzLm1hcmtlZEZvclJlbW92YWwgPSBmYWxzZTtcblxuICAgIC8vIGlmIG5vdCBhbGxvd2VkIHRvIHJlb3JkZXIgZmlsZSBpdGVtcywgZXhpdCBoZXJlXG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpKSByZXR1cm47XG5cbiAgICAvLyBzZXQgdG8gaWRsZSBzbyBzaG93cyBncmFiIGN1cnNvclxuICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcblxuICAgIGNvbnN0IGdyYWIgPSBlID0+IHtcbiAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgIGxldCByZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHtcbiAgICAgICAgICAgIHg6IGUucGFnZVgsXG4gICAgICAgICAgICB5OiBlLnBhZ2VZLFxuICAgICAgICB9O1xuXG4gICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICB4OiByb290LnRyYW5zbGF0ZVgsXG4gICAgICAgICAgICB5OiByb290LnRyYW5zbGF0ZVksXG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvcHMuZHJhZ0NlbnRlciA9IHtcbiAgICAgICAgICAgIHg6IGUub2Zmc2V0WCxcbiAgICAgICAgICAgIHk6IGUub2Zmc2V0WSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBkcmFnU3RhdGUgPSBjcmVhdGVEcmFnSGVscGVyKHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKSk7XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX0dSQUJfSVRFTScsIHsgaWQ6IHByb3BzLmlkLCBkcmFnU3RhdGUgfSk7XG5cbiAgICAgICAgY29uc3QgZHJhZyA9IGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLmlzUHJpbWFyeSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0ge1xuICAgICAgICAgICAgICAgIHg6IGUucGFnZVggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZIC0gb3JpZ2luLnksXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpZiBkcmFnZ2VkIHN0b3AgbGlzdGVuaW5nIHRvIGNsaWNrcywgd2lsbCByZS1hZGQgd2hlbiBkb25lIGRyYWdnaW5nXG4gICAgICAgICAgICBjb25zdCBkaXN0ID1cbiAgICAgICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0LnggKiBwcm9wcy5kcmFnT2Zmc2V0LnggKyBwcm9wcy5kcmFnT2Zmc2V0LnkgKiBwcm9wcy5kcmFnT2Zmc2V0Lnk7XG4gICAgICAgICAgICBpZiAoZGlzdCA+IDE2ICYmICFyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRBY3RpdmF0ZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUkFHX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRyb3AgPSBlID0+IHtcbiAgICAgICAgICAgIGlmICghZS5pc1ByaW1hcnkpIHJldHVybjtcblxuICAgICAgICAgICAgcHJvcHMuZHJhZ09mZnNldCA9IHtcbiAgICAgICAgICAgICAgICB4OiBlLnBhZ2VYIC0gb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgeTogZS5wYWdlWSAtIG9yaWdpbi55LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGRyYWcpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgZHJvcCk7XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9EUk9QX0lURU0nLCB7IGlkOiBwcm9wcy5pZCwgZHJhZ1N0YXRlIH0pO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBsaXN0ZW5pbmcgdG8gY2xpY2tzIGFnYWluXG4gICAgICAgICAgICBpZiAocmVtb3ZlZEFjdGl2YXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJvb3QucmVmLmhhbmRsZUNsaWNrKSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIGNhbmNlbCk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgZHJhZyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGRyb3ApO1xuICAgIH07XG5cbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBncmFiKTtcbn07XG5cbmNvbnN0IHJvdXRlJDEgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1VQREFURV9QQU5FTF9IRUlHSFQ6ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgICAgIHJvb3QuaGVpZ2h0ID0gYWN0aW9uLmhlaWdodDtcbiAgICB9LFxufSk7XG5cbmNvbnN0IHdyaXRlJDQgPSBjcmVhdGVSb3V0ZShcbiAgICB7XG4gICAgICAgIERJRF9HUkFCX0lURU06ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSB7XG4gICAgICAgICAgICAgICAgeDogcm9vdC50cmFuc2xhdGVYLFxuICAgICAgICAgICAgICAgIHk6IHJvb3QudHJhbnNsYXRlWSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIERJRF9EUkFHX0lURU06ICh7IHJvb3QgfSkgPT4ge1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2RyYWcnO1xuICAgICAgICB9LFxuICAgICAgICBESURfRFJPUF9JVEVNOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICAgICAgICBwcm9wcy5kcmFnT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHByb3BzLmRyYWdPcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZHJhZ1N0YXRlID0gJ2Ryb3AnO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgKHsgcm9vdCwgYWN0aW9ucywgcHJvcHMsIHNob3VsZE9wdGltaXplIH0pID0+IHtcbiAgICAgICAgaWYgKHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9PT0gJ2Ryb3AnKSB7XG4gICAgICAgICAgICBpZiAocm9vdC5zY2FsZVggPD0gMSkge1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5kYXRhc2V0LmRyYWdTdGF0ZSA9ICdpZGxlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlbGVjdCBsYXN0IHN0YXRlIGNoYW5nZSBhY3Rpb25cbiAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNcbiAgICAgICAgICAgIC5jb25jYXQoKVxuICAgICAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gL15ESURfLy50ZXN0KGFjdGlvbi50eXBlKSlcbiAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgIC5maW5kKGFjdGlvbiA9PiBTdGF0ZU1hcFthY3Rpb24udHlwZV0pO1xuXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gc2V0IHNhbWUgc3RhdGUgdHdpY2VcbiAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSAhPT0gcHJvcHMuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAvLyBzZXQgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgcHJvcHMuY3VycmVudFN0YXRlID0gYWN0aW9uLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIHNldCBzdGF0ZVxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuZmlsZXBvbmRJdGVtU3RhdGUgPSBTdGF0ZU1hcFtwcm9wcy5jdXJyZW50U3RhdGVdIHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm91dGUgYWN0aW9uc1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9XG4gICAgICAgICAgICByb290LnF1ZXJ5KCdHRVRfSVRFTV9QQU5FTF9BU1BFQ1RfUkFUSU8nKSB8fCByb290LnF1ZXJ5KCdHRVRfUEFORUxfQVNQRUNUX1JBVElPJyk7XG4gICAgICAgIGlmICghYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHJvdXRlJDEoeyByb290LCBhY3Rpb25zLCBwcm9wcyB9KTtcbiAgICAgICAgICAgIGlmICghcm9vdC5oZWlnaHQgJiYgcm9vdC5yZWYuY29udGFpbmVyLnJlY3QuZWxlbWVudC5oZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSByb290LnJlZi5jb250YWluZXIucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2hvdWxkT3B0aW1pemUpIHtcbiAgICAgICAgICAgIHJvb3QuaGVpZ2h0ID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN5bmMgcGFuZWwgaGVpZ2h0IHdpdGggaXRlbSBoZWlnaHRcbiAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICByb290LnJlZi5wYW5lbC5oZWlnaHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdC5yZWYucGFuZWwuaGVpZ2h0ID0gcm9vdC5oZWlnaHQ7XG4gICAgfVxuKTtcblxuY29uc3QgaXRlbSA9IGNyZWF0ZVZpZXcoe1xuICAgIGNyZWF0ZTogY3JlYXRlJDcsXG4gICAgd3JpdGU6IHdyaXRlJDQsXG4gICAgZGVzdHJveTogKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ1JFTEVBU0VfSVRFTScsIHsgcXVlcnk6IHByb3BzLmlkIH0pO1xuICAgIH0sXG4gICAgdGFnOiAnbGknLFxuICAgIG5hbWU6ICdpdGVtJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogW1xuICAgICAgICAgICAgJ2lkJyxcbiAgICAgICAgICAgICdpbnRlcmFjdGlvbk1ldGhvZCcsXG4gICAgICAgICAgICAnbWFya2VkRm9yUmVtb3ZhbCcsXG4gICAgICAgICAgICAnc3Bhd25EYXRlJyxcbiAgICAgICAgICAgICdkcmFnQ2VudGVyJyxcbiAgICAgICAgICAgICdkcmFnT3JpZ2luJyxcbiAgICAgICAgICAgICdkcmFnT2Zmc2V0JyxcbiAgICAgICAgXSxcbiAgICAgICAgc3R5bGVzOiBbJ3RyYW5zbGF0ZVgnLCAndHJhbnNsYXRlWScsICdzY2FsZVgnLCAnc2NhbGVZJywgJ29wYWNpdHknLCAnaGVpZ2h0J10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHNjYWxlWDogSVRFTV9TQ0FMRV9TUFJJTkcsXG4gICAgICAgICAgICBzY2FsZVk6IElURU1fU0NBTEVfU1BSSU5HLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogSVRFTV9UUkFOU0xBVEVfU1BSSU5HLFxuICAgICAgICAgICAgb3BhY2l0eTogeyB0eXBlOiAndHdlZW4nLCBkdXJhdGlvbjogMTUwIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG52YXIgZ2V0SXRlbXNQZXJSb3cgPSAoaG9yaXpvbnRhbFNwYWNlLCBpdGVtV2lkdGgpID0+IHtcbiAgICAvLyBhZGQgb25lIHBpeGVsIGxlZXdheSwgd2hlbiB1c2luZyBwZXJjZW50YWdlcyBmb3IgaXRlbSB3aWR0aCB0b3RhbCBpdGVtcyBjYW4gYmUgMS45OSBwZXIgcm93XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcigoaG9yaXpvbnRhbFNwYWNlICsgMSkgLyBpdGVtV2lkdGgpKTtcbn07XG5cbmNvbnN0IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24gPSAodmlldywgY2hpbGRyZW4sIHBvc2l0aW9uSW5WaWV3KSA9PiB7XG4gICAgaWYgKCFwb3NpdGlvbkluVmlldykgcmV0dXJuO1xuXG4gICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlID0gdmlldy5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgLy8gY29uc3QgY2hpbGRyZW4gPSB2aWV3LmNoaWxkVmlld3M7XG4gICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgbGFzdCA9IG51bGw7XG5cbiAgICAvLyAtMSwgZG9uJ3QgbW92ZSBpdGVtcyB0byBhY2NvbW9kYXRlIChlaXRoZXIgYWRkIHRvIHRvcCBvciBib3R0b20pXG4gICAgaWYgKGwgPT09IDAgfHwgcG9zaXRpb25JblZpZXcudG9wIDwgY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50LnRvcCkgcmV0dXJuIC0xO1xuXG4gICAgLy8gbGV0J3MgZ2V0IHRoZSBpdGVtIHdpZHRoXG4gICAgY29uc3QgaXRlbSA9IGNoaWxkcmVuWzBdO1xuICAgIGNvbnN0IGl0ZW1SZWN0ID0gaXRlbS5yZWN0LmVsZW1lbnQ7XG4gICAgY29uc3QgaXRlbUhvcml6b250YWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5MZWZ0ICsgaXRlbVJlY3QubWFyZ2luUmlnaHQ7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gaXRlbVJlY3Qud2lkdGggKyBpdGVtSG9yaXpvbnRhbE1hcmdpbjtcbiAgICBjb25zdCBpdGVtc1BlclJvdyA9IGdldEl0ZW1zUGVyUm93KGhvcml6b250YWxTcGFjZSwgaXRlbVdpZHRoKTtcblxuICAgIC8vIHN0YWNrXG4gICAgaWYgKGl0ZW1zUGVyUm93ID09PSAxKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTWlkID0gY2hpbGQucmVjdC5vdXRlci50b3AgKyBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0ICogMC41O1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGNoaWxkTWlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cblxuICAgIC8vIGdyaWRcbiAgICBjb25zdCBpdGVtVmVydGljYWxNYXJnaW4gPSBpdGVtUmVjdC5tYXJnaW5Ub3AgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGl0ZW1SZWN0LmhlaWdodCArIGl0ZW1WZXJ0aWNhbE1hcmdpbjtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBpbmRleFggPSBpbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICBjb25zdCBpbmRleFkgPSBNYXRoLmZsb29yKGluZGV4IC8gaXRlbXNQZXJSb3cpO1xuXG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBpbmRleFggKiBpdGVtV2lkdGg7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IGl0ZW1Ub3AgPSBvZmZzZXRZIC0gaXRlbVJlY3QubWFyZ2luVG9wO1xuICAgICAgICBjb25zdCBpdGVtUmlnaHQgPSBvZmZzZXRYICsgaXRlbVdpZHRoO1xuICAgICAgICBjb25zdCBpdGVtQm90dG9tID0gb2Zmc2V0WSArIGl0ZW1IZWlnaHQgKyBpdGVtUmVjdC5tYXJnaW5Cb3R0b207XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LnRvcCA8IGl0ZW1Cb3R0b20gJiYgcG9zaXRpb25JblZpZXcudG9wID4gaXRlbVRvcCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uSW5WaWV3LmxlZnQgPCBpdGVtUmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGFzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbDtcbn07XG5cbmNvbnN0IGRyb3BBcmVhRGltZW5zaW9ucyA9IHtcbiAgICBoZWlnaHQ6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgZ2V0IGdldEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgc2V0IHNldEhlaWdodCh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID09PSAwIHx8IHZhbCA9PT0gMCkgdGhpcy5oZWlnaHQgPSB2YWw7XG4gICAgfSxcbiAgICBnZXQgZ2V0V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sXG4gICAgc2V0IHNldFdpZHRoKHZhbCkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB2YWwgPT09IDApIHRoaXMud2lkdGggPSB2YWw7XG4gICAgfSxcbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbihoZWlnaHQsIHdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy53aWR0aCA9PT0gMCB8fCB3aWR0aCA9PT0gMCkgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH0sXG59O1xuXG5jb25zdCBjcmVhdGUkOCA9ICh7IHJvb3QgfSkgPT4ge1xuICAgIC8vIG5lZWQgdG8gc2V0IHJvbGUgdG8gbGlzdCBhcyBvdGhlcndpc2UgaXQgd29uJ3QgYmUgcmVhZCBhcyBhIGxpc3QgYnkgVm9pY2VPdmVyXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdyb2xlJywgJ2xpc3QnKTtcblxuICAgIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlID0gRGF0ZS5ub3coKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBpdGVtXG4gKiBAcGFyYW0gcm9vdFxuICogQHBhcmFtIGFjdGlvblxuICovXG5jb25zdCBhZGRJdGVtVmlldyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgeyBpZCwgaW5kZXgsIGludGVyYWN0aW9uTWV0aG9kIH0gPSBhY3Rpb247XG5cbiAgICByb290LnJlZi5hZGRJbmRleCA9IGluZGV4O1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgc3Bhd25EYXRlID0gbm93O1xuICAgIGxldCBvcGFjaXR5ID0gMTtcblxuICAgIGlmIChpbnRlcmFjdGlvbk1ldGhvZCAhPT0gSW50ZXJhY3Rpb25NZXRob2QuTk9ORSkge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgY29uc3QgY29vbGRvd24gPSByb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfSU5URVJWQUwnKTtcbiAgICAgICAgY29uc3QgZGlzdCA9IG5vdyAtIHJvb3QucmVmLmxhc3RJdGVtU3BhbndEYXRlO1xuICAgICAgICBzcGF3bkRhdGUgPSBkaXN0IDwgY29vbGRvd24gPyBub3cgKyAoY29vbGRvd24gLSBkaXN0KSA6IG5vdztcbiAgICB9XG5cbiAgICByb290LnJlZi5sYXN0SXRlbVNwYW53RGF0ZSA9IHNwYXduRGF0ZTtcblxuICAgIHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhcbiAgICAgICAgICAgIC8vIHZpZXcgdHlwZVxuICAgICAgICAgICAgaXRlbSxcblxuICAgICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzcGF3bkRhdGUsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgaW5kZXhcbiAgICApO1xufTtcblxuY29uc3QgbW92ZUl0ZW0gPSAoaXRlbSwgeCwgeSwgdnggPSAwLCB2eSA9IDEpID0+IHtcbiAgICAvLyBzZXQgdG8gbnVsbCB0byByZW1vdmUgYW5pbWF0aW9uIHdoaWxlIGRyYWdnaW5nXG4gICAgaWYgKGl0ZW0uZHJhZ09mZnNldCkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBpdGVtLmRyYWdPcmlnaW4ueCArIGl0ZW0uZHJhZ09mZnNldC54O1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBpdGVtLmRyYWdPcmlnaW4ueSArIGl0ZW0uZHJhZ09mZnNldC55O1xuICAgICAgICBpdGVtLnNjYWxlWCA9IDEuMDI1O1xuICAgICAgICBpdGVtLnNjYWxlWSA9IDEuMDI1O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHg7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWSA9IHk7XG5cbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBpdGVtLnNwYXduRGF0ZSkge1xuICAgICAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChpdGVtLm9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpbnRyb0l0ZW1WaWV3KGl0ZW0sIHgsIHksIHZ4LCB2eSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpcyBkZWZhdWx0IHNjYWxlIGV2ZXJ5IGZyYW1lXG4gICAgICAgICAgICBpdGVtLnNjYWxlWCA9IDE7XG4gICAgICAgICAgICBpdGVtLnNjYWxlWSA9IDE7XG4gICAgICAgICAgICBpdGVtLm9wYWNpdHkgPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgaW50cm9JdGVtVmlldyA9IChpdGVtLCB4LCB5LCB2eCwgdnkpID0+IHtcbiAgICBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuTk9ORSkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4O1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5O1xuICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuRFJPUCkge1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVggPSB4IC0gdnggKiAyMDtcblxuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICBpdGVtLnRyYW5zbGF0ZVkgPSB5IC0gdnkgKiAxMDtcblxuICAgICAgICBpdGVtLnNjYWxlWCA9IDAuODtcbiAgICAgICAgaXRlbS5zY2FsZVkgPSAwLjg7XG4gICAgfSBlbHNlIGlmIChpdGVtLmludGVyYWN0aW9uTWV0aG9kID09PSBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UpIHtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0geSAtIDMwO1xuICAgIH0gZWxzZSBpZiAoaXRlbS5pbnRlcmFjdGlvbk1ldGhvZCA9PT0gSW50ZXJhY3Rpb25NZXRob2QuQVBJKSB7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgIGl0ZW0udHJhbnNsYXRlWCA9IHggLSAzMDtcbiAgICAgICAgaXRlbS50cmFuc2xhdGVZID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXhpc3RpbmcgaXRlbVxuICogQHBhcmFtIHJvb3RcbiAqIEBwYXJhbSBhY3Rpb25cbiAqL1xuY29uc3QgcmVtb3ZlSXRlbVZpZXcgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQgfSA9IGFjdGlvbjtcblxuICAgIC8vIGdldCB0aGUgdmlldyBtYXRjaGluZyB0aGUgZ2l2ZW4gaWRcbiAgICBjb25zdCB2aWV3ID0gcm9vdC5jaGlsZFZpZXdzLmZpbmQoY2hpbGQgPT4gY2hpbGQuaWQgPT09IGlkKTtcblxuICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFuaW1hdGUgdmlldyBvdXQgb2Ygdmlld1xuICAgIHZpZXcuc2NhbGVYID0gMC45O1xuICAgIHZpZXcuc2NhbGVZID0gMC45O1xuICAgIHZpZXcub3BhY2l0eSA9IDA7XG5cbiAgICAvLyBtYXJrIGZvciByZW1vdmFsXG4gICAgdmlldy5tYXJrZWRGb3JSZW1vdmFsID0gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEl0ZW1IZWlnaHQgPSBjaGlsZCA9PlxuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgK1xuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b20gKiAwLjUgK1xuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AgKiAwLjU7XG5jb25zdCBnZXRJdGVtV2lkdGggPSBjaGlsZCA9PlxuICAgIGNoaWxkLnJlY3QuZWxlbWVudC53aWR0aCArXG4gICAgY2hpbGQucmVjdC5lbGVtZW50Lm1hcmdpbkxlZnQgKiAwLjUgK1xuICAgIGNoaWxkLnJlY3QuZWxlbWVudC5tYXJnaW5SaWdodCAqIDAuNTtcblxuY29uc3QgZHJhZ0l0ZW0gPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IHsgaWQsIGRyYWdTdGF0ZSB9ID0gYWN0aW9uO1xuXG4gICAgLy8gcmVmZXJlbmNlIHRvIGl0ZW1cbiAgICBjb25zdCBpdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCB7IGlkIH0pO1xuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdGNoaW5nIHRoZSBnaXZlbiBpZFxuICAgIGNvbnN0IHZpZXcgPSByb290LmNoaWxkVmlld3MuZmluZChjaGlsZCA9PiBjaGlsZC5pZCA9PT0gaWQpO1xuXG4gICAgY29uc3QgbnVtSXRlbXMgPSByb290LmNoaWxkVmlld3MubGVuZ3RoO1xuICAgIGNvbnN0IG9sZEluZGV4ID0gZHJhZ1N0YXRlLmdldEl0ZW1JbmRleChpdGVtKTtcblxuICAgIC8vIGlmIG5vIHZpZXcgZm91bmQsIGV4aXRcbiAgICBpZiAoIXZpZXcpIHJldHVybjtcblxuICAgIGNvbnN0IGRyYWdQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdmlldy5kcmFnT3JpZ2luLnggKyB2aWV3LmRyYWdPZmZzZXQueCArIHZpZXcuZHJhZ0NlbnRlci54LFxuICAgICAgICB5OiB2aWV3LmRyYWdPcmlnaW4ueSArIHZpZXcuZHJhZ09mZnNldC55ICsgdmlldy5kcmFnQ2VudGVyLnksXG4gICAgfTtcblxuICAgIC8vIGdldCBkcmFnIGFyZWEgZGltZW5zaW9uc1xuICAgIGNvbnN0IGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgIGNvbnN0IGRyYWdXaWR0aCA9IGdldEl0ZW1XaWR0aCh2aWV3KTtcblxuICAgIC8vIGdldCByb3dzIGFuZCBjb2x1bW5zIChUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgcm93IGFuZCBvbmUgY29sdW1uIGlmIGEgZmlsZSBpcyBwcmVzZW50KVxuICAgIGxldCBjb2xzID0gTWF0aC5mbG9vcihyb290LnJlY3Qub3V0ZXIud2lkdGggLyBkcmFnV2lkdGgpO1xuICAgIGlmIChjb2xzID4gbnVtSXRlbXMpIGNvbHMgPSBudW1JdGVtcztcblxuICAgIC8vIHJvd3MgYXJlIHVzZWQgdG8gZmluZCB3aGVuIHdlIGhhdmUgbGVmdCB0aGUgcHJldmlldyBhcmVhIGJvdW5kaW5nIGJveFxuICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKG51bUl0ZW1zIC8gY29scyArIDEpO1xuXG4gICAgZHJvcEFyZWFEaW1lbnNpb25zLnNldEhlaWdodCA9IGRyYWdIZWlnaHQgKiByb3dzO1xuICAgIGRyb3BBcmVhRGltZW5zaW9ucy5zZXRXaWR0aCA9IGRyYWdXaWR0aCAqIGNvbHM7XG5cbiAgICAvLyBnZXQgbmV3IGluZGV4IG9mIGRyYWdnZWQgaXRlbVxuICAgIHZhciBsb2NhdGlvbiA9IHtcbiAgICAgICAgeTogTWF0aC5mbG9vcihkcmFnUG9zaXRpb24ueSAvIGRyYWdIZWlnaHQpLFxuICAgICAgICB4OiBNYXRoLmZsb29yKGRyYWdQb3NpdGlvbi54IC8gZHJhZ1dpZHRoKSxcbiAgICAgICAgZ2V0R3JpZEluZGV4OiBmdW5jdGlvbiBnZXRHcmlkSW5kZXgoKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPiBkcm9wQXJlYURpbWVuc2lvbnMuZ2V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnkgPCAwIHx8XG4gICAgICAgICAgICAgICAgZHJhZ1Bvc2l0aW9uLnggPiBkcm9wQXJlYURpbWVuc2lvbnMuZ2V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICBkcmFnUG9zaXRpb24ueCA8IDBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy55ICogY29scyArIHRoaXMueDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Q29sSW5kZXg6IGZ1bmN0aW9uIGdldENvbEluZGV4KCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBpdGVtcy5tYXAoaXRlbSA9PlxuICAgICAgICAgICAgICAgIHZpc2libGVDaGlsZHJlbi5maW5kKGNoaWxkVmlldyA9PiBjaGlsZFZpZXcuaWQgPT09IGl0ZW0uaWQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY2hpbGRyZW4uZmluZEluZGV4KGNoaWxkID0+IGNoaWxkID09PSB2aWV3KTtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdIZWlnaHQgPSBnZXRJdGVtSGVpZ2h0KHZpZXcpO1xuICAgICAgICAgICAgY29uc3QgbCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBpZHggPSBsO1xuICAgICAgICAgICAgbGV0IGNoaWxkSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIGxldCBjaGlsZEJvdHRvbSA9IDA7XG4gICAgICAgICAgICBsZXQgY2hpbGRUb3AgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZEhlaWdodCA9IGdldEl0ZW1IZWlnaHQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9wID0gY2hpbGRCb3R0b207XG4gICAgICAgICAgICAgICAgY2hpbGRCb3R0b20gPSBjaGlsZFRvcCArIGNoaWxkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChkcmFnUG9zaXRpb24ueSA8IGNoaWxkQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ1Bvc2l0aW9uLnkgPCBjaGlsZFRvcCArIGRyYWdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gZ2V0IG5ldyBpbmRleFxuICAgIGNvbnN0IGluZGV4ID0gY29scyA+IDEgPyBsb2NhdGlvbi5nZXRHcmlkSW5kZXgoKSA6IGxvY2F0aW9uLmdldENvbEluZGV4KCk7XG4gICAgcm9vdC5kaXNwYXRjaCgnTU9WRV9JVEVNJywgeyBxdWVyeTogdmlldywgaW5kZXggfSk7XG5cbiAgICAvLyBpZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gY2hhbmdlZCwgZGlzcGF0Y2ggcmVvcmRlciBhY3Rpb25cbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSBkcmFnU3RhdGUuZ2V0SW5kZXgoKTtcblxuICAgIGlmIChjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgIGRyYWdTdGF0ZS5zZXRJbmRleChpbmRleCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1JFT1JERVJfSVRFTVMnLCB7XG4gICAgICAgICAgICBpdGVtczogcm9vdC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpLFxuICAgICAgICAgICAgb3JpZ2luOiBvbGRJbmRleCxcbiAgICAgICAgICAgIHRhcmdldDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0dXAgYWN0aW9uIHJvdXRlc1xuICovXG5jb25zdCByb3V0ZSQyID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9BRERfSVRFTTogYWRkSXRlbVZpZXcsXG4gICAgRElEX1JFTU9WRV9JVEVNOiByZW1vdmVJdGVtVmlldyxcbiAgICBESURfRFJBR19JVEVNOiBkcmFnSXRlbSxcbn0pO1xuXG4vKipcbiAqIFdyaXRlIHRvIHZpZXdcbiAqIEBwYXJhbSByb290XG4gKiBAcGFyYW0gYWN0aW9uc1xuICogQHBhcmFtIHByb3BzXG4gKi9cbmNvbnN0IHdyaXRlJDUgPSAoeyByb290LCBwcm9wcywgYWN0aW9ucywgc2hvdWxkT3B0aW1pemUgfSkgPT4ge1xuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSQyKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSk7XG5cbiAgICBjb25zdCB7IGRyYWdDb29yZGluYXRlcyB9ID0gcHJvcHM7XG5cbiAgICAvLyBhdmFpbGFibGUgc3BhY2Ugb24gaG9yaXpvbnRhbCBheGlzXG4gICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG5cbiAgICAvLyBvbmx5IGRyYXcgY2hpbGRyZW4gdGhhdCBoYXZlIGRpbWVuc2lvbnNcbiAgICBjb25zdCB2aXNpYmxlQ2hpbGRyZW4gPSByb290LmNoaWxkVmlld3MuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQpO1xuXG4gICAgLy8gc29ydCBiYXNlZCBvbiBjdXJyZW50IGFjdGl2ZSBpdGVtc1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAubWFwKGl0ZW0gPT4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuaWQgPT09IGl0ZW0uaWQpKVxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG5cbiAgICAvLyBnZXQgaW5kZXhcbiAgICBjb25zdCBkcmFnSW5kZXggPSBkcmFnQ29vcmRpbmF0ZXNcbiAgICAgICAgPyBnZXRJdGVtSW5kZXhCeVBvc2l0aW9uKHJvb3QsIGNoaWxkcmVuLCBkcmFnQ29vcmRpbmF0ZXMpXG4gICAgICAgIDogbnVsbDtcblxuICAgIC8vIGFkZCBpbmRleCBpcyB1c2VkIHRvIHJlc2VydmUgdGhlIGRyb3BwZWQvYWRkZWQgaXRlbSBpbmRleCB0aWxsIHRoZSBhY3R1YWwgaXRlbSBpcyByZW5kZXJlZFxuICAgIGNvbnN0IGFkZEluZGV4ID0gcm9vdC5yZWYuYWRkSW5kZXggfHwgbnVsbDtcblxuICAgIC8vIGFkZCBpbmRleCBubyBsb25nZXIgbmVlZGVkIHRpbGwgcG9zc2libHkgbmV4dCBkcmF3XG4gICAgcm9vdC5yZWYuYWRkSW5kZXggPSBudWxsO1xuXG4gICAgbGV0IGRyYWdJbmRleE9mZnNldCA9IDA7XG4gICAgbGV0IHJlbW92ZUluZGV4T2Zmc2V0ID0gMDtcbiAgICBsZXQgYWRkSW5kZXhPZmZzZXQgPSAwO1xuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2hpbGRSZWN0ID0gY2hpbGRyZW5bMF0ucmVjdC5lbGVtZW50O1xuICAgIGNvbnN0IGl0ZW1WZXJ0aWNhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5Ub3AgKyBjaGlsZFJlY3QubWFyZ2luQm90dG9tO1xuICAgIGNvbnN0IGl0ZW1Ib3Jpem9udGFsTWFyZ2luID0gY2hpbGRSZWN0Lm1hcmdpbkxlZnQgKyBjaGlsZFJlY3QubWFyZ2luUmlnaHQ7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG4gICAgY29uc3QgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAvLyBzdGFja1xuICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICBsZXQgb2Zmc2V0WSA9IDA7XG4gICAgICAgIGxldCBkcmFnT2Zmc2V0ID0gMDtcblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChkcmFnSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IGluZGV4IC0gZHJhZ0luZGV4O1xuICAgICAgICAgICAgICAgIGlmIChkaXN0ID09PSAtMikge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuMjU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gLWl0ZW1WZXJ0aWNhbE1hcmdpbiAqIDAuNzU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdPZmZzZXQgPSBpdGVtVmVydGljYWxNYXJnaW4gKiAwLjc1O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gaXRlbVZlcnRpY2FsTWFyZ2luICogMC4yNTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRPcHRpbWl6ZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVggPSBudWxsO1xuICAgICAgICAgICAgICAgIGNoaWxkLnRyYW5zbGF0ZVkgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHtcbiAgICAgICAgICAgICAgICBtb3ZlSXRlbShjaGlsZCwgMCwgb2Zmc2V0WSArIGRyYWdPZmZzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaXRlbUhlaWdodCA9IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICAgICAgICAgIGxldCB2aXN1YWxIZWlnaHQgPSBpdGVtSGVpZ2h0ICogKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgPyBjaGlsZC5vcGFjaXR5IDogMSk7XG5cbiAgICAgICAgICAgIG9mZnNldFkgKz0gdmlzdWFsSGVpZ2h0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ3JpZFxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgcHJldlggPSAwO1xuICAgICAgICBsZXQgcHJldlkgPSAwO1xuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBkcmFnSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBkcmFnSW5kZXhPZmZzZXQgPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IGFkZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgYWRkSW5kZXhPZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwgJiYgY2hpbGQub3BhY2l0eSA8IDAuNSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUluZGV4T2Zmc2V0IC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbEluZGV4ID0gaW5kZXggKyBhZGRJbmRleE9mZnNldCArIGRyYWdJbmRleE9mZnNldCArIHJlbW92ZUluZGV4T2Zmc2V0O1xuXG4gICAgICAgICAgICBjb25zdCBpbmRleFggPSB2aXN1YWxJbmRleCAlIGl0ZW1zUGVyUm93O1xuICAgICAgICAgICAgY29uc3QgaW5kZXhZID0gTWF0aC5mbG9vcih2aXN1YWxJbmRleCAvIGl0ZW1zUGVyUm93KTtcblxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGluZGV4WCAqIGl0ZW1XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSBpbmRleFkgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JYID0gTWF0aC5zaWduKG9mZnNldFggLSBwcmV2WCk7XG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JZID0gTWF0aC5zaWduKG9mZnNldFkgLSBwcmV2WSk7XG5cbiAgICAgICAgICAgIHByZXZYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgIHByZXZZID0gb2Zmc2V0WTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLm1hcmtlZEZvclJlbW92YWwpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHNob3VsZE9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNsYXRlWSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdmVJdGVtKGNoaWxkLCBvZmZzZXRYLCBvZmZzZXRZLCB2ZWN0b3JYLCB2ZWN0b3JZKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIGFjdGlvbnMgdGhhdCBhcmUgbWVhbnQgc3BlY2lmaWNhbGx5IGZvciBhIGNlcnRhaW4gY2hpbGQgb2YgdGhlIGxpc3RcbiAqIEBwYXJhbSBjaGlsZFxuICogQHBhcmFtIGFjdGlvbnNcbiAqL1xuY29uc3QgZmlsdGVyU2V0SXRlbUFjdGlvbnMgPSAoY2hpbGQsIGFjdGlvbnMpID0+XG4gICAgYWN0aW9ucy5maWx0ZXIoYWN0aW9uID0+IHtcbiAgICAgICAgLy8gaWYgYWN0aW9uIGhhcyBhbiBpZCwgZmlsdGVyIG91dCBhY3Rpb25zIHRoYXQgZG9uJ3QgaGF2ZSB0aGlzIGNoaWxkIGlkXG4gICAgICAgIGlmIChhY3Rpb24uZGF0YSAmJiBhY3Rpb24uZGF0YS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmlkID09PSBhY3Rpb24uZGF0YS5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsbG93IGFsbCBvdGhlciBhY3Rpb25zXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG5jb25zdCBsaXN0ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkOCxcbiAgICB3cml0ZTogd3JpdGUkNSxcbiAgICB0YWc6ICd1bCcsXG4gICAgbmFtZTogJ2xpc3QnLFxuICAgIGRpZFdyaXRlVmlldzogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QuY2hpbGRWaWV3c1xuICAgICAgICAgICAgLmZpbHRlcih2aWV3ID0+IHZpZXcubWFya2VkRm9yUmVtb3ZhbCAmJiB2aWV3Lm9wYWNpdHkgPT09IDAgJiYgdmlldy5yZXN0aW5nKVxuICAgICAgICAgICAgLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICAgICAgdmlldy5fZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZDogZmlsdGVyU2V0SXRlbUFjdGlvbnMsXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIGFwaXM6IFsnZHJhZ0Nvb3JkaW5hdGVzJ10sXG4gICAgfSxcbn0pO1xuXG5jb25zdCBjcmVhdGUkOSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdCkpO1xuICAgIHByb3BzLmRyYWdDb29yZGluYXRlcyA9IG51bGw7XG4gICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcbn07XG5cbmNvbnN0IHN0b3JlRHJhZ0Nvb3JkaW5hdGVzID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbiB9KSA9PiB7XG4gICAgaWYgKCFyb290LnF1ZXJ5KCdHRVRfSVRFTV9JTlNFUlRfTE9DQVRJT05fRlJFRURPTScpKSByZXR1cm47XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0ge1xuICAgICAgICBsZWZ0OiBhY3Rpb24ucG9zaXRpb24uc2NvcGVMZWZ0IC0gcm9vdC5yZWYubGlzdC5yZWN0LmVsZW1lbnQubGVmdCxcbiAgICAgICAgdG9wOlxuICAgICAgICAgICAgYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wIC1cbiAgICAgICAgICAgIChyb290LnJlY3Qub3V0ZXIudG9wICsgcm9vdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wICsgcm9vdC5yZWN0LmVsZW1lbnQuc2Nyb2xsVG9wKSxcbiAgICB9O1xufTtcblxuY29uc3QgY2xlYXJEcmFnQ29vcmRpbmF0ZXMgPSAoeyBwcm9wcyB9KSA9PiB7XG4gICAgcHJvcHMuZHJhZ0Nvb3JkaW5hdGVzID0gbnVsbDtcbn07XG5cbmNvbnN0IHJvdXRlJDMgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX0RSQUc6IHN0b3JlRHJhZ0Nvb3JkaW5hdGVzLFxuICAgIERJRF9FTkRfRFJBRzogY2xlYXJEcmFnQ29vcmRpbmF0ZXMsXG59KTtcblxuY29uc3Qgd3JpdGUkNiA9ICh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pID0+IHtcbiAgICAvLyByb3V0ZSBhY3Rpb25zXG4gICAgcm91dGUkMyh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pO1xuXG4gICAgLy8gY3VycmVudCBkcmFnIHBvc2l0aW9uXG4gICAgcm9vdC5yZWYubGlzdC5kcmFnQ29vcmRpbmF0ZXMgPSBwcm9wcy5kcmFnQ29vcmRpbmF0ZXM7XG5cbiAgICAvLyBpZiBjdXJyZW50bHkgb3ZlcmZsb3dpbmcgYnV0IG5vIGxvbmdlciByZWNlaXZlZCBvdmVyZmxvd1xuICAgIGlmIChwcm9wcy5vdmVyZmxvd2luZyAmJiAhcHJvcHMub3ZlcmZsb3cpIHtcbiAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXNldCBvdmVyZmxvdyBzdGF0ZVxuICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5zdGF0ZSA9ICcnO1xuICAgICAgICByb290LmhlaWdodCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gaWYgaXMgbm90IG92ZXJmbG93aW5nIGN1cnJlbnRseSBidXQgZG9lcyByZWNlaXZlIG92ZXJmbG93IHZhbHVlXG4gICAgaWYgKHByb3BzLm92ZXJmbG93KSB7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgucm91bmQocHJvcHMub3ZlcmZsb3cpO1xuICAgICAgICBpZiAobmV3SGVpZ2h0ICE9PSByb290LmhlaWdodCkge1xuICAgICAgICAgICAgcHJvcHMub3ZlcmZsb3dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcm9vdC5lbGVtZW50LmRhdGFzZXQuc3RhdGUgPSAnb3ZlcmZsb3cnO1xuICAgICAgICAgICAgcm9vdC5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBsaXN0U2Nyb2xsZXIgPSBjcmVhdGVWaWV3KHtcbiAgICBjcmVhdGU6IGNyZWF0ZSQ5LFxuICAgIHdyaXRlOiB3cml0ZSQ2LFxuICAgIG5hbWU6ICdsaXN0LXNjcm9sbGVyJyxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgYXBpczogWydvdmVyZmxvdycsICdkcmFnQ29vcmRpbmF0ZXMnXSxcbiAgICAgICAgc3R5bGVzOiBbJ2hlaWdodCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6ICdzcHJpbmcnLFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuY29uc3QgYXR0clRvZ2dsZSA9IChlbGVtZW50LCBuYW1lLCBzdGF0ZSwgZW5hYmxlZFZhbHVlID0gJycpID0+IHtcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgYXR0cihlbGVtZW50LCBuYW1lLCBlbmFibGVkVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbn07XG5cbmNvbnN0IHJlc2V0RmlsZUlucHV0ID0gaW5wdXQgPT4ge1xuICAgIC8vIG5vIHZhbHVlLCBubyBuZWVkIHRvIHJlc2V0XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICB9IGNhdGNoIChlcnIpIHt9XG5cbiAgICAvLyBmb3IgSUUxMFxuICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICAvLyBxdWlja2x5IGFwcGVuZCBpbnB1dCB0byB0ZW1wIGZvcm0gYW5kIHJlc2V0IGZvcm1cbiAgICAgICAgY29uc3QgZm9ybSA9IGNyZWF0ZUVsZW1lbnQkMSgnZm9ybScpO1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gaW5wdXQucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgcmVmID0gaW5wdXQubmV4dFNpYmxpbmc7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICBmb3JtLnJlc2V0KCk7XG5cbiAgICAgICAgLy8gcmUtaW5qZWN0IGlucHV0IHdoZXJlIGl0IG9yaWdpbmFsbHkgd2FzXG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0LCByZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBjcmVhdGUkYSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBzZXQgaWQgc28gY2FuIGJlIHJlZmVyZW5jZWQgZnJvbSBvdXRzaWRlIGxhYmVsc1xuICAgIHJvb3QuZWxlbWVudC5pZCA9IGBmaWxlcG9uZC0tYnJvd3Nlci0ke3Byb3BzLmlkfWA7XG5cbiAgICAvLyBzZXQgbmFtZSBvZiBlbGVtZW50IChpcyByZW1vdmVkIHdoZW4gYSB2YWx1ZSBpcyBzZXQpXG4gICAgYXR0cihyb290LmVsZW1lbnQsICduYW1lJywgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAvLyB3ZSBoYXZlIHRvIGxpbmsgdGhpcyBlbGVtZW50IHRvIHRoZSBzdGF0dXMgZWxlbWVudFxuICAgIGF0dHIocm9vdC5lbGVtZW50LCAnYXJpYS1jb250cm9scycsIGBmaWxlcG9uZC0tYXNzaXN0YW50LSR7cHJvcHMuaWR9YCk7XG5cbiAgICAvLyBzZXQgbGFiZWwsIHdlIHVzZSBsYWJlbGxlZCBieSBhcyBvdGhlcndpc2UgdGhlIHNjcmVlbnJlYWRlciBkb2VzIG5vdCByZWFkIHRoZSBcImJyb3dzZVwiIHRleHQgaW4gdGhlIGxhYmVsIChhcyBpdCBoYXMgdGFiaW5kZXg6IDApXG4gICAgYXR0cihyb290LmVsZW1lbnQsICdhcmlhLWxhYmVsbGVkYnknLCBgZmlsZXBvbmQtLWRyb3AtbGFiZWwtJHtwcm9wcy5pZH1gKTtcblxuICAgIC8vIHNldCBjb25maWd1cmFibGUgcHJvcHNcbiAgICBzZXRBY2NlcHRlZEZpbGVUeXBlcyh7IHJvb3QsIGFjdGlvbjogeyB2YWx1ZTogcm9vdC5xdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKSB9IH0pO1xuICAgIHRvZ2dsZUFsbG93TXVsdGlwbGUoeyByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpIH0gfSk7XG4gICAgdG9nZ2xlRGlyZWN0b3J5RmlsdGVyKHsgcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWScpIH0gfSk7XG4gICAgdG9nZ2xlRGlzYWJsZWQoeyByb290IH0pO1xuICAgIHRvZ2dsZVJlcXVpcmVkKHsgcm9vdCwgYWN0aW9uOiB7IHZhbHVlOiByb290LnF1ZXJ5KCdHRVRfUkVRVUlSRUQnKSB9IH0pO1xuICAgIHNldENhcHR1cmVNZXRob2QoeyByb290LCBhY3Rpb246IHsgdmFsdWU6IHJvb3QucXVlcnkoJ0dFVF9DQVBUVVJFX01FVEhPRCcpIH0gfSk7XG5cbiAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcbiAgICByb290LnJlZi5oYW5kbGVDaGFuZ2UgPSBlID0+IHtcbiAgICAgICAgaWYgKCFyb290LmVsZW1lbnQudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4dHJhY3QgZmlsZXMgYW5kIG1vdmUgdmFsdWUgb2Ygd2Via2l0UmVsYXRpdmVQYXRoIHBhdGggdG8gX3JlbGF0aXZlUGF0aFxuICAgICAgICBjb25zdCBmaWxlcyA9IEFycmF5LmZyb20ocm9vdC5lbGVtZW50LmZpbGVzKS5tYXAoZmlsZSA9PiB7XG4gICAgICAgICAgICBmaWxlLl9yZWxhdGl2ZVBhdGggPSBmaWxlLndlYmtpdFJlbGF0aXZlUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSBhZGQgYSBsaXR0bGUgZGVsYXkgc28gdGhlIE9TIGZpbGUgc2VsZWN0IHdpbmRvdyBjYW4gbW92ZSBvdXQgb2YgdGhlIHdheSBiZWZvcmUgd2UgYWRkIG91ciBmaWxlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gbG9hZCBmaWxlc1xuICAgICAgICAgICAgcHJvcHMub25sb2FkKGZpbGVzKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgaW5wdXQsIGl0J3MganVzdCBmb3IgZXhwb3NpbmcgYSBtZXRob2QgdG8gZHJvcCBmaWxlcywgc2hvdWxkIG5vdCByZXRhaW4gYW55IHN0YXRlXG4gICAgICAgICAgICByZXNldEZpbGVJbnB1dChyb290LmVsZW1lbnQpO1xuICAgICAgICB9LCAyNTApO1xuICAgIH07XG5cbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgcm9vdC5yZWYuaGFuZGxlQ2hhbmdlKTtcbn07XG5cbmNvbnN0IHNldEFjY2VwdGVkRmlsZVR5cGVzID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBpZiAoIXJvb3QucXVlcnkoJ0dFVF9BTExPV19TWU5DX0FDQ0VQVF9BVFRSSUJVVEUnKSkgcmV0dXJuO1xuICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAnYWNjZXB0JywgISFhY3Rpb24udmFsdWUsIGFjdGlvbi52YWx1ZSA/IGFjdGlvbi52YWx1ZS5qb2luKCcsJykgOiAnJyk7XG59O1xuXG5jb25zdCB0b2dnbGVBbGxvd011bHRpcGxlID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ211bHRpcGxlJywgYWN0aW9uLnZhbHVlKTtcbn07XG5cbmNvbnN0IHRvZ2dsZURpcmVjdG9yeUZpbHRlciA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICd3ZWJraXRkaXJlY3RvcnknLCBhY3Rpb24udmFsdWUpO1xufTtcblxuY29uc3QgdG9nZ2xlRGlzYWJsZWQgPSAoeyByb290IH0pID0+IHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgY29uc3QgZG9lc0FsbG93QnJvd3NlID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgIGNvbnN0IGRpc2FibGVGaWVsZCA9IGlzRGlzYWJsZWQgfHwgIWRvZXNBbGxvd0Jyb3dzZTtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2Rpc2FibGVkJywgZGlzYWJsZUZpZWxkKTtcbn07XG5cbmNvbnN0IHRvZ2dsZVJlcXVpcmVkID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAvLyB3YW50IHRvIHJlbW92ZSByZXF1aXJlZCwgYWx3YXlzIHBvc3NpYmxlXG4gICAgaWYgKCFhY3Rpb24udmFsdWUpIHtcbiAgICAgICAgYXR0clRvZ2dsZShyb290LmVsZW1lbnQsICdyZXF1aXJlZCcsIGZhbHNlKTtcbiAgICB9XG4gICAgLy8gaWYgd2FudCB0byBtYWtlIHJlcXVpcmVkLCBvbmx5IHBvc3NpYmxlIHdoZW4gemVybyBpdGVtc1xuICAgIGVsc2UgaWYgKHJvb3QucXVlcnkoJ0dFVF9UT1RBTF9JVEVNUycpID09PSAwKSB7XG4gICAgICAgIGF0dHJUb2dnbGUocm9vdC5lbGVtZW50LCAncmVxdWlyZWQnLCB0cnVlKTtcbiAgICB9XG59O1xuXG5jb25zdCBzZXRDYXB0dXJlTWV0aG9kID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBhdHRyVG9nZ2xlKHJvb3QuZWxlbWVudCwgJ2NhcHR1cmUnLCAhIWFjdGlvbi52YWx1ZSwgYWN0aW9uLnZhbHVlID09PSB0cnVlID8gJycgOiBhY3Rpb24udmFsdWUpO1xufTtcblxuY29uc3QgdXBkYXRlUmVxdWlyZWRTdGF0dXMgPSAoeyByb290IH0pID0+IHtcbiAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHJvb3Q7XG4gICAgLy8gYWx3YXlzIHJlbW92ZSB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIHdoZW4gbW9yZSB0aGFuIHplcm8gaXRlbXNcbiAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJykgPiAwKSB7XG4gICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgZmFsc2UpO1xuICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFkZCBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICBhdHRyVG9nZ2xlKGVsZW1lbnQsICduYW1lJywgdHJ1ZSwgcm9vdC5xdWVyeSgnR0VUX05BTUUnKSk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSB2YWxpZGF0aW9uIG1lc3NhZ2VzXG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrVmFsaWRpdHkgPSByb290LnF1ZXJ5KCdHRVRfQ0hFQ0tfVkFMSURJVFknKTtcbiAgICAgICAgaWYgKHNob3VsZENoZWNrVmFsaWRpdHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2Ugb25seSBhZGQgcmVxdWlyZWQgaWYgdGhlIGZpZWxkIGhhcyBiZWVuIGRlZW1lZCByZXF1aXJlZFxuICAgICAgICBpZiAocm9vdC5xdWVyeSgnR0VUX1JFUVVJUkVEJykpIHtcbiAgICAgICAgICAgIGF0dHJUb2dnbGUoZWxlbWVudCwgJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCB1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkQ2hlY2tWYWxpZGl0eSA9IHJvb3QucXVlcnkoJ0dFVF9DSEVDS19WQUxJRElUWScpO1xuICAgIGlmICghc2hvdWxkQ2hlY2tWYWxpZGl0eSkgcmV0dXJuO1xuICAgIHJvb3QuZWxlbWVudC5zZXRDdXN0b21WYWxpZGl0eShyb290LnF1ZXJ5KCdHRVRfTEFCRUxfSU5WQUxJRF9GSUVMRCcpKTtcbn07XG5cbmNvbnN0IGJyb3dzZXIgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdpbnB1dCcsXG4gICAgbmFtZTogJ2Jyb3dzZXInLFxuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICB9LFxuICAgIGNyZWF0ZTogY3JlYXRlJGEsXG4gICAgZGVzdHJveTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByb290LnJlZi5oYW5kbGVDaGFuZ2UpO1xuICAgIH0sXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgIERJRF9SRU1PVkVfSVRFTTogdXBkYXRlUmVxdWlyZWRTdGF0dXMsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IHVwZGF0ZUZpZWxkVmFsaWRpdHlTdGF0dXMsXG5cbiAgICAgICAgRElEX1NFVF9ESVNBQkxFRDogdG9nZ2xlRGlzYWJsZWQsXG4gICAgICAgIERJRF9TRVRfQUxMT1dfQlJPV1NFOiB0b2dnbGVEaXNhYmxlZCxcbiAgICAgICAgRElEX1NFVF9BTExPV19ESVJFQ1RPUklFU19PTkxZOiB0b2dnbGVEaXJlY3RvcnlGaWx0ZXIsXG4gICAgICAgIERJRF9TRVRfQUxMT1dfTVVMVElQTEU6IHRvZ2dsZUFsbG93TXVsdGlwbGUsXG4gICAgICAgIERJRF9TRVRfQUNDRVBURURfRklMRV9UWVBFUzogc2V0QWNjZXB0ZWRGaWxlVHlwZXMsXG4gICAgICAgIERJRF9TRVRfQ0FQVFVSRV9NRVRIT0Q6IHNldENhcHR1cmVNZXRob2QsXG4gICAgICAgIERJRF9TRVRfUkVRVUlSRUQ6IHRvZ2dsZVJlcXVpcmVkLFxuICAgIH0pLFxufSk7XG5cbmNvbnN0IEtleSA9IHtcbiAgICBFTlRFUjogMTMsXG4gICAgU1BBQ0U6IDMyLFxufTtcblxuY29uc3QgY3JlYXRlJGIgPSAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgLy8gY3JlYXRlIHRoZSBsYWJlbCBhbmQgbGluayBpdCB0byB0aGUgZmlsZSBicm93c2VyXG4gICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50JDEoJ2xhYmVsJyk7XG4gICAgYXR0cihsYWJlbCwgJ2ZvcicsIGBmaWxlcG9uZC0tYnJvd3Nlci0ke3Byb3BzLmlkfWApO1xuXG4gICAgLy8gdXNlIGZvciBsYWJlbGluZyBmaWxlIGlucHV0IChhcmlhLWxhYmVsbGVkYnkgb24gZmlsZSBpbnB1dClcbiAgICBhdHRyKGxhYmVsLCAnaWQnLCBgZmlsZXBvbmQtLWRyb3AtbGFiZWwtJHtwcm9wcy5pZH1gKTtcblxuICAgIC8vIGhhbmRsZSBrZXlzXG4gICAgcm9vdC5yZWYuaGFuZGxlS2V5RG93biA9IGUgPT4ge1xuICAgICAgICBjb25zdCBpc0FjdGl2YXRpb25LZXkgPSBlLmtleUNvZGUgPT09IEtleS5FTlRFUiB8fCBlLmtleUNvZGUgPT09IEtleS5TUEFDRTtcbiAgICAgICAgaWYgKCFpc0FjdGl2YXRpb25LZXkpIHJldHVybjtcbiAgICAgICAgLy8gc3RvcHMgZnJvbSB0cmlnZ2VyaW5nIHRoZSBlbGVtZW50IGEgc2Vjb25kIHRpbWVcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIGNsaWNrIGxpbmsgKHdpbGwgdGhlbiBpbiB0dXJuIGFjdGl2YXRlIGZpbGUgaW5wdXQpXG4gICAgICAgIHJvb3QucmVmLmxhYmVsLmNsaWNrKCk7XG4gICAgfTtcblxuICAgIHJvb3QucmVmLmhhbmRsZUNsaWNrID0gZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxDbGljayA9IGUudGFyZ2V0ID09PSBsYWJlbCB8fCBsYWJlbC5jb250YWlucyhlLnRhcmdldCk7XG5cbiAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byBjbGljayB0d2ljZVxuICAgICAgICBpZiAoaXNMYWJlbENsaWNrKSByZXR1cm47XG5cbiAgICAgICAgLy8gY2xpY2sgbGluayAod2lsbCB0aGVuIGluIHR1cm4gYWN0aXZhdGUgZmlsZSBpbnB1dClcbiAgICAgICAgcm9vdC5yZWYubGFiZWwuY2xpY2soKTtcbiAgICB9O1xuXG4gICAgLy8gYXR0YWNoIGV2ZW50c1xuICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByb290LnJlZi5oYW5kbGVDbGljayk7XG5cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVMYWJlbFZhbHVlKGxhYmVsLCBwcm9wcy5jYXB0aW9uKTtcblxuICAgIC8vIGFkZCFcbiAgICByb290LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICByb290LnJlZi5sYWJlbCA9IGxhYmVsO1xufTtcblxuY29uc3QgdXBkYXRlTGFiZWxWYWx1ZSA9IChsYWJlbCwgdmFsdWUpID0+IHtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSB2YWx1ZTtcbiAgICBjb25zdCBjbGlja2FibGUgPSBsYWJlbC5xdWVyeVNlbGVjdG9yKCcuZmlsZXBvbmQtLWxhYmVsLWFjdGlvbicpO1xuICAgIGlmIChjbGlja2FibGUpIHtcbiAgICAgICAgYXR0cihjbGlja2FibGUsICd0YWJpbmRleCcsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmNvbnN0IGRyb3BMYWJlbCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdkcm9wLWxhYmVsJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGNyZWF0ZTogY3JlYXRlJGIsXG4gICAgZGVzdHJveTogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHJvb3QucmVmLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCByb290LnJlZi5oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcm9vdC5yZWYuaGFuZGxlQ2xpY2spO1xuICAgIH0sXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX1NFVF9MQUJFTF9JRExFOiAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlTGFiZWxWYWx1ZShyb290LnJlZi5sYWJlbCwgYWN0aW9uLnZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBtaXhpbnM6IHtcbiAgICAgICAgc3R5bGVzOiBbJ29wYWNpdHknLCAndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJ10sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IHsgdHlwZTogJ3R3ZWVuJywgZHVyYXRpb246IDE1MCB9LFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogJ3NwcmluZycsXG4gICAgICAgICAgICB0cmFuc2xhdGVZOiAnc3ByaW5nJyxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGJsb2IgPSBjcmVhdGVWaWV3KHtcbiAgICBuYW1lOiAnZHJpcC1ibG9iJyxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIG1peGluczoge1xuICAgICAgICBzdHlsZXM6IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgJ3NjYWxlWCcsICdzY2FsZVknLCAnb3BhY2l0eSddLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBzY2FsZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgc2NhbGVZOiAnc3ByaW5nJyxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6ICdzcHJpbmcnLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogJ3NwcmluZycsXG4gICAgICAgICAgICBvcGFjaXR5OiB7IHR5cGU6ICd0d2VlbicsIGR1cmF0aW9uOiAyNTAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmNvbnN0IGFkZEJsb2IgPSAoeyByb290IH0pID0+IHtcbiAgICBjb25zdCBjZW50ZXJYID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGggKiAwLjU7XG4gICAgY29uc3QgY2VudGVyWSA9IHJvb3QucmVjdC5lbGVtZW50LmhlaWdodCAqIDAuNTtcblxuICAgIHJvb3QucmVmLmJsb2IgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgcm9vdC5jcmVhdGVDaGlsZFZpZXcoYmxvYiwge1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHNjYWxlWDogMi41LFxuICAgICAgICAgICAgc2NhbGVZOiAyLjUsXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiBjZW50ZXJYLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogY2VudGVyWSxcbiAgICAgICAgfSlcbiAgICApO1xufTtcblxuY29uc3QgbW92ZUJsb2IgPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGlmICghcm9vdC5yZWYuYmxvYikge1xuICAgICAgICBhZGRCbG9iKHsgcm9vdCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJvb3QucmVmLmJsb2IudHJhbnNsYXRlWCA9IGFjdGlvbi5wb3NpdGlvbi5zY29wZUxlZnQ7XG4gICAgcm9vdC5yZWYuYmxvYi50cmFuc2xhdGVZID0gYWN0aW9uLnBvc2l0aW9uLnNjb3BlVG9wO1xuICAgIHJvb3QucmVmLmJsb2Iuc2NhbGVYID0gMTtcbiAgICByb290LnJlZi5ibG9iLnNjYWxlWSA9IDE7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMTtcbn07XG5cbmNvbnN0IGhpZGVCbG9iID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbn07XG5cbmNvbnN0IGV4cGxvZGVCbG9iID0gKHsgcm9vdCB9KSA9PiB7XG4gICAgaWYgKCFyb290LnJlZi5ibG9iKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVggPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5zY2FsZVkgPSAyLjU7XG4gICAgcm9vdC5yZWYuYmxvYi5vcGFjaXR5ID0gMDtcbn07XG5cbmNvbnN0IHdyaXRlJDcgPSAoeyByb290LCBwcm9wcywgYWN0aW9ucyB9KSA9PiB7XG4gICAgcm91dGUkNCh7IHJvb3QsIHByb3BzLCBhY3Rpb25zIH0pO1xuXG4gICAgY29uc3QgeyBibG9iIH0gPSByb290LnJlZjtcblxuICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PT0gMCAmJiBibG9iICYmIGJsb2Iub3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhibG9iKTtcbiAgICAgICAgcm9vdC5yZWYuYmxvYiA9IG51bGw7XG4gICAgfVxufTtcblxuY29uc3Qgcm91dGUkNCA9IGNyZWF0ZVJvdXRlKHtcbiAgICBESURfRFJBRzogbW92ZUJsb2IsXG4gICAgRElEX0RST1A6IGV4cGxvZGVCbG9iLFxuICAgIERJRF9FTkRfRFJBRzogaGlkZUJsb2IsXG59KTtcblxuY29uc3QgZHJpcCA9IGNyZWF0ZVZpZXcoe1xuICAgIGlnbm9yZVJlY3Q6IHRydWUsXG4gICAgaWdub3JlUmVjdFVwZGF0ZTogdHJ1ZSxcbiAgICBuYW1lOiAnZHJpcCcsXG4gICAgd3JpdGU6IHdyaXRlJDcsXG59KTtcblxuY29uc3Qgc2V0SW5wdXRGaWxlcyA9IChlbGVtZW50LCBmaWxlcykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIERhdGFUcmFuc2ZlciBpbnN0YW5jZSBhbmQgYWRkIGEgbmV3bHkgY3JlYXRlZCBmaWxlXG4gICAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IG5ldyBEYXRhVHJhbnNmZXIoKTtcbiAgICAgICAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoZmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBGaWxlKFtmaWxlXSwgZmlsZS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQXNzaWduIHRoZSBEYXRhVHJhbnNmZXIgZmlsZXMgbGlzdCB0byB0aGUgZmlsZSBpbnB1dFxuICAgICAgICBlbGVtZW50LmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgY3JlYXRlJGMgPSAoeyByb290IH0pID0+IHtcbiAgICByb290LnJlZi5maWVsZHMgPSB7fTtcbiAgICBjb25zdCBsZWdlbmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsZWdlbmQnKTtcbiAgICBsZWdlbmQudGV4dENvbnRlbnQgPSAnRmlsZXMnO1xuICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChsZWdlbmQpO1xufTtcblxuY29uc3QgZ2V0RmllbGQgPSAocm9vdCwgaWQpID0+IHJvb3QucmVmLmZpZWxkc1tpZF07XG5cbmNvbnN0IHN5bmNGaWVsZFBvc2l0aW9uc1dpdGhJdGVtcyA9IHJvb3QgPT4ge1xuICAgIHJvb3QucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIXJvb3QucmVmLmZpZWxkc1tpdGVtLmlkXSkgcmV0dXJuO1xuICAgICAgICByb290LmVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdC5yZWYuZmllbGRzW2l0ZW0uaWRdKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGRpZFJlb3JkZXJJdGVtcyA9ICh7IHJvb3QgfSkgPT4gc3luY0ZpZWxkUG9zaXRpb25zV2l0aEl0ZW1zKHJvb3QpO1xuXG5jb25zdCBkaWRBZGRJdGVtID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCBmaWxlSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBpc0xvY2FsRmlsZSA9IGZpbGVJdGVtLm9yaWdpbiA9PT0gRmlsZU9yaWdpbi5MT0NBTDtcbiAgICBjb25zdCBzaG91bGRVc2VGaWxlSW5wdXQgPSAhaXNMb2NhbEZpbGUgJiYgcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJyk7XG4gICAgY29uc3QgZGF0YUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQkMSgnaW5wdXQnKTtcbiAgICBkYXRhQ29udGFpbmVyLnR5cGUgPSBzaG91bGRVc2VGaWxlSW5wdXQgPyAnZmlsZScgOiAnaGlkZGVuJztcbiAgICBkYXRhQ29udGFpbmVyLm5hbWUgPSByb290LnF1ZXJ5KCdHRVRfTkFNRScpO1xuICAgIHJvb3QucmVmLmZpZWxkc1thY3Rpb24uaWRdID0gZGF0YUNvbnRhaW5lcjtcbiAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG59O1xuXG5jb25zdCBkaWRMb2FkSXRlbSQxID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKHJvb3QsIGFjdGlvbi5pZCk7XG4gICAgaWYgKCFmaWVsZCkgcmV0dXJuO1xuXG4gICAgLy8gc3RvcmUgc2VydmVyIHJlZiBpbiBoaWRkZW4gaW5wdXRcbiAgICBpZiAoYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2UgIT09IG51bGwpIGZpZWxkLnZhbHVlID0gYWN0aW9uLnNlcnZlckZpbGVSZWZlcmVuY2U7XG5cbiAgICAvLyBzdG9yZSBmaWxlIGl0ZW0gaW4gZmlsZSBpbnB1dFxuICAgIGlmICghcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJykpIHJldHVybjtcblxuICAgIGNvbnN0IGZpbGVJdGVtID0gcm9vdC5xdWVyeSgnR0VUX0lURU0nLCBhY3Rpb24uaWQpO1xuICAgIHNldElucHV0RmlsZXMoZmllbGQsIFtmaWxlSXRlbS5maWxlXSk7XG59O1xuXG5jb25zdCBkaWRQcmVwYXJlT3V0cHV0ID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICAvLyB0aGlzIHRpbWVvdXQgcHVzaGVzIHRoZSBoYW5kbGVyIGFmdGVyICdsb2FkJ1xuICAgIGlmICghcm9vdC5xdWVyeSgnU0hPVUxEX1VQREFURV9GSUxFX0lOUFVUJykpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgICAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgICAgIHNldElucHV0RmlsZXMoZmllbGQsIFthY3Rpb24uZmlsZV0pO1xuICAgIH0sIDApO1xufTtcblxuY29uc3QgZGlkU2V0RGlzYWJsZWQgPSAoeyByb290IH0pID0+IHtcbiAgICByb290LmVsZW1lbnQuZGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbn07XG5cbmNvbnN0IGRpZFJlbW92ZUl0ZW0gPSAoeyByb290LCBhY3Rpb24gfSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZ2V0RmllbGQocm9vdCwgYWN0aW9uLmlkKTtcbiAgICBpZiAoIWZpZWxkKSByZXR1cm47XG4gICAgaWYgKGZpZWxkLnBhcmVudE5vZGUpIGZpZWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmllbGQpO1xuICAgIGRlbGV0ZSByb290LnJlZi5maWVsZHNbYWN0aW9uLmlkXTtcbn07XG5cbi8vIG9ubHkgcnVucyBmb3Igc2VydmVyIGZpbGVzLiB3aWxsIHJlZnVzZSB0byB1cGRhdGUgdGhlIHZhbHVlIGlmIHRoZSBmaWVsZFxuLy8gaXMgYSBmaWxlIGZpZWxkXG5jb25zdCBkaWREZWZpbmVWYWx1ZSA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgZmllbGQgPSBnZXRGaWVsZChyb290LCBhY3Rpb24uaWQpO1xuICAgIGlmICghZmllbGQpIHJldHVybjtcbiAgICBpZiAoYWN0aW9uLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIC8vIGNsZWFyIGZpZWxkIHZhbHVlXG4gICAgICAgIGZpZWxkLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXQgZmllbGQgdmFsdWVcbiAgICAgICAgaWYgKGZpZWxkLnR5cGUgIT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBmaWVsZC52YWx1ZSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMocm9vdCk7XG59O1xuXG5jb25zdCB3cml0ZSQ4ID0gY3JlYXRlUm91dGUoe1xuICAgIERJRF9TRVRfRElTQUJMRUQ6IGRpZFNldERpc2FibGVkLFxuICAgIERJRF9BRERfSVRFTTogZGlkQWRkSXRlbSxcbiAgICBESURfTE9BRF9JVEVNOiBkaWRMb2FkSXRlbSQxLFxuICAgIERJRF9SRU1PVkVfSVRFTTogZGlkUmVtb3ZlSXRlbSxcbiAgICBESURfREVGSU5FX1ZBTFVFOiBkaWREZWZpbmVWYWx1ZSxcbiAgICBESURfUFJFUEFSRV9PVVRQVVQ6IGRpZFByZXBhcmVPdXRwdXQsXG4gICAgRElEX1JFT1JERVJfSVRFTVM6IGRpZFJlb3JkZXJJdGVtcyxcbiAgICBESURfU09SVF9JVEVNUzogZGlkUmVvcmRlckl0ZW1zLFxufSk7XG5cbmNvbnN0IGRhdGEgPSBjcmVhdGVWaWV3KHtcbiAgICB0YWc6ICdmaWVsZHNldCcsXG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIGNyZWF0ZTogY3JlYXRlJGMsXG4gICAgd3JpdGU6IHdyaXRlJDgsXG4gICAgaWdub3JlUmVjdDogdHJ1ZSxcbn0pO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9IGVsZW1lbnQgPT4gKCdnZXRSb290Tm9kZScgaW4gZWxlbWVudCA/IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50KTtcblxuY29uc3QgaW1hZ2VzID0gWydqcGcnLCAnanBlZycsICdwbmcnLCAnZ2lmJywgJ2JtcCcsICd3ZWJwJywgJ3N2ZycsICd0aWZmJ107XG5jb25zdCB0ZXh0JDEgPSBbJ2NzcycsICdjc3YnLCAnaHRtbCcsICd0eHQnXTtcbmNvbnN0IG1hcCA9IHtcbiAgICB6aXA6ICd6aXB8Y29tcHJlc3NlZCcsXG4gICAgZXB1YjogJ2FwcGxpY2F0aW9uL2VwdWIremlwJyxcbn07XG5cbmNvbnN0IGd1ZXNzdGltYXRlTWltZVR5cGUgPSAoZXh0ZW5zaW9uID0gJycpID0+IHtcbiAgICBleHRlbnNpb24gPSBleHRlbnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaW1hZ2VzLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICdpbWFnZS8nICsgKGV4dGVuc2lvbiA9PT0gJ2pwZycgPyAnanBlZycgOiBleHRlbnNpb24gPT09ICdzdmcnID8gJ3N2Zyt4bWwnIDogZXh0ZW5zaW9uKVxuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAodGV4dCQxLmluY2x1ZGVzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgcmV0dXJuICd0ZXh0LycgKyBleHRlbnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcFtleHRlbnNpb25dIHx8ICcnO1xufTtcblxuY29uc3QgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zID0gZGF0YVRyYW5zZmVyID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyB0cnkgdG8gZ2V0IGxpbmtzIGZyb20gdHJhbnNmZXIsIGlmIGZvdW5kIHdlJ2xsIGV4aXQgaW1tZWRpYXRlbHkgKHVubGVzcyBhIGZpbGUgaXMgaW4gdGhlIGRhdGFUcmFuc2ZlciBhcyB3ZWxsLCB0aGlzIGlzIGJlY2F1c2UgRmlyZWZveCBjb3VsZCByZXByZXNlbnQgdGhlIGZpbGUgYXMgYSBVUkwgYW5kIGEgZmlsZSBvYmplY3QgYXQgdGhlIHNhbWUgdGltZSlcbiAgICAgICAgY29uc3QgbGlua3MgPSBnZXRMaW5rcyhkYXRhVHJhbnNmZXIpO1xuICAgICAgICBpZiAobGlua3MubGVuZ3RoICYmICFoYXNGaWxlcyhkYXRhVHJhbnNmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsaW5rcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IHRvIGdldCBmaWxlcyBmcm9tIHRoZSB0cmFuc2ZlclxuICAgICAgICBnZXRGaWxlcyhkYXRhVHJhbnNmZXIpLnRoZW4ocmVzb2x2ZSk7XG4gICAgfSk7XG5cbi8qKlxuICogVGVzdCBpZiBkYXRhdHJhbnNmZXIgaGFzIGZpbGVzXG4gKi9cbmNvbnN0IGhhc0ZpbGVzID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgICBpZiAoZGF0YVRyYW5zZmVyLmZpbGVzKSByZXR1cm4gZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBmaWxlcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5jb25zdCBnZXRGaWxlcyA9IGRhdGFUcmFuc2ZlciA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFuc2ZlciBpdGVtcyBhcyBwcm9taXNlc1xuICAgICAgICBjb25zdCBwcm9taXNlZEZpbGVzID0gKGRhdGFUcmFuc2Zlci5pdGVtcyA/IEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLml0ZW1zKSA6IFtdKVxuXG4gICAgICAgICAgICAvLyBvbmx5IGtlZXAgZmlsZSBzeXN0ZW0gaXRlbXMgKGZpbGVzIGFuZCBkaXJlY3RvcmllcylcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpc0ZpbGVTeXN0ZW1JdGVtKGl0ZW0pKVxuXG4gICAgICAgICAgICAvLyBtYXAgZWFjaCBpdGVtIHRvIHByb21pc2VcbiAgICAgICAgICAgIC5tYXAoaXRlbSA9PiBnZXRGaWxlc0Zyb21JdGVtKGl0ZW0pKTtcblxuICAgICAgICAvLyBpZiBpcyBlbXB0eSwgc2VlIGlmIHdlIGNhbiBleHRyYWN0IHNvbWUgaW5mbyBmcm9tIHRoZSBmaWxlcyBwcm9wZXJ0eSBhcyBhIGZhbGxiYWNrXG4gICAgICAgIGlmICghcHJvbWlzZWRGaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHRlc3QgZm9yIGRpcmVjdG9yaWVzIChzaG91bGQgbm90IGJlIGFsbG93ZWQpXG4gICAgICAgICAgICAvLyBVc2UgRmlsZVJlYWRlciwgcHJvYmxlbSBpcyB0aGF0IHRoZSBmaWxlcyBwcm9wZXJ0eSBnZXRzIGxvc3QgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YVRyYW5zZmVyLmZpbGVzID8gQXJyYXkuZnJvbShkYXRhVHJhbnNmZXIuZmlsZXMpIDogW10pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uZSFcbiAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZWRGaWxlcylcbiAgICAgICAgICAgIC50aGVuKHJldHVybmVkRmlsZUdyb3VwcyA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBncm91cHNcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybmVkRmlsZUdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaC5hcHBseShmaWxlcywgZ3JvdXApO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gZG9uZSAoZmlsdGVyIG91dCBlbXB0eSBmaWxlcykhXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsZSA9PiBmaWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmaWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGUuX3JlbGF0aXZlUGF0aCkgZmlsZS5fcmVsYXRpdmVQYXRoID0gZmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH0pO1xuXG5jb25zdCBpc0ZpbGVTeXN0ZW1JdGVtID0gaXRlbSA9PiB7XG4gICAgaWYgKGlzRW50cnkoaXRlbSkpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBnZXRBc0VudHJ5KGl0ZW0pO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5pc0ZpbGUgfHwgZW50cnkuaXNEaXJlY3Rvcnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW0ua2luZCA9PT0gJ2ZpbGUnO1xufTtcblxuY29uc3QgZ2V0RmlsZXNGcm9tSXRlbSA9IGl0ZW0gPT5cbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmIChpc0RpcmVjdG9yeUVudHJ5KGl0ZW0pKSB7XG4gICAgICAgICAgICBnZXRGaWxlc0luRGlyZWN0b3J5KGdldEFzRW50cnkoaXRlbSkpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoW2l0ZW0uZ2V0QXNGaWxlKCldKTtcbiAgICB9KTtcblxuY29uc3QgZ2V0RmlsZXNJbkRpcmVjdG9yeSA9IGVudHJ5ID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuXG4gICAgICAgIC8vIHRoZSB0b3RhbCBlbnRyaWVzIHRvIHJlYWRcbiAgICAgICAgbGV0IGRpckNvdW50ZXIgPSAwO1xuICAgICAgICBsZXQgZmlsZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGNvbnN0IHJlc29sdmVJZkRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZUNvdW50ZXIgPT09IDAgJiYgZGlyQ291bnRlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoZSByZWN1cnNpdmUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVhZEVudHJpZXMgPSBkaXJFbnRyeSA9PiB7XG4gICAgICAgICAgICBkaXJDb3VudGVyKys7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdG9yeVJlYWRlciA9IGRpckVudHJ5LmNyZWF0ZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAvLyBkaXJlY3RvcmllcyBhcmUgcmV0dXJuZWQgaW4gYmF0Y2hlcywgd2UgbmVlZCB0byBwcm9jZXNzIGFsbCBiYXRjaGVzIGJlZm9yZSB3ZSdyZSBkb25lXG4gICAgICAgICAgICBjb25zdCByZWFkQmF0Y2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5UmVhZGVyLnJlYWRFbnRyaWVzKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpckNvdW50ZXItLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVJZkRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSByZWFkIG1vcmUgZGlyZWN0b3JpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVhZCBhcyBmaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZUNvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LmZpbGUoZmlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZEZpbGUgPSBjb3JyZWN0TWlzc2luZ0ZpbGVUeXBlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW50cnkuZnVsbFBhdGgpIGNvcnJlY3RlZEZpbGUuX3JlbGF0aXZlUGF0aCA9IGVudHJ5LmZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGNvcnJlY3RlZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlQ291bnRlci0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSWZEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBnZXQgbmV4dCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgICAgICAgICByZWFkQmF0Y2goKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gcmVhZCBmaXJzdCBiYXRjaCBvZiBmaWxlc1xuICAgICAgICAgICAgcmVhZEJhdGNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ28hXG4gICAgICAgIHJlYWRFbnRyaWVzKGVudHJ5KTtcbiAgICB9KTtcblxuY29uc3QgY29ycmVjdE1pc3NpbmdGaWxlVHlwZSA9IGZpbGUgPT4ge1xuICAgIGlmIChmaWxlLnR5cGUubGVuZ3RoKSByZXR1cm4gZmlsZTtcbiAgICBjb25zdCBkYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIGNvbnN0IG5hbWUgPSBmaWxlLm5hbWU7XG4gICAgY29uc3QgdHlwZSA9IGd1ZXNzdGltYXRlTWltZVR5cGUoZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGUubmFtZSkpO1xuICAgIGlmICghdHlwZS5sZW5ndGgpIHJldHVybiBmaWxlO1xuICAgIGZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgdHlwZSk7XG4gICAgZmlsZS5uYW1lID0gbmFtZTtcbiAgICBmaWxlLmxhc3RNb2RpZmllZERhdGUgPSBkYXRlO1xuICAgIHJldHVybiBmaWxlO1xufTtcblxuY29uc3QgaXNEaXJlY3RvcnlFbnRyeSA9IGl0ZW0gPT4gaXNFbnRyeShpdGVtKSAmJiAoZ2V0QXNFbnRyeShpdGVtKSB8fCB7fSkuaXNEaXJlY3Rvcnk7XG5cbmNvbnN0IGlzRW50cnkgPSBpdGVtID0+ICd3ZWJraXRHZXRBc0VudHJ5JyBpbiBpdGVtO1xuXG5jb25zdCBnZXRBc0VudHJ5ID0gaXRlbSA9PiBpdGVtLndlYmtpdEdldEFzRW50cnkoKTtcblxuLyoqXG4gKiBFeHRyYWN0cyBsaW5rcyBmcm9tIGEgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5jb25zdCBnZXRMaW5rcyA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgbGV0IGxpbmtzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gbG9vayBpbiBtZXRhIGRhdGEgcHJvcGVydHlcbiAgICAgICAgbGlua3MgPSBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5rcztcbiAgICAgICAgfVxuICAgICAgICBsaW5rcyA9IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YShkYXRhVHJhbnNmZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gbm9wZSBub3BlIG5vcGUgKHByb2JhYmx5IElFIHRyb3VibGUpXG4gICAgfVxuICAgIHJldHVybiBsaW5rcztcbn07XG5cbmNvbnN0IGdldExpbmtzRnJvbVRyYW5zZmVyVVJMRGF0YSA9IGRhdGFUcmFuc2ZlciA9PiB7XG4gICAgbGV0IGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndXJsJyk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG5jb25zdCBnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgICBsZXQgZGF0YSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L2h0bWwnKTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBkYXRhLm1hdGNoKC9zcmNcXHMqPVxccypcIiguKz8pXCIvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbWF0Y2hlc1sxXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuY29uc3QgZHJhZ05Ecm9wT2JzZXJ2ZXJzID0gW107XG5cbmNvbnN0IGV2ZW50UG9zaXRpb24gPSBlID0+ICh7XG4gICAgcGFnZUxlZnQ6IGUucGFnZVgsXG4gICAgcGFnZVRvcDogZS5wYWdlWSxcbiAgICBzY29wZUxlZnQ6IGUub2Zmc2V0WCB8fCBlLmxheWVyWCxcbiAgICBzY29wZVRvcDogZS5vZmZzZXRZIHx8IGUubGF5ZXJZLFxufSk7XG5cbmNvbnN0IGNyZWF0ZURyYWdORHJvcENsaWVudCA9IChlbGVtZW50LCBzY29wZVRvT2JzZXJ2ZSwgZmlsdGVyRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IG9ic2VydmVyID0gZ2V0RHJhZ05Ecm9wT2JzZXJ2ZXIoc2NvcGVUb09ic2VydmUpO1xuXG4gICAgY29uc3QgY2xpZW50ID0ge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBmaWx0ZXJFbGVtZW50LFxuICAgICAgICBzdGF0ZTogbnVsbCxcbiAgICAgICAgb25kcm9wOiAoKSA9PiB7fSxcbiAgICAgICAgb25lbnRlcjogKCkgPT4ge30sXG4gICAgICAgIG9uZHJhZzogKCkgPT4ge30sXG4gICAgICAgIG9uZXhpdDogKCkgPT4ge30sXG4gICAgICAgIG9ubG9hZDogKCkgPT4ge30sXG4gICAgICAgIGFsbG93ZHJvcDogKCkgPT4ge30sXG4gICAgfTtcblxuICAgIGNsaWVudC5kZXN0cm95ID0gb2JzZXJ2ZXIuYWRkTGlzdGVuZXIoY2xpZW50KTtcblxuICAgIHJldHVybiBjbGllbnQ7XG59O1xuXG5jb25zdCBnZXREcmFnTkRyb3BPYnNlcnZlciA9IGVsZW1lbnQgPT4ge1xuICAgIC8vIHNlZSBpZiBhbHJlYWR5IGV4aXN0cywgaWYgc28sIHJldHVyblxuICAgIGNvbnN0IG9ic2VydmVyID0gZHJhZ05Ecm9wT2JzZXJ2ZXJzLmZpbmQoaXRlbSA9PiBpdGVtLmVsZW1lbnQgPT09IGVsZW1lbnQpO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXI7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG5ldyBvYnNlcnZlciwgZG9lcyBub3QgeWV0IGV4aXN0IGZvciB0aGlzIGVsZW1lbnRcbiAgICBjb25zdCBuZXdPYnNlcnZlciA9IGNyZWF0ZURyYWdORHJvcE9ic2VydmVyKGVsZW1lbnQpO1xuICAgIGRyYWdORHJvcE9ic2VydmVycy5wdXNoKG5ld09ic2VydmVyKTtcbiAgICByZXR1cm4gbmV3T2JzZXJ2ZXI7XG59O1xuXG5jb25zdCBjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciA9IGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGNsaWVudHMgPSBbXTtcblxuICAgIGNvbnN0IHJvdXRlcyA9IHtcbiAgICAgICAgZHJhZ2VudGVyLFxuICAgICAgICBkcmFnb3ZlcixcbiAgICAgICAgZHJhZ2xlYXZlLFxuICAgICAgICBkcm9wLFxuICAgIH07XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHt9O1xuXG4gICAgZm9yaW4ocm91dGVzLCAoZXZlbnQsIGNyZWF0ZUhhbmRsZXIpID0+IHtcbiAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjbGllbnRzKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9ic2VydmVyID0ge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBhZGRMaXN0ZW5lcjogY2xpZW50ID0+IHtcbiAgICAgICAgICAgIC8vIGFkZCBhcyBjbGllbnRcbiAgICAgICAgICAgIGNsaWVudHMucHVzaChjbGllbnQpO1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gcmVtb3ZlTGlzdGVuZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNsaWVudFxuICAgICAgICAgICAgICAgIGNsaWVudHMuc3BsaWNlKGNsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1vcmUgY2xpZW50cywgY2xlYW4gdXAgb2JzZXJ2ZXJcbiAgICAgICAgICAgICAgICBpZiAoY2xpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ05Ecm9wT2JzZXJ2ZXJzLnNwbGljZShkcmFnTkRyb3BPYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvcmluKHJvdXRlcywgZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyc1tldmVudF0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIG9ic2VydmVyO1xufTtcblxuY29uc3QgZWxlbWVudEZyb21Qb2ludCA9IChyb290LCBwb2ludCkgPT4ge1xuICAgIGlmICghKCdlbGVtZW50RnJvbVBvaW50JyBpbiByb290KSkge1xuICAgICAgICByb290ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiByb290LmVsZW1lbnRGcm9tUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG59O1xuXG5jb25zdCBpc0V2ZW50VGFyZ2V0ID0gKGUsIHRhcmdldCkgPT4ge1xuICAgIC8vIGdldCByb290XG4gICAgY29uc3Qgcm9vdCA9IGdldFJvb3ROb2RlKHRhcmdldCk7XG5cbiAgICAvLyBnZXQgZWxlbWVudCBhdCBwb3NpdGlvblxuICAgIC8vIGlmIHJvb3QgaXMgbm90IGFjdHVhbCBzaGFkb3cgRE9NIGFuZCBkb2VzIG5vdCBoYXZlIGVsZW1lbnRGcm9tUG9pbnQgbWV0aG9kLCB1c2UgdGhlIG9uZSBvbiBkb2N1bWVudFxuICAgIGNvbnN0IGVsZW1lbnRBdFBvc2l0aW9uID0gZWxlbWVudEZyb21Qb2ludChyb290LCB7XG4gICAgICAgIHg6IGUucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIHk6IGUucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgfSk7XG5cbiAgICAvLyB0ZXN0IGlmIHRhcmdldCBpcyB0aGUgZWxlbWVudCBvciBpZiBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzXG4gICAgcmV0dXJuIGVsZW1lbnRBdFBvc2l0aW9uID09PSB0YXJnZXQgfHwgdGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnRBdFBvc2l0aW9uKTtcbn07XG5cbmxldCBpbml0aWFsVGFyZ2V0ID0gbnVsbDtcblxuY29uc3Qgc2V0RHJvcEVmZmVjdCA9IChkYXRhVHJhbnNmZXIsIGVmZmVjdCkgPT4ge1xuICAgIC8vIGlzIGluIHRyeSBjYXRjaCBhcyBJRTExIHdpbGwgdGhyb3cgZXJyb3IgaWYgbm90XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfSBjYXRjaCAoZSkge31cbn07XG5cbmNvbnN0IGRyYWdlbnRlciA9IChyb290LCBjbGllbnRzKSA9PiBlID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpbml0aWFsVGFyZ2V0ID0gZS50YXJnZXQ7XG5cbiAgICBjbGllbnRzLmZvckVhY2goY2xpZW50ID0+IHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBvbmVudGVyIH0gPSBjbGllbnQ7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRUYXJnZXQoZSwgZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9ICdlbnRlcic7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgZW50ZXIgZXZlbnRcbiAgICAgICAgICAgIG9uZW50ZXIoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmNvbnN0IGRyYWdvdmVyID0gKHJvb3QsIGNsaWVudHMpID0+IGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihpdGVtcyA9PiB7XG4gICAgICAgIGxldCBvdmVyRHJvcFRhcmdldCA9IGZhbHNlO1xuXG4gICAgICAgIGNsaWVudHMuc29tZShjbGllbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXJFbGVtZW50LCBlbGVtZW50LCBvbmVudGVyLCBvbmV4aXQsIG9uZHJhZywgYWxsb3dkcm9wIH0gPSBjbGllbnQ7XG5cbiAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgd2UgY2FuIGRyb3BcbiAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnY29weScpO1xuXG4gICAgICAgICAgICAvLyBhbGxvdyB0cmFuc2ZlciBvZiB0aGVzZSBpdGVtc1xuICAgICAgICAgICAgY29uc3QgYWxsb3dzVHJhbnNmZXIgPSBhbGxvd2Ryb3AoaXRlbXMpO1xuXG4gICAgICAgICAgICAvLyBvbmx5IHVzZWQgd2hlbiBjYW4gYmUgZHJvcHBlZCBvbiBwYWdlXG4gICAgICAgICAgICBpZiAoIWFsbG93c1RyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0YXJnZXR0aW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICBpZiAoaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIG92ZXJEcm9wVGFyZ2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIGhhZCBubyBwcmV2aW91cyBzdGF0ZSwgbWVhbnMgd2UgYXJlIGVudGVyaW5nIHRoaXMgY2xpZW50XG4gICAgICAgICAgICAgICAgaWYgKGNsaWVudC5zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuc3RhdGUgPSAnZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICBvbmVudGVyKGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbm93IG92ZXIgZWxlbWVudCAobm8gbWF0dGVyIGlmIGl0IGFsbG93cyB0aGUgZHJvcCBvciBub3QpXG4gICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gJ292ZXInO1xuXG4gICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gYWxsb3cgdHJhbnNmZXJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhYWxsb3dzVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcEVmZmVjdChkYXRhVHJhbnNmZXIsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIG9uZHJhZyhldmVudFBvc2l0aW9uKGUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIG92ZXIgYW4gZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlckVsZW1lbnQgJiYgIW92ZXJEcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BFZmZlY3QoZGF0YVRyYW5zZmVyLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG1pZ2h0IGhhdmUganVzdCBsZWZ0IHRoaXMgY2xpZW50P1xuICAgICAgICAgICAgICAgIGlmIChjbGllbnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb25leGl0KGV2ZW50UG9zaXRpb24oZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBkcm9wID0gKHJvb3QsIGNsaWVudHMpID0+IGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGRhdGFUcmFuc2ZlcikudGhlbihpdGVtcyA9PiB7XG4gICAgICAgIGNsaWVudHMuZm9yRWFjaChjbGllbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXJFbGVtZW50LCBlbGVtZW50LCBvbmRyb3AsIG9uZXhpdCwgYWxsb3dkcm9wIH0gPSBjbGllbnQ7XG5cbiAgICAgICAgICAgIGNsaWVudC5zdGF0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZpbHRlcmluZyBvbiBlbGVtZW50IHdlIG5lZWQgdG8gYmUgb3ZlciB0aGUgZWxlbWVudCB0byBkcm9wXG4gICAgICAgICAgICBpZiAoZmlsdGVyRWxlbWVudCAmJiAhaXNFdmVudFRhcmdldChlLCBlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBubyB0cmFuc2ZlciBmb3IgdGhpcyBjbGllbnRcbiAgICAgICAgICAgIGlmICghYWxsb3dkcm9wKGl0ZW1zKSkgcmV0dXJuIG9uZXhpdChldmVudFBvc2l0aW9uKGUpKTtcblxuICAgICAgICAgICAgLy8gd2UgY2FuIGRyb3AgdGhlc2UgaXRlbXMgb24gdGhpcyBjbGllbnRcbiAgICAgICAgICAgIG9uZHJvcChldmVudFBvc2l0aW9uKGUpLCBpdGVtcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuY29uc3QgZHJhZ2xlYXZlID0gKHJvb3QsIGNsaWVudHMpID0+IGUgPT4ge1xuICAgIGlmIChpbml0aWFsVGFyZ2V0ICE9PSBlLnRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xpZW50cy5mb3JFYWNoKGNsaWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25leGl0IH0gPSBjbGllbnQ7XG5cbiAgICAgICAgY2xpZW50LnN0YXRlID0gbnVsbDtcblxuICAgICAgICBvbmV4aXQoZXZlbnRQb3NpdGlvbihlKSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBjcmVhdGVIb3BwZXIgPSAoc2NvcGUsIHZhbGlkYXRlSXRlbXMsIG9wdGlvbnMpID0+IHtcbiAgICAvLyBpcyBub3cgaG9wcGVyIHNjb3BlXG4gICAgc2NvcGUuY2xhc3NMaXN0LmFkZCgnZmlsZXBvbmQtLWhvcHBlcicpO1xuXG4gICAgLy8gc2hvcnRjdXRzXG4gICAgY29uc3QgeyBjYXRjaGVzRHJvcHNPblBhZ2UsIHJlcXVpcmVzRHJvcE9uRWxlbWVudCwgZmlsdGVySXRlbXMgPSBpdGVtcyA9PiBpdGVtcyB9ID0gb3B0aW9ucztcblxuICAgIC8vIGNyZWF0ZSBhIGRuZCBjbGllbnRcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVEcmFnTkRyb3BDbGllbnQoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBjYXRjaGVzRHJvcHNPblBhZ2UgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBzY29wZSxcbiAgICAgICAgcmVxdWlyZXNEcm9wT25FbGVtZW50XG4gICAgKTtcblxuICAgIC8vIGN1cnJlbnQgY2xpZW50IHN0YXRlXG4gICAgbGV0IGxhc3RTdGF0ZSA9ICcnO1xuICAgIGxldCBjdXJyZW50U3RhdGUgPSAnJztcblxuICAgIC8vIGRldGVybWluZXMgaWYgYSBmaWxlIG1heSBiZSBkcm9wcGVkXG4gICAgY2xpZW50LmFsbG93ZHJvcCA9IGl0ZW1zID0+IHtcbiAgICAgICAgLy8gVE9ETzogaWYgd2UgY2FuLCB0aHJvdyBlcnJvciB0byBpbmRpY2F0ZSB0aGUgaXRlbXMgY2Fubm90IGJ5IGRyb3BwZWRcblxuICAgICAgICByZXR1cm4gdmFsaWRhdGVJdGVtcyhmaWx0ZXJJdGVtcyhpdGVtcykpO1xuICAgIH07XG5cbiAgICBjbGllbnQub25kcm9wID0gKHBvc2l0aW9uLCBpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gZmlsdGVySXRlbXMoaXRlbXMpO1xuXG4gICAgICAgIGlmICghdmFsaWRhdGVJdGVtcyhmaWx0ZXJlZEl0ZW1zKSkge1xuICAgICAgICAgICAgYXBpLm9uZHJhZ2VuZChwb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1kcm9wJztcblxuICAgICAgICBhcGkub25sb2FkKGZpbHRlcmVkSXRlbXMsIHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY2xpZW50Lm9uZHJhZyA9IHBvc2l0aW9uID0+IHtcbiAgICAgICAgYXBpLm9uZHJhZyhwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIGNsaWVudC5vbmVudGVyID0gcG9zaXRpb24gPT4ge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1vdmVyJztcblxuICAgICAgICBhcGkub25kcmFnc3RhcnQocG9zaXRpb24pO1xuICAgIH07XG5cbiAgICBjbGllbnQub25leGl0ID0gcG9zaXRpb24gPT4ge1xuICAgICAgICBjdXJyZW50U3RhdGUgPSAnZHJhZy1leGl0JztcblxuICAgICAgICBhcGkub25kcmFnZW5kKHBvc2l0aW9uKTtcbiAgICB9O1xuXG4gICAgY29uc3QgYXBpID0ge1xuICAgICAgICB1cGRhdGVIb3BwZXJTdGF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxhc3RTdGF0ZSAhPT0gY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUuZGF0YXNldC5ob3BwZXJTdGF0ZSA9IGN1cnJlbnRTdGF0ZTtcbiAgICAgICAgICAgICAgICBsYXN0U3RhdGUgPSBjdXJyZW50U3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9ubG9hZDogKCkgPT4ge30sXG4gICAgICAgIG9uZHJhZ3N0YXJ0OiAoKSA9PiB7fSxcbiAgICAgICAgb25kcmFnOiAoKSA9PiB7fSxcbiAgICAgICAgb25kcmFnZW5kOiAoKSA9PiB7fSxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gZGVzdHJveSBjbGllbnRcbiAgICAgICAgICAgIGNsaWVudC5kZXN0cm95KCk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHJldHVybiBhcGk7XG59O1xuXG5sZXQgbGlzdGVuaW5nID0gZmFsc2U7XG5jb25zdCBsaXN0ZW5lcnMkMSA9IFtdO1xuXG5jb25zdCBoYW5kbGVQYXN0ZSA9IGUgPT4ge1xuICAgIC8vIGlmIGlzIHBhc3RpbmcgaW4gaW5wdXQgb3IgdGV4dGFyZWEgYW5kIHRoZSB0YXJnZXQgaXMgb3V0c2lkZSBvZiBhIGZpbGVwb25kIHNjb3BlLCBpZ25vcmVcbiAgICBjb25zdCBhY3RpdmVFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgaXNBY3RpdmVFbGVtZW50RWRpdGFibGUgPVxuICAgICAgICBhY3RpdmVFbCAmJlxuICAgICAgICAoL3RleHRhcmVhfGlucHV0L2kudGVzdChhY3RpdmVFbC5ub2RlTmFtZSkgfHxcbiAgICAgICAgICAgIGFjdGl2ZUVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJyk7XG5cbiAgICBpZiAoaXNBY3RpdmVFbGVtZW50RWRpdGFibGUpIHtcbiAgICAgICAgLy8gdGVzdCB0ZXh0YXJlYSBvciBpbnB1dCBpcyBjb250YWluZWQgaW4gZmlsZXBvbmQgcm9vdFxuICAgICAgICBsZXQgaW5TY29wZSA9IGZhbHNlO1xuICAgICAgICBsZXQgZWxlbWVudCA9IGFjdGl2ZUVsO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmaWxlcG9uZC0tcm9vdCcpKSB7XG4gICAgICAgICAgICAgICAgaW5TY29wZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpblNjb3BlKSByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zKGUuY2xpcGJvYXJkRGF0YSkudGhlbihmaWxlcyA9PiB7XG4gICAgICAgIC8vIG5vIGZpbGVzIHJlY2VpdmVkXG4gICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3RpZnkgbGlzdGVuZXJzIG9mIHJlY2VpdmVkIGZpbGVzXG4gICAgICAgIGxpc3RlbmVycyQxLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoZmlsZXMpKTtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGxpc3RlbiA9IGNiID0+IHtcbiAgICAvLyBjYW4ndCBhZGQgdHdpY2VcbiAgICBpZiAobGlzdGVuZXJzJDEuaW5jbHVkZXMoY2IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhZGQgaW5pdGlhbCBsaXN0ZW5lclxuICAgIGxpc3RlbmVycyQxLnB1c2goY2IpO1xuXG4gICAgLy8gc2V0dXAgcGFzdGUgbGlzdGVuZXIgZm9yIGVudGlyZSBwYWdlXG4gICAgaWYgKGxpc3RlbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGlzdGVuaW5nID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGhhbmRsZVBhc3RlKTtcbn07XG5cbmNvbnN0IHVubGlzdGVuID0gbGlzdGVuZXIgPT4ge1xuICAgIGFycmF5UmVtb3ZlKGxpc3RlbmVycyQxLCBsaXN0ZW5lcnMkMS5pbmRleE9mKGxpc3RlbmVyKSk7XG5cbiAgICAvLyBjbGVhbiB1cFxuICAgIGlmIChsaXN0ZW5lcnMkMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFzdGUnLCBoYW5kbGVQYXN0ZSk7XG4gICAgICAgIGxpc3RlbmluZyA9IGZhbHNlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVBhc3RlciA9ICgpID0+IHtcbiAgICBjb25zdCBjYiA9IGZpbGVzID0+IHtcbiAgICAgICAgYXBpLm9ubG9hZChmaWxlcyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgdW5saXN0ZW4oY2IpO1xuICAgICAgICB9LFxuICAgICAgICBvbmxvYWQ6ICgpID0+IHt9LFxuICAgIH07XG5cbiAgICBsaXN0ZW4oY2IpO1xuXG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZmlsZSB2aWV3XG4gKi9cbmNvbnN0IGNyZWF0ZSRkID0gKHsgcm9vdCwgcHJvcHMgfSkgPT4ge1xuICAgIHJvb3QuZWxlbWVudC5pZCA9IGBmaWxlcG9uZC0tYXNzaXN0YW50LSR7cHJvcHMuaWR9YDtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ3JvbGUnLCAnYWxlcnQnKTtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICBhdHRyKHJvb3QuZWxlbWVudCwgJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XG59O1xuXG5sZXQgYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbmxldCBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBudWxsO1xuXG5jb25zdCBmaWxlbmFtZXMgPSBbXTtcblxuY29uc3QgYXNzaXN0ID0gKHJvb3QsIG1lc3NhZ2UpID0+IHtcbiAgICByb290LmVsZW1lbnQudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xufTtcblxuY29uc3QgY2xlYXIkMSA9IHJvb3QgPT4ge1xuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xufTtcblxuY29uc3QgbGlzdE1vZGlmaWVkID0gKHJvb3QsIGZpbGVuYW1lLCBsYWJlbCkgPT4ge1xuICAgIGNvbnN0IHRvdGFsID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgYXNzaXN0KFxuICAgICAgICByb290LFxuICAgICAgICBgJHtsYWJlbH0gJHtmaWxlbmFtZX0sICR7dG90YWx9ICR7XG4gICAgICAgICAgICB0b3RhbCA9PT0gMVxuICAgICAgICAgICAgICAgID8gcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfU0lOR1VMQVInKVxuICAgICAgICAgICAgICAgIDogcm9vdC5xdWVyeSgnR0VUX0xBQkVMX0ZJTEVfQ09VTlRfUExVUkFMJylcbiAgICAgICAgfWBcbiAgICApO1xuXG4gICAgLy8gY2xlYXIgZ3JvdXAgYWZ0ZXIgc2V0IGFtb3VudCBvZiB0aW1lIHNvIHRoZSBzdGF0dXMgaXMgbm90IHJlYWQgdHdpY2VcbiAgICBjbGVhclRpbWVvdXQobm90aWZpY2F0aW9uQ2xlYXJUaW1lb3V0KTtcbiAgICBub3RpZmljYXRpb25DbGVhclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYXIkMShyb290KTtcbiAgICB9LCAxNTAwKTtcbn07XG5cbmNvbnN0IGlzVXNpbmdGaWxlUG9uZCA9IHJvb3QgPT4gcm9vdC5lbGVtZW50LnBhcmVudE5vZGUuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cbmNvbnN0IGl0ZW1BZGRlZCA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgaWYgKCFpc1VzaW5nRmlsZVBvbmQocm9vdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJvb3QuZWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgIGNvbnN0IGl0ZW0gPSByb290LnF1ZXJ5KCdHRVRfSVRFTScsIGFjdGlvbi5pZCk7XG4gICAgZmlsZW5hbWVzLnB1c2goaXRlbS5maWxlbmFtZSk7XG5cbiAgICBjbGVhclRpbWVvdXQoYWRkRmlsZXNOb3RpZmljYXRpb25UaW1lb3V0KTtcbiAgICBhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGlzdE1vZGlmaWVkKHJvb3QsIGZpbGVuYW1lcy5qb2luKCcsICcpLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9BRERFRCcpKTtcbiAgICAgICAgZmlsZW5hbWVzLmxlbmd0aCA9IDA7XG4gICAgfSwgNzUwKTtcbn07XG5cbmNvbnN0IGl0ZW1SZW1vdmVkID0gKHsgcm9vdCwgYWN0aW9uIH0pID0+IHtcbiAgICBpZiAoIWlzVXNpbmdGaWxlUG9uZChyb290KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbSA9IGFjdGlvbi5pdGVtO1xuICAgIGxpc3RNb2RpZmllZChyb290LCBpdGVtLmZpbGVuYW1lLCByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9SRU1PVkVEJykpO1xufTtcblxuY29uc3QgaXRlbVByb2Nlc3NlZCA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgLy8gd2lsbCBhbHNvIG5vdGlmeSB0aGUgdXNlciB3aGVuIEZpbGVQb25kIGlzIG5vdCBiZWluZyB1c2VkLCBhcyB0aGUgdXNlciBtaWdodCBiZSBvY2N1cGllZCB3aXRoIG90aGVyIGFjdGl2aXRpZXMgd2hpbGUgdXBsb2FkaW5nIGEgZmlsZVxuXG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG4gICAgY29uc3QgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0NPTVBMRVRFJyk7XG5cbiAgICBhc3Npc3Qocm9vdCwgYCR7ZmlsZW5hbWV9ICR7bGFiZWx9YCk7XG59O1xuXG5jb25zdCBpdGVtUHJvY2Vzc2VkVW5kbyA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG4gICAgY29uc3QgbGFiZWwgPSByb290LnF1ZXJ5KCdHRVRfTEFCRUxfRklMRV9QUk9DRVNTSU5HX0FCT1JURUQnKTtcblxuICAgIGFzc2lzdChyb290LCBgJHtmaWxlbmFtZX0gJHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IGl0ZW1FcnJvciA9ICh7IHJvb3QsIGFjdGlvbiB9KSA9PiB7XG4gICAgY29uc3QgaXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9JVEVNJywgYWN0aW9uLmlkKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGl0ZW0uZmlsZW5hbWU7XG5cbiAgICAvLyB3aWxsIGFsc28gbm90aWZ5IHRoZSB1c2VyIHdoZW4gRmlsZVBvbmQgaXMgbm90IGJlaW5nIHVzZWQsIGFzIHRoZSB1c2VyIG1pZ2h0IGJlIG9jY3VwaWVkIHdpdGggb3RoZXIgYWN0aXZpdGllcyB3aGlsZSB1cGxvYWRpbmcgYSBmaWxlXG5cbiAgICBhc3Npc3Qocm9vdCwgYCR7YWN0aW9uLnN0YXR1cy5tYWlufSAke2ZpbGVuYW1lfSAke2FjdGlvbi5zdGF0dXMuc3VifWApO1xufTtcblxuY29uc3QgYXNzaXN0YW50ID0gY3JlYXRlVmlldyh7XG4gICAgY3JlYXRlOiBjcmVhdGUkZCxcbiAgICBpZ25vcmVSZWN0OiB0cnVlLFxuICAgIGlnbm9yZVJlY3RVcGRhdGU6IHRydWUsXG4gICAgd3JpdGU6IGNyZWF0ZVJvdXRlKHtcbiAgICAgICAgRElEX0xPQURfSVRFTTogaXRlbUFkZGVkLFxuICAgICAgICBESURfUkVNT1ZFX0lURU06IGl0ZW1SZW1vdmVkLFxuICAgICAgICBESURfQ09NUExFVEVfSVRFTV9QUk9DRVNTSU5HOiBpdGVtUHJvY2Vzc2VkLFxuXG4gICAgICAgIERJRF9BQk9SVF9JVEVNX1BST0NFU1NJTkc6IGl0ZW1Qcm9jZXNzZWRVbmRvLFxuICAgICAgICBESURfUkVWRVJUX0lURU1fUFJPQ0VTU0lORzogaXRlbVByb2Nlc3NlZFVuZG8sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fUkVNT1ZFX0VSUk9SOiBpdGVtRXJyb3IsXG4gICAgICAgIERJRF9USFJPV19JVEVNX0xPQURfRVJST1I6IGl0ZW1FcnJvcixcbiAgICAgICAgRElEX1RIUk9XX0lURU1fSU5WQUxJRDogaXRlbUVycm9yLFxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBpdGVtRXJyb3IsXG4gICAgfSksXG4gICAgdGFnOiAnc3BhbicsXG4gICAgbmFtZTogJ2Fzc2lzdGFudCcsXG59KTtcblxuY29uc3QgdG9DYW1lbHMgPSAoc3RyaW5nLCBzZXBhcmF0b3IgPSAnLScpID0+XG4gICAgc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtzZXBhcmF0b3J9LmAsICdnJyksIHN1YiA9PiBzdWIuY2hhckF0KDEpLnRvVXBwZXJDYXNlKCkpO1xuXG5jb25zdCBkZWJvdW5jZSA9IChmdW5jLCBpbnRlcnZhbCA9IDE2LCBpbW1pZGlhdGVPbmx5ID0gdHJ1ZSkgPT4ge1xuICAgIGxldCBsYXN0ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgdGltZW91dCA9IG51bGw7XG5cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgIGNvbnN0IGRpc3QgPSBEYXRlLm5vdygpIC0gbGFzdDtcblxuICAgICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGlzdCA8IGludGVydmFsKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IGJ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gaW50ZXJ2YWwgYW5kIGRpc3RcbiAgICAgICAgICAgIC8vIGZvciBleGFtcGxlOiBpZiBkaXN0YW5jZSBpcyAxMCBtcyBhbmQgaW50ZXJ2YWwgaXMgMTYgbXMsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgYW4gYWRkaXRpb25hbCA2bXMgYmVmb3JlIGNhbGxpbmcgdGhlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgaWYgKCFpbW1pZGlhdGVPbmx5KSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGludGVydmFsIC0gZGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBnbyFcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuY29uc3QgTUFYX0ZJTEVTX0xJTUlUID0gMTAwMDAwMDtcblxuY29uc3QgcHJldmVudCA9IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5jb25zdCBjcmVhdGUkZSA9ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAvLyBBZGQgaWRcbiAgICBjb25zdCBpZCA9IHJvb3QucXVlcnkoJ0dFVF9JRCcpO1xuICAgIGlmIChpZCkge1xuICAgICAgICByb290LmVsZW1lbnQuaWQgPSBpZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgY2xhc3NOYW1lXG4gICAgY29uc3QgY2xhc3NOYW1lID0gcm9vdC5xdWVyeSgnR0VUX0NMQVNTX05BTUUnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLmxlbmd0aClcbiAgICAgICAgICAgIC5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJvb3QuZWxlbWVudC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmllbGQgbGFiZWxcbiAgICByb290LnJlZi5sYWJlbCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KFxuICAgICAgICByb290LmNyZWF0ZUNoaWxkVmlldyhkcm9wTGFiZWwsIHtcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogbnVsbCxcbiAgICAgICAgICAgIGNhcHRpb246IHJvb3QucXVlcnkoJ0dFVF9MQUJFTF9JRExFJyksXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIExpc3Qgb2YgaXRlbXNcbiAgICByb290LnJlZi5saXN0ID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcobGlzdFNjcm9sbGVyLCB7IHRyYW5zbGF0ZVk6IG51bGwgfSkpO1xuXG4gICAgLy8gQmFja2dyb3VuZCBwYW5lbFxuICAgIHJvb3QucmVmLnBhbmVsID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcocGFuZWwsIHsgbmFtZTogJ3BhbmVsLXJvb3QnIH0pKTtcblxuICAgIC8vIEFzc2lzdGFudCBub3RpZmllcyBhc3Npc3RpdmUgdGVjaCB3aGVuIGNvbnRlbnQgY2hhbmdlc1xuICAgIHJvb3QucmVmLmFzc2lzdGFudCA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGFzc2lzdGFudCwgeyAuLi5wcm9wcyB9KSk7XG5cbiAgICAvLyBEYXRhXG4gICAgcm9vdC5yZWYuZGF0YSA9IHJvb3QuYXBwZW5kQ2hpbGRWaWV3KHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGRhdGEsIHsgLi4ucHJvcHMgfSkpO1xuXG4gICAgLy8gTWVhc3VyZSAodGVzdHMgaWYgZml4ZWQgaGVpZ2h0IHdhcyBzZXQpXG4gICAgLy8gRE9DVFlQRSBuZWVkcyB0byBiZSBzZXQgZm9yIHRoaXMgdG8gd29ya1xuICAgIHJvb3QucmVmLm1lYXN1cmUgPSBjcmVhdGVFbGVtZW50JDEoJ2RpdicpO1xuICAgIHJvb3QucmVmLm1lYXN1cmUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIHJvb3QuZWxlbWVudC5hcHBlbmRDaGlsZChyb290LnJlZi5tZWFzdXJlKTtcblxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSByb290IGhlaWdodCBvciBmaXhlZCBoZWlnaHQgc3RhdHVzXG4gICAgcm9vdC5yZWYuYm91bmRzID0gbnVsbDtcblxuICAgIC8vIGFwcGx5IGluaXRpYWwgc3R5bGUgcHJvcGVydGllc1xuICAgIHJvb3QucXVlcnkoJ0dFVF9TVFlMRVMnKVxuICAgICAgICAuZmlsdGVyKHN0eWxlID0+ICFpc0VtcHR5KHN0eWxlLnZhbHVlKSlcbiAgICAgICAgLm1hcCgoeyBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9KTtcblxuICAgIC8vIGRldGVybWluZSBpZiB3aWR0aCBjaGFuZ2VkXG4gICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IG51bGw7XG4gICAgcm9vdC5yZWYud2lkdGhVcGRhdGVkID0gZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9SRVNJWkVfUk9PVCcpO1xuICAgIH0sIDI1MCk7XG5cbiAgICAvLyBoaXN0b3J5IG9mIHVwZGF0ZXNcbiAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gbnVsbDtcbiAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG5cbiAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyBhbmQgem9vbWluZyBvbiBpT1MgKG9ubHkgaWYgc3VwcG9ydHMgcG9pbnRlciBldmVudHMsIGZvciB0aGVuIHdlIGNhbiBlbmFibGUgcmVvcmRlcilcbiAgICBjb25zdCBjYW5Ib3ZlciA9IHdpbmRvdy5tYXRjaE1lZGlhKCcocG9pbnRlcjogZmluZSkgYW5kIChob3ZlcjogaG92ZXIpJykubWF0Y2hlcztcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gJ1BvaW50ZXJFdmVudCcgaW4gd2luZG93O1xuICAgIGlmIChyb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVPUkRFUicpICYmIGhhc1BvaW50ZXJFdmVudHMgJiYgIWNhbkhvdmVyKSB7XG4gICAgICAgIHJvb3QuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50LCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgICByb290LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JywgcHJldmVudCk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGNyZWRpdHNcbiAgICBjb25zdCBjcmVkaXRzID0gcm9vdC5xdWVyeSgnR0VUX0NSRURJVFMnKTtcbiAgICBjb25zdCBoYXNDcmVkaXRzID0gY3JlZGl0cy5sZW5ndGggPT09IDI7XG4gICAgaWYgKGhhc0NyZWRpdHMpIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgZnJhZy5jbGFzc05hbWUgPSAnZmlsZXBvbmQtLWNyZWRpdHMnO1xuICAgICAgICBmcmFnLmhyZWYgPSBjcmVkaXRzWzBdO1xuICAgICAgICBmcmFnLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIGZyYWcudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIGZyYWcucmVsID0gJ25vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3cnO1xuICAgICAgICBmcmFnLnRleHRDb250ZW50ID0gY3JlZGl0c1sxXTtcbiAgICAgICAgcm9vdC5lbGVtZW50LmFwcGVuZENoaWxkKGZyYWcpO1xuICAgICAgICByb290LnJlZi5jcmVkaXRzID0gZnJhZztcbiAgICB9XG59O1xuXG5jb25zdCB3cml0ZSQ5ID0gKHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSkgPT4ge1xuICAgIC8vIHJvdXRlIGFjdGlvbnNcbiAgICByb3V0ZSQ1KHsgcm9vdCwgcHJvcHMsIGFjdGlvbnMgfSk7XG5cbiAgICAvLyBhcHBseSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgYWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiAvXkRJRF9TRVRfU1RZTEVfLy50ZXN0KGFjdGlvbi50eXBlKSlcbiAgICAgICAgLmZpbHRlcihhY3Rpb24gPT4gIWlzRW1wdHkoYWN0aW9uLmRhdGEudmFsdWUpKVxuICAgICAgICAubWFwKCh7IHR5cGUsIGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxzKHR5cGUuc3Vic3RyaW5nKDgpLnRvTG93ZXJDYXNlKCksICdfJyk7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldFtuYW1lXSA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICByb290LmludmFsaWRhdGVMYXlvdXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQuaGlkZGVuKSByZXR1cm47XG5cbiAgICBpZiAocm9vdC5yZWN0LmVsZW1lbnQud2lkdGggIT09IHJvb3QucmVmLndpZHRoUHJldmlvdXMpIHtcbiAgICAgICAgcm9vdC5yZWYud2lkdGhQcmV2aW91cyA9IHJvb3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgICAgICByb290LnJlZi53aWR0aFVwZGF0ZWQoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYm94IGJvdW5kcywgd2UgZG8gdGhpcyBvbmx5IG9uY2VcbiAgICBsZXQgYm91bmRzID0gcm9vdC5yZWYuYm91bmRzO1xuICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgIGJvdW5kcyA9IHJvb3QucmVmLmJvdW5kcyA9IGNhbGN1bGF0ZVJvb3RCb3VuZGluZ0JveEhlaWdodChyb290KTtcblxuICAgICAgICAvLyBkZXN0cm95IG1lYXN1cmUgZWxlbWVudFxuICAgICAgICByb290LmVsZW1lbnQucmVtb3ZlQ2hpbGQocm9vdC5yZWYubWVhc3VyZSk7XG4gICAgICAgIHJvb3QucmVmLm1lYXN1cmUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2VzIHRvIHZhcmlvdXMgaGlnaCBsZXZlbCBwYXJ0cyBvZiB0aGUgdXBsb2FkIHRvb2xcbiAgICBjb25zdCB7IGhvcHBlciwgbGFiZWwsIGxpc3QsIHBhbmVsIH0gPSByb290LnJlZjtcblxuICAgIC8vIHNldHMgY29ycmVjdCBzdGF0ZSB0byBob3BwZXIgc2NvcGVcbiAgICBpZiAoaG9wcGVyKSB7XG4gICAgICAgIGhvcHBlci51cGRhdGVIb3BwZXJTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIGJvb2wgdG8gaW5kaWNhdGUgaWYgd2UncmUgZnVsbCBvciBub3RcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHJvb3QucXVlcnkoJ0dFVF9QQU5FTF9BU1BFQ1RfUkFUSU8nKTtcbiAgICBjb25zdCBpc011bHRpSXRlbSA9IHJvb3QucXVlcnkoJ0dFVF9BTExPV19NVUxUSVBMRScpO1xuICAgIGNvbnN0IHRvdGFsSXRlbXMgPSByb290LnF1ZXJ5KCdHRVRfVE9UQUxfSVRFTVMnKTtcbiAgICBjb25zdCBtYXhJdGVtcyA9IGlzTXVsdGlJdGVtID8gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpIHx8IE1BWF9GSUxFU19MSU1JVCA6IDE7XG4gICAgY29uc3QgYXRNYXhDYXBhY2l0eSA9IHRvdGFsSXRlbXMgPT09IG1heEl0ZW1zO1xuXG4gICAgLy8gYWN0aW9uIHVzZWQgdG8gYWRkIGl0ZW1cbiAgICBjb25zdCBhZGRBY3Rpb24gPSBhY3Rpb25zLmZpbmQoYWN0aW9uID0+IGFjdGlvbi50eXBlID09PSAnRElEX0FERF9JVEVNJyk7XG5cbiAgICAvLyBpZiByZWFjaGVkIG1heCBjYXBhY2l0eSBhbmQgd2UndmUganVzdCByZWFjaGVkIGl0XG4gICAgaWYgKGF0TWF4Q2FwYWNpdHkgJiYgYWRkQWN0aW9uKSB7XG4gICAgICAgIC8vIGdldCBpbnRlcmFjdGlvbiB0eXBlXG4gICAgICAgIGNvbnN0IGludGVyYWN0aW9uTWV0aG9kID0gYWRkQWN0aW9uLmRhdGEuaW50ZXJhY3Rpb25NZXRob2Q7XG5cbiAgICAgICAgLy8gaGlkZSBsYWJlbFxuICAgICAgICBsYWJlbC5vcGFjaXR5ID0gMDtcblxuICAgICAgICBpZiAoaXNNdWx0aUl0ZW0pIHtcbiAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAtNDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkFQSSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVggPSA0MDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb25NZXRob2QgPT09IEludGVyYWN0aW9uTWV0aG9kLkJST1dTRSkge1xuICAgICAgICAgICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSA0MDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFiZWwudHJhbnNsYXRlWSA9IDMwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghYXRNYXhDYXBhY2l0eSkge1xuICAgICAgICBsYWJlbC5vcGFjaXR5ID0gMTtcbiAgICAgICAgbGFiZWwudHJhbnNsYXRlWCA9IDA7XG4gICAgICAgIGxhYmVsLnRyYW5zbGF0ZVkgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IGxpc3RJdGVtTWFyZ2luID0gY2FsY3VsYXRlTGlzdEl0ZW1NYXJnaW4ocm9vdCk7XG5cbiAgICBjb25zdCBsaXN0SGVpZ2h0ID0gY2FsY3VsYXRlTGlzdEhlaWdodChyb290KTtcblxuICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gbGFiZWwucmVjdC5lbGVtZW50LmhlaWdodDtcbiAgICBjb25zdCBjdXJyZW50TGFiZWxIZWlnaHQgPSAhaXNNdWx0aUl0ZW0gfHwgYXRNYXhDYXBhY2l0eSA/IDAgOiBsYWJlbEhlaWdodDtcblxuICAgIGNvbnN0IGxpc3RNYXJnaW5Ub3AgPSBhdE1heENhcGFjaXR5ID8gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wIDogMDtcbiAgICBjb25zdCBsaXN0TWFyZ2luQm90dG9tID0gdG90YWxJdGVtcyA9PT0gMCA/IDAgOiBsaXN0LnJlY3QuZWxlbWVudC5tYXJnaW5Cb3R0b207XG5cbiAgICBjb25zdCB2aXN1YWxIZWlnaHQgPSBjdXJyZW50TGFiZWxIZWlnaHQgKyBsaXN0TWFyZ2luVG9wICsgbGlzdEhlaWdodC52aXN1YWwgKyBsaXN0TWFyZ2luQm90dG9tO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IGN1cnJlbnRMYWJlbEhlaWdodCArIGxpc3RNYXJnaW5Ub3AgKyBsaXN0SGVpZ2h0LmJvdW5kcyArIGxpc3RNYXJnaW5Cb3R0b207XG5cbiAgICAvLyBsaW5rIGxpc3QgdG8gbGFiZWwgYm90dG9tIHBvc2l0aW9uXG4gICAgbGlzdC50cmFuc2xhdGVZID1cbiAgICAgICAgTWF0aC5tYXgoMCwgY3VycmVudExhYmVsSGVpZ2h0IC0gbGlzdC5yZWN0LmVsZW1lbnQubWFyZ2luVG9wKSAtIGxpc3RJdGVtTWFyZ2luLnRvcDtcblxuICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAvLyBmaXhlZCBhc3BlY3QgcmF0aW9cblxuICAgICAgICAvLyBjYWxjdWxhdGUgaGVpZ2h0IGJhc2VkIG9uIHdpZHRoXG4gICAgICAgIGNvbnN0IHdpZHRoID0gcm9vdC5yZWN0LmVsZW1lbnQud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHdpZHRoICogYXNwZWN0UmF0aW87XG5cbiAgICAgICAgLy8gY2xlYXIgaGlzdG9yeSBpZiBhc3BlY3QgcmF0aW8gaGFzIGNoYW5nZWRcbiAgICAgICAgaWYgKGFzcGVjdFJhdGlvICE9PSByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICByb290LnJlZi5wcmV2aW91c0FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICByb290LnJlZi51cGRhdGVIaXN0b3J5ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1lbWJlciB0aGlzIHdpZHRoXG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSByb290LnJlZi51cGRhdGVIaXN0b3J5O1xuICAgICAgICBoaXN0b3J5LnB1c2god2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IE1BWF9CT1VOQ0VTID0gMjtcbiAgICAgICAgaWYgKGhpc3RvcnkubGVuZ3RoID4gTUFYX0JPVU5DRVMgKiAyKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gaGlzdG9yeS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsIC0gMTA7XG4gICAgICAgICAgICBsZXQgYm91bmNlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbDsgaSA+PSBib3R0b207IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChoaXN0b3J5W2ldID09PSBoaXN0b3J5W2kgLSAyXSkge1xuICAgICAgICAgICAgICAgICAgICBib3VuY2VzKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5jZXMgPj0gTUFYX0JPVU5DRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9udCBhZGp1c3QgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXggaGVpZ2h0IG9mIHBhbmVsIHNvIGl0IGFkaGVyZXMgdG8gYXNwZWN0IHJhdGlvXG4gICAgICAgIHBhbmVsLnNjYWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHBhbmVsLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBhdmFpbGFibGUgaGVpZ2h0IGZvciBsaXN0XG4gICAgICAgIGNvbnN0IGxpc3RBdmFpbGFibGVIZWlnaHQgPVxuICAgICAgICAgICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgcGFuZWwgbWludXMgdGhlIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgaGVpZ2h0IC1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChib3VuZHMuZml4ZWRIZWlnaHQpIHtcbiAgICAgICAgLy8gZml4ZWQgaGVpZ2h0XG5cbiAgICAgICAgLy8gZml4IGhlaWdodCBvZiBwYW5lbFxuICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGF2YWlsYWJsZSBoZWlnaHQgZm9yIGxpc3RcbiAgICAgICAgY29uc3QgbGlzdEF2YWlsYWJsZUhlaWdodCA9XG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBwYW5lbCBtaW51cyB0aGUgbGFiZWwgaGVpZ2h0XG4gICAgICAgICAgICBib3VuZHMuZml4ZWRIZWlnaHQgLVxuICAgICAgICAgICAgY3VycmVudExhYmVsSGVpZ2h0IC1cbiAgICAgICAgICAgIC8vIHRoZSByb29tIHdlIGxlYXZlIG9wZW4gYmV0d2VlbiB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0aGUgcGFuZWwgYm90dG9tXG4gICAgICAgICAgICAobGlzdE1hcmdpbkJvdHRvbSAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbSkgLVxuICAgICAgICAgICAgLy8gaWYgd2UncmUgZnVsbCB3ZSBuZWVkIHRvIGxlYXZlIHNvbWUgcm9vbSBiZXR3ZWVuIHRoZSB0b3Agb2YgdGhlIHBhbmVsIGFuZCB0aGUgbGlzdFxuICAgICAgICAgICAgKGF0TWF4Q2FwYWNpdHkgPyBsaXN0TWFyZ2luVG9wIDogMCk7XG5cbiAgICAgICAgLy8gc2V0IGxpc3QgaGVpZ2h0XG4gICAgICAgIGlmIChsaXN0SGVpZ2h0LnZpc3VhbCA+IGxpc3RBdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGxpc3Qub3ZlcmZsb3cgPSBsaXN0QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBuZWVkIHRvIHNldCBjb250YWluZXIgYm91bmRzIGFzIHRoZXNlIGFyZSBoYW5kbGVzIGJ5IENTUyBmaXhlZCBoZWlnaHRcbiAgICB9IGVsc2UgaWYgKGJvdW5kcy5jYXBwZWRIZWlnaHQpIHtcbiAgICAgICAgLy8gbWF4LWhlaWdodFxuXG4gICAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgICBjb25zdCBpc0NhcHBlZEhlaWdodCA9IHZpc3VhbEhlaWdodCA+PSBib3VuZHMuY2FwcGVkSGVpZ2h0O1xuICAgICAgICBjb25zdCBwYW5lbEhlaWdodCA9IE1hdGgubWluKGJvdW5kcy5jYXBwZWRIZWlnaHQsIHZpc3VhbEhlaWdodCk7XG4gICAgICAgIHBhbmVsLnNjYWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgcGFuZWwuaGVpZ2h0ID0gaXNDYXBwZWRIZWlnaHRcbiAgICAgICAgICAgID8gcGFuZWxIZWlnaHRcbiAgICAgICAgICAgIDogcGFuZWxIZWlnaHQgLSBsaXN0SXRlbU1hcmdpbi50b3AgLSBsaXN0SXRlbU1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgLy8gYXZhaWxhYmxlIGhlaWdodCBmb3IgbGlzdFxuICAgICAgICBjb25zdCBsaXN0QXZhaWxhYmxlSGVpZ2h0ID1cbiAgICAgICAgICAgIC8vIHRoZSBoZWlnaHQgb2YgdGhlIHBhbmVsIG1pbnVzIHRoZSBsYWJlbCBoZWlnaHRcbiAgICAgICAgICAgIHBhbmVsSGVpZ2h0IC1cbiAgICAgICAgICAgIGN1cnJlbnRMYWJlbEhlaWdodCAtXG4gICAgICAgICAgICAvLyB0aGUgcm9vbSB3ZSBsZWF2ZSBvcGVuIGJldHdlZW4gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdGhlIHBhbmVsIGJvdHRvbVxuICAgICAgICAgICAgKGxpc3RNYXJnaW5Cb3R0b20gLSBsaXN0SXRlbU1hcmdpbi5ib3R0b20pIC1cbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGZ1bGwgd2UgbmVlZCB0byBsZWF2ZSBzb21lIHJvb20gYmV0d2VlbiB0aGUgdG9wIG9mIHRoZSBwYW5lbCBhbmQgdGhlIGxpc3RcbiAgICAgICAgICAgIChhdE1heENhcGFjaXR5ID8gbGlzdE1hcmdpblRvcCA6IDApO1xuXG4gICAgICAgIC8vIHNldCBsaXN0IGhlaWdodCAoaWYgaXMgb3ZlcmZsb3dpbmcpXG4gICAgICAgIGlmICh2aXN1YWxIZWlnaHQgPiBib3VuZHMuY2FwcGVkSGVpZ2h0ICYmIGxpc3RIZWlnaHQudmlzdWFsID4gbGlzdEF2YWlsYWJsZUhlaWdodCkge1xuICAgICAgICAgICAgbGlzdC5vdmVyZmxvdyA9IGxpc3RBdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0Lm92ZXJmbG93ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBjb250YWluZXIgYm91bmRzIChzbyBwdXNoZXMgc2libGluZ3MgZG93bndhcmRzKVxuICAgICAgICByb290LmhlaWdodCA9IE1hdGgubWluKFxuICAgICAgICAgICAgYm91bmRzLmNhcHBlZEhlaWdodCxcbiAgICAgICAgICAgIGJvdW5kc0hlaWdodCAtIGxpc3RJdGVtTWFyZ2luLnRvcCAtIGxpc3RJdGVtTWFyZ2luLmJvdHRvbVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZsZXhpYmxlIGhlaWdodFxuXG4gICAgICAgIC8vIG5vdCBhIGZpeGVkIGhlaWdodCBwYW5lbFxuICAgICAgICBjb25zdCBpdGVtTWFyZ2luID0gdG90YWxJdGVtcyA+IDAgPyBsaXN0SXRlbU1hcmdpbi50b3AgKyBsaXN0SXRlbU1hcmdpbi5ib3R0b20gOiAwO1xuICAgICAgICBwYW5lbC5zY2FsYWJsZSA9IHRydWU7XG4gICAgICAgIHBhbmVsLmhlaWdodCA9IE1hdGgubWF4KGxhYmVsSGVpZ2h0LCB2aXN1YWxIZWlnaHQgLSBpdGVtTWFyZ2luKTtcblxuICAgICAgICAvLyBzZXQgY29udGFpbmVyIGJvdW5kcyAoc28gcHVzaGVzIHNpYmxpbmdzIGRvd253YXJkcylcbiAgICAgICAgcm9vdC5oZWlnaHQgPSBNYXRoLm1heChsYWJlbEhlaWdodCwgYm91bmRzSGVpZ2h0IC0gaXRlbU1hcmdpbik7XG4gICAgfVxuXG4gICAgLy8gbW92ZSBjcmVkaXRzIHRvIGJvdHRvbVxuICAgIGlmIChyb290LnJlZi5jcmVkaXRzICYmIHBhbmVsLmhlaWdodEN1cnJlbnQpXG4gICAgICAgIHJvb3QucmVmLmNyZWRpdHMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHtwYW5lbC5oZWlnaHRDdXJyZW50fXB4KWA7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVMaXN0SXRlbU1hcmdpbiA9IHJvb3QgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSByb290LnJlZi5saXN0LmNoaWxkVmlld3NbMF0uY2hpbGRWaWV3c1swXTtcbiAgICByZXR1cm4gaXRlbVxuICAgICAgICA/IHtcbiAgICAgICAgICAgICAgdG9wOiBpdGVtLnJlY3QuZWxlbWVudC5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIGJvdHRvbTogaXRlbS5yZWN0LmVsZW1lbnQubWFyZ2luQm90dG9tLFxuICAgICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIH07XG59O1xuXG5jb25zdCBjYWxjdWxhdGVMaXN0SGVpZ2h0ID0gcm9vdCA9PiB7XG4gICAgbGV0IHZpc3VhbCA9IDA7XG4gICAgbGV0IGJvdW5kcyA9IDA7XG5cbiAgICAvLyBnZXQgZmlsZSBsaXN0IHJlZmVyZW5jZVxuICAgIGNvbnN0IHNjcm9sbExpc3QgPSByb290LnJlZi5saXN0O1xuICAgIGNvbnN0IGl0ZW1MaXN0ID0gc2Nyb2xsTGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgIGNvbnN0IHZpc2libGVDaGlsZHJlbiA9IGl0ZW1MaXN0LmNoaWxkVmlld3MuZmlsdGVyKGNoaWxkID0+IGNoaWxkLnJlY3QuZWxlbWVudC5oZWlnaHQpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTVMnKVxuICAgICAgICAubWFwKGl0ZW0gPT4gdmlzaWJsZUNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQuaWQgPT09IGl0ZW0uaWQpKVxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG5cbiAgICAvLyBubyBjaGlsZHJlbiwgZG9uZSFcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSByZXR1cm4geyB2aXN1YWwsIGJvdW5kcyB9O1xuXG4gICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlID0gaXRlbUxpc3QucmVjdC5lbGVtZW50LndpZHRoO1xuICAgIGNvbnN0IGRyYWdJbmRleCA9IGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCBzY3JvbGxMaXN0LmRyYWdDb29yZGluYXRlcyk7XG5cbiAgICBjb25zdCBjaGlsZFJlY3QgPSBjaGlsZHJlblswXS5yZWN0LmVsZW1lbnQ7XG5cbiAgICBjb25zdCBpdGVtVmVydGljYWxNYXJnaW4gPSBjaGlsZFJlY3QubWFyZ2luVG9wICsgY2hpbGRSZWN0Lm1hcmdpbkJvdHRvbTtcbiAgICBjb25zdCBpdGVtSG9yaXpvbnRhbE1hcmdpbiA9IGNoaWxkUmVjdC5tYXJnaW5MZWZ0ICsgY2hpbGRSZWN0Lm1hcmdpblJpZ2h0O1xuXG4gICAgY29uc3QgaXRlbVdpZHRoID0gY2hpbGRSZWN0LndpZHRoICsgaXRlbUhvcml6b250YWxNYXJnaW47XG4gICAgY29uc3QgaXRlbUhlaWdodCA9IGNoaWxkUmVjdC5oZWlnaHQgKyBpdGVtVmVydGljYWxNYXJnaW47XG5cbiAgICBjb25zdCBuZXdJdGVtID0gdHlwZW9mIGRyYWdJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgZHJhZ0luZGV4ID49IDAgPyAxIDogMDtcbiAgICBjb25zdCByZW1vdmVkSXRlbSA9IGNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQubWFya2VkRm9yUmVtb3ZhbCAmJiBjaGlsZC5vcGFjaXR5IDwgMC40NSlcbiAgICAgICAgPyAtMVxuICAgICAgICA6IDA7XG4gICAgY29uc3QgdmVydGljYWxJdGVtQ291bnQgPSBjaGlsZHJlbi5sZW5ndGggKyBuZXdJdGVtICsgcmVtb3ZlZEl0ZW07XG4gICAgY29uc3QgaXRlbXNQZXJSb3cgPSBnZXRJdGVtc1BlclJvdyhob3Jpem9udGFsU3BhY2UsIGl0ZW1XaWR0aCk7XG5cbiAgICAvLyBzdGFja1xuICAgIGlmIChpdGVtc1BlclJvdyA9PT0gMSkge1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gaXRlbS5yZWN0LmVsZW1lbnQuaGVpZ2h0ICsgaXRlbVZlcnRpY2FsTWFyZ2luO1xuICAgICAgICAgICAgYm91bmRzICs9IGhlaWdodDtcbiAgICAgICAgICAgIHZpc3VhbCArPSBoZWlnaHQgKiBpdGVtLm9wYWNpdHk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBncmlkXG4gICAgZWxzZSB7XG4gICAgICAgIGJvdW5kcyA9IE1hdGguY2VpbCh2ZXJ0aWNhbEl0ZW1Db3VudCAvIGl0ZW1zUGVyUm93KSAqIGl0ZW1IZWlnaHQ7XG4gICAgICAgIHZpc3VhbCA9IGJvdW5kcztcbiAgICB9XG5cbiAgICByZXR1cm4geyB2aXN1YWwsIGJvdW5kcyB9O1xufTtcblxuY29uc3QgY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0ID0gcm9vdCA9PiB7XG4gICAgY29uc3QgaGVpZ2h0ID0gcm9vdC5yZWYubWVhc3VyZUhlaWdodCB8fCBudWxsO1xuICAgIGNvbnN0IGNhcHBlZEhlaWdodCA9IHBhcnNlSW50KHJvb3Quc3R5bGUubWF4SGVpZ2h0LCAxMCkgfHwgbnVsbDtcbiAgICBjb25zdCBmaXhlZEhlaWdodCA9IGhlaWdodCA9PT0gMCA/IG51bGwgOiBoZWlnaHQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjYXBwZWRIZWlnaHQsXG4gICAgICAgIGZpeGVkSGVpZ2h0LFxuICAgIH07XG59O1xuXG5jb25zdCBleGNlZWRzTWF4RmlsZXMgPSAocm9vdCwgaXRlbXMpID0+IHtcbiAgICBjb25zdCBhbGxvd1JlcGxhY2UgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfUkVQTEFDRScpO1xuICAgIGNvbnN0IGFsbG93TXVsdGlwbGUgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfTVVMVElQTEUnKTtcbiAgICBjb25zdCB0b3RhbEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX1RPVEFMX0lURU1TJyk7XG4gICAgbGV0IG1heEl0ZW1zID0gcm9vdC5xdWVyeSgnR0VUX01BWF9GSUxFUycpO1xuXG4gICAgLy8gdG90YWwgYW1vdW50IG9mIGl0ZW1zIGJlaW5nIGRyYWdnZWRcbiAgICBjb25zdCB0b3RhbEJyb3dzZUl0ZW1zID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgLy8gaWYgZG9lcyBub3QgYWxsb3cgbXVsdGlwbGUgaXRlbXMgYW5kIGRyYWdnaW5nIG1vcmUgdGhhbiBvbmUgaXRlbVxuICAgIGlmICghYWxsb3dNdWx0aXBsZSAmJiB0b3RhbEJyb3dzZUl0ZW1zID4gMSkge1xuICAgICAgICByb290LmRpc3BhdGNoKCdESURfVEhST1dfTUFYX0ZJTEVTJywge1xuICAgICAgICAgICAgc291cmNlOiBpdGVtcyxcbiAgICAgICAgICAgIGVycm9yOiBjcmVhdGVSZXNwb25zZSgnd2FybmluZycsIDAsICdNYXggZmlsZXMnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGxpbWl0IG1heCBpdGVtcyB0byBvbmUgaWYgbm90IGFsbG93ZWQgdG8gZHJvcCBtdWx0aXBsZSBpdGVtc1xuICAgIG1heEl0ZW1zID0gYWxsb3dNdWx0aXBsZSA/IG1heEl0ZW1zIDogMTtcblxuICAgIGlmICghYWxsb3dNdWx0aXBsZSAmJiBhbGxvd1JlcGxhY2UpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgaXRlbSwgc28gdGhlcmUgaXMgcm9vbSB0byByZXBsYWNlIG9yIGFkZCBhbiBpdGVtXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIHJvb20/XG4gICAgY29uc3QgaGFzTWF4SXRlbXMgPSBpc0ludChtYXhJdGVtcyk7XG4gICAgaWYgKGhhc01heEl0ZW1zICYmIHRvdGFsSXRlbXMgKyB0b3RhbEJyb3dzZUl0ZW1zID4gbWF4SXRlbXMpIHtcbiAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1RIUk9XX01BWF9GSUxFUycsIHtcbiAgICAgICAgICAgIHNvdXJjZTogaXRlbXMsXG4gICAgICAgICAgICBlcnJvcjogY3JlYXRlUmVzcG9uc2UoJ3dhcm5pbmcnLCAwLCAnTWF4IGZpbGVzJyksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBnZXREcmFnSW5kZXggPSAobGlzdCwgY2hpbGRyZW4sIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgaXRlbUxpc3QgPSBsaXN0LmNoaWxkVmlld3NbMF07XG4gICAgcmV0dXJuIGdldEl0ZW1JbmRleEJ5UG9zaXRpb24oaXRlbUxpc3QsIGNoaWxkcmVuLCB7XG4gICAgICAgIGxlZnQ6IHBvc2l0aW9uLnNjb3BlTGVmdCAtIGl0ZW1MaXN0LnJlY3QuZWxlbWVudC5sZWZ0LFxuICAgICAgICB0b3A6XG4gICAgICAgICAgICBwb3NpdGlvbi5zY29wZVRvcCAtXG4gICAgICAgICAgICAobGlzdC5yZWN0Lm91dGVyLnRvcCArIGxpc3QucmVjdC5lbGVtZW50Lm1hcmdpblRvcCArIGxpc3QucmVjdC5lbGVtZW50LnNjcm9sbFRvcCksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbGUgZHJvcCBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IHRvZ2dsZURyb3AgPSByb290ID0+IHtcbiAgICBjb25zdCBpc0FsbG93ZWQgPSByb290LnF1ZXJ5KCdHRVRfQUxMT1dfRFJPUCcpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICBjb25zdCBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5ob3BwZXIpIHtcbiAgICAgICAgY29uc3QgaG9wcGVyID0gY3JlYXRlSG9wcGVyKFxuICAgICAgICAgICAgcm9vdC5lbGVtZW50LFxuICAgICAgICAgICAgaXRlbXMgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHF1aWNrIHZhbGlkYXRpb24gb2YgZHJvcHBlZCBpdGVtc1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZURyb3BGaWxlID0gcm9vdC5xdWVyeSgnR0VUX0JFRk9SRV9EUk9QX0ZJTEUnKSB8fCAoKCkgPT4gdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhbGwgaXRlbXMgc2hvdWxkIGJlIHZhbGlkYXRlZCBieSBhbGwgZmlsdGVycyBhcyB2YWxpZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRyb3BWYWxpZGF0aW9uID0gcm9vdC5xdWVyeSgnR0VUX0RST1BfVkFMSURBVElPTicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wVmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGl0ZW1zLmV2ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUZpbHRlcnMoJ0FMTE9XX0hPUFBFUl9JVEVNJywgaXRlbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiByb290LnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuZXZlcnkocmVzdWx0ID0+IHJlc3VsdCA9PT0gdHJ1ZSkgJiYgYmVmb3JlRHJvcEZpbGUoaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmlsdGVySXRlbXM6IGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWdub3JlZEZpbGVzID0gcm9vdC5xdWVyeSgnR0VUX0lHTk9SRURfRklMRVMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpbGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlnbm9yZWRGaWxlcy5pbmNsdWRlcyhpdGVtLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYXRjaGVzRHJvcHNPblBhZ2U6IHJvb3QucXVlcnkoJ0dFVF9EUk9QX09OX1BBR0UnKSxcbiAgICAgICAgICAgICAgICByZXF1aXJlc0Ryb3BPbkVsZW1lbnQ6IHJvb3QucXVlcnkoJ0dFVF9EUk9QX09OX0VMRU1FTlQnKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBob3BwZXIub25sb2FkID0gKGl0ZW1zLCBwb3NpdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IGl0ZW0gY2hpbGRyZW4gZWxlbWVudHMgYW5kIHNvcnQgYmFzZWQgb24gbGlzdCBzb3J0XG4gICAgICAgICAgICBjb25zdCBsaXN0ID0gcm9vdC5yZWYubGlzdC5jaGlsZFZpZXdzWzBdO1xuICAgICAgICAgICAgY29uc3QgdmlzaWJsZUNoaWxkcmVuID0gbGlzdC5jaGlsZFZpZXdzLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5yZWN0LmVsZW1lbnQuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdFxuICAgICAgICAgICAgICAgIC5xdWVyeSgnR0VUX0FDVElWRV9JVEVNUycpXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IHZpc2libGVDaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmlkID09PSBpdGVtLmlkKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG5cbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4ocXVldWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gZ29cbiAgICAgICAgICAgICAgICByb290LmRpc3BhdGNoKCdBRERfSVRFTVMnLCB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBxdWV1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldERyYWdJbmRleChyb290LnJlZi5saXN0LCBjaGlsZHJlbiwgcG9zaXRpb24pLFxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbk1ldGhvZDogSW50ZXJhY3Rpb25NZXRob2QuRFJPUCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJPUCcsIHsgcG9zaXRpb24gfSk7XG5cbiAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0RJRF9FTkRfRFJBRycsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaG9wcGVyLm9uZHJhZ3N0YXJ0ID0gcG9zaXRpb24gPT4ge1xuICAgICAgICAgICAgcm9vdC5kaXNwYXRjaCgnRElEX1NUQVJUX0RSQUcnLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGhvcHBlci5vbmRyYWcgPSBkZWJvdW5jZShwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRFJBRycsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGhvcHBlci5vbmRyYWdlbmQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgICByb290LmRpc3BhdGNoKCdESURfRU5EX0RSQUcnLCB7IHBvc2l0aW9uIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJvb3QucmVmLmhvcHBlciA9IGhvcHBlcjtcblxuICAgICAgICByb290LnJlZi5kcmlwID0gcm9vdC5hcHBlbmRDaGlsZFZpZXcocm9vdC5jcmVhdGVDaGlsZFZpZXcoZHJpcCkpO1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgIHJvb3QucmVmLmhvcHBlci5kZXN0cm95KCk7XG4gICAgICAgIHJvb3QucmVmLmhvcHBlciA9IG51bGw7XG4gICAgICAgIHJvb3QucmVtb3ZlQ2hpbGRWaWV3KHJvb3QucmVmLmRyaXApO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgYnJvd3NlIGZ1bmN0aW9uYWxpdHlcbiAqL1xuY29uc3QgdG9nZ2xlQnJvd3NlID0gKHJvb3QsIHByb3BzKSA9PiB7XG4gICAgY29uc3QgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX0JST1dTRScpO1xuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSByb290LnF1ZXJ5KCdHRVRfRElTQUJMRUQnKTtcbiAgICBjb25zdCBlbmFibGVkID0gaXNBbGxvd2VkICYmICFpc0Rpc2FibGVkO1xuICAgIGlmIChlbmFibGVkICYmICFyb290LnJlZi5icm93c2VyKSB7XG4gICAgICAgIHJvb3QucmVmLmJyb3dzZXIgPSByb290LmFwcGVuZENoaWxkVmlldyhcbiAgICAgICAgICAgIHJvb3QuY3JlYXRlQ2hpbGRWaWV3KGJyb3dzZXIsIHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBvbmxvYWQ6IGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbignQUREX0lURU1TJywgaXRlbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoOiByb290LmRpc3BhdGNoLFxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKHF1ZXVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNlZWRzTWF4RmlsZXMocm9vdCwgcXVldWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdGVtcyFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogcXVldWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5CUk9XU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYuYnJvd3Nlcikge1xuICAgICAgICByb290LnJlbW92ZUNoaWxkVmlldyhyb290LnJlZi5icm93c2VyKTtcbiAgICAgICAgcm9vdC5yZWYuYnJvd3NlciA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBwYXN0ZSBmdW5jdGlvbmFsaXR5XG4gKi9cbmNvbnN0IHRvZ2dsZVBhc3RlID0gcm9vdCA9PiB7XG4gICAgY29uc3QgaXNBbGxvd2VkID0gcm9vdC5xdWVyeSgnR0VUX0FMTE9XX1BBU1RFJyk7XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHJvb3QucXVlcnkoJ0dFVF9ESVNBQkxFRCcpO1xuICAgIGNvbnN0IGVuYWJsZWQgPSBpc0FsbG93ZWQgJiYgIWlzRGlzYWJsZWQ7XG4gICAgaWYgKGVuYWJsZWQgJiYgIXJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICByb290LnJlZi5wYXN0ZXIgPSBjcmVhdGVQYXN0ZXIoKTtcbiAgICAgICAgcm9vdC5yZWYucGFzdGVyLm9ubG9hZCA9IGl0ZW1zID0+IHtcbiAgICAgICAgICAgIGFwcGx5RmlsdGVyQ2hhaW4oJ0FERF9JVEVNUycsIGl0ZW1zLCB7IGRpc3BhdGNoOiByb290LmRpc3BhdGNoIH0pLnRoZW4ocXVldWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRoZXNlIGZpbGVzIGRvbid0IGZpdCBzbyBzdG9wIGhlcmVcbiAgICAgICAgICAgICAgICBpZiAoZXhjZWVkc01heEZpbGVzKHJvb3QsIHF1ZXVlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0ZW1zIVxuICAgICAgICAgICAgICAgIHJvb3QuZGlzcGF0Y2goJ0FERF9JVEVNUycsIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5QQVNURSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgcm9vdC5yZWYucGFzdGVyKSB7XG4gICAgICAgIHJvb3QucmVmLnBhc3Rlci5kZXN0cm95KCk7XG4gICAgICAgIHJvb3QucmVmLnBhc3RlciA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSb3V0ZSBhY3Rpb25zXG4gKi9cbmNvbnN0IHJvdXRlJDUgPSBjcmVhdGVSb3V0ZSh7XG4gICAgRElEX1NFVF9BTExPV19CUk9XU0U6ICh7IHJvb3QsIHByb3BzIH0pID0+IHtcbiAgICAgICAgdG9nZ2xlQnJvd3NlKHJvb3QsIHByb3BzKTtcbiAgICB9LFxuICAgIERJRF9TRVRfQUxMT1dfRFJPUDogKHsgcm9vdCB9KSA9PiB7XG4gICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgfSxcbiAgICBESURfU0VUX0FMTE9XX1BBU1RFOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgdG9nZ2xlUGFzdGUocm9vdCk7XG4gICAgfSxcbiAgICBESURfU0VUX0RJU0FCTEVEOiAoeyByb290LCBwcm9wcyB9KSA9PiB7XG4gICAgICAgIHRvZ2dsZURyb3Aocm9vdCk7XG4gICAgICAgIHRvZ2dsZVBhc3RlKHJvb3QpO1xuICAgICAgICB0b2dnbGVCcm93c2Uocm9vdCwgcHJvcHMpO1xuICAgICAgICBjb25zdCBpc0Rpc2FibGVkID0gcm9vdC5xdWVyeSgnR0VUX0RJU0FCTEVEJyk7XG4gICAgICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICByb290LmVsZW1lbnQuZGF0YXNldC5kaXNhYmxlZCA9ICdkaXNhYmxlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWxldGUgcm9vdC5lbGVtZW50LmRhdGFzZXQuZGlzYWJsZWQ7IDw9IHRoaXMgZG9lcyBub3Qgd29yayBvbiBpT1MgMTBcbiAgICAgICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgIH0sXG59KTtcblxuY29uc3Qgcm9vdCA9IGNyZWF0ZVZpZXcoe1xuICAgIG5hbWU6ICdyb290JyxcbiAgICByZWFkOiAoeyByb290IH0pID0+IHtcbiAgICAgICAgaWYgKHJvb3QucmVmLm1lYXN1cmUpIHtcbiAgICAgICAgICAgIHJvb3QucmVmLm1lYXN1cmVIZWlnaHQgPSByb290LnJlZi5tZWFzdXJlLm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlOiBjcmVhdGUkZSxcbiAgICB3cml0ZTogd3JpdGUkOSxcbiAgICBkZXN0cm95OiAoeyByb290IH0pID0+IHtcbiAgICAgICAgaWYgKHJvb3QucmVmLnBhc3Rlcikge1xuICAgICAgICAgICAgcm9vdC5yZWYucGFzdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm9vdC5yZWYuaG9wcGVyKSB7XG4gICAgICAgICAgICByb290LnJlZi5ob3BwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBwcmV2ZW50KTtcbiAgICAgICAgcm9vdC5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2dlc3R1cmVzdGFydCcsIHByZXZlbnQpO1xuICAgIH0sXG4gICAgbWl4aW5zOiB7XG4gICAgICAgIHN0eWxlczogWydoZWlnaHQnXSxcbiAgICB9LFxufSk7XG5cbi8vIGNyZWF0ZXMgdGhlIGFwcFxuY29uc3QgY3JlYXRlQXBwID0gKGluaXRpYWxPcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBsZXQgZWxlbWVudFxuICAgIGxldCBvcmlnaW5hbEVsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gZ2V0IGRlZmF1bHQgb3B0aW9uc1xuICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkYXRhIHN0b3JlLCB0aGlzIHdpbGwgY29udGFpbiBhbGwgb3VyIGFwcCBpbmZvXG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICAgICAgLy8gaW5pdGlhbCBzdGF0ZSAoc2hvdWxkIGJlIHNlcmlhbGl6YWJsZSlcbiAgICAgICAgY3JlYXRlSW5pdGlhbFN0YXRlKGRlZmF1bHRPcHRpb25zKSxcblxuICAgICAgICAvLyBxdWVyaWVzXG4gICAgICAgIFtxdWVyaWVzLCBjcmVhdGVPcHRpb25RdWVyaWVzKGRlZmF1bHRPcHRpb25zKV0sXG5cbiAgICAgICAgLy8gYWN0aW9uIGhhbmRsZXJzXG4gICAgICAgIFthY3Rpb25zLCBjcmVhdGVPcHRpb25BY3Rpb25zKGRlZmF1bHRPcHRpb25zKV1cbiAgICApO1xuXG4gICAgLy8gc2V0IGluaXRpYWwgb3B0aW9uc1xuICAgIHN0b3JlLmRpc3BhdGNoKCdTRVRfT1BUSU9OUycsIHsgb3B0aW9uczogaW5pdGlhbE9wdGlvbnMgfSk7XG5cbiAgICAvLyBraWNrIHRocmVhZCBpZiB2aXNpYmlsaXR5IGNoYW5nZXNcbiAgICBjb25zdCB2aXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmhpZGRlbikgcmV0dXJuO1xuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnS0lDSycpO1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHZpc2liaWxpdHlIYW5kbGVyKTtcblxuICAgIC8vIHJlLXJlbmRlciBvbiB3aW5kb3cgcmVzaXplIHN0YXJ0IGFuZCBmaW5pc2hcbiAgICBsZXQgcmVzaXplRG9uZVRpbWVyID0gbnVsbDtcbiAgICBsZXQgaXNSZXNpemluZyA9IGZhbHNlO1xuICAgIGxldCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ID0gZmFsc2U7XG4gICAgbGV0IGluaXRpYWxXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRXaW5kb3dXaWR0aCA9IG51bGw7XG4gICAgY29uc3QgcmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplRG9uZVRpbWVyKTtcbiAgICAgICAgcmVzaXplRG9uZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudFdpbmRvd1dpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KSB7XG4gICAgICAgICAgICAgICAgaXNSZXNpemluZ0hvcml6b250YWxseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RPUF9SRVNJWkUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcblxuICAgIC8vIHJlbmRlciBpbml0aWFsIHZpZXdcbiAgICBjb25zdCB2aWV3ID0gcm9vdChzdG9yZSwgeyBpZDogZ2V0VW5pcXVlSWQoKSB9KTtcblxuICAgIC8vXG4gICAgLy8gUFJJVkFURSBBUEkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgbGV0IGlzUmVzdGluZyA9IGZhbHNlO1xuICAgIGxldCBpc0hpZGRlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgcmVhZFdyaXRlQXBpID0ge1xuICAgICAgICAvLyBuZWNlc3NhcnkgZm9yIHVwZGF0ZSBsb29wXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYWRzIGZyb20gZG9tIChuZXZlciBjYWxsIG1hbnVhbGx5KVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3JlYWQ6ICgpID0+IHtcbiAgICAgICAgICAgIC8vIHRlc3QgaWYgd2UncmUgcmVzaXppbmcgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIG9wdGltaXplIHRoaXMgYnkgbWVhc3VyaW5nIHJvb3QgcmVjdFxuICAgICAgICAgICAgaWYgKGlzUmVzaXppbmcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoIWluaXRpYWxXaW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsV2luZG93V2lkdGggPSBjdXJyZW50V2luZG93V2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5ICYmIGN1cnJlbnRXaW5kb3dXaWR0aCAhPT0gaW5pdGlhbFdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfU1RBUlRfUkVTSVpFJyk7XG4gICAgICAgICAgICAgICAgICAgIGlzUmVzaXppbmdIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzSGlkZGVuICYmIGlzUmVzdGluZykge1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgaWYgaXMgbm8gbG9uZ2VyIGhpZGRlblxuICAgICAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuZWxlbWVudC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHJlc3RpbmcsIG5vIG5lZWQgdG8gcmVhZCBhcyBudW1iZXJzIHdpbGwgc3RpbGwgYWxsIGJlIGNvcnJlY3RcbiAgICAgICAgICAgIGlmIChpc1Jlc3RpbmcpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gcmVhZCB2aWV3IGRhdGFcbiAgICAgICAgICAgIHZpZXcuX3JlYWQoKTtcblxuICAgICAgICAgICAgLy8gaWYgaXMgaGlkZGVuIHdlIG5lZWQgdG8ga25vdyBzbyB3ZSBleGl0IHJlc3QgbW9kZSB3aGVuIHJldmVhbGVkXG4gICAgICAgICAgICBpc0hpZGRlbiA9IHZpZXcucmVjdC5lbGVtZW50LmhpZGRlbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV3JpdGVzIHRvIGRvbSAobmV2ZXIgY2FsbCBtYW51YWxseSlcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF93cml0ZTogdHMgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IGFsbCBhY3Rpb25zIGZyb20gc3RvcmVcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBzdG9yZVxuICAgICAgICAgICAgICAgIC5wcm9jZXNzQWN0aW9uUXVldWUoKVxuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBzZXQgYWN0aW9ucyAodGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgRElEX1NFVClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiAhL15TRVRfLy50ZXN0KGFjdGlvbi50eXBlKSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHdhcyBpZGxpbmcgYW5kIG5vIGFjdGlvbnMgc3RvcCBoZXJlXG4gICAgICAgICAgICBpZiAoaXNSZXN0aW5nICYmICFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBzb21lIGFjdGlvbnMgbWlnaHQgdHJpZ2dlciBldmVudHNcbiAgICAgICAgICAgIHJvdXRlQWN0aW9uc1RvRXZlbnRzKGFjdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHZpZXdcbiAgICAgICAgICAgIGlzUmVzdGluZyA9IHZpZXcuX3dyaXRlKHRzLCBhY3Rpb25zLCBpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5KTtcblxuICAgICAgICAgICAgLy8gd2lsbCBjbGVhbiB1cCBhbGwgYXJjaGl2ZWQgaXRlbXNcbiAgICAgICAgICAgIHJlbW92ZVJlbGVhc2VkSXRlbXMoc3RvcmUucXVlcnkoJ0dFVF9JVEVNUycpKTtcblxuICAgICAgICAgICAgLy8gbm93IGlkbGluZ1xuICAgICAgICAgICAgaWYgKGlzUmVzdGluZykge1xuICAgICAgICAgICAgICAgIHN0b3JlLnByb2Nlc3NEaXNwYXRjaFF1ZXVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gRVhQT1NFIEVWRU5UUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICBjb25zdCBjcmVhdGVFdmVudCA9IG5hbWUgPT4gZGF0YSA9PiB7XG4gICAgICAgIC8vIGNyZWF0ZSBkZWZhdWx0IGV2ZW50XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBubyBkYXRhIHRvIGFkZFxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvcHkgcmVsZXZhbnQgcHJvcHNcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ2Vycm9yJykpIHtcbiAgICAgICAgICAgIGV2ZW50LmVycm9yID0gZGF0YS5lcnJvciA/IHsgLi4uZGF0YS5lcnJvciB9IDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cykge1xuICAgICAgICAgICAgZXZlbnQuc3RhdHVzID0geyAuLi5kYXRhLnN0YXR1cyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEuZmlsZSkge1xuICAgICAgICAgICAgZXZlbnQub3V0cHV0ID0gZGF0YS5maWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb25seSBzb3VyY2UgaXMgYXZhaWxhYmxlLCBlbHNlIGFkZCBpdGVtIGlmIHBvc3NpYmxlXG4gICAgICAgIGlmIChkYXRhLnNvdXJjZSkge1xuICAgICAgICAgICAgZXZlbnQuZmlsZSA9IGRhdGEuc291cmNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuaXRlbSB8fCBkYXRhLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YS5pdGVtID8gZGF0YS5pdGVtIDogc3RvcmUucXVlcnkoJ0dFVF9JVEVNJywgZGF0YS5pZCk7XG4gICAgICAgICAgICBldmVudC5maWxlID0gaXRlbSA/IGNyZWF0ZUl0ZW1BUEkoaXRlbSkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFwIGFsbCBpdGVtcyBpbiBhIHBvc3NpYmxlIGl0ZW1zIGFycmF5XG4gICAgICAgIGlmIChkYXRhLml0ZW1zKSB7XG4gICAgICAgICAgICBldmVudC5pdGVtcyA9IGRhdGEuaXRlbXMubWFwKGNyZWF0ZUl0ZW1BUEkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhIHByb2dyZXNzIGV2ZW50IGFkZCB0aGUgcHJvZ3Jlc3MgYW1vdW50XG4gICAgICAgIGlmICgvcHJvZ3Jlc3MvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByb2dyZXNzID0gZGF0YS5wcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvcHkgcmVsZXZhbnQgcHJvcHNcbiAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoJ29yaWdpbicpICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ3RhcmdldCcpKSB7XG4gICAgICAgICAgICBldmVudC5vcmlnaW4gPSBkYXRhLm9yaWdpbjtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGRhdGEudGFyZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICBjb25zdCBldmVudFJvdXRlcyA9IHtcbiAgICAgICAgRElEX0RFU1RST1k6IGNyZWF0ZUV2ZW50KCdkZXN0cm95JyksXG5cbiAgICAgICAgRElEX0lOSVQ6IGNyZWF0ZUV2ZW50KCdpbml0JyksXG5cbiAgICAgICAgRElEX1RIUk9XX01BWF9GSUxFUzogY3JlYXRlRXZlbnQoJ3dhcm5pbmcnKSxcblxuICAgICAgICBESURfSU5JVF9JVEVNOiBjcmVhdGVFdmVudCgnaW5pdGZpbGUnKSxcbiAgICAgICAgRElEX1NUQVJUX0lURU1fTE9BRDogY3JlYXRlRXZlbnQoJ2FkZGZpbGVzdGFydCcpLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fTE9BRF9QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ2FkZGZpbGVwcm9ncmVzcycpLFxuICAgICAgICBESURfTE9BRF9JVEVNOiBjcmVhdGVFdmVudCgnYWRkZmlsZScpLFxuXG4gICAgICAgIERJRF9USFJPV19JVEVNX0lOVkFMSUQ6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ2FkZGZpbGUnKV0sXG5cbiAgICAgICAgRElEX1RIUk9XX0lURU1fTE9BRF9FUlJPUjogW2NyZWF0ZUV2ZW50KCdlcnJvcicpLCBjcmVhdGVFdmVudCgnYWRkZmlsZScpXSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1I6IFtjcmVhdGVFdmVudCgnZXJyb3InKSwgY3JlYXRlRXZlbnQoJ3JlbW92ZWZpbGUnKV0sXG5cbiAgICAgICAgRElEX1BSRVBBUkVfT1VUUFVUOiBjcmVhdGVFdmVudCgncHJlcGFyZWZpbGUnKSxcblxuICAgICAgICBESURfU1RBUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzdGFydCcpLFxuICAgICAgICBESURfVVBEQVRFX0lURU1fUFJPQ0VTU19QUk9HUkVTUzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlcHJvZ3Jlc3MnKSxcbiAgICAgICAgRElEX0FCT1JUX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlYWJvcnQnKSxcbiAgICAgICAgRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORzogY3JlYXRlRXZlbnQoJ3Byb2Nlc3NmaWxlJyksXG4gICAgICAgIERJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVzJyksXG4gICAgICAgIERJRF9SRVZFUlRfSVRFTV9QUk9DRVNTSU5HOiBjcmVhdGVFdmVudCgncHJvY2Vzc2ZpbGVyZXZlcnQnKSxcblxuICAgICAgICBESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SOiBbY3JlYXRlRXZlbnQoJ2Vycm9yJyksIGNyZWF0ZUV2ZW50KCdwcm9jZXNzZmlsZScpXSxcblxuICAgICAgICBESURfUkVNT1ZFX0lURU06IGNyZWF0ZUV2ZW50KCdyZW1vdmVmaWxlJyksXG5cbiAgICAgICAgRElEX1VQREFURV9JVEVNUzogY3JlYXRlRXZlbnQoJ3VwZGF0ZWZpbGVzJyksXG5cbiAgICAgICAgRElEX0FDVElWQVRFX0lURU06IGNyZWF0ZUV2ZW50KCdhY3RpdmF0ZWZpbGUnKSxcblxuICAgICAgICBESURfUkVPUkRFUl9JVEVNUzogY3JlYXRlRXZlbnQoJ3Jlb3JkZXJmaWxlcycpLFxuICAgIH07XG5cbiAgICBjb25zdCBleHBvc2VFdmVudCA9IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gY3JlYXRlIGV2ZW50IG9iamVjdCB0byBiZSBkaXNwYXRjaGVkXG4gICAgICAgIGNvbnN0IGRldGFpbCA9IHsgcG9uZDogZXhwb3J0cywgLi4uZXZlbnQgfTtcbiAgICAgICAgZGVsZXRlIGRldGFpbC50eXBlO1xuICAgICAgICB2aWV3LmVsZW1lbnQuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChgRmlsZVBvbmQ6JHtldmVudC50eXBlfWAsIHtcbiAgICAgICAgICAgICAgICAvLyBldmVudCBpbmZvXG4gICAgICAgICAgICAgICAgZGV0YWlsLFxuXG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgYmVoYXZpb3VyXG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLCAvLyB0cmlnZ2VycyBsaXN0ZW5lcnMgb3V0c2lkZSBvZiBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBldmVudCBvYmplY3QgdG8gcGFyYW1zIHVzZWQgZm9yIGBvbigpYCBldmVudCBoYW5kbGVycyBhbmQgY2FsbGJhY2tzIGBvbmluaXQoKWBcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG5cbiAgICAgICAgLy8gaWYgaXMgcG9zc2libGUgZXJyb3IgZXZlbnQsIG1ha2UgaXQgdGhlIGZpcnN0IHBhcmFtXG4gICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnZXJyb3InKSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsZSBpcyBhbHdheXMgc2VjdGlvblxuICAgICAgICBpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ2ZpbGUnKSkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goZXZlbnQuZmlsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgb3RoZXIgcHJvcHNcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbJ3R5cGUnLCAnZXJyb3InLCAnZmlsZSddO1xuICAgICAgICBPYmplY3Qua2V5cyhldmVudClcbiAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+ICFmaWx0ZXJlZC5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgLmZvckVhY2goa2V5ID0+IHBhcmFtcy5wdXNoKGV2ZW50W2tleV0pKTtcblxuICAgICAgICAvLyBvbih0eXBlLCAoKSA9PiB7IH0pXG4gICAgICAgIGV4cG9ydHMuZmlyZShldmVudC50eXBlLCAuLi5wYXJhbXMpO1xuXG4gICAgICAgIC8vIG9uaW5pdCA9ICgpID0+IHt9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBzdG9yZS5xdWVyeShgR0VUX09OJHtldmVudC50eXBlLnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBoYW5kbGVyKC4uLnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgcm91dGVBY3Rpb25zVG9FdmVudHMgPSBhY3Rpb25zID0+IHtcbiAgICAgICAgaWYgKCFhY3Rpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiBldmVudFJvdXRlc1thY3Rpb24udHlwZV0pXG4gICAgICAgICAgICAuZm9yRWFjaChhY3Rpb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlcyA9IGV2ZW50Um91dGVzW2FjdGlvbi50eXBlXTtcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyb3V0ZXMpID8gcm91dGVzIDogW3JvdXRlc10pLmZvckVhY2gocm91dGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGZhbnRhc3RpYywgYnV0IGJlY2F1c2Ugb2YgdGhlIHN0YWNraW5nIG9mIHNldHRpbWVvdXRzIHBsdWdpbnMgY2FuIGhhbmRsZSB0aGUgZGlkX2xvYWQgYmVmb3JlIHRoZSBkaWRfaW5pdFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdESURfSU5JVF9JVEVNJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3NlRXZlbnQocm91dGUoYWN0aW9uLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZUV2ZW50KHJvdXRlKGFjdGlvbi5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gUFVCTElDIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICBjb25zdCBzZXRPcHRpb25zID0gb3B0aW9ucyA9PiBzdG9yZS5kaXNwYXRjaCgnU0VUX09QVElPTlMnLCB7IG9wdGlvbnMgfSk7XG5cbiAgICBjb25zdCBnZXRGaWxlID0gcXVlcnkgPT4gc3RvcmUucXVlcnkoJ0dFVF9BQ1RJVkVfSVRFTScsIHF1ZXJ5KTtcblxuICAgIGNvbnN0IHByZXBhcmVGaWxlID0gcXVlcnkgPT5cbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ1JFUVVFU1RfSVRFTV9QUkVQQVJFJywge1xuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBhZGRGaWxlID0gKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSA9PlxuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBhZGRGaWxlcyhbeyBzb3VyY2UsIG9wdGlvbnMgfV0sIHsgaW5kZXg6IG9wdGlvbnMuaW5kZXggfSlcbiAgICAgICAgICAgICAgICAudGhlbihpdGVtcyA9PiByZXNvbHZlKGl0ZW1zICYmIGl0ZW1zWzBdKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBpc0ZpbGVQb25kRmlsZSA9IG9iaiA9PiBvYmouZmlsZSAmJiBvYmouaWQ7XG5cbiAgICBjb25zdCByZW1vdmVGaWxlID0gKHF1ZXJ5LCBvcHRpb25zKSA9PiB7XG4gICAgICAgIC8vIGlmIG9ubHkgcGFzc2VkIG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcgJiYgIWlzRmlsZVBvbmRGaWxlKHF1ZXJ5KSAmJiAhb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHF1ZXJ5O1xuICAgICAgICAgICAgcXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXF1ZXN0IGl0ZW0gcmVtb3ZhbFxuICAgICAgICBzdG9yZS5kaXNwYXRjaCgnUkVNT1ZFX0lURU0nLCB7IC4uLm9wdGlvbnMsIHF1ZXJ5IH0pO1xuXG4gICAgICAgIC8vIHNlZSBpZiBpdGVtIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgcmV0dXJuIHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU0nLCBxdWVyeSkgPT09IG51bGw7XG4gICAgfTtcblxuICAgIGNvbnN0IGFkZEZpbGVzID0gKC4uLmFyZ3MpID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgICAgLy8gdXNlciBwYXNzZWQgYSBzb3VyY2VzIGFycmF5XG4gICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaC5hcHBseShzb3VyY2VzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGFyZ3NbMV0gfHwge30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHBhc3NlZCBzb3VyY2VzIGFzIGFyZ3VtZW50cywgbGFzdCBvbmUgbWlnaHQgYmUgb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0QXJndW1lbnQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0QXJndW1lbnQgPT09ICdvYmplY3QnICYmICEobGFzdEFyZ3VtZW50IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBhcmdzLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgcmVzdCB0byBzb3VyY2VzXG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdG9yZS5kaXNwYXRjaCgnQUREX0lURU1TJywge1xuICAgICAgICAgICAgICAgIGl0ZW1zOiBzb3VyY2VzLFxuICAgICAgICAgICAgICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uTWV0aG9kOiBJbnRlcmFjdGlvbk1ldGhvZC5BUEksXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBmYWlsdXJlOiByZWplY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICBjb25zdCBnZXRGaWxlcyA9ICgpID0+IHN0b3JlLnF1ZXJ5KCdHRVRfQUNUSVZFX0lURU1TJyk7XG5cbiAgICBjb25zdCBwcm9jZXNzRmlsZSA9IHF1ZXJ5ID0+XG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdSRVFVRVNUX0lURU1fUFJPQ0VTU0lORycsIHtcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgY29uc3QgcHJlcGFyZUZpbGVzID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSkgPyBhcmdzWzBdIDogYXJncztcbiAgICAgICAgY29uc3QgaXRlbXMgPSBxdWVyaWVzLmxlbmd0aCA/IHF1ZXJpZXMgOiBnZXRGaWxlcygpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMubWFwKHByZXBhcmVGaWxlKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHByb2Nlc3NGaWxlcyA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3M7XG4gICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZ2V0RmlsZXMoKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgaXRlbSA9PlxuICAgICAgICAgICAgICAgICAgICAhKGl0ZW0uc3RhdHVzID09PSBJdGVtU3RhdHVzLklETEUgJiYgaXRlbS5vcmlnaW4gPT09IEZpbGVPcmlnaW4uTE9DQUwpICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc3RhdHVzICE9PSBJdGVtU3RhdHVzLlBST0NFU1NJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zdGF0dXMgIT09IEl0ZW1TdGF0dXMuUFJPQ0VTU0lOR19DT01QTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLnN0YXR1cyAhPT0gSXRlbVN0YXR1cy5QUk9DRVNTSU5HX1JFVkVSVF9FUlJPUlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocXVlcmllcy5tYXAocHJvY2Vzc0ZpbGUpKTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVtb3ZlRmlsZXMgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gQXJyYXkuaXNBcnJheShhcmdzWzBdKSA/IGFyZ3NbMF0gOiBhcmdzO1xuXG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXNbcXVlcmllcy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBxdWVyaWVzLnBvcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlcygpO1xuXG4gICAgICAgIGlmICghcXVlcmllcy5sZW5ndGgpIHJldHVybiBQcm9taXNlLmFsbChmaWxlcy5tYXAoZmlsZSA9PiByZW1vdmVGaWxlKGZpbGUsIG9wdGlvbnMpKSk7XG5cbiAgICAgICAgLy8gd2hlbiByZW1vdmluZyBieSBpbmRleCB0aGUgaW5kZXhlcyBzaGlmdCBhZnRlciBlYWNoIGZpbGUgcmVtb3ZhbCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaW5kZXhlcyB0byBpZHNcbiAgICAgICAgY29uc3QgbWFwcGVkUXVlcmllcyA9IHF1ZXJpZXNcbiAgICAgICAgICAgIC5tYXAocXVlcnkgPT4gKGlzTnVtYmVyKHF1ZXJ5KSA/IChmaWxlc1txdWVyeV0gPyBmaWxlc1txdWVyeV0uaWQgOiBudWxsKSA6IHF1ZXJ5KSlcbiAgICAgICAgICAgIC5maWx0ZXIocXVlcnkgPT4gcXVlcnkpO1xuXG4gICAgICAgIHJldHVybiBtYXBwZWRRdWVyaWVzLm1hcChxID0+IHJlbW92ZUZpbGUocSwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICBjb25zdCBleHBvcnRzID0ge1xuICAgICAgICAvLyBzdXBwb3J0cyBldmVudHNcbiAgICAgICAgLi4ub24oKSxcblxuICAgICAgICAvLyBpbmplY3QgcHJpdmF0ZSBhcGkgbWV0aG9kc1xuICAgICAgICAuLi5yZWFkV3JpdGVBcGksXG5cbiAgICAgICAgLy8gaW5qZWN0IGFsbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIC4uLmNyZWF0ZU9wdGlvbkFQSShzdG9yZSwgZGVmYXVsdE9wdGlvbnMpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdmVycmlkZSBvcHRpb25zIGRlZmluZWQgaW4gb3B0aW9ucyBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHNldE9wdGlvbnMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHNvdXJjZSAtIHRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgKGVpdGhlciBhIEZpbGUsIGJhc2U2NCBkYXRhIHVyaSBvciB1cmwpXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIC0gb2JqZWN0LCB7IGluZGV4OiAwIH1cbiAgICAgICAgICovXG4gICAgICAgIGFkZEZpbGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIGdpdmVuIGZpbGVzXG4gICAgICAgICAqIEBwYXJhbSBzb3VyY2VzIC0gdGhlIHNvdXJjZXMgb2YgdGhlIGZpbGVzIHRvIGxvYWRcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgLSBvYmplY3QsIHsgaW5kZXg6IDAgfVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGZpbGUgb2JqZWN0cyBtYXRjaGluZyB0aGUgZ2l2ZW4gcXVlcnlcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBsb2FkIGZpbGUgd2l0aCBnaXZlbiBuYW1lXG4gICAgICAgICAqIEBwYXJhbSBxdWVyeSB7IHN0cmluZywgbnVtYmVyLCBudWxsICB9XG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBwcmVwYXJlIG91dHB1dCBmb3IgZmlsZSB3aXRoIGdpdmVuIG5hbWVcbiAgICAgICAgICogQHBhcmFtIHF1ZXJ5IHsgc3RyaW5nLCBudW1iZXIsIG51bGwgIH1cbiAgICAgICAgICovXG4gICAgICAgIHByZXBhcmVGaWxlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgZmlsZSBieSBpdHMgbmFtZVxuICAgICAgICAgKiBAcGFyYW0gcXVlcnkgeyBzdHJpbmcsIG51bWJlciwgbnVsbCAgfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgYSBmaWxlIHRvIGEgbmV3IGxvY2F0aW9uIGluIHRoZSBmaWxlcyBsaXN0XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlRmlsZTogKHF1ZXJ5LCBpbmRleCkgPT4gc3RvcmUuZGlzcGF0Y2goJ01PVkVfSVRFTScsIHsgcXVlcnksIGluZGV4IH0pLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBmaWxlcyAod3JhcHBlZCBpbiBwdWJsaWMgYXBpKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyB1cGxvYWRpbmcgYWxsIGZpbGVzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFycyBhbGwgZmlsZXMgZnJvbSB0aGUgZmlsZXMgbGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlRmlsZXMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0cyBwcmVwYXJpbmcgb3V0cHV0IG9mIGFsbCBmaWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGFyZUZpbGVzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3J0IGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICovXG4gICAgICAgIHNvcnQ6IGNvbXBhcmUgPT4gc3RvcmUuZGlzcGF0Y2goJ1NPUlQnLCB7IGNvbXBhcmUgfSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb3dzZSB0aGUgZmlsZSBzeXN0ZW0gZm9yIGEgZmlsZVxuICAgICAgICAgKi9cbiAgICAgICAgYnJvd3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBuZWVkcyB0byBiZSB0cmlnZ2VyIGRpcmVjdGx5IGFzIHVzZXIgYWN0aW9uIG5lZWRzIHRvIGJlIHRyYWNlYWJsZSAoaXMgbm90IHRyYWNlYWJsZSBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB2aWV3LmVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1maWxlXScpO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdHJveXMgdGhlIGFwcFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgLy8gcmVxdWVzdCBkZXN0cnVjdGlvblxuICAgICAgICAgICAgZXhwb3J0cy5maXJlKCdkZXN0cm95Jywgdmlldy5lbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gc3RvcCBhY3RpdmUgcHJvY2Vzc2VzIChmaWxlIHVwbG9hZHMsIGZldGNoZXMsIHN0dWZmIGxpa2UgdGhhdClcbiAgICAgICAgICAgIC8vIGxvb3Agb3ZlciBpdGVtcyBhbmQgZGVwZW5kaW5nIG9uIHN0YXRlcyBjYWxsIGFib3J0IGZvciBvbmdvaW5nIHByb2Nlc3Nlc1xuICAgICAgICAgICAgc3RvcmUuZGlzcGF0Y2goJ0FCT1JUX0FMTCcpO1xuXG4gICAgICAgICAgICAvLyBkZXN0cm95IHZpZXdcbiAgICAgICAgICAgIHZpZXcuX2Rlc3Ryb3koKTtcblxuICAgICAgICAgICAgLy8gc3RvcCBsaXN0ZW5pbmcgdG8gcmVzaXplXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG5cbiAgICAgICAgICAgIC8vIHN0b3AgbGlzdGVuaW5nIHRvIHRoZSB2aXNpYmxpdHljaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB2aXNpYmlsaXR5SGFuZGxlcik7XG5cbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGRlc3Ryb3lcbiAgICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdESURfREVTVFJPWScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIHRoZSBwbHVnaW4gYmVmb3JlIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBlbGVtZW50ID0+IGluc2VydEJlZm9yZSh2aWV3LmVsZW1lbnQsIGVsZW1lbnQpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIHRoZSBwbHVnaW4gYWZ0ZXIgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBpbnNlcnRBZnRlcjogZWxlbWVudCA9PiBpbnNlcnRBZnRlcih2aWV3LmVsZW1lbnQsIGVsZW1lbnQpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIHRoZSBwbHVnaW4gdG8gdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRUbzogZWxlbWVudCA9PiBlbGVtZW50LmFwcGVuZENoaWxkKHZpZXcuZWxlbWVudCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2VzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXBwXG4gICAgICAgICAqL1xuICAgICAgICByZXBsYWNlRWxlbWVudDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGFwcCBiZWZvcmUgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIGluc2VydEJlZm9yZSh2aWV3LmVsZW1lbnQsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gcmVtZW1iZXIgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgICAgb3JpZ2luYWxFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHJlc3RvcmVFbGVtZW50OiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW9yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbm8gZWxlbWVudCB0byByZXN0b3JlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZWxlbWVudFxuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXIob3JpZ2luYWxFbGVtZW50LCB2aWV3LmVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgb3VyIGVsZW1lbnRcbiAgICAgICAgICAgIHZpZXcuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHZpZXcuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIG9yaWdpbmFsRWxlbWVudCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwIHJvb3QgaXMgYXR0YWNoZWQgdG8gZ2l2ZW4gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaXNBdHRhY2hlZFRvOiBlbGVtZW50ID0+IHZpZXcuZWxlbWVudCA9PT0gZWxlbWVudCB8fCBvcmlnaW5hbEVsZW1lbnQgPT09IGVsZW1lbnQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudDoge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiB2aWV3LmVsZW1lbnQsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcG9uZCBzdGF0dXNcbiAgICAgICAgICovXG4gICAgICAgIHN0YXR1czoge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiBzdG9yZS5xdWVyeSgnR0VUX1NUQVRVUycpLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBEb25lIVxuICAgIHN0b3JlLmRpc3BhdGNoKCdESURfSU5JVCcpO1xuXG4gICAgLy8gY3JlYXRlIGFjdHVhbCBhcGkgb2JqZWN0XG4gICAgcmV0dXJuIGNyZWF0ZU9iamVjdChleHBvcnRzKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUFwcE9iamVjdCA9IChjdXN0b21PcHRpb25zID0ge30pID0+IHtcbiAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHt9O1xuICAgIGZvcmluKGdldE9wdGlvbnMoKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgZGVmYXVsdE9wdGlvbnNba2V5XSA9IHZhbHVlWzBdO1xuICAgIH0pO1xuXG4gICAgLy8gc2V0IGFwcCBvcHRpb25zXG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwKHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuXG4gICAgICAgIC8vIGN1c3RvbSBvcHRpb25zXG4gICAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHBsdWdpbiBpbnN0YW5jZVxuICAgIHJldHVybiBhcHA7XG59O1xuXG5jb25zdCBsb3dlckNhc2VGaXJzdExldHRlciA9IHN0cmluZyA9PiBzdHJpbmcuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG5cbmNvbnN0IGF0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZSA9IGF0dHJpYnV0ZU5hbWUgPT4gdG9DYW1lbHMoYXR0cmlidXRlTmFtZS5yZXBsYWNlKC9eZGF0YS0vLCAnJykpO1xuXG5jb25zdCBtYXBPYmplY3QgPSAob2JqZWN0LCBwcm9wZXJ0eU1hcCkgPT4ge1xuICAgIC8vIHJlbW92ZSB1bndhbnRlZFxuICAgIGZvcmluKHByb3BlcnR5TWFwLCAoc2VsZWN0b3IsIG1hcHBpbmcpID0+IHtcbiAgICAgICAgZm9yaW4ob2JqZWN0LCAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcmVnZXhwIHNob3J0Y3V0XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvclJlZ0V4cCA9IG5ldyBSZWdFeHAoc2VsZWN0b3IpO1xuXG4gICAgICAgICAgICAvLyB0ZXN0cyBpZlxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNlbGVjdG9yUmVnRXhwLnRlc3QocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAvLyBubyBtYXRjaCwgc2tpcFxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgbWFwcGluZywgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGlzIGFsd2F5cyByZW1vdmVkXG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgLy8gc2hvdWxkIG9ubHkgcmVtb3ZlLCB3ZSBkb25lIVxuICAgICAgICAgICAgaWYgKG1hcHBpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlIHZhbHVlIHRvIG5ldyBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W21hcHBpbmddID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtb3ZlIHRvIGdyb3VwXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IG1hcHBpbmcuZ3JvdXA7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QobWFwcGluZykgJiYgIW9iamVjdFtncm91cF0pIHtcbiAgICAgICAgICAgICAgICBvYmplY3RbZ3JvdXBdID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iamVjdFtncm91cF1bbG93ZXJDYXNlRmlyc3RMZXR0ZXIocHJvcGVydHkucmVwbGFjZShzZWxlY3RvclJlZ0V4cCwgJycpKV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZG8gc3VibWFwcGluZ1xuICAgICAgICBpZiAobWFwcGluZy5tYXBwaW5nKSB7XG4gICAgICAgICAgICBtYXBPYmplY3Qob2JqZWN0W21hcHBpbmcuZ3JvdXBdLCBtYXBwaW5nLm1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5jb25zdCBnZXRBdHRyaWJ1dGVzQXNPYmplY3QgPSAobm9kZSwgYXR0cmlidXRlTWFwcGluZyA9IHt9KSA9PiB7XG4gICAgLy8gdHVybiBhdHRyaWJ1dGVzIGludG8gb2JqZWN0XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIGZvcmluKG5vZGUuYXR0cmlidXRlcywgaW5kZXggPT4ge1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzW2luZGV4XSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXQgPSBhdHRyaWJ1dGVzXG4gICAgICAgIC5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5uYW1lKVxuICAgICAgICAucmVkdWNlKChvYmosIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyKG5vZGUsIGF0dHJpYnV0ZS5uYW1lKTtcblxuICAgICAgICAgICAgb2JqW2F0dHJpYnV0ZU5hbWVUb1Byb3BlcnR5TmFtZShhdHRyaWJ1dGUubmFtZSldID1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gYXR0cmlidXRlLm5hbWUgPyB0cnVlIDogdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG5cbiAgICAvLyBkbyBtYXBwaW5nIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgbWFwT2JqZWN0KG91dHB1dCwgYXR0cmlidXRlTWFwcGluZyk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgY3JlYXRlQXBwQXRFbGVtZW50ID0gKGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIC8vIGhvdyBhdHRyaWJ1dGVzIG9mIHRoZSBpbnB1dCBlbGVtZW50IGFyZSBtYXBwZWQgdG8gdGhlIG9wdGlvbnMgZm9yIHRoZSBwbHVnaW5cbiAgICBjb25zdCBhdHRyaWJ1dGVNYXBwaW5nID0ge1xuICAgICAgICAvLyB0cmFuc2xhdGUgdG8gb3RoZXIgbmFtZVxuICAgICAgICAnXmNsYXNzJCc6ICdjbGFzc05hbWUnLFxuICAgICAgICAnXm11bHRpcGxlJCc6ICdhbGxvd011bHRpcGxlJyxcbiAgICAgICAgJ15jYXB0dXJlJCc6ICdjYXB0dXJlTWV0aG9kJyxcbiAgICAgICAgJ153ZWJraXRkaXJlY3RvcnkkJzogJ2FsbG93RGlyZWN0b3JpZXNPbmx5JyxcblxuICAgICAgICAvLyBncm91cCB1bmRlciBzaW5nbGUgcHJvcGVydHlcbiAgICAgICAgJ15zZXJ2ZXInOiB7XG4gICAgICAgICAgICBncm91cDogJ3NlcnZlcicsXG4gICAgICAgICAgICBtYXBwaW5nOiB7XG4gICAgICAgICAgICAgICAgJ15wcm9jZXNzJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15yZXZlcnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiAncmV2ZXJ0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdeZmV0Y2gnOiB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15yZXN0b3JlJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ3Jlc3RvcmUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ15sb2FkJzoge1xuICAgICAgICAgICAgICAgICAgICBncm91cDogJ2xvYWQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGRvbid0IGluY2x1ZGUgaW4gb2JqZWN0XG4gICAgICAgICdedHlwZSQnOiBmYWxzZSxcbiAgICAgICAgJ15maWxlcyQnOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFkZGl0aW9uYWwgb3B0aW9uIHRyYW5zbGF0b3JzXG4gICAgYXBwbHlGaWx0ZXJzKCdTRVRfQVRUUklCVVRFX1RPX09QVElPTl9NQVAnLCBhdHRyaWJ1dGVNYXBwaW5nKTtcblxuICAgIC8vIGNyZWF0ZSBmaW5hbCBvcHRpb25zIG9iamVjdCBieSBzZXR0aW5nIG9wdGlvbnMgb2JqZWN0IGFuZCB0aGVuIG92ZXJyaWRpbmcgb3B0aW9ucyBzdXBwbGllZCBvbiBlbGVtZW50XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgY29uc3QgYXR0cmlidXRlT3B0aW9ucyA9IGdldEF0dHJpYnV0ZXNBc09iamVjdChcbiAgICAgICAgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0ZJRUxEU0VUJyA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdHlwZT1maWxlXScpIDogZWxlbWVudCxcbiAgICAgICAgYXR0cmlidXRlTWFwcGluZ1xuICAgICk7XG5cbiAgICAvLyBtZXJnZSB3aXRoIG9wdGlvbnMgb2JqZWN0XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoaXNPYmplY3QoYXR0cmlidXRlT3B0aW9uc1trZXldKSkge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChtZXJnZWRPcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9uc1trZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZE9wdGlvbnNba2V5XSwgYXR0cmlidXRlT3B0aW9uc1trZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlZE9wdGlvbnNba2V5XSA9IGF0dHJpYnV0ZU9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgcGFyZW50IGlzIGEgZmllbGRzZXQsIGdldCBmaWxlcyBmcm9tIHBhcmVudCBieSBzZWxlY3RpbmcgYWxsIGlucHV0IGZpZWxkcyB0aGF0IGFyZSBub3QgZmlsZSB1cGxvYWQgZmllbGRzXG4gICAgLy8gdGhlc2Ugd2lsbCB0aGVuIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSBpbml0aWFsIGZpbGVzXG4gICAgbWVyZ2VkT3B0aW9ucy5maWxlcyA9IChvcHRpb25zLmZpbGVzIHx8IFtdKS5jb25jYXQoXG4gICAgICAgIEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpub3QoW3R5cGU9ZmlsZV0pJykpLm1hcChpbnB1dCA9PiAoe1xuICAgICAgICAgICAgc291cmNlOiBpbnB1dC52YWx1ZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBpbnB1dC5kYXRhc2V0LnR5cGUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSlcbiAgICApO1xuXG4gICAgLy8gYnVpbGQgcGx1Z2luXG4gICAgY29uc3QgYXBwID0gY3JlYXRlQXBwT2JqZWN0KG1lcmdlZE9wdGlvbnMpO1xuXG4gICAgLy8gYWRkIGFscmVhZHkgc2VsZWN0ZWQgZmlsZXNcbiAgICBpZiAoZWxlbWVudC5maWxlcykge1xuICAgICAgICBBcnJheS5mcm9tKGVsZW1lbnQuZmlsZXMpLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICBhcHAuYWRkRmlsZShmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBhcHAucmVwbGFjZUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBleHBvc2VcbiAgICByZXR1cm4gYXBwO1xufTtcblxuLy8gaWYgYW4gZWxlbWVudCBpcyBwYXNzZWQsIHdlIGNyZWF0ZSB0aGUgaW5zdGFuY2UgYXQgdGhhdCBlbGVtZW50LCBpZiBub3QsIHdlIGp1c3QgY3JlYXRlIGFuIHVwIG9iamVjdFxuY29uc3QgY3JlYXRlQXBwJDEgPSAoLi4uYXJncykgPT5cbiAgICBpc05vZGUoYXJnc1swXSkgPyBjcmVhdGVBcHBBdEVsZW1lbnQoLi4uYXJncykgOiBjcmVhdGVBcHBPYmplY3QoLi4uYXJncyk7XG5cbmNvbnN0IFBSSVZBVEVfTUVUSE9EUyA9IFsnZmlyZScsICdfcmVhZCcsICdfd3JpdGUnXTtcblxuY29uc3QgY3JlYXRlQXBwQVBJID0gYXBwID0+IHtcbiAgICBjb25zdCBhcGkgPSB7fTtcblxuICAgIGNvcHlPYmplY3RQcm9wZXJ0aWVzVG9PYmplY3QoYXBwLCBhcGksIFBSSVZBVEVfTUVUSE9EUyk7XG5cbiAgICByZXR1cm4gYXBpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlcyBwbGFjZWhvbGRlcnMgaW4gZ2l2ZW4gc3RyaW5nIHdpdGggcmVwbGFjZW1lbnRzXG4gKiBAcGFyYW0gc3RyaW5nIC0gXCJGb28ge2Jhcn1cIlwiXG4gKiBAcGFyYW0gcmVwbGFjZW1lbnRzIC0geyBcImJhclwiOiAxMCB9XG4gKi9cbmNvbnN0IHJlcGxhY2VJblN0cmluZyA9IChzdHJpbmcsIHJlcGxhY2VtZW50cykgPT5cbiAgICBzdHJpbmcucmVwbGFjZSgvKD86eyhbYS16QS1aXSspfSkvZywgKG1hdGNoLCBncm91cCkgPT4gcmVwbGFjZW1lbnRzW2dyb3VwXSk7XG5cbmNvbnN0IGNyZWF0ZVdvcmtlciA9IGZuID0+IHtcbiAgICBjb25zdCB3b3JrZXJCbG9iID0gbmV3IEJsb2IoWycoJywgZm4udG9TdHJpbmcoKSwgJykoKSddLCB7XG4gICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHdvcmtlckJsb2IpO1xuICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVVJMKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zZmVyOiAobWVzc2FnZSwgY2IpID0+IHt9LFxuICAgICAgICBwb3N0OiAobWVzc2FnZSwgY2IsIHRyYW5zZmVyTGlzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBnZXRVbmlxdWVJZCgpO1xuXG4gICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJMaXN0XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICB0ZXJtaW5hdGU6ICgpID0+IHtcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwod29ya2VyVVJMKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuY29uc3QgbG9hZEltYWdlID0gdXJsID0+XG4gICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBlID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IHVybDtcbiAgICB9KTtcblxuY29uc3QgcmVuYW1lRmlsZSA9IChmaWxlLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgcmVuYW1lZEZpbGUgPSBmaWxlLnNsaWNlKDAsIGZpbGUuc2l6ZSwgZmlsZS50eXBlKTtcbiAgICByZW5hbWVkRmlsZS5sYXN0TW9kaWZpZWREYXRlID0gZmlsZS5sYXN0TW9kaWZpZWREYXRlO1xuICAgIHJlbmFtZWRGaWxlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiByZW5hbWVkRmlsZTtcbn07XG5cbmNvbnN0IGNvcHlGaWxlID0gZmlsZSA9PiByZW5hbWVGaWxlKGZpbGUsIGZpbGUubmFtZSk7XG5cbi8vIGFscmVhZHkgcmVnaXN0ZXJlZCBwbHVnaW5zIChjYW4ndCByZWdpc3RlciB0d2ljZSlcbmNvbnN0IHJlZ2lzdGVyZWRQbHVnaW5zID0gW107XG5cbi8vIHBhc3MgdXRpbHMgdG8gcGx1Z2luXG5jb25zdCBjcmVhdGVBcHBQbHVnaW4gPSBwbHVnaW4gPT4ge1xuICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuICAgIGlmIChyZWdpc3RlcmVkUGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyByZW1lbWJlciB0aGlzIHBsdWdpblxuICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcblxuICAgIC8vIHNldHVwIVxuICAgIGNvbnN0IHBsdWdpbk91dGxpbmUgPSBwbHVnaW4oe1xuICAgICAgICBhZGRGaWx0ZXIsXG4gICAgICAgIHV0aWxzOiB7XG4gICAgICAgICAgICBUeXBlLFxuICAgICAgICAgICAgZm9yaW4sXG4gICAgICAgICAgICBpc1N0cmluZyxcbiAgICAgICAgICAgIGlzRmlsZSxcbiAgICAgICAgICAgIHRvTmF0dXJhbEZpbGVTaXplLFxuICAgICAgICAgICAgcmVwbGFjZUluU3RyaW5nLFxuICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lLFxuICAgICAgICAgICAgZ2V0RmlsZW5hbWVXaXRob3V0RXh0ZW5zaW9uLFxuICAgICAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgICAgIGdldEZpbGVGcm9tQmxvYixcbiAgICAgICAgICAgIGdldEZpbGVuYW1lRnJvbVVSTCxcbiAgICAgICAgICAgIGNyZWF0ZVJvdXRlLFxuICAgICAgICAgICAgY3JlYXRlV29ya2VyLFxuICAgICAgICAgICAgY3JlYXRlVmlldyxcbiAgICAgICAgICAgIGNyZWF0ZUl0ZW1BUEksXG4gICAgICAgICAgICBsb2FkSW1hZ2UsXG4gICAgICAgICAgICBjb3B5RmlsZSxcbiAgICAgICAgICAgIHJlbmFtZUZpbGUsXG4gICAgICAgICAgICBjcmVhdGVCbG9iLFxuICAgICAgICAgICAgYXBwbHlGaWx0ZXJDaGFpbixcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICBnZXROdW1lcmljQXNwZWN0UmF0aW9Gcm9tU3RyaW5nLFxuICAgICAgICB9LFxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgZmlsZUFjdGlvbkJ1dHRvbixcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIGFkZCBwbHVnaW4gb3B0aW9ucyB0byBkZWZhdWx0IG9wdGlvbnNcbiAgICBleHRlbmREZWZhdWx0T3B0aW9ucyhwbHVnaW5PdXRsaW5lLm9wdGlvbnMpO1xufTtcblxuLy8gZmVhdHVyZSBkZXRlY3Rpb24gdXNlZCBieSBzdXBwb3J0ZWQoKSBtZXRob2RcbmNvbnN0IGlzT3BlcmFNaW5pID0gKCkgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHdpbmRvdy5vcGVyYW1pbmkpID09PSAnW29iamVjdCBPcGVyYU1pbmldJztcbmNvbnN0IGhhc1Byb21pc2VzID0gKCkgPT4gJ1Byb21pc2UnIGluIHdpbmRvdztcbmNvbnN0IGhhc0Jsb2JTbGljZSA9ICgpID0+ICdzbGljZScgaW4gQmxvYi5wcm90b3R5cGU7XG5jb25zdCBoYXNDcmVhdGVPYmplY3RVUkwgPSAoKSA9PiAnVVJMJyBpbiB3aW5kb3cgJiYgJ2NyZWF0ZU9iamVjdFVSTCcgaW4gd2luZG93LlVSTDtcbmNvbnN0IGhhc1Zpc2liaWxpdHkgPSAoKSA9PiAndmlzaWJpbGl0eVN0YXRlJyBpbiBkb2N1bWVudDtcbmNvbnN0IGhhc1RpbWluZyA9ICgpID0+ICdwZXJmb3JtYW5jZScgaW4gd2luZG93OyAvLyBpT1MgOC54XG5jb25zdCBoYXNDU1NTdXBwb3J0cyA9ICgpID0+ICdzdXBwb3J0cycgaW4gKHdpbmRvdy5DU1MgfHwge30pOyAvLyB1c2UgdG8gZGV0ZWN0IFNhZmFyaSA5K1xuY29uc3QgaXNJRTExID0gKCkgPT4gL01TSUV8VHJpZGVudC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmNvbnN0IHN1cHBvcnRlZCA9ICgoKSA9PiB7XG4gICAgLy8gUnVucyBpbW1lZGlhdGVseSBhbmQgdGhlbiByZW1lbWJlcnMgcmVzdWx0IGZvciBzdWJzZXF1ZW50IGNhbGxzXG4gICAgY29uc3QgaXNTdXBwb3J0ZWQgPVxuICAgICAgICAvLyBIYXMgdG8gYmUgYSBicm93c2VyXG4gICAgICAgIGlzQnJvd3NlcigpICYmXG4gICAgICAgIC8vIENhbid0IHJ1biBvbiBPcGVyYSBNaW5pIGR1ZSB0byBsYWNrIG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgIWlzT3BlcmFNaW5pKCkgJiZcbiAgICAgICAgLy8gUmVxdWlyZSB0aGVzZSBBUElzIHRvIGZlYXR1cmUgZGV0ZWN0IGEgbW9kZXJuIGJyb3dzZXJcbiAgICAgICAgaGFzVmlzaWJpbGl0eSgpICYmXG4gICAgICAgIGhhc1Byb21pc2VzKCkgJiZcbiAgICAgICAgaGFzQmxvYlNsaWNlKCkgJiZcbiAgICAgICAgaGFzQ3JlYXRlT2JqZWN0VVJMKCkgJiZcbiAgICAgICAgaGFzVGltaW5nKCkgJiZcbiAgICAgICAgLy8gZG9lc24ndCBuZWVkIENTU1N1cHBvcnRzIGJ1dCBpcyBhIGdvb2Qgd2F5IHRvIGRldGVjdCBTYWZhcmkgOSsgKHdlIGRvIHdhbnQgdG8gc3VwcG9ydCBJRTExIHRob3VnaClcbiAgICAgICAgKGhhc0NTU1N1cHBvcnRzKCkgfHwgaXNJRTExKCkpO1xuXG4gICAgcmV0dXJuICgpID0+IGlzU3VwcG9ydGVkO1xufSkoKTtcblxuLyoqXG4gKiBQbHVnaW4gaW50ZXJuYWwgc3RhdGUgKG92ZXIgYWxsIGluc3RhbmNlcylcbiAqL1xuY29uc3Qgc3RhdGUgPSB7XG4gICAgLy8gYWN0aXZlIGFwcCBpbnN0YW5jZXMsIHVzZWQgdG8gcmVkcmF3IHRoZSBhcHBzIGFuZCB0byBmaW5kIHRoZSBsYXRlclxuICAgIGFwcHM6IFtdLFxufTtcblxuLy8gcGx1Z2luIG5hbWVcbmNvbnN0IG5hbWUgPSAnZmlsZXBvbmQnO1xuXG4vKipcbiAqIFB1YmxpYyBQbHVnaW4gbWV0aG9kc1xuICovXG5jb25zdCBmbiA9ICgpID0+IHt9O1xubGV0IFN0YXR1cyQxID0ge307XG5sZXQgRmlsZVN0YXR1cyA9IHt9O1xubGV0IEZpbGVPcmlnaW4kMSA9IHt9O1xubGV0IE9wdGlvblR5cGVzID0ge307XG5sZXQgY3JlYXRlJGYgPSBmbjtcbmxldCBkZXN0cm95ID0gZm47XG5sZXQgcGFyc2UgPSBmbjtcbmxldCBmaW5kID0gZm47XG5sZXQgcmVnaXN0ZXJQbHVnaW4gPSBmbjtcbmxldCBnZXRPcHRpb25zJDEgPSBmbjtcbmxldCBzZXRPcHRpb25zJDEgPSBmbjtcblxuLy8gaWYgbm90IHN1cHBvcnRlZCwgbm8gQVBJXG5pZiAoc3VwcG9ydGVkKCkpIHtcbiAgICAvLyBzdGFydCBwYWludGVyIGFuZCBmaXJlIGxvYWQgZXZlbnRcbiAgICBjcmVhdGVQYWludGVyKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5hcHBzLmZvckVhY2goYXBwID0+IGFwcC5fcmVhZCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHMgPT4ge1xuICAgICAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGFwcCA9PiBhcHAuX3dyaXRlKHRzKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gZmlyZSBsb2FkZWQgZXZlbnQgc28gd2Uga25vdyB3aGVuIEZpbGVQb25kIGlzIGF2YWlsYWJsZVxuICAgIGNvbnN0IGRpc3BhdGNoID0gKCkgPT4ge1xuICAgICAgICAvLyBsZXQgb3RoZXJzIGtub3cgd2UgaGF2ZSBhcmVhIHJlYWR5XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ0ZpbGVQb25kOmxvYWRlZCcsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGU6IGNyZWF0ZSRmLFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95LFxuICAgICAgICAgICAgICAgICAgICBwYXJzZSxcbiAgICAgICAgICAgICAgICAgICAgZmluZCxcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbnM6IHNldE9wdGlvbnMkMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBjbGVhbiB1cCBldmVudFxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZGlzcGF0Y2gpO1xuICAgIH07XG5cbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgIC8vIG1vdmUgdG8gYmFjayBvZiBleGVjdXRpb24gcXVldWUsIEZpbGVQb25kIHNob3VsZCBoYXZlIGJlZW4gZXhwb3J0ZWQgYnkgdGhlblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRpc3BhdGNoKCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBkaXNwYXRjaCk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlcyB0aGUgT3B0aW9uVHlwZXMgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IG9wdGlvbnNcbiAgICBjb25zdCB1cGRhdGVPcHRpb25UeXBlcyA9ICgpID0+XG4gICAgICAgIGZvcmluKGdldE9wdGlvbnMoKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIE9wdGlvblR5cGVzW2tleV0gPSB2YWx1ZVsxXTtcbiAgICAgICAgfSk7XG5cbiAgICBTdGF0dXMkMSA9IHsgLi4uU3RhdHVzIH07XG4gICAgRmlsZU9yaWdpbiQxID0geyAuLi5GaWxlT3JpZ2luIH07XG4gICAgRmlsZVN0YXR1cyA9IHsgLi4uSXRlbVN0YXR1cyB9O1xuXG4gICAgT3B0aW9uVHlwZXMgPSB7fTtcbiAgICB1cGRhdGVPcHRpb25UeXBlcygpO1xuXG4gICAgLy8gY3JlYXRlIG1ldGhvZCwgY3JlYXRlcyBhcHBzIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGFwcCBhcnJheVxuICAgIGNyZWF0ZSRmID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgYXBwID0gY3JlYXRlQXBwJDEoLi4uYXJncyk7XG4gICAgICAgIGFwcC5vbignZGVzdHJveScsIGRlc3Ryb3kpO1xuICAgICAgICBzdGF0ZS5hcHBzLnB1c2goYXBwKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFwcEFQSShhcHApO1xuICAgIH07XG5cbiAgICAvLyBkZXN0cm95cyBhcHBzIGFuZCByZW1vdmVzIHRoZW0gZnJvbSB0aGUgYXBwIGFycmF5XG4gICAgZGVzdHJveSA9IGhvb2sgPT4ge1xuICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgdGhlIGFwcCB3YXMgZGVzdHJveWVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBjb25zdCBpbmRleFRvUmVtb3ZlID0gc3RhdGUuYXBwcy5maW5kSW5kZXgoYXBwID0+IGFwcC5pc0F0dGFjaGVkVG8oaG9vaykpO1xuICAgICAgICBpZiAoaW5kZXhUb1JlbW92ZSA+PSAwKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSBhcHBzXG4gICAgICAgICAgICBjb25zdCBhcHAgPSBzdGF0ZS5hcHBzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKVswXTtcblxuICAgICAgICAgICAgLy8gcmVzdG9yZSBvcmlnaW5hbCBkb20gZWxlbWVudFxuICAgICAgICAgICAgYXBwLnJlc3RvcmVFbGVtZW50KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBwYXJzZXMgdGhlIGdpdmVuIGNvbnRleHQgZm9yIHBsdWdpbnMgKGRvZXMgbm90IGluY2x1ZGUgdGhlIGNvbnRleHQgZWxlbWVudCBpdHNlbGYpXG4gICAgcGFyc2UgPSBjb250ZXh0ID0+IHtcbiAgICAgICAgLy8gZ2V0IGFsbCBwb3NzaWJsZSBob29rc1xuICAgICAgICBjb25zdCBtYXRjaGVkSG9va3MgPSBBcnJheS5mcm9tKGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChgLiR7bmFtZX1gKSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBhbHJlYWR5IGFjdGl2ZSBob29rc1xuICAgICAgICBjb25zdCBuZXdIb29rcyA9IG1hdGNoZWRIb29rcy5maWx0ZXIoXG4gICAgICAgICAgICBuZXdIb29rID0+ICFzdGF0ZS5hcHBzLmZpbmQoYXBwID0+IGFwcC5pc0F0dGFjaGVkVG8obmV3SG9vaykpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBpbnN0YW5jZSBmb3IgZWFjaCBob29rXG4gICAgICAgIHJldHVybiBuZXdIb29rcy5tYXAoaG9vayA9PiBjcmVhdGUkZihob29rKSk7XG4gICAgfTtcblxuICAgIC8vIHJldHVybnMgYW4gYXBwIGJhc2VkIG9uIHRoZSBnaXZlbiBlbGVtZW50IGhvb2tcbiAgICBmaW5kID0gaG9vayA9PiB7XG4gICAgICAgIGNvbnN0IGFwcCA9IHN0YXRlLmFwcHMuZmluZChhcHAgPT4gYXBwLmlzQXR0YWNoZWRUbyhob29rKSk7XG4gICAgICAgIGlmICghYXBwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQXBwQVBJKGFwcCk7XG4gICAgfTtcblxuICAgIC8vIGFkZHMgYSBwbHVnaW4gZXh0ZW5zaW9uXG4gICAgcmVnaXN0ZXJQbHVnaW4gPSAoLi4ucGx1Z2lucykgPT4ge1xuICAgICAgICAvLyByZWdpc3RlciBwbHVnaW5zXG4gICAgICAgIHBsdWdpbnMuZm9yRWFjaChjcmVhdGVBcHBQbHVnaW4pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBPcHRpb25UeXBlcywgZWFjaCBwbHVnaW4gbWlnaHQgaGF2ZSBleHRlbmRlZCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgICAgIHVwZGF0ZU9wdGlvblR5cGVzKCk7XG4gICAgfTtcblxuICAgIGdldE9wdGlvbnMkMSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICBmb3JpbihnZXRPcHRpb25zKCksIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBvcHRzW2tleV0gPSB2YWx1ZVswXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH07XG5cbiAgICBzZXRPcHRpb25zJDEgPSBvcHRzID0+IHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdHMpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgZXhpc3RpbmcgcGx1Z2luc1xuICAgICAgICAgICAgc3RhdGUuYXBwcy5mb3JFYWNoKGFwcCA9PiB7XG4gICAgICAgICAgICAgICAgYXBwLnNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgZGVmYXVsdHNcbiAgICAgICAgICAgIHNldE9wdGlvbnMob3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gbmV3IG9wdGlvbnNcbiAgICAgICAgcmV0dXJuIGdldE9wdGlvbnMkMSgpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7XG4gICAgRmlsZU9yaWdpbiQxIGFzIEZpbGVPcmlnaW4sXG4gICAgRmlsZVN0YXR1cyxcbiAgICBPcHRpb25UeXBlcyxcbiAgICBTdGF0dXMkMSBhcyBTdGF0dXMsXG4gICAgY3JlYXRlJGYgYXMgY3JlYXRlLFxuICAgIGRlc3Ryb3ksXG4gICAgZmluZCxcbiAgICBnZXRPcHRpb25zJDEgYXMgZ2V0T3B0aW9ucyxcbiAgICBwYXJzZSxcbiAgICByZWdpc3RlclBsdWdpbixcbiAgICBzZXRPcHRpb25zJDEgYXMgc2V0T3B0aW9ucyxcbiAgICBzdXBwb3J0ZWQsXG59O1xuIl0sIm5hbWVzIjpbImlzTm9kZSIsInZhbHVlIiwiSFRNTEVsZW1lbnQiLCJjcmVhdGVTdG9yZSIsImluaXRpYWxTdGF0ZSIsInF1ZXJpZXMiLCJhY3Rpb25zIiwic3RhdGUiLCJhY3Rpb25RdWV1ZSIsImRpc3BhdGNoUXVldWUiLCJnZXRTdGF0ZSIsInByb2Nlc3NBY3Rpb25RdWV1ZSIsInF1ZXVlIiwibGVuZ3RoIiwicHJvY2Vzc0Rpc3BhdGNoUXVldWUiLCJmb3JFYWNoIiwidHlwZSIsImRhdGEiLCJkaXNwYXRjaCIsImlzQmxvY2tpbmciLCJkb2N1bWVudCIsImhpZGRlbiIsInB1c2giLCJhY3Rpb25IYW5kbGVycyIsInF1ZXJ5Iiwic3RyIiwiYXJncyIsInF1ZXJ5SGFuZGxlcyIsImFwaSIsImFjdGlvbiIsImRlZmluZVByb3BlcnR5Iiwib2JqIiwicHJvcGVydHkiLCJkZWZpbml0aW9uIiwiT2JqZWN0IiwiZm9yaW4iLCJjYiIsImtleSIsImhhc093blByb3BlcnR5IiwiY3JlYXRlT2JqZWN0IiwiYXR0ciIsIm5vZGUiLCJuYW1lIiwiZ2V0QXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwibnMiLCJzdmdFbGVtZW50cyIsImlzU1ZHRWxlbWVudCIsInRhZyIsImluY2x1ZGVzIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImF0dHJpYnV0ZXMiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnQiLCJjaGlsZCIsImluZGV4IiwiY2hpbGRyZW4iLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZFZpZXciLCJjaGlsZFZpZXdzIiwidmlldyIsInNwbGljZSIsInJlbW92ZUNoaWxkVmlldyIsImluZGV4T2YiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJJU19CUk9XU0VSIiwid2luZG93IiwiaXNCcm93c2VyIiwidGVzdEVsZW1lbnQiLCJnZXRDaGlsZENvdW50IiwiZWwiLCJjaGlsZE5vZGVzIiwiZ2V0Vmlld1JlY3QiLCJlbGVtZW50UmVjdCIsIm9mZnNldCIsInNjYWxlIiwibGVmdCIsInRvcCIsInJpZ2h0Iiwid2lkdGgiLCJib3R0b20iLCJoZWlnaHQiLCJyZWN0IiwiaW5uZXIiLCJvdXRlciIsImZpbHRlciIsImNoaWxkVmlldyIsImlzUmVjdElnbm9yZWQiLCJtYXAiLCJjaGlsZFZpZXdSZWN0IiwiZXhwYW5kUmVjdCIsImNhbGN1bGF0ZVJlY3RTaXplIiwibWFyZ2luQm90dG9tIiwibWFyZ2luUmlnaHQiLCJpc051bWJlciIsInRoZXJlWWV0IiwicG9zaXRpb24iLCJkZXN0aW5hdGlvbiIsInZlbG9jaXR5IiwiZXJyb3JNYXJnaW4iLCJNYXRoIiwiYWJzIiwic3ByaW5nIiwic3RpZmZuZXNzIiwiZGFtcGluZyIsIm1hc3MiLCJ0YXJnZXQiLCJyZXN0aW5nIiwiaW50ZXJwb2xhdGUiLCJ0cyIsInNraXBUb0VuZFN0YXRlIiwiZiIsIm9udXBkYXRlIiwib25jb21wbGV0ZSIsInNldFRhcmdldCIsInNldCIsImdldCIsImVhc2VMaW5lYXIiLCJ0IiwiZWFzZUluT3V0UXVhZCIsInR3ZWVuIiwiZHVyYXRpb24iLCJlYXNpbmciLCJkZWxheSIsInN0YXJ0IiwicCIsInJldmVyc2UiLCJhbmltYXRvciIsImNyZWF0ZUFuaW1hdG9yIiwiY2F0ZWdvcnkiLCJkZWYiLCJwcm9wcyIsImFkZEdldFNldCIsImtleXMiLCJvdmVyd3JpdGUiLCJBcnJheSIsImlzQXJyYXkiLCJvIiwiZ2V0dGVyIiwic2V0dGVyIiwiYW5pbWF0aW9ucyIsIm1peGluQ29uZmlnIiwidmlld1Byb3BzIiwidmlld0ludGVybmFsQVBJIiwidmlld0V4dGVybmFsQVBJIiwiaW5pdGlhbFByb3BzIiwiYW5pbWF0aW9uIiwicHJvcCIsIndyaXRlIiwiZGVzdHJveSIsImFkZEV2ZW50IiwiZm4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGlzdGVuZXJzIiwidmlld1N0YXRlIiwiZXZlbnRzIiwiYWRkIiwicmVtb3ZlIiwib24iLCJvZmYiLCJmaW5kSW5kZXgiLCJldmVudCIsImFwaXMiLCJpc0RlZmluZWQiLCJkZWZhdWx0cyIsIm9wYWNpdHkiLCJzY2FsZVgiLCJzY2FsZVkiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsIm9yaWdpblgiLCJvcmlnaW5ZIiwic3R5bGVzIiwiY3VycmVudFByb3BzIiwiZ2V0T2Zmc2V0IiwiZ2V0U2NhbGUiLCJnZXRSZWN0IiwicHJvcHNIYXZlQ2hhbmdlZCIsImFwcGx5U3R5bGVzIiwiYXNzaWduIiwibmV3UHJvcHMiLCJwZXJzcGVjdGl2ZSIsInRyYW5zZm9ybXMiLCJlbGVtZW50Q3VycmVudFN0eWxlIiwic3R5bGUiLCJjc3NUZXh0IiwiTWl4aW5zIiwidXBkYXRlUmVjdCIsImxheW91dENhbGN1bGF0ZWQiLCJwYWRkaW5nVG9wIiwicGFyc2VJbnQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0Iiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsVG9wIiwib2Zmc2V0UGFyZW50IiwiY3JlYXRlVmlldyIsInJlYWQiLCJjcmVhdGUiLCJmaWx0ZXJGcmFtZUFjdGlvbnNGb3JDaGlsZCIsImRpZENyZWF0ZVZpZXciLCJkaWRXcml0ZVZpZXciLCJpZ25vcmVSZWN0IiwiaWdub3JlUmVjdFVwZGF0ZSIsIm1peGlucyIsInN0b3JlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImZyYW1lUmVjdCIsImlzUmVzdGluZyIsImFjdGl2ZU1peGlucyIsInJlZiIsIndyaXRlcnMiLCJyZWFkZXJzIiwiZGVzdHJveWVycyIsImdldEVsZW1lbnQiLCJnZXRDaGlsZFZpZXdzIiwiY29uY2F0IiwiZ2V0UmVmZXJlbmNlIiwiY3JlYXRlQ2hpbGRWaWV3IiwiZ2V0U3R5bGUiLCJfcmVhZCIsInNob3VsZFVwZGF0ZSIsInJvb3QiLCJpbnRlcm5hbEFQSSIsInJlYWRlciIsIl93cml0ZSIsImZyYW1lQWN0aW9ucyIsInNob3VsZE9wdGltaXplIiwid3JpdGVyIiwid3JpdGVyUmVzdGluZyIsInRpbWVzdGFtcCIsIm1peGluIiwibWl4aW5SZXN0aW5nIiwiY2hpbGRSZXN0aW5nIiwiX2Rlc3Ryb3kiLCJkZXN0cm95ZXIiLCJzaGFyZWRBUElEZWZpbml0aW9uIiwiaW50ZXJuYWxBUElEZWZpbml0aW9uIiwiaXMiLCJuZWVkbGUiLCJsaW5rVmlldyIsInVubGlua1ZpZXciLCJyZWdpc3RlcldyaXRlciIsInJlZ2lzdGVyUmVhZGVyIiwicmVnaXN0ZXJEZXN0cm95ZXIiLCJpbnZhbGlkYXRlTGF5b3V0IiwiZXh0ZXJuYWxBUElEZWZpbml0aW9uIiwibWl4aW5BUElEZWZpbml0aW9uIiwic29ydCIsImEiLCJiIiwibWl4aW5BUEkiLCJjaGlsZENvdW50IiwiY3JlYXRlUGFpbnRlciIsImZwcyIsInBhaW50ZXIiLCJpbnRlcnZhbCIsImxhc3QiLCJpZCIsInJlcXVlc3RUaWNrIiwiY2FuY2VsVGljayIsInNldFRpbWVyVHlwZSIsInNldFRpbWVvdXQiLCJ0aWNrIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImRlbHRhIiwicGF1c2UiLCJjcmVhdGVSb3V0ZSIsInJvdXRlcyIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwiaW5zZXJ0QWZ0ZXIiLCJuZXh0U2libGluZyIsImlzRW1wdHkiLCJ0cmltIiwidG9TdHJpbmciLCJ0b0FycmF5Iiwic3BsaXR0ZXIiLCJzcGxpdCIsImlzQm9vbGVhbiIsInRvQm9vbGVhbiIsImlzU3RyaW5nIiwidG9OdW1iZXIiLCJyZXBsYWNlIiwidG9JbnQiLCJ0b0Zsb2F0IiwicGFyc2VGbG9hdCIsImlzSW50IiwiaXNGaW5pdGUiLCJmbG9vciIsInRvQnl0ZXMiLCJiYXNlIiwibmF0dXJhbEZpbGVTaXplIiwidGVzdCIsImlzRnVuY3Rpb24iLCJ0b0Z1bmN0aW9uUmVmZXJlbmNlIiwic3RyaW5nIiwic2VsZiIsImxldmVscyIsImxldmVsIiwic2hpZnQiLCJtZXRob2RzIiwicHJvY2VzcyIsInBhdGNoIiwicmV2ZXJ0IiwiZmV0Y2giLCJyZXN0b3JlIiwibG9hZCIsImNyZWF0ZVNlcnZlckFQSSIsIm91dGxpbmUiLCJ1cmwiLCJ0aW1lb3V0IiwiaGVhZGVycyIsImNyZWF0ZUFjdGlvbiIsIm1ldGhvZCIsIndpdGhDcmVkZW50aWFscyIsIm9ubG9hZCIsIm9uZGF0YSIsIm9uZXJyb3IiLCJwYXJ0cyIsImhlYWRlciIsInRvU2VydmVyQVBJIiwiaXNOdWxsIiwiaXNPYmplY3QiLCJpc0FQSSIsImdldFR5cGUiLCJyZXBsYWNlU2luZ2xlUXVvdGVzIiwiY29udmVyc2lvblRhYmxlIiwiYXJyYXkiLCJib29sZWFuIiwiaW50IiwibnVtYmVyIiwiZmxvYXQiLCJieXRlcyIsImZ1bmN0aW9uIiwic2VydmVyYXBpIiwib2JqZWN0IiwiSlNPTiIsInBhcnNlIiwiZSIsImNvbnZlcnRUbyIsImdldFZhbHVlQnlUeXBlIiwibmV3VmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZVR5cGUiLCJuZXdWYWx1ZVR5cGUiLCJjb252ZXJ0ZWRWYWx1ZSIsIm9wdGlvbiIsImNyZWF0ZU9wdGlvbiIsImN1cnJlbnRWYWx1ZSIsImVudW1lcmFibGUiLCJjcmVhdGVPcHRpb25zIiwib3B0aW9ucyIsIm9wdGlvbkRlZmluaXRpb24iLCJjcmVhdGVJbml0aWFsU3RhdGUiLCJpdGVtcyIsImxpc3RVcGRhdGVUaW1lb3V0IiwiaXRlbVVwZGF0ZVRpbWVvdXQiLCJwcm9jZXNzaW5nUXVldWUiLCJmcm9tQ2FtZWxzIiwic2VwYXJhdG9yIiwicGFydCIsInRvTG93ZXJDYXNlIiwiam9pbiIsImNyZWF0ZU9wdGlvbkFQSSIsInRvVXBwZXJDYXNlIiwiY3JlYXRlT3B0aW9uQWN0aW9ucyIsImNyZWF0ZU9wdGlvblF1ZXJpZXMiLCJJbnRlcmFjdGlvbk1ldGhvZCIsIkFQSSIsIkRST1AiLCJCUk9XU0UiLCJQQVNURSIsIk5PTkUiLCJnZXRVbmlxdWVJZCIsInJhbmRvbSIsInN1YnN0cmluZyIsImFycmF5UmVtb3ZlIiwiYXJyIiwicnVuIiwic3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImxpc3RlbmVyIiwiZmlyZSIsImZpcmVTeW5jIiwib25PbmNlIiwiY29weU9iamVjdFByb3BlcnRpZXNUb09iamVjdCIsInNyYyIsImV4Y2x1ZGVkIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlBSSVZBVEUiLCJjcmVhdGVJdGVtQVBJIiwiaXRlbSIsInJlbW92ZVJlbGVhc2VkSXRlbXMiLCJyZWxlYXNlZCIsIkl0ZW1TdGF0dXMiLCJJTklUIiwiSURMRSIsIlBST0NFU1NJTkdfUVVFVUVEIiwiUFJPQ0VTU0lORyIsIlBST0NFU1NJTkdfQ09NUExFVEUiLCJQUk9DRVNTSU5HX0VSUk9SIiwiUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IiLCJMT0FESU5HIiwiTE9BRF9FUlJPUiIsIkZpbGVPcmlnaW4iLCJJTlBVVCIsIkxJTUJPIiwiTE9DQUwiLCJnZXROb25OdW1lcmljIiwiZXhlYyIsImdldERlY2ltYWxTZXBhcmF0b3IiLCJ0b0xvY2FsZVN0cmluZyIsImdldFRob3VzYW5kc1NlcGFyYXRvciIsImRlY2ltYWxTZXBhcmF0b3IiLCJ0aG91c2FuZHNTdHJpbmdXaXRoU2VwYXJhdG9yIiwidGhvdXNhbmRzU3RyaW5nV2l0aG91dFNlcGFyYXRvciIsIlR5cGUiLCJCT09MRUFOIiwiSU5UIiwiTlVNQkVSIiwiU1RSSU5HIiwiQVJSQVkiLCJPQkpFQ1QiLCJGVU5DVElPTiIsIkFDVElPTiIsIlNFUlZFUl9BUEkiLCJSRUdFWCIsImZpbHRlcnMiLCJhcHBseUZpbHRlckNoYWluIiwidXRpbHMiLCJyZWplY3QiLCJtYXRjaGluZ0ZpbHRlcnMiLCJpbml0aWFsRmlsdGVyIiwicmVkdWNlIiwiY3VycmVudCIsIm5leHQiLCJjYXRjaCIsImVycm9yIiwiYXBwbHlGaWx0ZXJzIiwiYWRkRmlsdGVyIiwiZXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJhZGRpdGlvbmFsT3B0aW9ucyIsImRlZmF1bHRPcHRpb25zIiwiZ2V0T3B0aW9ucyIsInNldE9wdGlvbnMiLCJvcHRzIiwiZGlzYWJsZWQiLCJyZXF1aXJlZCIsImNhcHR1cmVNZXRob2QiLCJhbGxvd1N5bmNBY2NlcHRBdHRyaWJ1dGUiLCJhbGxvd0Ryb3AiLCJhbGxvd0Jyb3dzZSIsImFsbG93UGFzdGUiLCJhbGxvd011bHRpcGxlIiwiYWxsb3dSZXBsYWNlIiwiYWxsb3dSZXZlcnQiLCJhbGxvd1JlbW92ZSIsImFsbG93UHJvY2VzcyIsImFsbG93UmVvcmRlciIsImFsbG93RGlyZWN0b3JpZXNPbmx5Iiwic3RvcmVBc0ZpbGUiLCJmb3JjZVJldmVydCIsIm1heEZpbGVzIiwiY2hlY2tWYWxpZGl0eSIsIml0ZW1JbnNlcnRMb2NhdGlvbkZyZWVkb20iLCJpdGVtSW5zZXJ0TG9jYXRpb24iLCJpdGVtSW5zZXJ0SW50ZXJ2YWwiLCJkcm9wT25QYWdlIiwiZHJvcE9uRWxlbWVudCIsImRyb3BWYWxpZGF0aW9uIiwiaWdub3JlZEZpbGVzIiwiaW5zdGFudFVwbG9hZCIsIm1heFBhcmFsbGVsVXBsb2FkcyIsImFsbG93TWluaW11bVVwbG9hZER1cmF0aW9uIiwiY2h1bmtVcGxvYWRzIiwiY2h1bmtGb3JjZSIsImNodW5rU2l6ZSIsImNodW5rUmV0cnlEZWxheXMiLCJzZXJ2ZXIiLCJmaWxlU2l6ZUJhc2UiLCJsYWJlbEZpbGVTaXplQnl0ZXMiLCJsYWJlbEZpbGVTaXplS2lsb2J5dGVzIiwibGFiZWxGaWxlU2l6ZU1lZ2FieXRlcyIsImxhYmVsRmlsZVNpemVHaWdhYnl0ZXMiLCJsYWJlbERlY2ltYWxTZXBhcmF0b3IiLCJsYWJlbFRob3VzYW5kc1NlcGFyYXRvciIsImxhYmVsSWRsZSIsImxhYmVsSW52YWxpZEZpZWxkIiwibGFiZWxGaWxlV2FpdGluZ0ZvclNpemUiLCJsYWJlbEZpbGVTaXplTm90QXZhaWxhYmxlIiwibGFiZWxGaWxlQ291bnRTaW5ndWxhciIsImxhYmVsRmlsZUNvdW50UGx1cmFsIiwibGFiZWxGaWxlTG9hZGluZyIsImxhYmVsRmlsZUFkZGVkIiwibGFiZWxGaWxlTG9hZEVycm9yIiwibGFiZWxGaWxlUmVtb3ZlZCIsImxhYmVsRmlsZVJlbW92ZUVycm9yIiwibGFiZWxGaWxlUHJvY2Vzc2luZyIsImxhYmVsRmlsZVByb2Nlc3NpbmdDb21wbGV0ZSIsImxhYmVsRmlsZVByb2Nlc3NpbmdBYm9ydGVkIiwibGFiZWxGaWxlUHJvY2Vzc2luZ0Vycm9yIiwibGFiZWxGaWxlUHJvY2Vzc2luZ1JldmVydEVycm9yIiwibGFiZWxUYXBUb0NhbmNlbCIsImxhYmVsVGFwVG9SZXRyeSIsImxhYmVsVGFwVG9VbmRvIiwibGFiZWxCdXR0b25SZW1vdmVJdGVtIiwibGFiZWxCdXR0b25BYm9ydEl0ZW1Mb2FkIiwibGFiZWxCdXR0b25SZXRyeUl0ZW1Mb2FkIiwibGFiZWxCdXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nIiwibGFiZWxCdXR0b25VbmRvSXRlbVByb2Nlc3NpbmciLCJsYWJlbEJ1dHRvblJldHJ5SXRlbVByb2Nlc3NpbmciLCJsYWJlbEJ1dHRvblByb2Nlc3NJdGVtIiwiaWNvblJlbW92ZSIsImljb25Qcm9jZXNzIiwiaWNvblJldHJ5IiwiaWNvblVuZG8iLCJpY29uRG9uZSIsIm9uaW5pdCIsIm9ud2FybmluZyIsIm9uYWN0aXZhdGVmaWxlIiwib25pbml0ZmlsZSIsIm9uYWRkZmlsZXN0YXJ0Iiwib25hZGRmaWxlcHJvZ3Jlc3MiLCJvbmFkZGZpbGUiLCJvbnByb2Nlc3NmaWxlc3RhcnQiLCJvbnByb2Nlc3NmaWxlcHJvZ3Jlc3MiLCJvbnByb2Nlc3NmaWxlYWJvcnQiLCJvbnByb2Nlc3NmaWxlcmV2ZXJ0Iiwib25wcm9jZXNzZmlsZSIsIm9ucHJvY2Vzc2ZpbGVzIiwib25yZW1vdmVmaWxlIiwib25wcmVwYXJlZmlsZSIsIm9udXBkYXRlZmlsZXMiLCJvbnJlb3JkZXJmaWxlcyIsImJlZm9yZURyb3BGaWxlIiwiYmVmb3JlQWRkRmlsZSIsImJlZm9yZVJlbW92ZUZpbGUiLCJiZWZvcmVQcmVwYXJlRmlsZSIsInN0eWxlUGFuZWxMYXlvdXQiLCJzdHlsZVBhbmVsQXNwZWN0UmF0aW8iLCJzdHlsZUl0ZW1QYW5lbEFzcGVjdFJhdGlvIiwic3R5bGVCdXR0b25SZW1vdmVJdGVtUG9zaXRpb24iLCJzdHlsZUJ1dHRvblByb2Nlc3NJdGVtUG9zaXRpb24iLCJzdHlsZUxvYWRJbmRpY2F0b3JQb3NpdGlvbiIsInN0eWxlUHJvZ3Jlc3NJbmRpY2F0b3JQb3NpdGlvbiIsInN0eWxlQnV0dG9uUmVtb3ZlSXRlbUFsaWduIiwiZmlsZXMiLCJjcmVkaXRzIiwiZ2V0SXRlbUJ5UXVlcnkiLCJmaW5kIiwiZ2V0TnVtZXJpY0FzcGVjdFJhdGlvRnJvbVN0cmluZyIsImFzcGVjdFJhdGlvIiwiZ2V0QWN0aXZlSXRlbXMiLCJhcmNoaXZlZCIsIlN0YXR1cyIsIkVNUFRZIiwiRVJST1IiLCJCVVNZIiwiUkVBRFkiLCJyZXMiLCJjYW5VcGRhdGVGaWxlSW5wdXQiLCJkYXRhVHJhbnNmZXIiLCJEYXRhVHJhbnNmZXIiLCJGaWxlIiwiZXJyIiwiSVRFTV9FUlJPUiIsIklURU1fQlVTWSIsIklURU1fUkVBRFkiLCJpc0l0ZW1JbkVycm9yU3RhdGUiLCJzdGF0dXMiLCJpc0l0ZW1JbkJ1c3lTdGF0ZSIsImlzSXRlbUluUmVhZHlTdGF0ZSIsImlzQXN5bmMiLCJHRVRfU1RBVFVTIiwic29tZSIsIkdFVF9JVEVNIiwiR0VUX0FDVElWRV9JVEVNIiwiR0VUX0FDVElWRV9JVEVNUyIsIkdFVF9JVEVNUyIsIkdFVF9JVEVNX05BTUUiLCJmaWxlbmFtZSIsIkdFVF9JVEVNX1NJWkUiLCJmaWxlU2l6ZSIsIkdFVF9TVFlMRVMiLCJHRVRfUEFORUxfQVNQRUNUX1JBVElPIiwiaXNTaGFwZUNpcmNsZSIsIkdFVF9JVEVNX1BBTkVMX0FTUEVDVF9SQVRJTyIsIkdFVF9JVEVNU19CWV9TVEFUVVMiLCJHRVRfVE9UQUxfSVRFTVMiLCJTSE9VTERfVVBEQVRFX0ZJTEVfSU5QVVQiLCJJU19BU1lOQyIsIkdFVF9GSUxFX1NJWkVfTEFCRUxTIiwibGFiZWxCeXRlcyIsInVuZGVmaW5lZCIsImxhYmVsS2lsb2J5dGVzIiwibGFiZWxNZWdhYnl0ZXMiLCJsYWJlbEdpZ2FieXRlcyIsImhhc1Jvb21Gb3JJdGVtIiwiY291bnQiLCJtYXhGaWxlQ291bnQiLCJsaW1pdCIsIm1pbiIsIm1heCIsImFycmF5SW5zZXJ0IiwiaW5zZXJ0SXRlbSIsImlzQmFzZTY0RGF0YVVSSSIsImdldEZpbGVuYW1lRnJvbVVSTCIsInBvcCIsImdldEV4dGVuc2lvbkZyb21GaWxlbmFtZSIsImd1ZXNzdGltYXRlRXh0ZW5zaW9uIiwic3VidHlwZSIsImxlZnRQYWQiLCJwYWRkaW5nIiwic2xpY2UiLCJnZXREYXRlU3RyaW5nIiwiZGF0ZSIsIkRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRGaWxlRnJvbUJsb2IiLCJibG9iIiwiZXh0ZW5zaW9uIiwiZmlsZSIsInNpemUiLCJsYXN0TW9kaWZpZWREYXRlIiwiX3JlbGF0aXZlUGF0aCIsImdldEJsb2JCdWlsZGVyIiwiQmxvYkJ1aWxkZXIiLCJXZWJLaXRCbG9iQnVpbGRlciIsIk1vekJsb2JCdWlsZGVyIiwiTVNCbG9iQnVpbGRlciIsImNyZWF0ZUJsb2IiLCJhcnJheUJ1ZmZlciIsIm1pbWVUeXBlIiwiQkIiLCJiYiIsImFwcGVuZCIsImdldEJsb2IiLCJCbG9iIiwiZ2V0QmxvYkZyb21CeXRlU3RyaW5nV2l0aE1pbWVUeXBlIiwiYnl0ZVN0cmluZyIsImFiIiwiQXJyYXlCdWZmZXIiLCJpYSIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImdldE1pbWVUeXBlRnJvbUJhc2U2NERhdGFVUkkiLCJkYXRhVVJJIiwiZ2V0QmFzZTY0RGF0YUZyb21CYXNlNjREYXRhVVJJIiwiZ2V0Qnl0ZVN0cmluZ0Zyb21CYXNlNjREYXRhVVJJIiwiYXRvYiIsImdldEJsb2JGcm9tQmFzZTY0RGF0YVVSSSIsImdldEZpbGVGcm9tQmFzZTY0RGF0YVVSSSIsImdldEZpbGVOYW1lRnJvbUhlYWRlciIsIm1hdGNoZXMiLCJkZWNvZGVVUkkiLCJnZXRGaWxlU2l6ZUZyb21IZWFkZXIiLCJtYXRjaCIsImdldFRyYW5mc2VySWRGcm9tSGVhZGVyIiwiZ2V0RmlsZUluZm9Gcm9tSGVhZGVycyIsImluZm8iLCJzb3VyY2UiLCJyb3dzIiwiY3JlYXRlRmlsZUxvYWRlciIsImZldGNoRm4iLCJjb21wbGV0ZSIsInByb2dyZXNzIiwicmVxdWVzdCIsImdldFByb2dyZXNzIiwiYWJvcnQiLCJsb2FkVVJMIiwiYm9keSIsImNvZGUiLCJyZXNwb25zZSIsImNvbXB1dGFibGUiLCJ0b3RhbCIsImZpbGVpbmZvIiwic2V0U291cmNlIiwiaXNHZXQiLCJzZW5kUmVxdWVzdCIsIm9uaGVhZGVycyIsIm9ucHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJvbmFib3J0IiwiYWJvcnRlZCIsInhociIsImhlYWRlcnNSZWNlaXZlZCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeSIsIlhNTEh0dHBSZXF1ZXN0IiwidXBsb2FkIiwibGVuZ3RoQ29tcHV0YWJsZSIsImxvYWRlZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJvcGVuIiwidW5lc2NhcGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVzcG9uc2VUeXBlIiwic2VuZCIsImNyZWF0ZVJlc3BvbnNlIiwiY3JlYXRlVGltZW91dFJlc3BvbnNlIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiaGFzUVMiLCJidWlsZFVSTCIsImNyZWF0ZUZldGNoRnVuY3Rpb24iLCJhcGlVcmwiLCJzdGF0dXNUZXh0IiwiQ2h1bmtTdGF0dXMiLCJRVUVVRUQiLCJDT01QTEVURSIsIldBSVRJTkciLCJwcm9jZXNzRmlsZUNodW5rZWQiLCJtZXRhZGF0YSIsInRyYW5zZmVyIiwiY2h1bmtzIiwiY2h1bmtUcmFuc2ZlcklkIiwiY2h1bmtTZXJ2ZXIiLCJzZXJ2ZXJJZCIsImZkIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJyZXF1ZXN0VHJhbnNmZXJJZCIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJyZXF1ZXN0UGFyYW1zIiwicmVxdWVzdFRyYW5zZmVyT2Zmc2V0IiwicmVxdWVzdFVybCIsImxhc3RDaHVua0luZGV4IiwicmV0cmllcyIsImNvbXBsZXRlUHJvY2Vzc2luZ0NodW5rcyIsImNhblByb2Nlc3NDaHVuayIsImNodW5rIiwicHJvY2Vzc0NodW5rIiwiZXZlcnkiLCJwcm9jZXNzQ2h1bmtzIiwidXBkYXRlVG90YWxQcm9ncmVzcyIsInJldHJ5UHJvY2Vzc0NodW5rIiwidG90YWxCeXRlc1RyYW5zZmVyZWQiLCJ0b3RhbFNpemUiLCJ0b3RhbFByb2Nlc3NpbmciLCJhYm9ydENodW5rcyIsImNyZWF0ZUZpbGVQcm9jZXNzb3JGdW5jdGlvbiIsImNhbkNodW5rVXBsb2FkIiwic2hvdWxkQ2h1bmtVcGxvYWQiLCJ3aWxsQ2h1bmtVcGxvYWQiLCJjcmVhdGVQcm9jZXNzb3JGdW5jdGlvbiIsInBhcmFtcyIsImNyZWF0ZVJldmVydEZ1bmN0aW9uIiwidW5pcXVlRmlsZUlkIiwiZ2V0UmFuZG9tTnVtYmVyIiwiY3JlYXRlUGVyY2VpdmVkUGVyZm9ybWFuY2VVcGRhdGVyIiwidGlja01pbiIsInRpY2tNYXgiLCJydW50aW1lIiwiY2xlYXIiLCJjcmVhdGVGaWxlUHJvY2Vzc29yIiwicHJvY2Vzc0ZuIiwicGVyY2VpdmVkUHJvZ3Jlc3MiLCJwZXJjZWl2ZWRQZXJmb3JtYW5jZVVwZGF0ZXIiLCJwZXJjZWl2ZWREdXJhdGlvbiIsInByb2dyZXNzRm4iLCJjb21wbGV0ZUZuIiwidHJhbnNmZXJJZCIsInJlc2V0IiwiZ2V0RHVyYXRpb24iLCJnZXRGaWxlbmFtZVdpdGhvdXRFeHRlbnNpb24iLCJsYXN0SW5kZXhPZiIsImNyZWF0ZUZpbGVTdHViIiwiaXNGaWxlIiwiZGVlcENsb25lT2JqZWN0IiwidiIsImNyZWF0ZUl0ZW0iLCJvcmlnaW4iLCJzZXJ2ZXJGaWxlUmVmZXJlbmNlIiwiZnJvemVuIiwicHJvY2Vzc2luZ0Fib3J0ZWQiLCJhY3RpdmVMb2FkZXIiLCJhY3RpdmVQcm9jZXNzb3IiLCJhYm9ydFByb2Nlc3NpbmdSZXF1ZXN0Q29tcGxldGUiLCJzZXRTdGF0dXMiLCJnZXRGaWxlRXh0ZW5zaW9uIiwiZ2V0RmlsZVR5cGUiLCJnZXRGaWxlU2l6ZSIsImdldEZpbGUiLCJsb2FkZXIiLCJtZXRhIiwic3VjY2VzcyIsInJlc3VsdCIsInJldHJ5TG9hZCIsImFib3J0TG9hZCIsInByb2Nlc3NvciIsIm9ucHJvY2VzcyIsImNvbnNvbGUiLCJyZXF1ZXN0UHJvY2Vzc2luZyIsImFib3J0UHJvY2Vzc2luZyIsInJldmVydEZpbGVVcGxvYWQiLCJzZXJ2ZXJUcmFuc2ZlcklkIiwic2V0TWV0YWRhdGEiLCJzaWxlbnQiLCJnZXRNZXRhZGF0YSIsImZpbGVuYW1lV2l0aG91dEV4dGVuc2lvbiIsImZpbGVFeHRlbnNpb24iLCJmaWxlVHlwZSIsInJlbGF0aXZlUGF0aCIsImV4dGVuZCIsImhhbmRsZXIiLCJpdGVtQVBJIiwiZnJlZXplIiwicmVsZWFzZSIsImFyY2hpdmUiLCJzZXRGaWxlIiwiZ2V0SXRlbUluZGV4QnlRdWVyeSIsImdldEl0ZW1CeUlkIiwiaXRlbUlkIiwiZmV0Y2hCbG9iIiwiZ2V0RG9tYWluRnJvbVVSTCIsImxvY2F0aW9uIiwicHJvdG9jb2wiLCJpc0V4dGVybmFsVVJMIiwiaHJlZiIsImR5bmFtaWNMYWJlbCIsImxhYmVsIiwiaXNNb2NrSXRlbSIsImxpc3RVcGRhdGVkIiwib3B0aW9uYWxQcm9taXNlIiwic29ydEl0ZW1zIiwiY29tcGFyZSIsImdldEl0ZW1CeVF1ZXJ5RnJvbVN0YXRlIiwiaXRlbUhhbmRsZXIiLCJmYWlsdXJlIiwiQUJPUlRfQUxMIiwiRElEX1NFVF9GSUxFUyIsImFjdGl2ZUl0ZW1zIiwiaW50ZXJhY3Rpb25NZXRob2QiLCJESURfVVBEQVRFX0lURU1fTUVUQURBVEEiLCJjaGFuZ2UiLCJzaG91bGRQcmVwYXJlT3V0cHV0IiwiZG9VcGxvYWQiLCJNT1ZFX0lURU0iLCJjdXJyZW50SW5kZXgiLCJTT1JUIiwiQUREX0lURU1TIiwiaW5zZXJ0TG9jYXRpb24iLCJ0b3RhbEl0ZW1zIiwiaXNWYWxpZEZpbGUiLCJ2YWxpZEl0ZW1zIiwicHJvbWlzZXMiLCJhbGwiLCJBRERfSVRFTSIsIm1haW5TdGF0dXMiLCJtYWluIiwic3ViIiwiaGFuZGxlQWRkIiwic2hvdWxkQWRkIiwibG9hZENvbXBsZXRlIiwiUkVRVUVTVF9QUkVQQVJFX09VVFBVVCIsIkNPTVBMRVRFX0xPQURfSVRFTSIsIlJFVFJZX0lURU1fTE9BRCIsIlJFUVVFU1RfSVRFTV9QUkVQQVJFIiwib3V0cHV0IiwiUkVRVUVTVF9JVEVNX1BST0NFU1NJTkciLCJpdGVtQ2FuQmVRdWV1ZWRGb3JQcm9jZXNzaW5nIiwicHJvY2Vzc05vdyIsIlBST0NFU1NfSVRFTSIsInRvdGFsQ3VycmVudFVwbG9hZHMiLCJwcm9jZXNzTmV4dCIsInF1ZXVlRW50cnkiLCJpdGVtUmVmZXJlbmNlIiwibm9vcCIsImFsbEl0ZW1zUHJvY2Vzc2VkIiwiUkVUUllfSVRFTV9QUk9DRVNTSU5HIiwiUkVRVUVTVF9SRU1PVkVfSVRFTSIsInNob3VsZFJlbW92ZSIsIlJFTEVBU0VfSVRFTSIsIlJFTU9WRV9JVEVNIiwicmVtb3ZlRnJvbVZpZXciLCJBQk9SVF9JVEVNX0xPQUQiLCJBQk9SVF9JVEVNX1BST0NFU1NJTkciLCJSRVFVRVNUX1JFVkVSVF9JVEVNX1BST0NFU1NJTkciLCJoYW5kbGVSZXZlcnQiLCJzaG91bGRSZXZlcnQiLCJyZXF1ZXN0UmVtb3ZlUmVzdWx0IiwiUkVWRVJUX0lURU1fUFJPQ0VTU0lORyIsIlNFVF9PUFRJT05TIiwib3B0aW9uS2V5cyIsInByaW9yaXRpemVkT3B0aW9uS2V5cyIsIlByaW9yaXRpemVkT3B0aW9ucyIsIm9yZGVyZWRPcHRpb25LZXlzIiwiZm9ybWF0RmlsZW5hbWUiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwidGV4dCIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJub2RlVmFsdWUiLCJwb2xhclRvQ2FydGVzaWFuIiwiY2VudGVyWCIsImNlbnRlclkiLCJyYWRpdXMiLCJhbmdsZUluRGVncmVlcyIsImFuZ2xlSW5SYWRpYW5zIiwiUEkiLCJ4IiwiY29zIiwieSIsInNpbiIsImRlc2NyaWJlQXJjIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYXJjU3dlZXAiLCJlbmQiLCJwZXJjZW50YWdlQXJjIiwiZnJvbSIsInRvIiwic3BpbiIsInN2ZyIsInBhdGgiLCJhbGlnbiIsImRhdGFzZXQiLCJyaW5nU3Ryb2tlV2lkdGgiLCJyaW5nRnJvbSIsInJpbmdUbyIsImNvb3JkaW5hdGVzIiwicHJvZ3Jlc3NJbmRpY2F0b3IiLCJjcmVhdGUkMSIsImlubmVySFRNTCIsImljb24iLCJpc0Rpc2FibGVkIiwid3JpdGUkMSIsInNob3VsZERpc2FibGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJmaWxlQWN0aW9uQnV0dG9uIiwidG9OYXR1cmFsRmlsZVNpemUiLCJyb3VuZCIsIktCIiwiTUIiLCJHQiIsInJlbW92ZURlY2ltYWxzV2hlblplcm8iLCJkZWNpbWFsQ291bnQiLCJ0b0ZpeGVkIiwiY3JlYXRlJDIiLCJmaWxlTmFtZSIsInVwZGF0ZUZpbGUiLCJ1cGRhdGVGaWxlU2l6ZU9uRXJyb3IiLCJmaWxlSW5mbyIsIkRJRF9MT0FEX0lURU0iLCJESURfVVBEQVRFX0lURU1fTUVUQSIsIkRJRF9USFJPV19JVEVNX0xPQURfRVJST1IiLCJESURfVEhST1dfSVRFTV9JTlZBTElEIiwidG9QZXJjZW50YWdlIiwiY3JlYXRlJDMiLCJkaWRTZXRJdGVtTG9hZFByb2dyZXNzIiwidGl0bGUiLCJkaWRTZXRJdGVtUHJvY2Vzc1Byb2dyZXNzIiwiZGlkUmVxdWVzdEl0ZW1Qcm9jZXNzaW5nIiwiZGlkQWJvcnRJdGVtUHJvY2Vzc2luZyIsImRpZENvbXBsZXRlSXRlbVByb2Nlc3NpbmciLCJmaWxlU3RhdHVzIiwiRElEX1JFVkVSVF9JVEVNX1BST0NFU1NJTkciLCJESURfUkVRVUVTVF9JVEVNX1BST0NFU1NJTkciLCJESURfQUJPUlRfSVRFTV9QUk9DRVNTSU5HIiwiRElEX0NPTVBMRVRFX0lURU1fUFJPQ0VTU0lORyIsIkRJRF9VUERBVEVfSVRFTV9QUk9DRVNTX1BST0dSRVNTIiwiRElEX1VQREFURV9JVEVNX0xPQURfUFJPR1JFU1MiLCJESURfVEhST1dfSVRFTV9QUk9DRVNTSU5HX0VSUk9SIiwiRElEX1RIUk9XX0lURU1fUFJPQ0VTU0lOR19SRVZFUlRfRVJST1IiLCJESURfVEhST1dfSVRFTV9SRU1PVkVfRVJST1IiLCJCdXR0b25zIiwiQWJvcnRJdGVtTG9hZCIsIlJldHJ5SXRlbUxvYWQiLCJSZW1vdmVJdGVtIiwiUHJvY2Vzc0l0ZW0iLCJBYm9ydEl0ZW1Qcm9jZXNzaW5nIiwiUmV0cnlJdGVtUHJvY2Vzc2luZyIsIlJldmVydEl0ZW1Qcm9jZXNzaW5nIiwiQnV0dG9uS2V5cyIsImNhbGN1bGF0ZUZpbGVJbmZvT2Zmc2V0IiwiZ2V0UmVtb3ZlSW5kaWNhdG9yQWxpZ21lbnQiLCJidXR0b25SZWN0IiwiYnV0dG9uUmVtb3ZlSXRlbSIsImNhbGN1bGF0ZUJ1dHRvbldpZHRoIiwiYnV0dG9uQWJvcnRJdGVtTG9hZCIsImNhbGN1bGF0ZUZpbGVWZXJ0aWNhbENlbnRlck9mZnNldCIsImNhbGN1bGF0ZUZpbGVIb3Jpem9udGFsQ2VudGVyT2Zmc2V0IiwiZ2V0TG9hZEluZGljYXRvckFsaWdubWVudCIsImdldFByb2Nlc3NJbmRpY2F0b3JBbGlnbm1lbnQiLCJEZWZhdWx0U3R5bGUiLCJidXR0b25SZXRyeUl0ZW1Mb2FkIiwiYnV0dG9uUHJvY2Vzc0l0ZW0iLCJidXR0b25BYm9ydEl0ZW1Qcm9jZXNzaW5nIiwiYnV0dG9uUmV0cnlJdGVtUHJvY2Vzc2luZyIsImJ1dHRvblJldmVydEl0ZW1Qcm9jZXNzaW5nIiwibG9hZFByb2dyZXNzSW5kaWNhdG9yIiwicHJvY2Vzc1Byb2dyZXNzSW5kaWNhdG9yIiwicHJvY2Vzc2luZ0NvbXBsZXRlSW5kaWNhdG9yIiwiSWRsZVN0eWxlIiwiUHJvY2Vzc2luZ1N0eWxlIiwiU3R5bGVNYXAiLCJESURfU1RBUlRfSVRFTV9MT0FEIiwiRElEX1NUQVJUX0lURU1fUkVNT1ZFIiwiRElEX0xPQURfTE9DQUxfSVRFTSIsIkRJRF9TVEFSVF9JVEVNX1BST0NFU1NJTkciLCJwcm9jZXNzaW5nQ29tcGxldGVJbmRpY2F0b3JWaWV3IiwiY3JlYXRlJDQiLCJMb2NhbEJ1dHRvbnMiLCJwcmV2IiwiY3VyciIsImFsaWduUmVtb3ZlSXRlbUJ1dHRvbiIsImJ1dHRvbkZpbHRlciIsImVuYWJsZWRCdXR0b25zIiwiYnV0dG9uVmlldyIsImNsYXNzTGlzdCIsInN0b3BQcm9wYWdhdGlvbiIsImxvYWRJbmRpY2F0b3JWaWV3IiwicHJvZ3Jlc3NJbmRpY2F0b3JWaWV3IiwiYWN0aXZlU3R5bGVzIiwid3JpdGUkMiIsInJvdXRlIiwic3R5bGVzVG9BcHBseSIsImRlZmF1bHRTdHlsZXMiLCJjb250cm9sIiwiRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9QUk9DRVNTSU5HIiwiRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9MT0FEIiwiRElEX1NFVF9MQUJFTF9CVVRUT05fQUJPUlRfSVRFTV9SRU1PVkFMIiwiYnV0dG9uQWJvcnRJdGVtUmVtb3ZhbCIsImNyZWF0ZSQ1IiwiZGlkTG9hZEl0ZW0iLCJmaWxlV3JhcHBlciIsIlBBTkVMX1NQUklOR19QUk9QUyIsImNyZWF0ZSQ2Iiwic2VjdGlvbiIsImNyZWF0ZVNlY3Rpb24iLCJzY2FsYWJsZSIsInZpZXdDb25zdHJ1Y3RvciIsIndyaXRlJDMiLCJ0b3BSZWN0IiwiYm90dG9tUmVjdCIsImNlbnRlciIsInBhbmVsIiwiaGVpZ2h0Q3VycmVudCIsImNyZWF0ZURyYWdIZWxwZXIiLCJpdGVtSWRzIiwicHJldkluZGV4Iiwic2V0SW5kZXgiLCJnZXRJbmRleCIsImdldEl0ZW1JbmRleCIsIklURU1fVFJBTlNMQVRFX1NQUklORyIsIklURU1fU0NBTEVfU1BSSU5HIiwiU3RhdGVNYXAiLCJjcmVhdGUkNyIsImhhbmRsZUNsaWNrIiwiY29udGFpbmVyIiwibWFya2VkRm9yUmVtb3ZhbCIsImRyYWdTdGF0ZSIsImdyYWIiLCJpc1ByaW1hcnkiLCJyZW1vdmVkQWN0aXZhdGVMaXN0ZW5lciIsInBhZ2VYIiwicGFnZVkiLCJkcmFnT3JpZ2luIiwiZHJhZ0NlbnRlciIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZHJhZyIsInByZXZlbnREZWZhdWx0IiwiZHJhZ09mZnNldCIsImRpc3QiLCJkcm9wIiwiY2FuY2VsIiwicm91dGUkMSIsIkRJRF9VUERBVEVfUEFORUxfSEVJR0hUIiwid3JpdGUkNCIsIkRJRF9HUkFCX0lURU0iLCJESURfRFJBR19JVEVNIiwiRElEX0RST1BfSVRFTSIsImN1cnJlbnRTdGF0ZSIsImZpbGVwb25kSXRlbVN0YXRlIiwiZ2V0SXRlbXNQZXJSb3ciLCJob3Jpem9udGFsU3BhY2UiLCJpdGVtV2lkdGgiLCJnZXRJdGVtSW5kZXhCeVBvc2l0aW9uIiwicG9zaXRpb25JblZpZXciLCJsIiwiaXRlbVJlY3QiLCJpdGVtSG9yaXpvbnRhbE1hcmdpbiIsIml0ZW1zUGVyUm93IiwiY2hpbGRNaWQiLCJpdGVtVmVydGljYWxNYXJnaW4iLCJpdGVtSGVpZ2h0IiwiaW5kZXhYIiwiaW5kZXhZIiwiaXRlbVRvcCIsIml0ZW1SaWdodCIsIml0ZW1Cb3R0b20iLCJkcm9wQXJlYURpbWVuc2lvbnMiLCJnZXRIZWlnaHQiLCJzZXRIZWlnaHQiLCJ2YWwiLCJnZXRXaWR0aCIsInNldFdpZHRoIiwic2V0RGltZW5zaW9ucyIsImNyZWF0ZSQ4IiwibGFzdEl0ZW1TcGFud0RhdGUiLCJhZGRJdGVtVmlldyIsImFkZEluZGV4Iiwic3Bhd25EYXRlIiwiY29vbGRvd24iLCJtb3ZlSXRlbSIsInZ4IiwidnkiLCJpbnRyb0l0ZW1WaWV3IiwicmVtb3ZlSXRlbVZpZXciLCJnZXRJdGVtSGVpZ2h0IiwiZ2V0SXRlbVdpZHRoIiwiZHJhZ0l0ZW0iLCJudW1JdGVtcyIsIm9sZEluZGV4IiwiZHJhZ1Bvc2l0aW9uIiwiZHJhZ0hlaWdodCIsImRyYWdXaWR0aCIsImNvbHMiLCJnZXRHcmlkSW5kZXgiLCJnZXRDb2xJbmRleCIsInZpc2libGVDaGlsZHJlbiIsImlkeCIsImNoaWxkSGVpZ2h0IiwiY2hpbGRCb3R0b20iLCJjaGlsZFRvcCIsInJvdXRlJDIiLCJESURfQUREX0lURU0iLCJESURfUkVNT1ZFX0lURU0iLCJ3cml0ZSQ1IiwiZHJhZ0Nvb3JkaW5hdGVzIiwiZHJhZ0luZGV4IiwiZHJhZ0luZGV4T2Zmc2V0IiwicmVtb3ZlSW5kZXhPZmZzZXQiLCJhZGRJbmRleE9mZnNldCIsImNoaWxkUmVjdCIsInZpc3VhbEhlaWdodCIsInByZXZYIiwicHJldlkiLCJ2aXN1YWxJbmRleCIsInZlY3RvclgiLCJzaWduIiwidmVjdG9yWSIsImZpbHRlclNldEl0ZW1BY3Rpb25zIiwibGlzdCIsImNyZWF0ZSQ5Iiwib3ZlcmZsb3dpbmciLCJzdG9yZURyYWdDb29yZGluYXRlcyIsInNjb3BlTGVmdCIsInNjb3BlVG9wIiwiY2xlYXJEcmFnQ29vcmRpbmF0ZXMiLCJyb3V0ZSQzIiwiRElEX0RSQUciLCJESURfRU5EX0RSQUciLCJ3cml0ZSQ2Iiwib3ZlcmZsb3ciLCJuZXdIZWlnaHQiLCJsaXN0U2Nyb2xsZXIiLCJhdHRyVG9nZ2xlIiwiZW5hYmxlZFZhbHVlIiwicmVzZXRGaWxlSW5wdXQiLCJpbnB1dCIsImZvcm0iLCJjcmVhdGUkYSIsInNldEFjY2VwdGVkRmlsZVR5cGVzIiwidG9nZ2xlQWxsb3dNdWx0aXBsZSIsInRvZ2dsZURpcmVjdG9yeUZpbHRlciIsInRvZ2dsZURpc2FibGVkIiwidG9nZ2xlUmVxdWlyZWQiLCJzZXRDYXB0dXJlTWV0aG9kIiwiaGFuZGxlQ2hhbmdlIiwid2Via2l0UmVsYXRpdmVQYXRoIiwiZG9lc0FsbG93QnJvd3NlIiwiZGlzYWJsZUZpZWxkIiwidXBkYXRlUmVxdWlyZWRTdGF0dXMiLCJzaG91bGRDaGVja1ZhbGlkaXR5Iiwic2V0Q3VzdG9tVmFsaWRpdHkiLCJ1cGRhdGVGaWVsZFZhbGlkaXR5U3RhdHVzIiwiYnJvd3NlciIsIkRJRF9TRVRfRElTQUJMRUQiLCJESURfU0VUX0FMTE9XX0JST1dTRSIsIkRJRF9TRVRfQUxMT1dfRElSRUNUT1JJRVNfT05MWSIsIkRJRF9TRVRfQUxMT1dfTVVMVElQTEUiLCJESURfU0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMiLCJESURfU0VUX0NBUFRVUkVfTUVUSE9EIiwiRElEX1NFVF9SRVFVSVJFRCIsIktleSIsIkVOVEVSIiwiU1BBQ0UiLCJjcmVhdGUkYiIsImhhbmRsZUtleURvd24iLCJpc0FjdGl2YXRpb25LZXkiLCJrZXlDb2RlIiwiY2xpY2siLCJpc0xhYmVsQ2xpY2siLCJjb250YWlucyIsInVwZGF0ZUxhYmVsVmFsdWUiLCJjYXB0aW9uIiwiY2xpY2thYmxlIiwicXVlcnlTZWxlY3RvciIsImRyb3BMYWJlbCIsIkRJRF9TRVRfTEFCRUxfSURMRSIsImFkZEJsb2IiLCJtb3ZlQmxvYiIsImhpZGVCbG9iIiwiZXhwbG9kZUJsb2IiLCJ3cml0ZSQ3Iiwicm91dGUkNCIsIkRJRF9EUk9QIiwiZHJpcCIsInNldElucHV0RmlsZXMiLCJjcmVhdGUkYyIsImZpZWxkcyIsImxlZ2VuZCIsInRleHRDb250ZW50IiwiZ2V0RmllbGQiLCJzeW5jRmllbGRQb3NpdGlvbnNXaXRoSXRlbXMiLCJkaWRSZW9yZGVySXRlbXMiLCJkaWRBZGRJdGVtIiwiZmlsZUl0ZW0iLCJpc0xvY2FsRmlsZSIsInNob3VsZFVzZUZpbGVJbnB1dCIsImRhdGFDb250YWluZXIiLCJkaWRMb2FkSXRlbSQxIiwiZmllbGQiLCJkaWRQcmVwYXJlT3V0cHV0IiwiZGlkU2V0RGlzYWJsZWQiLCJkaWRSZW1vdmVJdGVtIiwiZGlkRGVmaW5lVmFsdWUiLCJ3cml0ZSQ4IiwiRElEX0RFRklORV9WQUxVRSIsIkRJRF9QUkVQQVJFX09VVFBVVCIsIkRJRF9SRU9SREVSX0lURU1TIiwiRElEX1NPUlRfSVRFTVMiLCJnZXRSb290Tm9kZSIsImltYWdlcyIsInRleHQkMSIsInppcCIsImVwdWIiLCJndWVzc3RpbWF0ZU1pbWVUeXBlIiwicmVxdWVzdERhdGFUcmFuc2Zlckl0ZW1zIiwibGlua3MiLCJnZXRMaW5rcyIsImhhc0ZpbGVzIiwiZ2V0RmlsZXMiLCJwcm9taXNlZEZpbGVzIiwiaXNGaWxlU3lzdGVtSXRlbSIsImdldEZpbGVzRnJvbUl0ZW0iLCJyZXR1cm5lZEZpbGVHcm91cHMiLCJncm91cCIsImFwcGx5IiwiaXNFbnRyeSIsImVudHJ5IiwiZ2V0QXNFbnRyeSIsImlzRGlyZWN0b3J5Iiwia2luZCIsImlzRGlyZWN0b3J5RW50cnkiLCJnZXRGaWxlc0luRGlyZWN0b3J5IiwiZ2V0QXNGaWxlIiwiZGlyQ291bnRlciIsImZpbGVDb3VudGVyIiwicmVzb2x2ZUlmRG9uZSIsInJlYWRFbnRyaWVzIiwiZGlyRW50cnkiLCJkaXJlY3RvcnlSZWFkZXIiLCJjcmVhdGVSZWFkZXIiLCJyZWFkQmF0Y2giLCJlbnRyaWVzIiwiY29ycmVjdGVkRmlsZSIsImNvcnJlY3RNaXNzaW5nRmlsZVR5cGUiLCJmdWxsUGF0aCIsIndlYmtpdEdldEFzRW50cnkiLCJnZXRMaW5rc0Zyb21UcmFuc2Zlck1ldGFEYXRhIiwiZ2V0TGlua3NGcm9tVHJhbnNmZXJVUkxEYXRhIiwiZ2V0RGF0YSIsImRyYWdORHJvcE9ic2VydmVycyIsImV2ZW50UG9zaXRpb24iLCJwYWdlTGVmdCIsInBhZ2VUb3AiLCJsYXllclgiLCJsYXllclkiLCJjcmVhdGVEcmFnTkRyb3BDbGllbnQiLCJzY29wZVRvT2JzZXJ2ZSIsImZpbHRlckVsZW1lbnQiLCJvYnNlcnZlciIsImdldERyYWdORHJvcE9ic2VydmVyIiwiY2xpZW50Iiwib25kcm9wIiwib25lbnRlciIsIm9uZHJhZyIsIm9uZXhpdCIsImFsbG93ZHJvcCIsImFkZExpc3RlbmVyIiwibmV3T2JzZXJ2ZXIiLCJjcmVhdGVEcmFnTkRyb3BPYnNlcnZlciIsImNsaWVudHMiLCJkcmFnZW50ZXIiLCJkcmFnb3ZlciIsImRyYWdsZWF2ZSIsImhhbmRsZXJzIiwiY3JlYXRlSGFuZGxlciIsImVsZW1lbnRGcm9tUG9pbnQiLCJwb2ludCIsImlzRXZlbnRUYXJnZXQiLCJlbGVtZW50QXRQb3NpdGlvbiIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJpbml0aWFsVGFyZ2V0Iiwic2V0RHJvcEVmZmVjdCIsImVmZmVjdCIsImRyb3BFZmZlY3QiLCJvdmVyRHJvcFRhcmdldCIsImFsbG93c1RyYW5zZmVyIiwiY3JlYXRlSG9wcGVyIiwic2NvcGUiLCJ2YWxpZGF0ZUl0ZW1zIiwiY2F0Y2hlc0Ryb3BzT25QYWdlIiwicmVxdWlyZXNEcm9wT25FbGVtZW50IiwiZmlsdGVySXRlbXMiLCJkb2N1bWVudEVsZW1lbnQiLCJsYXN0U3RhdGUiLCJmaWx0ZXJlZEl0ZW1zIiwib25kcmFnZW5kIiwib25kcmFnc3RhcnQiLCJ1cGRhdGVIb3BwZXJTdGF0ZSIsImhvcHBlclN0YXRlIiwibGlzdGVuaW5nIiwibGlzdGVuZXJzJDEiLCJoYW5kbGVQYXN0ZSIsImFjdGl2ZUVsIiwiYWN0aXZlRWxlbWVudCIsImlzQWN0aXZlRWxlbWVudEVkaXRhYmxlIiwibm9kZU5hbWUiLCJpblNjb3BlIiwiY2xpcGJvYXJkRGF0YSIsImxpc3RlbiIsInVubGlzdGVuIiwiY3JlYXRlUGFzdGVyIiwiY3JlYXRlJGQiLCJhZGRGaWxlc05vdGlmaWNhdGlvblRpbWVvdXQiLCJub3RpZmljYXRpb25DbGVhclRpbWVvdXQiLCJmaWxlbmFtZXMiLCJhc3Npc3QiLCJtZXNzYWdlIiwiY2xlYXIkMSIsImxpc3RNb2RpZmllZCIsImlzVXNpbmdGaWxlUG9uZCIsIml0ZW1BZGRlZCIsIml0ZW1SZW1vdmVkIiwiaXRlbVByb2Nlc3NlZCIsIml0ZW1Qcm9jZXNzZWRVbmRvIiwiaXRlbUVycm9yIiwiYXNzaXN0YW50IiwidG9DYW1lbHMiLCJSZWdFeHAiLCJjaGFyQXQiLCJkZWJvdW5jZSIsImZ1bmMiLCJpbW1pZGlhdGVPbmx5IiwiTUFYX0ZJTEVTX0xJTUlUIiwicHJldmVudCIsImNyZWF0ZSRlIiwibWVhc3VyZSIsImJvdW5kcyIsIndpZHRoUHJldmlvdXMiLCJ3aWR0aFVwZGF0ZWQiLCJ1cGRhdGVIaXN0b3J5IiwicHJldmlvdXNBc3BlY3RSYXRpbyIsImNhbkhvdmVyIiwibWF0Y2hNZWRpYSIsImhhc1BvaW50ZXJFdmVudHMiLCJwYXNzaXZlIiwiaGFzQ3JlZGl0cyIsImZyYWciLCJ0YWJJbmRleCIsInJlbCIsIndyaXRlJDkiLCJyb3V0ZSQ1IiwiY2FsY3VsYXRlUm9vdEJvdW5kaW5nQm94SGVpZ2h0IiwiaG9wcGVyIiwiaXNNdWx0aUl0ZW0iLCJtYXhJdGVtcyIsImF0TWF4Q2FwYWNpdHkiLCJhZGRBY3Rpb24iLCJsaXN0SXRlbU1hcmdpbiIsImNhbGN1bGF0ZUxpc3RJdGVtTWFyZ2luIiwibGlzdEhlaWdodCIsImNhbGN1bGF0ZUxpc3RIZWlnaHQiLCJsYWJlbEhlaWdodCIsImN1cnJlbnRMYWJlbEhlaWdodCIsImxpc3RNYXJnaW5Ub3AiLCJsaXN0TWFyZ2luQm90dG9tIiwidmlzdWFsIiwiYm91bmRzSGVpZ2h0IiwiaGlzdG9yeSIsIk1BWF9CT1VOQ0VTIiwiYm91bmNlcyIsImxpc3RBdmFpbGFibGVIZWlnaHQiLCJmaXhlZEhlaWdodCIsImNhcHBlZEhlaWdodCIsImlzQ2FwcGVkSGVpZ2h0IiwicGFuZWxIZWlnaHQiLCJpdGVtTWFyZ2luIiwidHJhbnNmb3JtIiwic2Nyb2xsTGlzdCIsIml0ZW1MaXN0IiwibmV3SXRlbSIsInJlbW92ZWRJdGVtIiwidmVydGljYWxJdGVtQ291bnQiLCJjZWlsIiwibWVhc3VyZUhlaWdodCIsIm1heEhlaWdodCIsImV4Y2VlZHNNYXhGaWxlcyIsInRvdGFsQnJvd3NlSXRlbXMiLCJoYXNNYXhJdGVtcyIsImdldERyYWdJbmRleCIsInRvZ2dsZURyb3AiLCJpc0FsbG93ZWQiLCJlbmFibGVkIiwidG9nZ2xlQnJvd3NlIiwidG9nZ2xlUGFzdGUiLCJwYXN0ZXIiLCJESURfU0VUX0FMTE9XX0RST1AiLCJESURfU0VUX0FMTE9XX1BBU1RFIiwiY3JlYXRlQXBwIiwiaW5pdGlhbE9wdGlvbnMiLCJvcmlnaW5hbEVsZW1lbnQiLCJ2aXNpYmlsaXR5SGFuZGxlciIsInJlc2l6ZURvbmVUaW1lciIsImlzUmVzaXppbmciLCJpc1Jlc2l6aW5nSG9yaXpvbnRhbGx5IiwiaW5pdGlhbFdpbmRvd1dpZHRoIiwiY3VycmVudFdpbmRvd1dpZHRoIiwicmVzaXplSGFuZGxlciIsImlzSGlkZGVuIiwicmVhZFdyaXRlQXBpIiwiaW5uZXJXaWR0aCIsInJvdXRlQWN0aW9uc1RvRXZlbnRzIiwiY3JlYXRlRXZlbnQiLCJldmVudFJvdXRlcyIsIkRJRF9ERVNUUk9ZIiwiRElEX0lOSVQiLCJESURfVEhST1dfTUFYX0ZJTEVTIiwiRElEX0lOSVRfSVRFTSIsIkRJRF9DT01QTEVURV9JVEVNX1BST0NFU1NJTkdfQUxMIiwiRElEX1VQREFURV9JVEVNUyIsIkRJRF9BQ1RJVkFURV9JVEVNIiwiZXhwb3NlRXZlbnQiLCJkZXRhaWwiLCJwb25kIiwiZXhwb3J0cyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY29tcG9zZWQiLCJmaWx0ZXJlZCIsInByZXBhcmVGaWxlIiwiYWRkRmlsZSIsImFkZEZpbGVzIiwiaXNGaWxlUG9uZEZpbGUiLCJyZW1vdmVGaWxlIiwic291cmNlcyIsImxhc3RBcmd1bWVudCIsInByb2Nlc3NGaWxlIiwicHJlcGFyZUZpbGVzIiwicHJvY2Vzc0ZpbGVzIiwicmVtb3ZlRmlsZXMiLCJtYXBwZWRRdWVyaWVzIiwicSIsIm1vdmVGaWxlIiwiYnJvd3NlIiwiYXBwZW5kVG8iLCJyZXBsYWNlRWxlbWVudCIsInJlc3RvcmVFbGVtZW50IiwiaXNBdHRhY2hlZFRvIiwiY3JlYXRlQXBwT2JqZWN0IiwiY3VzdG9tT3B0aW9ucyIsImFwcCIsImxvd2VyQ2FzZUZpcnN0TGV0dGVyIiwiYXR0cmlidXRlTmFtZVRvUHJvcGVydHlOYW1lIiwiYXR0cmlidXRlTmFtZSIsIm1hcE9iamVjdCIsInByb3BlcnR5TWFwIiwic2VsZWN0b3IiLCJtYXBwaW5nIiwic2VsZWN0b3JSZWdFeHAiLCJnZXRBdHRyaWJ1dGVzQXNPYmplY3QiLCJhdHRyaWJ1dGVNYXBwaW5nIiwiYXR0cmlidXRlIiwiY3JlYXRlQXBwQXRFbGVtZW50IiwibWVyZ2VkT3B0aW9ucyIsImF0dHJpYnV0ZU9wdGlvbnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY3JlYXRlQXBwJDEiLCJQUklWQVRFX01FVEhPRFMiLCJjcmVhdGVBcHBBUEkiLCJyZXBsYWNlSW5TdHJpbmciLCJyZXBsYWNlbWVudHMiLCJjcmVhdGVXb3JrZXIiLCJ3b3JrZXJCbG9iIiwid29ya2VyVVJMIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwid29ya2VyIiwiV29ya2VyIiwicG9zdCIsInRyYW5zZmVyTGlzdCIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwidGVybWluYXRlIiwicmV2b2tlT2JqZWN0VVJMIiwibG9hZEltYWdlIiwiaW1nIiwiSW1hZ2UiLCJyZW5hbWVGaWxlIiwicmVuYW1lZEZpbGUiLCJjb3B5RmlsZSIsInJlZ2lzdGVyZWRQbHVnaW5zIiwiY3JlYXRlQXBwUGx1Z2luIiwicGx1Z2luIiwicGx1Z2luT3V0bGluZSIsInZpZXdzIiwiaXNPcGVyYU1pbmkiLCJwcm90b3R5cGUiLCJjYWxsIiwib3BlcmFtaW5pIiwiaGFzUHJvbWlzZXMiLCJoYXNCbG9iU2xpY2UiLCJoYXNDcmVhdGVPYmplY3RVUkwiLCJoYXNWaXNpYmlsaXR5IiwiaGFzVGltaW5nIiwiaGFzQ1NTU3VwcG9ydHMiLCJDU1MiLCJpc0lFMTEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJzdXBwb3J0ZWQiLCJpc1N1cHBvcnRlZCIsImFwcHMiLCJTdGF0dXMkMSIsIkZpbGVTdGF0dXMiLCJGaWxlT3JpZ2luJDEiLCJPcHRpb25UeXBlcyIsImNyZWF0ZSRmIiwicmVnaXN0ZXJQbHVnaW4iLCJnZXRPcHRpb25zJDEiLCJzZXRPcHRpb25zJDEiLCJ1cGRhdGVPcHRpb25UeXBlcyIsImhvb2siLCJpbmRleFRvUmVtb3ZlIiwiY29udGV4dCIsIm1hdGNoZWRIb29rcyIsIm5ld0hvb2tzIiwibmV3SG9vayIsInBsdWdpbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond/dist/filepond.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/filepond/dist/filepond.min.css":
/*!*****************************************************!*\
  !*** ./node_modules/filepond/dist/filepond.min.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ad56d68715ff\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQvZGlzdC9maWxlcG9uZC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmluLWV4dHJhY3Rvci8uL25vZGVfbW9kdWxlcy9maWxlcG9uZC9kaXN0L2ZpbGVwb25kLm1pbi5jc3M/Y2U1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcImFkNTZkNjg3MTVmZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond/dist/filepond.min.css\n");

/***/ })

};
;