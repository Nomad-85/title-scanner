"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/filepond-plugin-file-validate-type";
exports.ids = ["vendor-chunks/filepond-plugin-file-validate-type"];
exports.modules = {

/***/ "(ssr)/./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * FilePondPluginFileValidateType 1.2.9\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */ /* eslint-disable */ const plugin = ({ addFilter, utils })=>{\n    // get quick reference to Type utils\n    const { Type, isString, replaceInString, guesstimateMimeType, getExtensionFromFilename, getFilenameFromURL } = utils;\n    const mimeTypeMatchesWildCard = (mimeType, wildcard)=>{\n        const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n        const wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n        return mimeTypeGroup === wildcardGroup;\n    };\n    const isValidMimeType = (acceptedTypes, userInputType)=>acceptedTypes.some((acceptedType)=>{\n            // accepted is wildcard mime type\n            if (/\\*$/.test(acceptedType)) {\n                return mimeTypeMatchesWildCard(userInputType, acceptedType);\n            }\n            // is normal mime type\n            return acceptedType === userInputType;\n        });\n    const getItemType = (item)=>{\n        // if the item is a url we guess the mime type by the extension\n        let type = \"\";\n        if (isString(item)) {\n            const filename = getFilenameFromURL(item);\n            const extension = getExtensionFromFilename(filename);\n            if (extension) {\n                type = guesstimateMimeType(extension);\n            }\n        } else {\n            type = item.type;\n        }\n        return type;\n    };\n    const validateFile = (item, acceptedFileTypes, typeDetector)=>{\n        // no types defined, everything is allowed \\o/\n        if (acceptedFileTypes.length === 0) {\n            return true;\n        }\n        // gets the item type\n        const type = getItemType(item);\n        // no type detector, test now\n        if (!typeDetector) {\n            return isValidMimeType(acceptedFileTypes, type);\n        }\n        // use type detector\n        return new Promise((resolve, reject)=>{\n            typeDetector(item, type).then((detectedType)=>{\n                if (isValidMimeType(acceptedFileTypes, detectedType)) {\n                    resolve();\n                } else {\n                    reject();\n                }\n            }).catch(reject);\n        });\n    };\n    const applyMimeTypeMap = (map)=>(acceptedFileType)=>map[acceptedFileType] === null ? false : map[acceptedFileType] || acceptedFileType;\n    // setup attribute mapping for accept\n    addFilter(\"SET_ATTRIBUTE_TO_OPTION_MAP\", (map)=>Object.assign(map, {\n            accept: \"acceptedFileTypes\"\n        }));\n    // filtering if an item is allowed in hopper\n    addFilter(\"ALLOW_HOPPER_ITEM\", (file, { query })=>{\n        // if we are not doing file type validation exit\n        if (!query(\"GET_ALLOW_FILE_TYPE_VALIDATION\")) {\n            return true;\n        }\n        // we validate the file against the accepted file types\n        return validateFile(file, query(\"GET_ACCEPTED_FILE_TYPES\"));\n    });\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter(\"LOAD_FILE\", (file, { query })=>new Promise((resolve, reject)=>{\n            if (!query(\"GET_ALLOW_FILE_TYPE_VALIDATION\")) {\n                resolve(file);\n                return;\n            }\n            const acceptedFileTypes = query(\"GET_ACCEPTED_FILE_TYPES\");\n            // custom type detector method\n            const typeDetector = query(\"GET_FILE_VALIDATE_TYPE_DETECT_TYPE\");\n            // if invalid, exit here\n            const validationResult = validateFile(file, acceptedFileTypes, typeDetector);\n            const handleRejection = ()=>{\n                const acceptedFileTypesMapped = acceptedFileTypes.map(applyMimeTypeMap(query(\"GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP\"))).filter((label)=>label !== false);\n                const acceptedFileTypesMappedUnique = acceptedFileTypesMapped.filter((item, index)=>acceptedFileTypesMapped.indexOf(item) === index);\n                reject({\n                    status: {\n                        main: query(\"GET_LABEL_FILE_TYPE_NOT_ALLOWED\"),\n                        sub: replaceInString(query(\"GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES\"), {\n                            allTypes: acceptedFileTypesMappedUnique.join(\", \"),\n                            allButLastType: acceptedFileTypesMappedUnique.slice(0, -1).join(\", \"),\n                            lastType: acceptedFileTypesMappedUnique[acceptedFileTypesMappedUnique.length - 1]\n                        })\n                    }\n                });\n            };\n            // has returned new filename immidiately\n            if (typeof validationResult === \"boolean\") {\n                if (!validationResult) {\n                    return handleRejection();\n                }\n                return resolve(file);\n            }\n            // is promise\n            validationResult.then(()=>{\n                resolve(file);\n            }).catch(handleRejection);\n        }));\n    // expose plugin\n    return {\n        // default options\n        options: {\n            // Enable or disable file type validation\n            allowFileTypeValidation: [\n                true,\n                Type.BOOLEAN\n            ],\n            // What file types to accept\n            acceptedFileTypes: [\n                [],\n                Type.ARRAY\n            ],\n            // - must be comma separated\n            // - mime types: image/png, image/jpeg, image/gif\n            // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n            // - wildcards: image/*\n            // label to show when a type is not allowed\n            labelFileTypeNotAllowed: [\n                \"File is of invalid type\",\n                Type.STRING\n            ],\n            // nicer label\n            fileValidateTypeLabelExpectedTypes: [\n                \"Expects {allButLastType} or {lastType}\",\n                Type.STRING\n            ],\n            // map mime types to extensions\n            fileValidateTypeLabelExpectedTypesMap: [\n                {},\n                Type.OBJECT\n            ],\n            // Custom function to detect type of file\n            fileValidateTypeDetectType: [\n                null,\n                Type.FUNCTION\n            ]\n        }\n    };\n};\n// fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\nconst isBrowser =  false && 0;\nif (isBrowser) {\n    document.dispatchEvent(new CustomEvent(\"FilePond:pluginloaded\", {\n        detail: plugin\n    }));\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztDQUlDLEdBRUQsa0JBQWtCLEdBRWxCLE1BQU1BLFNBQVMsQ0FBQyxFQUFFQyxTQUFTLEVBQUVDLEtBQUssRUFBRTtJQUNoQyxvQ0FBb0M7SUFDcEMsTUFBTSxFQUNGQyxJQUFJLEVBQ0pDLFFBQVEsRUFDUkMsZUFBZSxFQUNmQyxtQkFBbUIsRUFDbkJDLHdCQUF3QixFQUN4QkMsa0JBQWtCLEVBQ3JCLEdBQUdOO0lBRUosTUFBTU8sMEJBQTBCLENBQUNDLFVBQVVDO1FBQ3ZDLE1BQU1DLGdCQUFnQixDQUFDLFNBQVNDLElBQUksQ0FBQ0gsYUFBYSxFQUFFLEVBQUVJLEdBQUcsSUFBSSxxQkFBcUI7UUFDbEYsTUFBTUMsZ0JBQWdCSixTQUFTSyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksbUJBQW1CO1FBQ2hFLE9BQU9KLGtCQUFrQkc7SUFDN0I7SUFFQSxNQUFNRSxrQkFBa0IsQ0FBQ0MsZUFBZUMsZ0JBQ3BDRCxjQUFjRSxJQUFJLENBQUNDLENBQUFBO1lBQ2YsaUNBQWlDO1lBQ2pDLElBQUksTUFBTUMsSUFBSSxDQUFDRCxlQUFlO2dCQUMxQixPQUFPWix3QkFBd0JVLGVBQWVFO1lBQ2xEO1lBRUEsc0JBQXNCO1lBQ3RCLE9BQU9BLGlCQUFpQkY7UUFDNUI7SUFFSixNQUFNSSxjQUFjQyxDQUFBQTtRQUNoQiwrREFBK0Q7UUFDL0QsSUFBSUMsT0FBTztRQUNYLElBQUlyQixTQUFTb0IsT0FBTztZQUNoQixNQUFNRSxXQUFXbEIsbUJBQW1CZ0I7WUFDcEMsTUFBTUcsWUFBWXBCLHlCQUF5Qm1CO1lBQzNDLElBQUlDLFdBQVc7Z0JBQ1hGLE9BQU9uQixvQkFBb0JxQjtZQUMvQjtRQUNKLE9BQU87WUFDSEYsT0FBT0QsS0FBS0MsSUFB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QkFBbUI7Z0JBQUMsRUFBRTtnQkFBRTFCLEtBQUs2RCxLQUFLO2FBQUM7WUFDbkMsNEJBQTRCO1lBQzVCLGlEQUFpRDtZQUNqRCxzREFBc0Q7WUFDdEQsdUJBQXVCO1lBRXZCLDJDQUEyQztZQUMzQ0MseUJBQXlCO2dCQUFDO2dCQUEyQjlELEtBQUsrRCxNQUFNO2FBQUM7WUFFakUsY0FBYztZQUNkQyxvQ0FBb0M7Z0JBQ2hDO2dCQUNBaEUsS0FBSytELE1BQU07YUFDZDtZQUVELCtCQUErQjtZQUMvQkUsdUNBQXVDO2dCQUFDLENBQUM7Z0JBQUdqRSxLQUFLa0UsTUFBTTthQUFDO1lBRXhELHlDQUF5QztZQUN6Q0MsNEJBQTRCO2dCQUFDO2dCQUFNbkUsS0FBS29FLFFBQVE7YUFBQztRQUNyRDtJQUNKO0FBQ0o7QUFFQSxpSEFBaUg7QUFDakgsTUFBTUMsWUFBWSxNQUFrQixJQUFlLENBQTJCO0FBQzlFLElBQUlBLFdBQVc7SUFDWEUsU0FBU0MsYUFBYSxDQUFDLElBQUlDLFlBQVkseUJBQXlCO1FBQUVDLFFBQVE3RTtJQUFPO0FBQ3JGO0FBRUEsaUVBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aW4tZXh0cmFjdG9yLy4vbm9kZV9tb2R1bGVzL2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUvZGlzdC9maWxlcG9uZC1wbHVnaW4tZmlsZS12YWxpZGF0ZS10eXBlLmVzbS5qcz8xZGE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIDEuMi45XG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmNvbnN0IHBsdWdpbiA9ICh7IGFkZEZpbHRlciwgdXRpbHMgfSkgPT4ge1xuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgIGNvbnN0IHtcbiAgICAgICAgVHlwZSxcbiAgICAgICAgaXNTdHJpbmcsXG4gICAgICAgIHJlcGxhY2VJblN0cmluZyxcbiAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lLFxuICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkwsXG4gICAgfSA9IHV0aWxzO1xuXG4gICAgY29uc3QgbWltZVR5cGVNYXRjaGVzV2lsZENhcmQgPSAobWltZVR5cGUsIHdpbGRjYXJkKSA9PiB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlR3JvdXAgPSAoL15bXi9dKy8uZXhlYyhtaW1lVHlwZSkgfHwgW10pLnBvcCgpOyAvLyBpbWFnZS9wbmcgLT4gaW1hZ2VcbiAgICAgICAgY29uc3Qgd2lsZGNhcmRHcm91cCA9IHdpbGRjYXJkLnNsaWNlKDAsIC0yKTsgLy8gaW1hZ2UvKiAtPiBpbWFnZVxuICAgICAgICByZXR1cm4gbWltZVR5cGVHcm91cCA9PT0gd2lsZGNhcmRHcm91cDtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNWYWxpZE1pbWVUeXBlID0gKGFjY2VwdGVkVHlwZXMsIHVzZXJJbnB1dFR5cGUpID0+XG4gICAgICAgIGFjY2VwdGVkVHlwZXMuc29tZShhY2NlcHRlZFR5cGUgPT4ge1xuICAgICAgICAgICAgLy8gYWNjZXB0ZWQgaXMgd2lsZGNhcmQgbWltZSB0eXBlXG4gICAgICAgICAgICBpZiAoL1xcKiQvLnRlc3QoYWNjZXB0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZU1hdGNoZXNXaWxkQ2FyZCh1c2VySW5wdXRUeXBlLCBhY2NlcHRlZFR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpcyBub3JtYWwgbWltZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gYWNjZXB0ZWRUeXBlID09PSB1c2VySW5wdXRUeXBlO1xuICAgICAgICB9KTtcblxuICAgIGNvbnN0IGdldEl0ZW1UeXBlID0gaXRlbSA9PiB7XG4gICAgICAgIC8vIGlmIHRoZSBpdGVtIGlzIGEgdXJsIHdlIGd1ZXNzIHRoZSBtaW1lIHR5cGUgYnkgdGhlIGV4dGVuc2lvblxuICAgICAgICBsZXQgdHlwZSA9ICcnO1xuICAgICAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tVVJMKGl0ZW0pO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gZ3Vlc3N0aW1hdGVNaW1lVHlwZShleHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZGF0ZUZpbGUgPSAoaXRlbSwgYWNjZXB0ZWRGaWxlVHlwZXMsIHR5cGVEZXRlY3RvcikgPT4ge1xuICAgICAgICAvLyBubyB0eXBlcyBkZWZpbmVkLCBldmVyeXRoaW5nIGlzIGFsbG93ZWQgXFxvL1xuICAgICAgICBpZiAoYWNjZXB0ZWRGaWxlVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldHMgdGhlIGl0ZW0gdHlwZVxuICAgICAgICBjb25zdCB0eXBlID0gZ2V0SXRlbVR5cGUoaXRlbSk7XG5cbiAgICAgICAgLy8gbm8gdHlwZSBkZXRlY3RvciwgdGVzdCBub3dcbiAgICAgICAgaWYgKCF0eXBlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkTWltZVR5cGUoYWNjZXB0ZWRGaWxlVHlwZXMsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHR5cGUgZGV0ZWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHR5cGVEZXRlY3RvcihpdGVtLCB0eXBlKVxuICAgICAgICAgICAgICAgIC50aGVuKGRldGVjdGVkVHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkTWltZVR5cGUoYWNjZXB0ZWRGaWxlVHlwZXMsIGRldGVjdGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwcGx5TWltZVR5cGVNYXAgPSBtYXAgPT4gYWNjZXB0ZWRGaWxlVHlwZSA9PlxuICAgICAgICBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gPT09IG51bGwgPyBmYWxzZSA6IG1hcFthY2NlcHRlZEZpbGVUeXBlXSB8fCBhY2NlcHRlZEZpbGVUeXBlO1xuXG4gICAgLy8gc2V0dXAgYXR0cmlidXRlIG1hcHBpbmcgZm9yIGFjY2VwdFxuICAgIGFkZEZpbHRlcignU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgbWFwID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgICAgICBhY2NlcHQ6ICdhY2NlcHRlZEZpbGVUeXBlcycsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIGZpbHRlcmluZyBpZiBhbiBpdGVtIGlzIGFsbG93ZWQgaW4gaG9wcGVyXG4gICAgYWRkRmlsdGVyKCdBTExPV19IT1BQRVJfSVRFTScsIChmaWxlLCB7IHF1ZXJ5IH0pID0+IHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBkb2luZyBmaWxlIHR5cGUgdmFsaWRhdGlvbiBleGl0XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHZhbGlkYXRlIHRoZSBmaWxlIGFnYWluc3QgdGhlIGFjY2VwdGVkIGZpbGUgdHlwZXNcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRmlsZShmaWxlLCBxdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKSk7XG4gICAgfSk7XG5cbiAgICAvLyBjYWxsZWQgZm9yIGVhY2ggZmlsZSB0aGF0IGlzIGxvYWRlZFxuICAgIC8vIHJpZ2h0IGJlZm9yZSBpdCBpcyBzZXQgdG8gdGhlIGl0ZW0gc3RhdGVcbiAgICAvLyBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZVxuICAgIGFkZEZpbHRlcihcbiAgICAgICAgJ0xPQURfRklMRScsXG4gICAgICAgIChmaWxlLCB7IHF1ZXJ5IH0pID0+XG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfVFlQRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2VwdGVkRmlsZVR5cGVzID0gcXVlcnkoJ0dFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gdHlwZSBkZXRlY3RvciBtZXRob2RcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlRGV0ZWN0b3IgPSBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9ERVRFQ1RfVFlQRScpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaW52YWxpZCwgZXhpdCBoZXJlXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHZhbGlkYXRlRmlsZShmaWxlLCBhY2NlcHRlZEZpbGVUeXBlcywgdHlwZURldGVjdG9yKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVJlamVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQgPSBhY2NlcHRlZEZpbGVUeXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU1pbWVUeXBlTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9MQUJFTF9FWFBFQ1RFRF9UWVBFU19NQVAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGFiZWwgPT4gbGFiZWwgIT09IGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFVuaXF1ZSA9IGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1RZUEVfTk9UX0FMTE9XRUQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHJlcGxhY2VJblN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1ZBTElEQVRFX1RZUEVfTEFCRUxfRVhQRUNURURfVFlQRVMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHlwZXM6IGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkVW5pcXVlLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxCdXRMYXN0VHlwZTogYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWRVbmlxdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VHlwZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFVuaXF1ZVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWRVbmlxdWUubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGhhcyByZXR1cm5lZCBuZXcgZmlsZW5hbWUgaW1taWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZWplY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpcyBwcm9taXNlXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goaGFuZGxlUmVqZWN0aW9uKTtcbiAgICAgICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIGV4cG9zZSBwbHVnaW5cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGFsbG93RmlsZVR5cGVWYWxpZGF0aW9uOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAgICAgLy8gV2hhdCBmaWxlIHR5cGVzIHRvIGFjY2VwdFxuICAgICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXM6IFtbXSwgVHlwZS5BUlJBWV0sXG4gICAgICAgICAgICAvLyAtIG11c3QgYmUgY29tbWEgc2VwYXJhdGVkXG4gICAgICAgICAgICAvLyAtIG1pbWUgdHlwZXM6IGltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmXG4gICAgICAgICAgICAvLyAtIGV4dGVuc2lvbnM6IC5wbmcsIC5qcGcsIC5qcGVnICggbm90IGVuYWJsZWQgeWV0IClcbiAgICAgICAgICAgIC8vIC0gd2lsZGNhcmRzOiBpbWFnZS8qXG5cbiAgICAgICAgICAgIC8vIGxhYmVsIHRvIHNob3cgd2hlbiBhIHR5cGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIGxhYmVsRmlsZVR5cGVOb3RBbGxvd2VkOiBbJ0ZpbGUgaXMgb2YgaW52YWxpZCB0eXBlJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgICAgICAvLyBuaWNlciBsYWJlbFxuICAgICAgICAgICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RzIHthbGxCdXRMYXN0VHlwZX0gb3Ige2xhc3RUeXBlfScsXG4gICAgICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAvLyBtYXAgbWltZSB0eXBlcyB0byBleHRlbnNpb25zXG4gICAgICAgICAgICBmaWxlVmFsaWRhdGVUeXBlTGFiZWxFeHBlY3RlZFR5cGVzTWFwOiBbe30sIFR5cGUuT0JKRUNUXSxcblxuICAgICAgICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVjdCB0eXBlIG9mIGZpbGVcbiAgICAgICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVEZXRlY3RUeXBlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbi8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBsdWdpbjtcbiJdLCJuYW1lcyI6WyJwbHVnaW4iLCJhZGRGaWx0ZXIiLCJ1dGlscyIsIlR5cGUiLCJpc1N0cmluZyIsInJlcGxhY2VJblN0cmluZyIsImd1ZXNzdGltYXRlTWltZVR5cGUiLCJnZXRFeHRlbnNpb25Gcm9tRmlsZW5hbWUiLCJnZXRGaWxlbmFtZUZyb21VUkwiLCJtaW1lVHlwZU1hdGNoZXNXaWxkQ2FyZCIsIm1pbWVUeXBlIiwid2lsZGNhcmQiLCJtaW1lVHlwZUdyb3VwIiwiZXhlYyIsInBvcCIsIndpbGRjYXJkR3JvdXAiLCJzbGljZSIsImlzVmFsaWRNaW1lVHlwZSIsImFjY2VwdGVkVHlwZXMiLCJ1c2VySW5wdXRUeXBlIiwic29tZSIsImFjY2VwdGVkVHlwZSIsInRlc3QiLCJnZXRJdGVtVHlwZSIsIml0ZW0iLCJ0eXBlIiwiZmlsZW5hbWUiLCJleHRlbnNpb24iLCJ2YWxpZGF0ZUZpbGUiLCJhY2NlcHRlZEZpbGVUeXBlcyIsInR5cGVEZXRlY3RvciIsImxlbmd0aCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsImRldGVjdGVkVHlwZSIsImNhdGNoIiwiYXBwbHlNaW1lVHlwZU1hcCIsIm1hcCIsImFjY2VwdGVkRmlsZVR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJhY2NlcHQiLCJmaWxlIiwicXVlcnkiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiaGFuZGxlUmVqZWN0aW9uIiwiYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQiLCJmaWx0ZXIiLCJsYWJlbCIsImFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkVW5pcXVlIiwiaW5kZXgiLCJpbmRleE9mIiwic3RhdHVzIiwibWFpbiIsInN1YiIsImFsbFR5cGVzIiwiam9pbiIsImFsbEJ1dExhc3RUeXBlIiwibGFzdFR5cGUiLCJvcHRpb25zIiwiYWxsb3dGaWxlVHlwZVZhbGlkYXRpb24iLCJCT09MRUFOIiwiQVJSQVkiLCJsYWJlbEZpbGVUeXBlTm90QWxsb3dlZCIsIlNUUklORyIsImZpbGVWYWxpZGF0ZVR5cGVMYWJlbEV4cGVjdGVkVHlwZXMiLCJmaWxlVmFsaWRhdGVUeXBlTGFiZWxFeHBlY3RlZFR5cGVzTWFwIiwiT0JKRUNUIiwiZmlsZVZhbGlkYXRlVHlwZURldGVjdFR5cGUiLCJGVU5DVElPTiIsImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js\n");

/***/ })

};
;