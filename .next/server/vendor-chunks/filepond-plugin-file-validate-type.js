"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/filepond-plugin-file-validate-type";
exports.ids = ["vendor-chunks/filepond-plugin-file-validate-type"];
exports.modules = {

/***/ "(ssr)/./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * FilePondPluginFileValidateType 1.2.9\n * Licensed under MIT, https://opensource.org/licenses/MIT/\n * Please visit https://pqina.nl/filepond/ for details.\n */\n\n/* eslint-disable */\n\nconst plugin = ({ addFilter, utils }) => {\n    // get quick reference to Type utils\n    const {\n        Type,\n        isString,\n        replaceInString,\n        guesstimateMimeType,\n        getExtensionFromFilename,\n        getFilenameFromURL,\n    } = utils;\n\n    const mimeTypeMatchesWildCard = (mimeType, wildcard) => {\n        const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop(); // image/png -> image\n        const wildcardGroup = wildcard.slice(0, -2); // image/* -> image\n        return mimeTypeGroup === wildcardGroup;\n    };\n\n    const isValidMimeType = (acceptedTypes, userInputType) =>\n        acceptedTypes.some(acceptedType => {\n            // accepted is wildcard mime type\n            if (/\\*$/.test(acceptedType)) {\n                return mimeTypeMatchesWildCard(userInputType, acceptedType);\n            }\n\n            // is normal mime type\n            return acceptedType === userInputType;\n        });\n\n    const getItemType = item => {\n        // if the item is a url we guess the mime type by the extension\n        let type = '';\n        if (isString(item)) {\n            const filename = getFilenameFromURL(item);\n            const extension = getExtensionFromFilename(filename);\n            if (extension) {\n                type = guesstimateMimeType(extension);\n            }\n        } else {\n            type = item.type;\n        }\n\n        return type;\n    };\n\n    const validateFile = (item, acceptedFileTypes, typeDetector) => {\n        // no types defined, everything is allowed \\o/\n        if (acceptedFileTypes.length === 0) {\n            return true;\n        }\n\n        // gets the item type\n        const type = getItemType(item);\n\n        // no type detector, test now\n        if (!typeDetector) {\n            return isValidMimeType(acceptedFileTypes, type);\n        }\n\n        // use type detector\n        return new Promise((resolve, reject) => {\n            typeDetector(item, type)\n                .then(detectedType => {\n                    if (isValidMimeType(acceptedFileTypes, detectedType)) {\n                        resolve();\n                    } else {\n                        reject();\n                    }\n                })\n                .catch(reject);\n        });\n    };\n\n    const applyMimeTypeMap = map => acceptedFileType =>\n        map[acceptedFileType] === null ? false : map[acceptedFileType] || acceptedFileType;\n\n    // setup attribute mapping for accept\n    addFilter('SET_ATTRIBUTE_TO_OPTION_MAP', map =>\n        Object.assign(map, {\n            accept: 'acceptedFileTypes',\n        })\n    );\n\n    // filtering if an item is allowed in hopper\n    addFilter('ALLOW_HOPPER_ITEM', (file, { query }) => {\n        // if we are not doing file type validation exit\n        if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n            return true;\n        }\n\n        // we validate the file against the accepted file types\n        return validateFile(file, query('GET_ACCEPTED_FILE_TYPES'));\n    });\n\n    // called for each file that is loaded\n    // right before it is set to the item state\n    // should return a promise\n    addFilter(\n        'LOAD_FILE',\n        (file, { query }) =>\n            new Promise((resolve, reject) => {\n                if (!query('GET_ALLOW_FILE_TYPE_VALIDATION')) {\n                    resolve(file);\n                    return;\n                }\n\n                const acceptedFileTypes = query('GET_ACCEPTED_FILE_TYPES');\n\n                // custom type detector method\n                const typeDetector = query('GET_FILE_VALIDATE_TYPE_DETECT_TYPE');\n\n                // if invalid, exit here\n                const validationResult = validateFile(file, acceptedFileTypes, typeDetector);\n\n                const handleRejection = () => {\n                    const acceptedFileTypesMapped = acceptedFileTypes\n                        .map(\n                            applyMimeTypeMap(\n                                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP')\n                            )\n                        )\n                        .filter(label => label !== false);\n\n                    const acceptedFileTypesMappedUnique = acceptedFileTypesMapped.filter(\n                        (item, index) => acceptedFileTypesMapped.indexOf(item) === index\n                    );\n\n                    reject({\n                        status: {\n                            main: query('GET_LABEL_FILE_TYPE_NOT_ALLOWED'),\n                            sub: replaceInString(\n                                query('GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES'),\n                                {\n                                    allTypes: acceptedFileTypesMappedUnique.join(', '),\n                                    allButLastType: acceptedFileTypesMappedUnique\n                                        .slice(0, -1)\n                                        .join(', '),\n                                    lastType:\n                                        acceptedFileTypesMappedUnique[\n                                            acceptedFileTypesMappedUnique.length - 1\n                                        ],\n                                }\n                            ),\n                        },\n                    });\n                };\n\n                // has returned new filename immidiately\n                if (typeof validationResult === 'boolean') {\n                    if (!validationResult) {\n                        return handleRejection();\n                    }\n                    return resolve(file);\n                }\n\n                // is promise\n                validationResult\n                    .then(() => {\n                        resolve(file);\n                    })\n                    .catch(handleRejection);\n            })\n    );\n\n    // expose plugin\n    return {\n        // default options\n        options: {\n            // Enable or disable file type validation\n            allowFileTypeValidation: [true, Type.BOOLEAN],\n\n            // What file types to accept\n            acceptedFileTypes: [[], Type.ARRAY],\n            // - must be comma separated\n            // - mime types: image/png, image/jpeg, image/gif\n            // - extensions: .png, .jpg, .jpeg ( not enabled yet )\n            // - wildcards: image/*\n\n            // label to show when a type is not allowed\n            labelFileTypeNotAllowed: ['File is of invalid type', Type.STRING],\n\n            // nicer label\n            fileValidateTypeLabelExpectedTypes: [\n                'Expects {allButLastType} or {lastType}',\n                Type.STRING,\n            ],\n\n            // map mime types to extensions\n            fileValidateTypeLabelExpectedTypesMap: [{}, Type.OBJECT],\n\n            // Custom function to detect type of file\n            fileValidateTypeDetectType: [null, Type.FUNCTION],\n        },\n    };\n};\n\n// fire pluginloaded event if running in browser, this allows registering the plugin when using async script tags\nconst isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nif (isBrowser) {\n    document.dispatchEvent(new CustomEvent('FilePond:pluginloaded', { detail: plugin }));\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmlsZXBvbmQtcGx1Z2luLWZpbGUtdmFsaWRhdGUtdHlwZS9kaXN0L2ZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxxRUFBcUU7QUFDckUscURBQXFEO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQixJQUFJLFNBQVM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0I7QUFDdEY7O0FBRUEsaUVBQWUsTUFBTSxFQUFDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHRtb3Nlc1xcT25lRHJpdmUgLSBUZXNsYVxcRG9jdW1lbnRzXFx0aXRsZS1zY2FubmVyXFxub2RlX21vZHVsZXNcXGZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGVcXGRpc3RcXGZpbGVwb25kLXBsdWdpbi1maWxlLXZhbGlkYXRlLXR5cGUuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRmlsZVBvbmRQbHVnaW5GaWxlVmFsaWRhdGVUeXBlIDEuMi45XG4gKiBMaWNlbnNlZCB1bmRlciBNSVQsIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUL1xuICogUGxlYXNlIHZpc2l0IGh0dHBzOi8vcHFpbmEubmwvZmlsZXBvbmQvIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmNvbnN0IHBsdWdpbiA9ICh7IGFkZEZpbHRlciwgdXRpbHMgfSkgPT4ge1xuICAgIC8vIGdldCBxdWljayByZWZlcmVuY2UgdG8gVHlwZSB1dGlsc1xuICAgIGNvbnN0IHtcbiAgICAgICAgVHlwZSxcbiAgICAgICAgaXNTdHJpbmcsXG4gICAgICAgIHJlcGxhY2VJblN0cmluZyxcbiAgICAgICAgZ3Vlc3N0aW1hdGVNaW1lVHlwZSxcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lLFxuICAgICAgICBnZXRGaWxlbmFtZUZyb21VUkwsXG4gICAgfSA9IHV0aWxzO1xuXG4gICAgY29uc3QgbWltZVR5cGVNYXRjaGVzV2lsZENhcmQgPSAobWltZVR5cGUsIHdpbGRjYXJkKSA9PiB7XG4gICAgICAgIGNvbnN0IG1pbWVUeXBlR3JvdXAgPSAoL15bXi9dKy8uZXhlYyhtaW1lVHlwZSkgfHwgW10pLnBvcCgpOyAvLyBpbWFnZS9wbmcgLT4gaW1hZ2VcbiAgICAgICAgY29uc3Qgd2lsZGNhcmRHcm91cCA9IHdpbGRjYXJkLnNsaWNlKDAsIC0yKTsgLy8gaW1hZ2UvKiAtPiBpbWFnZVxuICAgICAgICByZXR1cm4gbWltZVR5cGVHcm91cCA9PT0gd2lsZGNhcmRHcm91cDtcbiAgICB9O1xuXG4gICAgY29uc3QgaXNWYWxpZE1pbWVUeXBlID0gKGFjY2VwdGVkVHlwZXMsIHVzZXJJbnB1dFR5cGUpID0+XG4gICAgICAgIGFjY2VwdGVkVHlwZXMuc29tZShhY2NlcHRlZFR5cGUgPT4ge1xuICAgICAgICAgICAgLy8gYWNjZXB0ZWQgaXMgd2lsZGNhcmQgbWltZSB0eXBlXG4gICAgICAgICAgICBpZiAoL1xcKiQvLnRlc3QoYWNjZXB0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZU1hdGNoZXNXaWxkQ2FyZCh1c2VySW5wdXRUeXBlLCBhY2NlcHRlZFR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpcyBub3JtYWwgbWltZSB0eXBlXG4gICAgICAgICAgICByZXR1cm4gYWNjZXB0ZWRUeXBlID09PSB1c2VySW5wdXRUeXBlO1xuICAgICAgICB9KTtcblxuICAgIGNvbnN0IGdldEl0ZW1UeXBlID0gaXRlbSA9PiB7XG4gICAgICAgIC8vIGlmIHRoZSBpdGVtIGlzIGEgdXJsIHdlIGd1ZXNzIHRoZSBtaW1lIHR5cGUgYnkgdGhlIGV4dGVuc2lvblxuICAgICAgICBsZXQgdHlwZSA9ICcnO1xuICAgICAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tVVJMKGl0ZW0pO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uRnJvbUZpbGVuYW1lKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gZ3Vlc3N0aW1hdGVNaW1lVHlwZShleHRlbnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH07XG5cbiAgICBjb25zdCB2YWxpZGF0ZUZpbGUgPSAoaXRlbSwgYWNjZXB0ZWRGaWxlVHlwZXMsIHR5cGVEZXRlY3RvcikgPT4ge1xuICAgICAgICAvLyBubyB0eXBlcyBkZWZpbmVkLCBldmVyeXRoaW5nIGlzIGFsbG93ZWQgXFxvL1xuICAgICAgICBpZiAoYWNjZXB0ZWRGaWxlVHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldHMgdGhlIGl0ZW0gdHlwZVxuICAgICAgICBjb25zdCB0eXBlID0gZ2V0SXRlbVR5cGUoaXRlbSk7XG5cbiAgICAgICAgLy8gbm8gdHlwZSBkZXRlY3RvciwgdGVzdCBub3dcbiAgICAgICAgaWYgKCF0eXBlRGV0ZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkTWltZVR5cGUoYWNjZXB0ZWRGaWxlVHlwZXMsIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHR5cGUgZGV0ZWN0b3JcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHR5cGVEZXRlY3RvcihpdGVtLCB0eXBlKVxuICAgICAgICAgICAgICAgIC50aGVuKGRldGVjdGVkVHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkTWltZVR5cGUoYWNjZXB0ZWRGaWxlVHlwZXMsIGRldGVjdGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFwcGx5TWltZVR5cGVNYXAgPSBtYXAgPT4gYWNjZXB0ZWRGaWxlVHlwZSA9PlxuICAgICAgICBtYXBbYWNjZXB0ZWRGaWxlVHlwZV0gPT09IG51bGwgPyBmYWxzZSA6IG1hcFthY2NlcHRlZEZpbGVUeXBlXSB8fCBhY2NlcHRlZEZpbGVUeXBlO1xuXG4gICAgLy8gc2V0dXAgYXR0cmlidXRlIG1hcHBpbmcgZm9yIGFjY2VwdFxuICAgIGFkZEZpbHRlcignU0VUX0FUVFJJQlVURV9UT19PUFRJT05fTUFQJywgbWFwID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24obWFwLCB7XG4gICAgICAgICAgICBhY2NlcHQ6ICdhY2NlcHRlZEZpbGVUeXBlcycsXG4gICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIGZpbHRlcmluZyBpZiBhbiBpdGVtIGlzIGFsbG93ZWQgaW4gaG9wcGVyXG4gICAgYWRkRmlsdGVyKCdBTExPV19IT1BQRVJfSVRFTScsIChmaWxlLCB7IHF1ZXJ5IH0pID0+IHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBkb2luZyBmaWxlIHR5cGUgdmFsaWRhdGlvbiBleGl0XG4gICAgICAgIGlmICghcXVlcnkoJ0dFVF9BTExPV19GSUxFX1RZUEVfVkFMSURBVElPTicpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIHZhbGlkYXRlIHRoZSBmaWxlIGFnYWluc3QgdGhlIGFjY2VwdGVkIGZpbGUgdHlwZXNcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlRmlsZShmaWxlLCBxdWVyeSgnR0VUX0FDQ0VQVEVEX0ZJTEVfVFlQRVMnKSk7XG4gICAgfSk7XG5cbiAgICAvLyBjYWxsZWQgZm9yIGVhY2ggZmlsZSB0aGF0IGlzIGxvYWRlZFxuICAgIC8vIHJpZ2h0IGJlZm9yZSBpdCBpcyBzZXQgdG8gdGhlIGl0ZW0gc3RhdGVcbiAgICAvLyBzaG91bGQgcmV0dXJuIGEgcHJvbWlzZVxuICAgIGFkZEZpbHRlcihcbiAgICAgICAgJ0xPQURfRklMRScsXG4gICAgICAgIChmaWxlLCB7IHF1ZXJ5IH0pID0+XG4gICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSgnR0VUX0FMTE9XX0ZJTEVfVFlQRV9WQUxJREFUSU9OJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFjY2VwdGVkRmlsZVR5cGVzID0gcXVlcnkoJ0dFVF9BQ0NFUFRFRF9GSUxFX1RZUEVTJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gdHlwZSBkZXRlY3RvciBtZXRob2RcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlRGV0ZWN0b3IgPSBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9ERVRFQ1RfVFlQRScpO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaW52YWxpZCwgZXhpdCBoZXJlXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHZhbGlkYXRlRmlsZShmaWxlLCBhY2NlcHRlZEZpbGVUeXBlcywgdHlwZURldGVjdG9yKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZVJlamVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQgPSBhY2NlcHRlZEZpbGVUeXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseU1pbWVUeXBlTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSgnR0VUX0ZJTEVfVkFMSURBVEVfVFlQRV9MQUJFTF9FWFBFQ1RFRF9UWVBFU19NQVAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGFiZWwgPT4gbGFiZWwgIT09IGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFVuaXF1ZSA9IGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIChpdGVtLCBpbmRleCkgPT4gYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWQuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogcXVlcnkoJ0dFVF9MQUJFTF9GSUxFX1RZUEVfTk9UX0FMTE9XRUQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWI6IHJlcGxhY2VJblN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkoJ0dFVF9GSUxFX1ZBTElEQVRFX1RZUEVfTEFCRUxfRVhQRUNURURfVFlQRVMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsVHlwZXM6IGFjY2VwdGVkRmlsZVR5cGVzTWFwcGVkVW5pcXVlLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxCdXRMYXN0VHlwZTogYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWRVbmlxdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VHlwZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZEZpbGVUeXBlc01hcHBlZFVuaXF1ZVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXNNYXBwZWRVbmlxdWUubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIGhhcyByZXR1cm5lZCBuZXcgZmlsZW5hbWUgaW1taWRpYXRlbHlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRpb25SZXN1bHQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZWplY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpcyBwcm9taXNlXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goaGFuZGxlUmVqZWN0aW9uKTtcbiAgICAgICAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIGV4cG9zZSBwbHVnaW5cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZmlsZSB0eXBlIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGFsbG93RmlsZVR5cGVWYWxpZGF0aW9uOiBbdHJ1ZSwgVHlwZS5CT09MRUFOXSxcblxuICAgICAgICAgICAgLy8gV2hhdCBmaWxlIHR5cGVzIHRvIGFjY2VwdFxuICAgICAgICAgICAgYWNjZXB0ZWRGaWxlVHlwZXM6IFtbXSwgVHlwZS5BUlJBWV0sXG4gICAgICAgICAgICAvLyAtIG11c3QgYmUgY29tbWEgc2VwYXJhdGVkXG4gICAgICAgICAgICAvLyAtIG1pbWUgdHlwZXM6IGltYWdlL3BuZywgaW1hZ2UvanBlZywgaW1hZ2UvZ2lmXG4gICAgICAgICAgICAvLyAtIGV4dGVuc2lvbnM6IC5wbmcsIC5qcGcsIC5qcGVnICggbm90IGVuYWJsZWQgeWV0IClcbiAgICAgICAgICAgIC8vIC0gd2lsZGNhcmRzOiBpbWFnZS8qXG5cbiAgICAgICAgICAgIC8vIGxhYmVsIHRvIHNob3cgd2hlbiBhIHR5cGUgaXMgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIGxhYmVsRmlsZVR5cGVOb3RBbGxvd2VkOiBbJ0ZpbGUgaXMgb2YgaW52YWxpZCB0eXBlJywgVHlwZS5TVFJJTkddLFxuXG4gICAgICAgICAgICAvLyBuaWNlciBsYWJlbFxuICAgICAgICAgICAgZmlsZVZhbGlkYXRlVHlwZUxhYmVsRXhwZWN0ZWRUeXBlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RzIHthbGxCdXRMYXN0VHlwZX0gb3Ige2xhc3RUeXBlfScsXG4gICAgICAgICAgICAgICAgVHlwZS5TVFJJTkcsXG4gICAgICAgICAgICBdLFxuXG4gICAgICAgICAgICAvLyBtYXAgbWltZSB0eXBlcyB0byBleHRlbnNpb25zXG4gICAgICAgICAgICBmaWxlVmFsaWRhdGVUeXBlTGFiZWxFeHBlY3RlZFR5cGVzTWFwOiBbe30sIFR5cGUuT0JKRUNUXSxcblxuICAgICAgICAgICAgLy8gQ3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVjdCB0eXBlIG9mIGZpbGVcbiAgICAgICAgICAgIGZpbGVWYWxpZGF0ZVR5cGVEZXRlY3RUeXBlOiBbbnVsbCwgVHlwZS5GVU5DVElPTl0sXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbi8vIGZpcmUgcGx1Z2lubG9hZGVkIGV2ZW50IGlmIHJ1bm5pbmcgaW4gYnJvd3NlciwgdGhpcyBhbGxvd3MgcmVnaXN0ZXJpbmcgdGhlIHBsdWdpbiB3aGVuIHVzaW5nIGFzeW5jIHNjcmlwdCB0YWdzXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmlmIChpc0Jyb3dzZXIpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnRmlsZVBvbmQ6cGx1Z2lubG9hZGVkJywgeyBkZXRhaWw6IHBsdWdpbiB9KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBsdWdpbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js\n");

/***/ })

};
;